# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

interface AwsNativeAccountDescendantType {
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface AwsNativeAccountLogicalChildType {
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"A Blueprint"
interface Blueprint {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "list of children"
    children: [BlueprintChild!]!
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "status of the last test failover"
    currentFailoverStatus: AppBlueprintFailoverStatusEnum!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "relic status of the Blueprint"
    isRelic: Boolean!
    "last failover"
    lastFailover: Failover
    "last test failover"
    lastTestFailover: Failover
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "number of child snappables of the Blueprint"
    numChildren: Int!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "resource mapping status of the Blueprint"
    rmStatus: AppBlueprintRmStatusEnum!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "status of the Blueprint"
    status: AppBlueprintStatusEnum!
}

"Blueprint Child"
interface BlueprintChild {
    "boot priority"
    bootPriority: Int!
    "child fid"
    fid: UUID!
}

"A Blueprint failover instance"
interface BlueprintFailoverInstance {
    "blueprint child snappable id"
    snappableId: String!
}

"Blueprint Location"
interface BlueprintLocation {
    "The type of the location"
    type: BlueprintLocationTypeEnum!
}

"A Blueprint"
interface BlueprintNew {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "list of children"
    children: [BlueprintChild!]!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "archived status of the Blueprint"
    isArchived: Boolean!
    "Status of hydration enablement."
    isHydrationEnabled: Boolean
    "Source Uuid of the last failover."
    lastFailoverSource: String
    "Status of the last failover."
    lastFailoverStatus: BlueprintFailoverStatus!
    "Last failover time."
    lastFailoverTime: DateTime
    "Last local recovery time."
    lastLocalRecoveryTime: DateTime
    "Status of the last test failover."
    lastTestFailoverStatus: BlueprintFailoverStatus!
    "Last test failover time."
    lastTestFailoverTime: DateTime
    "Details of the latest failover."
    latestFailover: BlueprintFailover
    "Details of the local blueprint RPO lag."
    localRpoLagInfo: RPOLagInfo
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "number of child snappables of the Blueprint"
    numChildren: Int!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "blueprint remote RPO lag info"
    remoteRpoLagInfo: RPOLagInfo
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "The source location from which this object originated."
    sourceLocation: BlueprintLocation
    "status of the Blueprint"
    status: BlueprintStatusEnum!
    "The target location to which the object failed over"
    targetLocation: BlueprintLocation
    "version of the Blueprint"
    version: Int!
}

interface CassandraKeyspaceDescendantType {
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface CassandraKeyspacePhysicalChildType {
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface CassandraSourceDescendantType {
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface CassandraSourcePhysicalChildType {
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"A Rubrik CDM Managed Hierarchy object."
interface CdmHierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"A Managed Hierarchy Snappable"
interface CdmHierarchySnappableNew {
    "The ID of the snappable on the Rubrik CDM cluster."
    cdmId: String!
    "A link to view the snappable on the CDM cluster. For dev use only."
    cdmLink: String!
    "The cluster from which this snappable originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The list of missed snapshots for this workload."
    missedSnapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int
    ): MissedSnapshotCommonConnection
    "The list of missed snapshots for this workload."
    missedSnapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: MissedSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): MissedSnapshotGroupByConnection
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot archived to AWS."
    newestArchivedSnapshot: CdmSnapshot
    "The newest snapshot replicated to a cluster."
    newestReplicatedSnapshot: CdmSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: CdmSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: CdmSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for the snapshots of this workload."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: CdmSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): cdmSnapshotGroupByConnection
}

"Cloud Account (AWS, Azure etc.) information."
interface CloudAccount {
    "The ID of this Cloud Account."
    cloudAccountId: String!
    "The type of this Cloud Provider."
    cloudProvider: CloudAccountType!
    "The connection status of this Cloud Account."
    connectionStatus: ConnectionStatusType!
    "The description of this Cloud Account."
    description: String
    "The name of this Cloud Account."
    name: String!
}

interface Db2InstanceDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface Db2InstancePhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface DisplayableValue {
    displayValue: String!
    reportHeader: String!
    serializedValue: String!
}

"Descendant of the Exchange DAG object."
interface ExchangeDagDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"Descendant of the Exchange Server object."
interface ExchangeServerDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface FailoverClusterAppDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface FailoverClusterAppPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface FailoverClusterTopLevelDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface FilesetTemplateDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface FilesetTemplatePhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface GcpNativeProjectDescendantType {
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface GcpNativeProjectLogicalChildType {
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"A generic snapshot type"
interface GenericSnapshot {
    "The date of the snapshot."
    date: DateTime!
    "The expirationDate of the snapshot."
    expirationDate: DateTime
    "The id of the snapshot."
    id: UUID!
    "The number of indexing attempts for the snapshot."
    indexingAttempts: Long!
    "Whether or not the snapshot is corrupted."
    isCorrupted: Boolean!
    "Whether or not the snapshot is expired"
    isExpired: Boolean!
    "Whether or not the snapshot is indexed."
    isIndexed: Boolean!
    "Whether the snapshot is an on-demand snapshot"
    isOnDemandSnapshot: Boolean!
    "Whether or not the snapshot is unindexable."
    isUnindexable: Boolean!
    "The snappableId of the snapshot."
    snappableId: String!
}

"A Generic Hierarchy Object"
interface HierarchyObject {
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"A Generic Hierarchy Snappable"
interface HierarchySnappable {
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface HostFailoverClusterDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface HostFailoverClusterPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface HostShareDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface HostSharePhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface HyperVClusterDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface HyperVClusterLogicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface HyperVSCVMMDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface HyperVSCVMMLogicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface HyperVServerDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface HyperVServerLogicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface HyperVTopLevelDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface K8sClusterDescendant {
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface ManagedVolumeDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface ManagedVolumePhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface MongodbDatabaseDescendantType {
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface MongodbDatabasePhysicalChildType {
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface MongodbSourceDescendantType {
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface MongodbSourcePhysicalChildType {
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface MssqlAvailabilityGroupDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface MssqlAvailabilityGroupLogicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface MssqlInstanceDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface MssqlInstanceLogicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface MssqlTopLevelDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface NasNamespaceDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface NasNamespaceLogicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface NasSystemDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface NasSystemLogicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface NasVolumeDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface NasVolumeLogicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface NutanixClusterDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface NutanixClusterLogicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface O365AppObject {
    "The added time of the O365 app."
    addedAt: DateTime!
    "The id of the O365 app."
    appId: String!
    "The owner of the O365 app (RUBRIK or CUSTOMER)."
    appOwner: String!
    "The type of the O365 app (e.g. ONEDRIVE)"
    appType: String!
    "The authentication status of the app against the subscription"
    isAuthenticated: Boolean!
    "The subscription to which the O365 app is associated."
    subscription: String!
    "The id of the O365 subscription."
    subscriptionId: String!
}

interface O365ExchangeObject {
    "The id of the O365 exchange object."
    id: String!
    "The parent folder id of the object (ROOT indicates root folder)."
    parentFolderId: String
}

interface O365OnedriveObject {
    "The name of the folder corresponding to the Teams channel."
    channelFolderName: String
    "The display name of the Teams channel."
    channelName: String
    "The creation time of the onedrive object"
    createTime: DateTime
    "The id of the O365 onedrive object."
    id: String!
    "The modified time of the onedrive object"
    modifiedTime: DateTime
    "The name of the onedrive object"
    name: String
    "The parent folder id of the object (ROOT indicates root folder)."
    parentFolderId: String
    "The size of the onedrive object or its contents in bytes"
    size: Long
}

interface O365OrgDescendant {
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface O365SharepointObject {
    "The sharepoint object ID"
    objectId: String!
    "The parent id of the object"
    parentId: String!
    "The title or name of the sharepoint object"
    title: String!
}

interface O365TeamsChannelObject {
    "The id of the Sharepoint folder for the Teams channel."
    folderId: String
    "The name of the Sharepoint folder for the Teams channel."
    folderName: String
    "The id of the Teams channel"
    id: String
    "The display name of the Teams channel."
    name: String
}

interface O365UserDescendant {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface O365UserDescendantMetadata {
    "The object ID."
    id: UUID!
    "The name of the object."
    name: String!
    "The user principal name of the object."
    userPrincipalName: String!
}

interface OracleHostDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface OracleHostLogicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface OracleRacDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface OracleRacLogicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface OracleTopLevelDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface PhysicalHostDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface PhysicalHostPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"A Polaris Managed Hierarchy Object."
interface PolarisHierarchyObject {
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"A Polaris Snappable"
interface PolarisHierarchySnappable {
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: PolarisSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: PolarisSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this workload."
    snapshotsOfSnappableConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Whether to ignore the active protected object check."
        ignoreActiveSnappableCheck: Boolean,
        "Returns the last n elements from the list."
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
}

interface ProtectedObjectSummary {
    "The effective sla of the protected object (if defined)."
    effectiveSlaOpt: String
    "The id of the protected object."
    id: String!
    "Whether the protected object is archived."
    isArchived: Boolean!
    "The name of the protected object."
    name: String!
    "The object type of the protected object (if returned)"
    objectType: ManagedObjectType
}

"A Recovery Spec"
interface RecoverySpec {
    "the user provided scripts"
    userData: String
    "recovery spec version"
    version: Long!
}

"A Resource Spec"
interface ResourceSpec {
    "resource spec is archived"
    isArchived: Boolean!
    "Recovery point of the snappable."
    recoveryPointOpt: Long
    "resource spec child snappable id"
    snappableId: String!
    "resource spec child snappable name"
    snappableName: String!
    "resource spec child snapshot id"
    snapshotId: String!
}

interface SapHanaSystemDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface SapHanaSystemPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface SlaDomain {
    "The id of the SLA Domain."
    id: String!
    "The name of the SLA Domain."
    name: String!
    "The version of the SLA Domain."
    version: String
}

"Target Info to be used for archival or replication"
interface Target {
    "The cluster to which this target belongs."
    cluster: Cluster!
    "Name of the Rubrik cluster that archives to this archival location."
    clusterName: String
    "Number of bytes stored on target."
    consumedBytes: Long
    "Number of failed tasks acting on this target."
    failedTasks: Int
    "The id of this Target."
    id: String!
    "The pause/resume status of this Target."
    isActive: Boolean!
    "Whether this Target is archived."
    isArchived: Boolean!
    "The scope of location, whether Global or Local."
    locationScope: LocationScope!
    "The name of this Target."
    name: String!
    "The retrieval method of the reader target."
    readerRetrievalMethod: ReaderRetrievalMethod
    "Number of running tasks acting on this target."
    runningTasks: Int
    "Status of the target."
    status: ArchivalLocationStatus!
    "Archival location to which the mapping target belongs."
    targetMapping: TargetMappingBasic
    "The type of this Target."
    targetType: TargetTypeEnum!
}

"Target Template to be used for automatic archival group."
interface TargetTemplate {
    "The type of this Target."
    targetType: TargetTypeEnum!
}

interface VSphereComputeClusterDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereComputeClusterPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereDatacenterDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereDatacenterLogicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereDatacenterPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereFolderDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereFolderLogicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereHostDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereHostPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereResourcePoolDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereResourcePoolPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereTagCategoryDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereTagCategoryTagChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereTagDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereTagTagChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereVCenterDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereVCenterLogicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereVCenterPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VSphereVCenterTagChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface Value {
    serializedValue: String!
}

interface VcdCatalogDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VcdCatalogLogicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VcdDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VcdLogicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VcdOrgDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VcdOrgLogicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VcdOrgVdcDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VcdOrgVdcLogicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VcdTopLevelDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VcdVappLogicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VsphereDatastoreClusterDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface VsphereDatastoreClusterPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface WindowsClusterDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

interface WindowsClusterLogicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

union ActivitySeriesGroupByInfo = ActivityObjectType | ActivityStatus | ActivityType | Cluster | ClusterType | TimeRangeWithUnit

union AnomalyResultGroupByInfo = AnomalyStatus | Cluster | Snappable | TimeRangeWithUnit

union CdmSnapshotGroupByInfo = TimeRangeWithUnit

union ClusterGroupByInfo = ClusterType | TimeRangeWithUnit

union ClusterMetricGroupByInfo = TimeRangeWithUnit

union CustomReportGroupByInfo = ReportFocus

union FailoverGroupByInfo = FailoverStatus | FailoverType | LastTestStatus | Source | TargetSite | TimeRangeWithUnit

union MissedSnapshotGroupByInfo = TimeRangeWithUnit

union MosaicSnapshotGroupByInfo = TimeRangeWithUnit

union PolarisSnapshotGroupByInfo = TimeRangeWithUnit

union RansomwareResultGroupByInfo = Cluster | Snappable | TimeRangeWithUnit

"All the possible chart types."
union ReportChartType = ActivityChart | AnomalyChart | FailoverChart | InfrastructureChart | SnappableChart | SonarContentReportChart | SonarReportChart | TaskDetailChart | TaskSummaryChart | UserAuditChart

"All the possible table types."
union ReportTableType = ActivityTable | AnomalyTable | FailoverTable | InfrastructureTable | SnappableTable | SonarContentReportTable | SonarReportTable | TaskDetailTable | TaskSummaryTable | UserAuditTable

union SnappableGroupByInfo = Cluster | ClusterSlaDomain | ClusterType | ComplianceStatus | ObjectType | ProtectionStatus | TimeRangeWithUnit

union TaskDetailGroupByInfo = Cluster | Status | TaskDetailClusterType | TaskDetailObjectType | TimeRangeWithUnit

union TaskSummaryGroupByInfo = Cluster | ClusterType | GlobalSla | ObjectType | PolarisHierarchySnappableObject | TimeRangeWithUnit

union UpgradeGroupByInfo = ClusterJobStatusType | ClusterType

union UserAuditGroupByInfo = Cluster | ClusterType | TimeRangeWithUnit | UserAuditObjectType | UserAuditStatus | UserAuditType

"Active Directory Groups from Microsoft."
type ADGroup {
    "DisplayName of AD Group."
    displayName: String!
    "Natural ID of AD Group."
    id: String!
}

type ASPKey {
    account: String!
    component: ComponentEnum!
    name: String!
    targetId: String!
}

type ASPValue {
    key: ASPKey
    value: String!
}

"additional information about the vcenter object, such as name, version, os type, and api type, only available on clusters 5.1+"
type AboutInformation {
    apiType: String!
    name: String!
    osType: String!
    version: String!
}

"An absolute monthly recurrence pattern (e.g. 21st of every 3 months)."
type AbsoluteMonthlyRecurrencePattern {
    "Which day of the month the event occurs."
    dayOfMonth: Int!
    "The interval at which the recurrence applies."
    interval: Int!
}

"An absolute yearly recurrence pattern (e.g. 25th of December)."
type AbsoluteYearlyRecurrencePattern {
    "Which day of the month the event occurs."
    dayOfMonth: Int!
    "The month to which the recurrence applies."
    month: String!
}

type AccessGroup {
    groupId: String!
    groupName: String!
}

"Paginated list of AccessGroup objects."
type AccessGroupConnection {
    "Total number of AccessGroup objects matching the request arguments."
    count: Int!
    "List of AccessGroup objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [AccessGroupEdge!]!
    "List of AccessGroup objects."
    nodes: [AccessGroup!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the AccessGroup object. This wrapper is used for pagination."
type AccessGroupEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual AccessGroup object wrapped by this edge."
    node: AccessGroup!
}

type AccessUser {
    activityDelta: Long!
    email: String!
    lastAccessTime: Long!
    numActivities: Long!
    subjectName: String!
    userSid: String!
    username: String!
}

"Paginated list of AccessUser objects."
type AccessUserConnection {
    "Total number of AccessUser objects matching the request arguments."
    count: Int!
    "List of AccessUser objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [AccessUserEdge!]!
    "List of AccessUser objects."
    nodes: [AccessUser!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the AccessUser object. This wrapper is used for pagination."
type AccessUserEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual AccessUser object wrapped by this edge."
    node: AccessUser!
}

"Product enabled via Salesforce."
type AccountProduct {
    "Account name for the given product."
    account: String!
    "Date when product expires."
    expirationDate: DateTime!
    "Name of the product - GPS, Sonar, etc."
    name: ProductName!
    "State of the product - Acive, disabled, etc."
    state: ProductState!
    "The type of product - Revenue, Trial, POC."
    type: ProductType!
}

type AccountSetting {
    isEmailNotificationEnabled: Boolean
    isEulaAccepted: Boolean
}

type Activity {
    activityInfo: String
    activitySeries: ActivitySeries!
    clusterId: UUID!
    id: ID!
    message: String!
    objectId: String!
    objectType: ActivityObjectTypeEnum!
    progress: String
    severity: ActivitySeverityEnum!
    status: ActivityStatusEnum!
    time: DateTime!
    type: ActivityTypeEnum!
}

type ActivityChart {
    focus: ReportFocusEnum!
    groupBy: [ActivitySeriesGroupByEnum!]
    name: String!
}

"Paginated list of Activity objects."
type ActivityConnection {
    "Total number of Activity objects matching the request arguments."
    count: Int!
    "List of Activity objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [ActivityEdge!]!
    "List of Activity objects."
    nodes: [Activity!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the Activity object. This wrapper is used for pagination."
type ActivityEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual Activity object wrapped by this edge."
    node: Activity!
}

type ActivityObjectType {
    enumValue: ActivityObjectTypeEnum!
}

type ActivityResult {
    accessType: ActivityAccessTypeEnum!
    count: Long!
    countDelta: Long!
}

type ActivitySeries {
    activityConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int
    ): ActivityConnection!
    activitySeriesId: UUID!
    causeErrorCode: String
    causeErrorMessage: String
    causeErrorReason: String
    causeErrorRemedy: String
    cluster: Cluster
    clusterName: String!
    clusterUuid: UUID!
    failureReason: String
    fid: UUID
    id: Long!
    isCancelable: Boolean
    isPolarisEventSeries: Boolean!
    lastActivityStatus: ActivityStatusEnum!
    lastActivityType: ActivityTypeEnum!
    lastEventAddedAt: DateTime
    lastUpdated: DateTime!
    lastVerifiedAt: DateTime
    location: String!
    objectId: String!
    objectName: String
    objectType: ActivityObjectTypeEnum!
    progress: String
    severity: ActivitySeverityEnum!
    startTime: DateTime
}

"Paginated list of ActivitySeries objects."
type ActivitySeriesConnection {
    "Total number of ActivitySeries objects matching the request arguments."
    count: Int!
    "List of ActivitySeries objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [ActivitySeriesEdge!]!
    "List of ActivitySeries objects."
    nodes: [ActivitySeries!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the ActivitySeries object. This wrapper is used for pagination."
type ActivitySeriesEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual ActivitySeries object wrapped by this edge."
    node: ActivitySeries!
}

"Activity series data with groupby info applied to it."
type ActivitySeriesGroupBy {
    "Paginated activity series data."
    activitySeriesConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Sort activity series by field."
        sortBy: ActivitySeriesSortByEnum = LastUpdated
    ): ActivitySeriesConnection!
    "Further provide groupings for the data."
    activitySeriesGroupBy(
        "group activity series by a field"
        groupBy: ActivitySeriesGroupByEnum!
    ): [ActivitySeriesGroupBy!]!
    "The data groupby info."
    groupByInfo: ActivitySeriesGroupByInfo!
}

"Paginated list of ActivitySeriesGroupBy objects."
type ActivitySeriesGroupByConnection {
    "Total number of ActivitySeriesGroupBy objects matching the request arguments."
    count: Int!
    "List of ActivitySeriesGroupBy objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [ActivitySeriesGroupByEdge!]!
    "List of ActivitySeriesGroupBy objects."
    nodes: [ActivitySeriesGroupBy!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the ActivitySeriesGroupBy object. This wrapper is used for pagination."
type ActivitySeriesGroupByEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual ActivitySeriesGroupBy object wrapped by this edge."
    node: ActivitySeriesGroupBy!
}

type ActivityStatus {
    enumValue: ActivityStatusEnum!
}

type ActivityTable {
    focus: ReportFocusEnum!
    groupBy: [ActivitySeriesGroupByEnum!]
    name: String!
    selectedColumns: [ActivityTableColumnEnum!]!
    sortBy: ActivitySeriesSortByEnum
    sortOrder: SortOrderEnum
}

type ActivityTimelineResult {
    activityResults: [ActivityResult!]!
    day: String!
    topFiles: [FileAccessResult!]!
}

"Paginated list of ActivityTimelineResult objects."
type ActivityTimelineResultConnection {
    "Total number of ActivityTimelineResult objects matching the request arguments."
    count: Int!
    "List of ActivityTimelineResult objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [ActivityTimelineResultEdge!]!
    "List of ActivityTimelineResult objects."
    nodes: [ActivityTimelineResult!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the ActivityTimelineResult object. This wrapper is used for pagination."
type ActivityTimelineResultEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual ActivityTimelineResult object wrapped by this edge."
    node: ActivityTimelineResult!
}

type ActivityType {
    enumValue: ActivityTypeEnum!
}

"Response for the request to add authentication server based AWS cloud account."
type AddAwsAuthenticationServerBasedCloudAccountReply {
    "Account details for the new cloud account."
    awsAccount: AwsCloudAccount
    "Success response message or error message."
    message: String
}

"Response for the request to add IAM user-based AWS cloud accounts."
type AddAwsIamUserBasedCloudAccountReply {
    "Account details for the new cloud account."
    awsAccount: AwsCloudAccount
}

"Response of the operation to add Exocompute Configurations to Azure Cloud Account."
type AddAzureCloudAccountExocomputeConfigurationsReply {
    "Configuration details of the Exocompute for the Azure Cloud Account."
    configs: [AzureExocomputeConfigDetails!]!
}

"Response of the operation to add an Azure Cloud Account."
type AddAzureCloudAccountReply {
    "Status of the operation to add Azure Cloud Account."
    status: [AddAzureCloudAccountStatus!]!
    "Tenant ID for the added subscriptions."
    tenantId: String!
}

"Status of the operation to add Azure Cloud Account."
type AddAzureCloudAccountStatus {
    "Native ID of the Azure Subscription."
    azureSubscriptionNativeId: String!
    "Rubrik ID of the Azure Subscription."
    azureSubscriptionRubrikId: String!
    "Error encountered, if any."
    error: String!
}

"Response of the operation to add Azure Cloud Account without OAuth."
type AddAzureCloudAccountWithoutOauthReply {
    "Status of the operation to add Azure Cloud Account."
    status: [AddAzureCloudAccountStatus!]!
    "Tenant ID for the added subscriptions."
    tenantId: String!
}

"List of objects where adding backup credentials succeeded and failed."
type AddCloudNativeSqlServerBackupCredentialsReply {
    "Object IDs for which adding credentials failed."
    failedObjectIds: [UUID!]!
    "Object IDs for which adding credentials succeeded."
    successObjectIds: [UUID!]!
}

"Supported in v7.0+"
type AddDb2InstanceResponse {
    """

    Required. Supported in v7.0+
    Status of the refresh job triggered on the new Db2 instance.
    """
    asyncRequestStatus: AsyncRequestStatus
    """

    Required. Supported in v7.0+
    ID of the new Db2 instance.
    """
    id: String!
}

"Add O365 Org response"
type AddO365OrgResponse {
    orgId: String!
    refreshOrgTaskchainId: String!
}

"It contains the reply of Add vm app consistent specs endpoint"
type AddVmAppConsistentSpecsReply {
    failedSnappableIds: [String!]!
    successSnappableIds: [String!]!
}

type AddressBlockV4 {
    cidrBlock: String!
}

"The status of the agent running on the vm"
type AgentStatus {
    agentStatus: AgentConnectStatusEnum!
    disconnectReason: String
}

"Aggregation values calculated across all results prior to pagination."
type AggregatedValues {
    "The highest created file count."
    maxCreatedFileCount: Long!
    "The highest deleted file count."
    maxDeletedFileCount: Long!
    "The highest modified file count."
    maxModifiedFileCount: Long!
    "The highest suspicious file count."
    maxSuspiciousFileCount: Long!
    "The total number of snappable anomalies."
    total: Long!
}

"Amazon Machine Image (AMI) type for exporting an archived EC2 Instance snapshot."
type AmiTypeForAwsNativeArchivedSnapshotExportReply {
    "If amiType is pre-existing, this field will contain the id of the AMI."
    amiId: String!
    "Type of the AMI to be used for export of EC2 instance archived snapshot. This can be an existing AMI, or a runtime-generated AMI or a user-specified AMI."
    amiType: AmiType!
    "Rubrik Id of the aws account which contains the pre-existing AMI."
    awsAccountRubrikId: String!
    "Region where the pre-existing AMI exists."
    regionNativeId: AwsNativeRegion!
}

type Analyzer {
    analyzerType: AnalyzerTypeEnum!
    dictionary: [String!]!
    dictionaryCsv: String!
    id: String!
    name: String!
    regex: String!
}

type AnalyzerAccessUsage {
    analyzer: Analyzer
    count: Int!
    countDelta: Int!
    topFiles: [FileAccessResult!]!
}

"Paginated list of AnalyzerAccessUsage objects."
type AnalyzerAccessUsageConnection {
    "Total number of AnalyzerAccessUsage objects matching the request arguments."
    count: Int!
    "List of AnalyzerAccessUsage objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [AnalyzerAccessUsageEdge!]!
    "List of AnalyzerAccessUsage objects."
    nodes: [AnalyzerAccessUsage!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the AnalyzerAccessUsage object. This wrapper is used for pagination."
type AnalyzerAccessUsageEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual AnalyzerAccessUsage object wrapped by this edge."
    node: AnalyzerAccessUsage!
}

"Paginated list of Analyzer objects."
type AnalyzerConnection {
    "Total number of Analyzer objects matching the request arguments."
    count: Int!
    "List of Analyzer objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [AnalyzerEdge!]!
    "List of Analyzer objects."
    nodes: [Analyzer!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the Analyzer object. This wrapper is used for pagination."
type AnalyzerEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual Analyzer object wrapped by this edge."
    node: Analyzer!
}

type AnalyzerGroup {
    analyzers: [Analyzer!]!
    groupType: AnalyzerGroupTypeEnum!
    id: String!
    name: String!
}

"Paginated list of AnalyzerGroup objects."
type AnalyzerGroupConnection {
    "Total number of AnalyzerGroup objects matching the request arguments."
    count: Int!
    "List of AnalyzerGroup objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [AnalyzerGroupEdge!]!
    "List of AnalyzerGroup objects."
    nodes: [AnalyzerGroup!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the AnalyzerGroup object. This wrapper is used for pagination."
type AnalyzerGroupEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual AnalyzerGroup object wrapped by this edge."
    node: AnalyzerGroup!
}

type AnalyzerGroupResult {
    analyzerGroup: AnalyzerGroup!
    analyzerResults: [AnalyzerResult!]!
    hits: Hits!
}

type AnalyzerMapping {
    analyzerResult: AnalyzerResult!
    groups: [AnalyzerGroup!]!
}

type AnalyzerResult {
    analyzer: Analyzer!
    hits: Hits!
}

type AnalyzerUsage {
    analyzer: Analyzer!
    policies: [ClassificationPolicySummary!]!
}

"Paginated list of AnalyzerUsage objects."
type AnalyzerUsageConnection {
    "Total number of AnalyzerUsage objects matching the request arguments."
    count: Int!
    "List of AnalyzerUsage objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [AnalyzerUsageEdge!]!
    "List of AnalyzerUsage objects."
    nodes: [AnalyzerUsage!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the AnalyzerUsage object. This wrapper is used for pagination."
type AnalyzerUsageEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual AnalyzerUsage object wrapped by this edge."
    node: AnalyzerUsage!
}

type AnomalyChart {
    focus: ReportFocusEnum!
    groupBy: [AnomalyResultGroupByEnum!]
    name: String!
}

"Anomaly analysis report from lambda service"
type AnomalyResult {
    anomalyProbability: Float!
    bytesCreatedCount: Long
    bytesDeletedCount: Long
    bytesModifiedCount: Long
    bytesNetChangedCount: Long
    cluster: Cluster!
    filesCreatedCount: Long
    filesDeletedCount: Long
    filesModifiedCount: Long
    id: String!
    isAnomaly: Boolean!
    "The location of the object."
    location: String!
    managedId: String!
    objectType: ObjectTypeEnum
    previousSnapshotDate: DateTime!
    previousSnapshotId: String!
    "The ransomware analysis result, including encryption."
    ransomwareResult: RansomwareResult
    snappableFid: UUID!
    snappableId: String!
    snappableName: String
    "The analyzed snapshot."
    snapshot: CdmSnapshot
    snapshotDate: DateTime!
    snapshotFid: UUID!
    snapshotId: String!
    suspiciousFilesCount: Long
}

type AnomalyResultAggregation {
    bytesAdded: Long!
    bytesDeleted: Long!
    bytesModified: Long!
    filesAdded: Long!
    filesDeleted: Long!
    filesModified: Long!
}

"Paginated list of AnomalyResult objects."
type AnomalyResultConnection {
    aggregation: AnomalyResultAggregation!
    "Total number of AnomalyResult objects matching the request arguments."
    count: Int!
    "List of AnomalyResult objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [AnomalyResultEdge!]!
    "List of AnomalyResult objects."
    nodes: [AnomalyResult!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the AnomalyResult object. This wrapper is used for pagination."
type AnomalyResultEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual AnomalyResult object wrapped by this edge."
    node: AnomalyResult!
}

"Anomaly result data with groupby info applied to it"
type AnomalyResultGroupBy {
    "Paginated anomaly result data"
    anomalyResultConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter anomaly results by input"
        filter: AnomalyResultFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort anomaly results by field"
        sortBy: AnomalyResultSortByEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): AnomalyResultConnection!
    "Further provide groupings for the data."
    anomalyResultGroupBy(
        "group anomaly results by field"
        groupBy: AnomalyResultGroupByEnum!
    ): [AnomalyResultGroupBy!]!
    "Groupby info."
    groupByInfo: AnomalyResultGroupByInfo!
}

"Paginated list of AnomalyResultGroupBy objects."
type AnomalyResultGroupByConnection {
    "Total number of AnomalyResultGroupBy objects matching the request arguments."
    count: Int!
    "List of AnomalyResultGroupBy objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [AnomalyResultGroupByEdge!]!
    "List of AnomalyResultGroupBy objects."
    nodes: [AnomalyResultGroupBy!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the AnomalyResultGroupBy object. This wrapper is used for pagination."
type AnomalyResultGroupByEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual AnomalyResultGroupBy object wrapped by this edge."
    node: AnomalyResultGroupBy!
}

type AnomalyStatus {
    isAnomaly: Boolean!
}

type AnomalyTable {
    focus: ReportFocusEnum!
    groupBy: [AnomalyResultGroupByEnum!]
    name: String!
    selectedColumns: [AnomalyTableColumnEnum!]!
    sortBy: AnomalyResultSortByEnum
    sortOrder: SortOrderEnum
}

type AppBlueprintSnapshotCloudImage {
    appImageIds: [String!]!
    imageConverted: Boolean!
    snapshotFid: String!
}

type AppIDForType {
    appId: String!
    appType: String!
}

type AppflowsSummary {
    numBlueprintsReady: Int!
    numBlueprintsWithIssues: Int!
    numBpFailedLastFailover: Int!
    numBpFailedLastTestFailover: Int!
    numBpFailedTestFailoverLastQuarter: Int!
    numBpPassedLastFailover: Int!
    numBpPassedLastTestFailover: Int!
    numDRPlansReady: Int!
    numDRPlansWithIssues: Int!
    numVmwareVmsProtected: Int!
    totalBlueprints: Int!
    totalDRPlans: Int!
    totalVmwareVms: Int!
}

"Connection status for archival group."
type ArchivalGroupConnectionStatus {
    status: ConnectionStatusType!
}

type ArchivalLocation {
    bucket: String
    id: String!
    isActive: Boolean!
    locationType: ArchivalLocationType!
    name: String!
}

type ArchivalSpec {
    archivalTieringSpec: ArchivalTieringSpec
    "Archives all snapshots taken with the specified frequency."
    frequencies: [RetentionUnitEnum!]!
    storageSetting: TargetMapping
    threshold: Int!
    thresholdUnit: RetentionUnitEnum!
}

"Archival tiering specification."
type ArchivalTieringSpec {
    "Cold storage class for tiering."
    coldStorageClass: ColdStorageClass!
    "True when instant tiering enabled."
    isInstantTieringEnabled: Boolean!
    "Minimum accessible duration specified for smart tiering."
    minAccessibleDurationInSeconds: Long!
    "Tier existing snapshots for instant tiering, when true."
    shouldTierExistingSnapshots: Boolean!
}

"A reply of the async download request"
type AsyncDownloadReply {
    "The Id of the job"
    jobId: Long!
    "The reference Id of the job"
    referenceId: String!
}

type AsyncJobStatus {
    "Error message if pre validation failed."
    error: String!
    "Job ID for object if pre validation succeeds for object. If pre validation failed Job ID will be empty and detials will be present in error field."
    jobId: String!
}

type AsyncJobStatusJobError {
    error: String!
    rubrikObjectId: String!
}

type AsyncJobStatusJobId {
    jobId: String!
    rubrikObjectId: String!
}

"Supported in v5.0+"
type AsyncRequestStatus {
    """

    Supported in v5.0+
    The end time of the request.
    """
    endTime: DateTime
    """

    Supported in v5.0+
    Any errors encountered.
    """
    error: RequestErrorInfo
    """

    Required. Supported in v5.0+
    v5.0: The ID of the request object. Use it to poll the status.
    v5.1+: The ID of the request object used to poll the status.
    """
    id: String!
    """

    Required. Supported in v5.0+
    References to any related objects.
    """
    links: [Link!]!
    """

    Supported in v5.0+
    The ID of the node where the job ran.
    """
    nodeId: String
    """

    Supported in v5.0+
    v5.0: The current progress in terms of percentage of the async request.
    v5.1+: The current percentage progress of the asynchronous request.
    """
    progress: Float
    """

    Supported in v5.0+
    The start time of the request.
    """
    startTime: DateTime
    """

    Required. Supported in v5.0+
    v5.0: Status of the id.
    v5.1+: Status of the ID.
    """
    status: String!
}

"Host AWS EC2 instance specifications for AWS EBS volume."
type AttachmentSpecForEbsVolume {
    "EC2 instance ID."
    awsNativeEc2InstanceId: String!
    "The device path of the EBS volume on the instance."
    devicePath: String!
    "Specifies whether the EBS volume is excluded from snapshots of the EC2 instance.."
    isExcludedFromSnapshot: Boolean!
    "Specifies whether the EBS volume is the root volume."
    isRootVolume: Boolean!
}

"EBS volume attachment specifications."
type AttachmentSpecForEc2Instance {
    "EBS volume ID."
    awsNativeEbsVolumeId: String!
    "The device path of this EBS volume attachment."
    devicePath: String!
    "Specifies whether this EBS volume is excluded from snapshots."
    isExcludedFromSnapshot: Boolean!
    "Specifies whether this EBS volume is the root volume of the corresponding EC2 instance."
    isRootVolume: Boolean!
}

"Attachment Specifications for Azure Native Managed Disk."
type AttachmentSpecsForManagedDisk {
    attachedToVmId: String!
    isExcludedFromSnapshot: Boolean!
    isOsDisk: Boolean!
    lun: Int!
}

"Attachment Specifications for Azure Native Virtual Machine."
type AttachmentSpecsForVirtualMachine {
    isExcludedFromSnapshot: Boolean!
    isOsDisk: Boolean!
    lun: Int!
    managedDiskId: String!
}

type AuthorizedOperations {
    id: String!
    operations: [OperationEnum!]!
    snappableHierarchy: SnappableLevelHierarchyTypeEnum
}

"Ldap Authorized Principal"
type AuthorizedPrincipal {
    "ID of the authentication domain."
    authDomainId: String!
    "Name of the authentication domain."
    authDomainName: String!
    "Email address."
    email: String
    "Principal ID"
    id: String!
    "Last login timestamp."
    lastLogin: DateTime
    "Name of the principal."
    name: String!
    "Principal Type."
    principalType: PrincipalTypeEnum!
    roles: [Role!]!
    "TOTP status for a LDAP principal."
    totpStatus: LdapTotpStatus
}

"Paginated list of AuthorizedPrincipal objects."
type AuthorizedPrincipalConnection {
    "Total number of AuthorizedPrincipal objects matching the request arguments."
    count: Int!
    "List of AuthorizedPrincipal objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [AuthorizedPrincipalEdge!]!
    "List of AuthorizedPrincipal objects."
    nodes: [AuthorizedPrincipal!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the AuthorizedPrincipal object. This wrapper is used for pagination."
type AuthorizedPrincipalEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual AuthorizedPrincipal object wrapped by this edge."
    node: AuthorizedPrincipal!
}

"AWS Account specific info."
type AwsAccount implements CloudAccount {
    "Access key for IAM user, which is required while adding new AWS cloud account."
    accessKey: String!
    "The ID of this Cloud Account."
    cloudAccountId: String!
    "The type of this Cloud Provider."
    cloudProvider: CloudAccountType!
    "The connection status of this Cloud Account."
    connectionStatus: ConnectionStatusType!
    "The description of this Cloud Account."
    description: String
    "The name of this Cloud Account."
    name: String!
}

"Validate given aws accounts."
type AwsAccountValidationResponse {
    "AWS account name."
    accountName: String!
    "AWS account cloud type."
    cloudType: AwsCloudType!
    "AWS account validation response message."
    message: String!
    "AWS account native ID."
    nativeId: String!
    "Specfies whether seamless flow is enabled for this AWS account."
    seamlessFlowEnabled: Boolean!
}

"Details of AWS authentication server-based cloud account."
type AwsAuthServerDetail {
    "Agency name for the feature."
    agency: String!
    "List of AWS secret regions."
    authServerAwsRegions: [AwsAuthServerBasedCloudAccountRegion!]!
    "CA certificate ID for the authentication server."
    authServerCaCertId: Long!
    "Host name of the authentication server."
    authServerHostName: String!
    "Client's TLS Certificate ID for the authentication server."
    authServerUserClientCertId: Long!
    "Role name for the feature."
    roleName: String!
}

"CDM image version info from Aws marketplace."
type AwsCdmVersion {
    "Image ID."
    imageId: String!
    "Product codes of Aws image."
    productCodes: [String!]!
    "Image tag array with each element in key=value format."
    tags: [AwsCdmVersionTag!]!
    "Image version."
    version: String!
}

"CDM image version Tag."
type AwsCdmVersionTag {
    "Tag key."
    key: String!
    "Tag value."
    value: String!
}

"Details of AWS account."
type AwsCloudAccount {
    "Name of cloud account."
    accountName: String!
    "Type of cloud account."
    cloudType: AwsCloudType!
    "Rubrik ID of cloud account."
    id: String!
    "Message for cloud account, in case of error."
    message: String!
    "Native ID of cloud account."
    nativeId: String!
    "Whether seamless flow is enabled on cloud account."
    seamlessFlowEnabled: Boolean!
}

"Initiate aws cloud accounts."
type AwsCloudAccountCreateResponse {
    "List of AWS regions for the cloud account."
    awsRegions: [AwsCloudAccountRegion!]
    "AWS CloudFormation URL."
    cloudFormationUrl: String!
    "External ID for the cloud account."
    externalId: String!
    "List of feature versions."
    featureVersions: [AwsCloudAccountFeatureVersion!]!
    "Role ARN for the feature (if valid)."
    roleArn: String!
    "Stack name of template to run, only for single account addition."
    stackName: String
    "StackSet name of template to run, only for bulk account addition."
    stackSetName: String
    "AWS CloudFormation template URL."
    templateUrl: String!
}

"Feature version of AWS cloud accounts."
type AwsCloudAccountFeatureVersion {
    "Feature Enum."
    feature: CloudAccountFeature!
    "Version."
    version: Int!
}

"Aws cloud accounts validate response."
type AwsCloudAccountValidateResponse {
    "Contains error message for account(s)."
    invalidAwsAccounts: [AwsAccountValidationResponse!]!
    "Contains error message for admin account."
    invalidAwsAdminAccount: AwsAccountValidationResponse
}

"Aws cloud accounts features."
type AwsCloudAccountWithFeatures {
    "AWS account details."
    awsCloudAccount: AwsCloudAccount
    "Feature details for the cloud account."
    featureDetails: [FeatureDetail!]!
}

"Compute setting for AWS Target."
type AwsComputeSettings {
    cloudAccount: CloudAccount
    clusterInterfaceCidrs: [ClusterInfCidrs!]!
    id: String!
    isArchived: Boolean!
    isPolarisManaged: Boolean!
    name: String!
    proxySettings: ProxySettings
    region: AwsRegion!
    securityGroupId: String!
    subnetId: String!
    vpcId: String!
}

type AwsEc2Instance {
    imageId: String!
    instanceId: String!
    instanceName: String!
    instanceType: String!
}

"AWS Exocompute configurations in an AWS account."
type AwsExocomputeConfig {
    "Account details."
    awsCloudAccount: AwsCloudAccount!
    "AWS exocompute get configurations response."
    configs: [AwsExocomputeGetConfigResponse!]!
    "List of regions for which exocompute can be configured."
    exocomputeEligibleRegions: [AwsCloudAccountRegion!]!
    "Feature details."
    featureDetail: FeatureDetail!
}

"AWS Exocompute configurations Deletion status."
type AwsExocomputeConfigsDeletionStatusType {
    "Exocompute configuration ID."
    exocomputeConfigId: String!
    "Specifies whether the deletion of the Exocompute configuration was successful."
    success: Boolean!
}

"AWS Exocompute configuration in a region."
type AwsExocomputeGetConfigResponse {
    "Specifies whether the security groups are managed by Polaris."
    areSecurityGroupsPolarisManaged: Boolean!
    "Cluster security group ID."
    clusterSecurityGroupId: String!
    "Exocompute configuration UUID."
    configUuid: String!
    "Exocompute configuration message."
    message: String!
    "Node security group ID."
    nodeSecurityGroupId: String!
    "Exocompute configuration region."
    region: AwsCloudAccountRegion!
    "First subnet."
    subnet1: AwsExocomputeSubnetType!
    "Second subnet."
    subnet2: AwsExocomputeSubnetType!
    "VPC ID."
    vpcId: String!
}

"AWS Exocompute subnet."
type AwsExocomputeSubnetType {
    "Availability zone in which the subnet resides."
    availabilityZone: String!
    "ID of the subnet."
    subnetId: String!
}

"AWS feature configurations in an AWS account."
type AwsFeatureConfig {
    "Account details."
    awsCloudAccount: AwsCloudAccount!
    "Aws exocompute configurations."
    exocomputeConfigs: [AwsExocomputeGetConfigResponse!]!
    "Feature detail."
    featureDetail: FeatureDetail!
}

"Immutability settings for aws cdm target."
type AwsImmutabilitySettingsType {
    "Number of days location is immutable."
    lockDurationDays: Int!
}

type AwsInstanceType {
    instanceTypeId: Int!
    memoryMbs: Int!
    name: String!
    networkPerformance: String!
    region: String!
    storage: String!
    tenancy: String!
    vcpus: Int!
}

"AWS native account."
type AwsNativeAccount implements HierarchyObject & PolarisHierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [PolarisObjectAuthorizedOperationsEnum!]!
    "List of all EBS Volumes under this AWS Native account."
    awsNativeEbsVolumes(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        ebsVolumeFilters: AwsNativeEbsVolumeFilters,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Sort fields for list of AWS EBS volumes."
        sortBy: AwsNativeEbsVolumeSortFields,
        sortOrder: HierarchySortOrder
    ): AwsNativeEbsVolumeConnection!
    "List of all EC2 instances under this AWS Native account."
    awsNativeEc2Instances(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        ec2InstanceFilters: AwsNativeEc2InstanceFilters,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Sort fields for list of AWS EC2 instances."
        sortBy: AwsNativeEc2InstanceSortFields,
        sortOrder: HierarchySortOrder
    ): AwsNativeEc2InstanceConnection!
    "List of all RDS Instances under this AWS Native account."
    awsNativeRdsInstances(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        rdsInstanceFilters: AwsNativeRdsInstanceFilters,
        "Sort fields for list of AWS RDS instances."
        sortBy: AwsNativeRdsInstanceSortFields,
        sortOrder: HierarchySortOrder
    ): AwsNativeRdsInstanceConnection!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "Count of EBS Volumes in the AWS Native account."
    ebsVolumeCount: Int!
    "Count of EC2 Instances in the AWS Native account."
    ec2InstanceCount: Int!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Last refresh time of the account, in UTC date-time format."
    lastRefreshedAt: DateTime
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "Count of RDS Instances in the account."
    rdsInstanceCount: Int!
    "List of AWS region specifications associated with the account."
    regionSpecs: [AwsNativeRegionSpec!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "Specifies the state of account in Rubrik environment like Refreshed, Disconnected, etc. An account can be in a single state at a time."
    status: AwsAccountStatus!
}

"Paginated list of AwsNativeAccount objects."
type AwsNativeAccountConnection {
    "Total number of AwsNativeAccount objects matching the request arguments."
    count: Int!
    "List of AwsNativeAccount objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [AwsNativeAccountEdge!]!
    "List of AwsNativeAccount objects."
    nodes: [AwsNativeAccount!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the AwsNativeAccount object. This wrapper is used for pagination."
type AwsNativeAccountEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual AwsNativeAccount object wrapped by this edge."
    node: AwsNativeAccount!
}

"AWS native EBS volume."
type AwsNativeEbsVolume implements AwsNativeAccountDescendantType & AwsNativeAccountLogicalChildType & HierarchyObject & PolarisHierarchyObject & PolarisHierarchySnappable {
    "EC2 Instances to which this volume is attached."
    attachedEc2Instances: [AwsNativeEc2Instance!]!
    "List of EC2 instance details to which volume is attached."
    attachmentSpecs: [AttachmentSpecForEbsVolume!]!
    "The authorized operations on the object."
    authorizedOperations: [PolarisSnappableAuthorizedOperationsEnum!]!
    "Name of the Availability Zone (AZ). Some examples are: US_EAST_1, AP_EAST_1. This field cannot be null or empty string and will be mapped directly to available AZ for EC2 instance on cloud(AWS). For more information, see https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-availability-zones."
    availabilityZone: String!
    "Rubrik ID of Instance."
    awsAccountRubrikId: String!
    "AWS Native account associated with the EBS Volumes."
    awsNativeAccount: AwsNativeAccount!
    "Name for the AWS account."
    awsNativeAccountName: String!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Input/Output (IO) limit per second for volume."
    iops: Long!
    "Whether exocompute is configured for the region where the volume is."
    isExocomputeConfigured: Boolean!
    "Whether indexing is enabled for snapshots of volume."
    isIndexingEnabled: Boolean!
    "Whether the volume image is marketplace image."
    isMarketplace: Boolean!
    "Whether the volume is relic."
    isRelic: Boolean!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: PolarisSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: PolarisSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "Name of the region. Some examples are: US_EAST_1, AP_EAST_1. This field cannot be null or empty string and will be mapped directly to available regions for EBS volume on cloud(AWS). For more information, see https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions."
    region: AwsNativeRegion!
    "Size of volume in GiB."
    sizeInGiBs: Int!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this workload."
    snapshotsOfSnappableConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Whether to ignore the active protected object check."
        ignoreActiveSnappableCheck: Boolean,
        "Returns the last n elements from the list."
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
    "List of tags associated with volume."
    tags: [Tag!]!
    "Name of volume on AWS. Name is not necessarily unique for different volumes."
    volumeName: String!
    "AWS Native ID of EBS volume."
    volumeNativeId: String!
    "AWS Native EBS volume type. Some examples are: g3, io2. This field cannot be null or empty string and will be mapped directly to available EBS volumes on cloud(AWS). For more information, see https://aws.amazon.com/ebs/volume-types."
    volumeType: String!
}

"Paginated list of AwsNativeEbsVolume objects."
type AwsNativeEbsVolumeConnection {
    "Total number of AwsNativeEbsVolume objects matching the request arguments."
    count: Int!
    "List of AwsNativeEbsVolume objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [AwsNativeEbsVolumeEdge!]!
    "List of AwsNativeEbsVolume objects."
    nodes: [AwsNativeEbsVolume!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the AwsNativeEbsVolume object. This wrapper is used for pagination."
type AwsNativeEbsVolumeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual AwsNativeEbsVolume object wrapped by this edge."
    node: AwsNativeEbsVolume!
}

"AWS native EC2 instance."
type AwsNativeEc2Instance implements AwsNativeAccountDescendantType & AwsNativeAccountLogicalChildType & HierarchyObject & PolarisHierarchyObject & PolarisHierarchySnappable {
    "Attached ebs volumes"
    attachedEbsVolumes: [AwsNativeEbsVolume!]!
    "List of EBS volume details attached to the instance."
    attachmentSpecs: [AttachmentSpecForEc2Instance!]!
    "The authorized operations on the object."
    authorizedOperations: [PolarisSnappableAuthorizedOperationsEnum!]!
    "Name of the Availability Zone (AZ). Some examples are: US_EAST_1, AP_EAST_1. This field cannot be null or empty string and will be mapped directly to available AZs for EC2 instance on cloud(AWS). For more information, see https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-availability-zones."
    availabilityZone: String!
    "Rubrik ID of Instance."
    awsAccountRubrikId: String!
    "Aws account of the Ec2 instance"
    awsNativeAccount: AwsNativeAccount!
    "Name for the AWS Account."
    awsNativeAccountName: String!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "Rubrik CDM host information for the AWS EC2 instance added as a host to the cluster. The value is Null when the virtual machine is not added as a host on any Rubrik cluster."
    hostInfo: PhysicalHost
    "The fid of the hierarchy object."
    id: UUID!
    "Name of instance on AWS. Name is not necessarily unique for different instances."
    instanceName: String!
    "AWS Native ID of Instance."
    instanceNativeId: String!
    "AWS Native EC2 instance type. Some examples are: t2.nano, m5.xlarge. This field cannot be null or empty string and will be mapped directly to available EC2 instance on cloud(AWS). For more information, see https://aws.amazon.com/ec2/instance-types."
    instanceType: String!
    "Whether exocompute is configured for the region where the instance is."
    isExocomputeConfigured: Boolean!
    "Whether indexing is enabled for snapshots of instance."
    isIndexingEnabled: Boolean!
    "Whether the instance image is marketplace image."
    isMarketplace: Boolean!
    "Whether the instance is relic."
    isRelic: Boolean!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: PolarisSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: PolarisSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    "Name of the Operating System (OS) for the Instance. Some examples are: Linux, Windows. This field cannot be null or empty string but can be Undefined in case it is not currently supported.List of supported OS: Linux, Windows."
    osType: OsTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "Private IP address for instance."
    privateIp: String!
    "Public IP address for instance."
    publicIp: String!
    "Name of the region. Some examples are: US_EAST_1, AP_EAST_1. This field cannot be null or empty string and will be mapped directly to available regions for EC2 instance on cloud(AWS). For more information, see https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions."
    region: AwsNativeRegion!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this workload."
    snapshotsOfSnappableConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Whether to ignore the active protected object check."
        ignoreActiveSnappableCheck: Boolean,
        "Returns the last n elements from the list."
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
    "Name of SSH key-pair for the Instance."
    sshKeyPairName: String!
    "List of tags associated with Instance."
    tags: [Tag!]!
    "ID of Virtual Private Cloud (VPC) associated with instance."
    vpcId: String!
    "Name of Virtual Private Cloud (VPC) associated with instance."
    vpcName: String!
}

"Paginated list of AwsNativeEc2Instance objects."
type AwsNativeEc2InstanceConnection {
    "Total number of AwsNativeEc2Instance objects matching the request arguments."
    count: Int!
    "List of AwsNativeEc2Instance objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [AwsNativeEc2InstanceEdge!]!
    "List of AwsNativeEc2Instance objects."
    nodes: [AwsNativeEc2Instance!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the AwsNativeEc2Instance object. This wrapper is used for pagination."
type AwsNativeEc2InstanceEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual AwsNativeEc2Instance object wrapped by this edge."
    node: AwsNativeEc2Instance!
}

"AWS native RDS instance."
type AwsNativeRdsInstance implements AwsNativeAccountDescendantType & AwsNativeAccountLogicalChildType & HierarchyObject & PolarisHierarchyObject & PolarisHierarchySnappable {
    "Allocated size of RDS Instance in GiB."
    allocatedStorageInGibi: Long!
    "The authorized operations on the object."
    authorizedOperations: [PolarisSnappableAuthorizedOperationsEnum!]!
    "Rubrik Identifier for account associated with RDS Instance."
    awsAccountRubrikId: String!
    "AWS account of the RDS instance"
    awsNativeAccount: AwsNativeAccount!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "Engine being used for RDS Instance."
    dbEngine: AwsNativeRdsDbEngine!
    "Class type of RDS Instance."
    dbInstanceClass: AwsNativeRdsDbInstanceClass!
    "Name of RDS Instance."
    dbInstanceName: String!
    "Resource identifier of RDS Instance."
    dbiResourceId: String!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Identifies if the RDS Instance is part of multiple Availability Zones."
    isMultiAz: Boolean!
    "Specifies whether the RDS Instance is a relic."
    isRelic: Boolean!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "Maintenance window of RDS Instance."
    maintenanceWindow: String!
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: PolarisSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: PolarisSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "Name of Availability Zone(AZ) associated with RDS Instance."
    primaryAvailabilityZone: String!
    "Name of the source RDS instance if this instance is a read replica. This field is not applicable for primary RDS instances."
    readReplicaSourceName: String!
    "AWS region of RDS Instance."
    region: AwsNativeRegion!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this workload."
    snapshotsOfSnappableConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Whether to ignore the active protected object check."
        ignoreActiveSnappableCheck: Boolean,
        "Returns the last n elements from the list."
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
    "List of tags associated with RDS Instance."
    tags: [Tag!]!
    "Identifier of VPC associated with RDS Instance."
    vpcId: String!
    "Name of VPC associated with RDS Instance."
    vpcName: String!
}

"Paginated list of AwsNativeRdsInstance objects."
type AwsNativeRdsInstanceConnection {
    "Total number of AwsNativeRdsInstance objects matching the request arguments."
    count: Int!
    "List of AwsNativeRdsInstance objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [AwsNativeRdsInstanceEdge!]!
    "List of AwsNativeRdsInstance objects."
    nodes: [AwsNativeRdsInstance!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the AwsNativeRdsInstance object. This wrapper is used for pagination."
type AwsNativeRdsInstanceEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual AwsNativeRdsInstance object wrapped by this edge."
    node: AwsNativeRdsInstance!
}

"The Point-in-Time (PiT) restore window of the RDS Instance."
type AwsNativeRdsPointInTimeRestoreWindow {
    "The earliest time to which RDS Instance can be restored."
    earliestTime: DateTime
    "The latest time to which RDS Instance can be restored."
    latestTime: DateTime
}

"List of AWS region specifications associated with an AWS account."
type AwsNativeRegionSpec {
    "A boolean specifying whether exocompute is configured in the region or not."
    isExocomputeConfigured: Boolean!
    "Name of the AWS region."
    region: AwsNativeRegion!
}

"Represents a subnet in AWS."
type AwsNativeSubnet {
    "Availability Zone corresponding to the subnet."
    availabilityZone: String!
    "ID of the subnet."
    id: String!
    "Name of the subnet."
    name: String!
}

"The SLA Domain configuration for AWS RDS instances."
type AwsRdsConfig {
    "Specifies the duration for which the logs will be retained. This duration determines the earliest time to which a Point-in-Time recovery can be performed on the associated RDS instances."
    logRetention: Duration
}

"AWS Replication target."
type AwsReplicationTarget {
    "AWS account ID."
    accountId: String!
    "AWS account name."
    accountName: String!
    region: AwsNativeRegionForReplication!
}

"AWS role based Account specific info."
type AwsRoleBasedAccount implements CloudAccount {
    awsSpecificInfo: AwsCloudAccountWithFeatures!
    "The ID of this Cloud Account."
    cloudAccountId: String!
    "The type of this Cloud Provider."
    cloudProvider: CloudAccountType!
    "The connection status of this Cloud Account."
    connectionStatus: ConnectionStatusType!
    "The description of this Cloud Account."
    description: String
    "The name of this Cloud Account."
    name: String!
}

"A Security group in AWS realm."
type AwsSecurityGroup {
    id: String!
    name: String!
}

type AwsStorageVolumeType {
    maxIops: Int!
    maxSizeGbs: Int!
    name: String!
    volumeTypeId: Int!
}

"A Subnet in AWS realm."
type AwsSubnet {
    "Availability zone in which the subnet resides."
    availabilityZone: String!
    "ID of the subnet."
    id: String!
    "Name of the subnet."
    name: String!
}

"Specific info for AWS Target Template."
type AwsTargetTemplate implements TargetTemplate {
    bucketPrefix: String!
    bucketTags: [TagObject!]!
    cloudAccount: CloudAccount!
    cloudNativeLocTemplateType: CloudNativeLocTemplateType!
    computeSettings: AwsComputeSettings
    encryptionType: TargetEncryptionTypeEnum!
    isConsolidationEnabled: Boolean!
    kmsMasterKeyId: String
    proxySettings: ProxySettings
    region: AwsRegion!
    storageClass: AwsStorageClassTypeEnum!
    "The type of this Target."
    targetType: TargetTypeEnum!
}

type AwsVMNicSpec {
    ipv4Address: String!
    key: Int!
    "security group of the nic"
    securityGroup: SnappableSecurityGroup
    securityGroupId: String!
    "subnet of the nic"
    subnet: SnappableSubnet
    subnetId: String!
}

type AwsVMVolumeSpec {
    iops: Int!
    key: Int!
    sizeGbs: Int!
    volumeTypeId: Int!
}

"A Virtual Private Cloud (VPC) in AWS realm."
type AwsVpc {
    "ID for the VPC."
    id: String!
    "Name of the VPC."
    name: String!
    "List of security groups associated with the VPC."
    securityGroups: [AwsSecurityGroup!]!
    "List of subnets associated with the VPC."
    subnets: [AwsSubnet!]!
}

"Azure Account specific info."
type AzureAccount implements CloudAccount {
    "The ID of this Cloud Account."
    cloudAccountId: String!
    "The type of this Cloud Provider."
    cloudProvider: CloudAccountType!
    "The connection status of this Cloud Account."
    connectionStatus: ConnectionStatusType!
    "The description of this Cloud Account."
    description: String
    "The name of this Cloud Account."
    name: String!
    "The native ID of the subscription."
    subscriptionId: String!
    "The native ID of the tenant of the subscription."
    tenantId: String!
}

"CDM image version info from Azure marketplace."
type AzureCdmVersion {
    "Image SKU."
    sku: String!
    "Image tag array with each element in key=value format."
    tags: [AzureCdmVersionTag!]!
    "Image version."
    version: String!
}

"CDM image version Tag."
type AzureCdmVersionTag {
    "Tag key."
    key: String!
    "Tag value."
    value: String!
}

"Azure Cloud Account Feature details."
type AzureCloudAccountFeatureDetail {
    feature: CloudAccountFeature!
    "Persistent storage configured for the feature. It is null for features other than Azure SQL DB and Azure SQL MI."
    persistentStorage: PersistentStorage
    regions: [AzureCloudAccountRegion!]!
    "Resource group for the feature."
    resourceGroup: AzureResourceGroup!
    status: CloudAccountStatus!
    "User assigned managed identity for encryption feature. It is null for features other than Cloud Native Archival Encryption."
    userAssignedManagedIdentity: AzureUserAssignedManagedIdentity
}

"Configuration consisting of role permissions and feature policy version required for Azure subscription setup. Features refer to the Polaris features that the customer wants to be enabled on the cloud account."
type AzureCloudAccountPermissionConfigResponse {
    "Policy permission version to be used on Polaris for adding a subscription."
    permissionVersion: Int!
    "List of permissions to be applied on the role created in Azure for a subscription."
    rolePermissions: [AzureCloudAccountRolePermission!]!
}

"Azure Permission type with included and excluded actions."
type AzureCloudAccountRolePermission {
    "Actions which should be explicitly disallowed on the Azure role for the subscription."
    excludedActions: [String!]!
    "Data actions which should be explicitly disallowed on the Azure role for the subscription."
    excludedDataActions: [String!]!
    "Actions which should be allowed on the Azure role for the subscription."
    includedActions: [String!]!
    "Data actions which should be allowed on the Azure role for the subscription."
    includedDataActions: [String!]!
}

"Azure Cloud Account Subscription for a given feature."
type AzureCloudAccountSubscription {
    customerSubscriptionId: String!
    customerTenantId: String!
    isAuthorized: Boolean!
    name: String!
    nativeId: String!
}

"Azure Cloud Account Subscription details for a given feature."
type AzureCloudAccountSubscriptionDetail {
    featureDetail: AzureCloudAccountFeatureDetail
    id: String!
    name: String!
    nativeId: String!
}

"Azure cloud account with features."
type AzureCloudAccountSubscriptionWithFeatures {
    "Details of features of the cloud account."
    featureDetails: [AzureCloudAccountFeatureDetail!]!
    "Azure subscription details."
    subscription: AzureCloudAccountSubscription
}

"Azure Tenant with details of subscriptions that are configured for a given feature."
type AzureCloudAccountTenant {
    "Rubrik ID of the Azure Tenant."
    azureCloudAccountTenantRubrikId: String!
    "Client ID of the application configured for authentication of the Azure tenant."
    clientId: String!
    "Type of Azure Tenant. Possible values: Azure Public Cloud, Azure China Cloud."
    cloudType: AzureCloudType!
    "Domain Name of the Azure Tenant."
    domainName: String!
    "Count of subscriptions added to the Rubrik ecosystem for this Azure Tenant."
    subscriptionCount: Int!
    "Subscriptions added to the Rubrik ecosystem for this Azure Tenant."
    subscriptions: [AzureCloudAccountSubscriptionDetail!]!
}

"Azure Cloud Account Tenant with details of exocompute configured for subscriptions for a given feature."
type AzureCloudAccountTenantWithExoConfigs {
    "Client ID of azure application for the tenant."
    clientId: String!
    "Type of Azure Tenant. Can be Azure Public Cloud or Azure China Cloud."
    cloudType: AzureCloudType!
    "Azure Active Directory (AD) domain corresponding to subscription."
    domainName: String!
    "Number of subscriptions for the tenant."
    subscriptionCount: Int!
    "Details of subscriptions for the tenant."
    subscriptions: [AzureSubscriptionWithExoConfigs!]!
}

"Azure native archival specific fields for Azure Target Template."
type AzureCloudNativeTargetCompanion {
    "Template type of the storage settings. Must be either SOURCE_REGION or SPECIFIC_REGION."
    cloudNativeLocTemplateType: CloudNativeLocTemplateType!
    "List of configured customer managed keys per region."
    cmkInfo: [AzureCmk!]!
    "Redundancy type for the Storage Account. Some examples are: LRS, ZRS, GRS etc. More Info: https://docs.microsoft.com/en-us/azure/storage/common/storage-redundancy."
    redundancy: AzureRedundancy!
    "Region for the Storage Account. All the storage accounts created are General Purpose V2 Storage Account. GPV2 accounts are supported only in certain regions. List of Supported Regions: https://docs.microsoft.com/en-us/azure/storage/common/storage-redundancy#redundancy-in-the-primary-region."
    storageAccountRegion: AzureRegion!
    "Tags for the Storage Account."
    storageAccountTags: [TagObject!]!
    "Storage Tier for the Storage Account. Only Cool, Hot storage tier are supported for now. More Info: https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-storage-tiers."
    storageTier: AzureStorageTier!
    "Native id of the Azure subscription."
    subscriptionNativeId: String!
}

type AzureClusterCreateReply {
    clusterUuid: String!
    vmInfo: [VmInfo!]!
}

"Customer managed key vault and key information for a region."
type AzureCmk {
    "Name of the customer managed key."
    keyName: String!
    "Name of the key vault."
    keyVaultName: String!
    "Region of the key vault."
    region: AzureRegion!
}

"Compute setting for Azure Target."
type AzureComputeSettings {
    appId: String!
    computeProxySettings: ProxySettings
    generalPurposeStorageContainer: String!
    generalPurposeStorageName: String!
    region: AzureRegion!
    resourceGroup: String!
    securityGroupId: String!
    subnetId: String!
    virtualNetworkId: String!
}

"Details of Azure Encryption Key."
type AzureEncryptionKey {
    "Name of Encryption Key."
    keyName: String!
}

"Exocompute configurations details."
type AzureExocomputeConfigDetails {
    "ID for exocompute configuration."
    configUuid: String!
    "Whether exocompute is polaris managed or not."
    isPolarisManaged: Boolean!
    message: String!
    "Region in which exocompute is configured. It will be in the format like EASTUS."
    region: AzureCloudAccountRegion!
    "Native ID of subnet coresponding to exocompute. This will be the subnet provided during setting up exocompute."
    subnetNativeId: String!
}

"Contains validation information, such as blockers or errors encountered in validating the Exocompute configuration."
type AzureExocomputeConfigValidationInfo {
    config: AzureExocomputeRegionConfig
    errorMessage: String!
    "Specifies whether the configuration has blocking security rules in its associated network security group attached to the subnet for running AKS cluster in the specific region. For more details, visit https://docs.microsoft.com/en-us/azure/aks/limit-egress-traffic#required-outbound-network-rules-and-fqdns-for-aks-clusters."
    hasBlockedSecurityRules: Boolean!
    "Specifies whether the configuration has the corresponding subnet address range overlap with Azure restricted address ranges. For more details, visit https://docs.microsoft.com/en-us/azure/aks/configure-azure-cni#prerequisites."
    hasRestrictedAddressRangeOverlap: Boolean!
    "Specifies whether the the subnet specified in configuration is delegated. For more details, visit https://docs.microsoft.com/en-us/azure/aks/configure-azure-cni#prerequisites."
    isSubnetDelegated: Boolean!
}

"Azure Exocompute configurations in an Azure subscription."
type AzureExocomputeConfigsInAccount {
    "Account details."
    azureCloudAccount: AzureCloudAccountSubscriptionDetail!
    "Azure exocompute configurations."
    configs: [AzureExocomputeGetConfigResponse!]!
    "List of regions for which exocompute can be configured."
    exocomputeEligibleRegions: [AzureCloudAccountRegion!]!
    "Feature details."
    featureDetails: AzureCloudAccountFeatureDetail!
}

"Azure Exocompute config."
type AzureExocomputeGetConfigResponse {
    configUuid: String!
    isPolarisManaged: Boolean!
    message: String!
    region: AzureCloudAccountRegion!
    subnetNativeId: String!
}

"Represents an Azure Exocompute Configuration for a specific region. The Azure Exocompute Configuration includes the subnet native ID to be used for launching an Azure Kubernetes Service (AKS) Cluster in a specific region."
type AzureExocomputeRegionConfig {
    isPolarisManaged: Boolean!
    region: AzureCloudAccountRegion!
    subnetNativeId: String!
}

"Immutability settings for azure cdm target."
type AzureImmutabilitySettingsType {
    "Number of days location is immutable."
    lockDurationDays: Int!
}

"Details of Azure Key Vault."
type AzureKeyVault {
    "Whether the Key Vault is accessible by the user assigned managed identity. False by default if userAssignedManagedIdentityPrincipalId is not provided."
    isAccessibleByUserAssignedManagedIdentity: Boolean!
    "Name of Key Vault."
    keyVaultName: String!
    "Name of resource group in which the Key Vault resides."
    resourceGroupName: String!
}

"Mapped Azure subscription for launching Exocompute."
type AzureMappedExocomputeSubscription {
    "Cloud account ID of the Azure subscription."
    id: String!
    "Name of the Azure subscription."
    name: String!
    "Native ID of the Azure subscription."
    nativeId: String!
}

"An Azure availability set. An availability set is a logical grouping of VMs to facilitate redundancy and availability. For more information, see https://docs.microsoft.com/en-us/azure/virtual-machines/availability-set-overview."
type AzureNativeAvailabilitySet {
    "Name of the availability set."
    name: String!
    "Native ID of the availability set."
    nativeId: String!
}

"List of disk types available for use in an Azure availability zone. Not all disk types are supported in all the regions. For more information, see https://docs.microsoft.com/en-us/azure/virtual-machines/disks-types."
type AzureNativeExportCompatibleDiskTypes {
    "Availabity zone of the disk."
    availabilityZone: String!
    "Types of the disk."
    diskTypes: [AzureNativeManagedDiskType!]!
}

"The virtual machine (VM) sizes for an Azure availability zone. Not all VM sizes are supported in all the regions. For more information, see https://docs.microsoft.com/en-us/azure/virtual-machines/sizes."
type AzureNativeExportCompatibleVmSizes {
    "Availability zone of the virtual machine (VM)."
    availabilityZone: String!
    "Sizes of the virtual machines (VMs). For more information, see https://docs.microsoft.com/en-us/azure/virtual-machines/sizes."
    vmSizes: [String!]!
}

"An Azure Native Managed Disk that refers to the block storage designed to be used with Azure Virtual Machines. Some examples are: ultra disks, premium solid-state drives (SSD), standard SSDs, and standard hard disk drives (HDD). For more information, see https://docs.microsoft.com/en-us/azure/virtual-machines/managed-disks-overview."
type AzureNativeManagedDisk implements HierarchyObject & PolarisHierarchyObject & PolarisHierarchySnappable {
    "All Virtual Machines (VMs) attached to the Managed Disk."
    allAttachedAzureNativeVirtualMachines: [AzureNativeVirtualMachine!]!
    "Attachment Specifications are properties of the Managed Disk,  like the ID of the virtual machine (VM) that is associated with the Managed Disk."
    attachmentSpecs: [AttachmentSpecsForManagedDisk!]!
    "The authorized operations on the object."
    authorizedOperations: [PolarisSnappableAuthorizedOperationsEnum!]!
    "Availability Zone associated with the Managed Disk."
    availabilityZone: String!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "Number of Input/Output operations Per Second (IOPS) allowed for the Managed Disk."
    diskIopsReadWrite: Long!
    "Bandwidth allowed for the Managed Disk, in millions of bytes per second (MBps)."
    diskMbpsReadWrite: Long!
    "Native ID of the Managed Disk."
    diskNativeId: String!
    "Size of the Managed Disk in gigabytes (GiB)."
    diskSizeGib: Int!
    "Storage tier of the Managed Disk."
    diskStorageTier: AzureNativeManagedDiskType!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Specifies whether Azure Disk Encryption (ADE) is enabled on the Managed Disk or not. When the value is true, ADE is enabled."
    isAdeEnabled: Boolean!
    "Specifies whether exocompute is configured for the region in which the Managed Disk exists or not. When the value is true, exocompute can be used to perform tasks like file indexing."
    isExocomputeConfigured: Boolean!
    "Specifies whether file indexing is enabled for this Managed Disk or not. When file indexing is enabled, Rubrik can scan through the file structure inside the managed disk in a protected environment where only the meta data like folder structure, file names, and file sizes will be readable by Rubrik."
    isFileIndexingEnabled: Boolean!
    "Specifies whether the Managed Disk is a relic. When the value is true, the Managed Disk is a relic. A managed disk is a relic when it is unprotected or deleted, but the previously taken snapshots of the VM continue to exist within the Rubrik ecosystem."
    isRelic: Boolean!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: PolarisSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: PolarisSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    "Type of the Operating System (OS) installed on the Managed Disk."
    osType: AzureNativeVmOsType!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "Azure region where the Managed Disk is located."
    region: AzureNativeRegion!
    "Resource Group of the Azure Native Managed Disk."
    resourceGroup: AzureNativeResourceGroup!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this workload."
    snapshotsOfSnappableConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Whether to ignore the active protected object check."
        ignoreActiveSnappableCheck: Boolean,
        "Returns the last n elements from the list."
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
    "List of tags associated with the Managed Disk."
    tags: [AzureTag!]!
}

"Paginated list of AzureNativeManagedDisk objects."
type AzureNativeManagedDiskConnection {
    "Total number of AzureNativeManagedDisk objects matching the request arguments."
    count: Int!
    "List of AzureNativeManagedDisk objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [AzureNativeManagedDiskEdge!]!
    "List of AzureNativeManagedDisk objects."
    nodes: [AzureNativeManagedDisk!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the AzureNativeManagedDisk object. This wrapper is used for pagination."
type AzureNativeManagedDiskEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual AzureNativeManagedDisk object wrapped by this edge."
    node: AzureNativeManagedDisk!
}

"Azure region specification."
type AzureNativeRegionSpec {
    "Specifies whether Exocompute is configured in the region or not."
    isExocomputeConfigured: Boolean!
    "Name of the Azure region."
    region: AzureNativeRegion!
}

"An Azure Native Resource Group. Refers to a collection of resources in which multiple Azure services can reside."
type AzureNativeResourceGroup implements HierarchyObject & PolarisHierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [PolarisObjectAuthorizedOperationsEnum!]!
    "Paginated ist of Azure Virtual Machines (VMs) in the Resource Group."
    azureNativeVirtualMachines(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Sort fields for list of Azure virtual machines."
        sortBy: AzureNativeVirtualMachineSortFields,
        sortOrder: HierarchySortOrder,
        virtualMachineFilters: AzureNativeVirtualMachineFilters
    ): AzureNativeVirtualMachineConnection!
    "Count of Azure SQL databases in the Resource Group."
    azureSqlDatabaseCount: Int!
    "Count of Azure SQL Managed Instance databases in the Resource Group."
    azureSqlManagedInstanceDbCount: Int!
    "Rubrik ID of the Azure Native Resource Group."
    azureSubscriptionRubrikId: UUID!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "Deprecated, use protectedObjectTypeToSla instead. Rubrik Service Level Agreement (SLA) assigned to the disks in the Resource Group."
    diskSla: AzureNativeResourceGroupSlaAssignment!
    "Count of disks in the Resource Group."
    disksCount: Int!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "A list of mappings between protected object types and SLA Domains."
    protectedObjectTypeToSla: [ProtectedObjectTypeToSla!]!
    "Azure region associated with the Resource Group."
    region: AzureNativeRegion!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "A list of mappings between object types and details about the backup setup."
    snappableTypeToBackupSetupSpecs: [SnappableTypeToBackupSetupSpecs!]!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "Azure Native Subscription of the Resource Group."
    subscription: AzureNativeSubscription!
    "List of tags associated with the Resource Group."
    tags: [AzureTag!]!
    "Deprecated, use protectedObjectTypeToSla instead. Rubrik Service Level Agreement (SLA) assigned to the Virtual Machines (VMs) in the Resource Group."
    vmSla: AzureNativeResourceGroupSlaAssignment!
    "Count of Virtual Machines (VMs) in the Resource Group."
    vmsCount: Int!
}

"Paginated list of AzureNativeResourceGroup objects."
type AzureNativeResourceGroupConnection {
    "Total number of AzureNativeResourceGroup objects matching the request arguments."
    count: Int!
    "List of AzureNativeResourceGroup objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [AzureNativeResourceGroupEdge!]!
    "List of AzureNativeResourceGroup objects."
    nodes: [AzureNativeResourceGroup!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the AzureNativeResourceGroup object. This wrapper is used for pagination."
type AzureNativeResourceGroupEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual AzureNativeResourceGroup object wrapped by this edge."
    node: AzureNativeResourceGroup!
}

"SLA Domain assignment type for the Azure resource group."
type AzureNativeResourceGroupSlaAssignment {
    configuredSlaDomain: GlobalSla!
    effectiveSlaDomain: GlobalSla!
    slaAssignment: SlaAssignmentTypeEnum!
}

"An Azure security group. Security groups enable you to configure network security as a natural extension of an application's structure, allowing you to group virtual machines and define network security policies based on those groups. For more information, see https://docs.microsoft.com/en-us/azure/virtual-network/application-security-groups."
type AzureNativeSecurityGroup {
    "Name of the security group."
    name: String!
    "Native ID of the security group."
    nativeId: String!
    "Name of the resource group associated with the security group."
    resourceGroupName: String!
}

"The Point-in-Time (PiT) restore window of the Azure SQL Database. Database could be Azure SQL Managed Instance Database or Azure SQL Server Database."
type AzureNativeSqlDatabasePointInTimeRestoreWindow {
    "The earliest time to which database can be restored."
    earliestTime: DateTime
    "The latest time to which database can be restored."
    latestTime: DateTime
}

"Azure storage account."
type AzureNativeStorageAccount {
    "Azure ID of the storage account."
    id: String!
    "Name of the storage account."
    name: String!
    "Region where the storage account is located."
    region: AzureNativeRegion!
    "Name of the resource group where storage account is located."
    resourceGroupName: String!
    "Tags attached to the storage account."
    tags: [AzureTag!]!
}

"An Azure subnet. Subnets allow you to choose IP address range of your choice. For more information, see https://docs.microsoft.com/en-us/azure/virtual-network/network-overview#virtual-network-and-subnets."
type AzureNativeSubnet {
    "List of subnet IP address prefixes in CIDR notation. The list can contain both IPv4 and IPv6 addresses. The list cannot be empty."
    addressPrefixes: [String!]!
    "Name of the subnet."
    name: String!
    "Native ID of the subnet."
    nativeId: String!
    "Virtual Network (VNet) associated with the subnet."
    vnet: AzureNativeVirtualNetwork!
}

"An Azure Native Subscription. Refers to the logical entity that provides entitlement to deploy and consume Azure resources."
type AzureNativeSubscription implements HierarchyObject & PolarisHierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [PolarisObjectAuthorizedOperationsEnum!]!
    "Type of Azure cloud, for example, Azure Public Cloud and Azure China Cloud."
    azureCloudType: AzureCloudType!
    "Paginated list of all Azure Resource Groups in the subscription."
    azureNativeResourceGroups(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Filters for listing Azure resource groups"
        commonResourceGroupFilters: AzureNativeCommonResourceGroupFilters,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Sort fields for listing Azure resource groups."
        sortBy: AzureNativeCommonResourceGroupSortFields,
        sortOrder: HierarchySortOrder
    ): AzureNativeResourceGroupConnection!
    "Count of Azure SQL databases in the subscription."
    azureSqlDatabaseDbCount: Int!
    "Count of Azure SQL Managed Instance databases in the subscription."
    azureSqlManagedInstanceDbCount: Int!
    "Native ID of the subscription."
    azureSubscriptionNativeId: String!
    "Status of the subscription at a given time. Some examples are: added, deleted, refreshed. For more information, see https://docs.microsoft.com/en-us/azure/cost-management-billing/manage/subscription-states."
    azureSubscriptionStatus: AzureSubscriptionStatus!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "Count of managed disks in the subscription."
    disksCount: Int!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "Details of features enabled for the subscription."
    enabledFeatures: [AzureNativeSubscriptionEnabledFeature!]!
    "The fid of the hierarchy object."
    id: UUID!
    "Last refresh time of the subscription, in UTC date-time format."
    lastRefreshedAt: DateTime
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "List of Azure region specifications associated with the subscription."
    regionSpecs: [AzureNativeRegionSpec!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "A list of mappings between object types and details about the backup setup."
    snappableTypeToBackupSetupSpecs: [SnappableTypeToBackupSetupSpecs!]!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "Tenant ID associated with the subscription."
    tenantId: String!
    "Count of virtual machines (VMs) in the subscription."
    vmsCount: Int!
}

"Paginated list of AzureNativeSubscription objects."
type AzureNativeSubscriptionConnection {
    "Total number of AzureNativeSubscription objects matching the request arguments."
    count: Int!
    "List of AzureNativeSubscription objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [AzureNativeSubscriptionEdge!]!
    "List of AzureNativeSubscription objects."
    nodes: [AzureNativeSubscription!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the AzureNativeSubscription object. This wrapper is used for pagination."
type AzureNativeSubscriptionEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual AzureNativeSubscription object wrapped by this edge."
    node: AzureNativeSubscription!
}

"Details of a feature enabled in Azure Native Subscription."
type AzureNativeSubscriptionEnabledFeature {
    "Name of the feature enabled for the Azure Subscription."
    featureName: AzureNativeProtectionFeature!
    "Time, in UTC date-time format, when the feature was last refreshed."
    lastRefreshedAt: DateTime
    "Status of the feature at a given time. Some examples are: added, deleted, refreshed."
    status: AzureSubscriptionStatus!
}

"An Azure Native Virtual Machine that refers to the Azure infrastructure as a service (IaaS) used to deploy persistent VMs. For more information, see https://docs.microsoft.com/en-us/azure/virtual-machines/."
type AzureNativeVirtualMachine implements HierarchyObject & PolarisHierarchyObject & PolarisHierarchySnappable {
    "List of Managed Disks attached to the Azure Virtual Machine (VM)."
    attachedManagedDisks: [AzureNativeManagedDisk!]!
    "Sequence of attachment specs for the virtual machine (VM)."
    attachmentSpecs: [AttachmentSpecsForVirtualMachine!]!
    "The authorized operations on the object."
    authorizedOperations: [PolarisSnappableAuthorizedOperationsEnum!]!
    "Native ID of the availability set associated with the virtual machine (VM)."
    availabilitySetNativeId: String!
    "Availability Zone associated with the virtual machine (VM)."
    availabilityZone: String!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "Rubrik CDM host information for the Azure Virtual Machine added as a host to the cluster. The value is Null when the virtual machine is not added as a host on any Rubrik cluster."
    hostInfo: PhysicalHost
    "The fid of the hierarchy object."
    id: UUID!
    "Specifies whether accelerated networking is enabled on the virtual machine (VM) or not. Accelerated Networking improves the network performance on the VM. For more information, see https://docs.microsoft.com/en-us/azure/virtual-machine-scale-sets/virtual-machine-scale-sets-networking."
    isAcceleratedNetworkingEnabled: Boolean!
    "Specifies whether Azure Disk Encryption (ADE) exists on the virtual machine (VM) or not."
    isAdeEnabled: Boolean!
    "Specifies whether application consistent snapshots are enabled for this virtual machine (VM) or not. When enabled, Rubrik informs the Azure applications before taking snapshots, so apps can prepare. During the preparation phrase, Rubrik waits for the IO to be frozen and then the snapshot is taken. Once snapshot is taken, IO is unfreezed and the apps resume normal operation."
    isAppConsistencyEnabled: Boolean!
    "Specifies whether exocompute is configured for the region in which the virtual machine (VM) exists, or not. When the value is true, exocompute can be used to perform tasks like file indexing."
    isExocomputeConfigured: Boolean!
    "Specifies whether file indexing is enabled for this virtual machine (VM) or not. When enabled, Rubrik can scan through the file structure inside the VM in a protected environment where only the meta data like folder structure, file names, and file sizes will be readable by Rubrik."
    isFileIndexingEnabled: Boolean!
    "Specifies whether pre-script or post-script framework is enabled on the the virtual machine (VM) or not. When true, it facilitates application-consistent backups."
    isPreOrPostScriptEnabled: Boolean!
    "Specifies whether the virtual machine (VM) is a relic or not. A VM is a relic when it is unprotected or deleted, but the previously taken snapshots of the VM continue to exist within the Rubrik ecosystem."
    isRelic: Boolean!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: PolarisSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: PolarisSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    "Type of the Operating System (OS) installed on the virtual machine (VM)."
    osType: AzureNativeVmOsType!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "Private IP address of the virtual machine."
    privateIp: String!
    "Azure region where the virtual machine (VM) is located."
    region: AzureNativeRegion!
    "Resource Group of the Azure Virtual Machine (VM)."
    resourceGroup: AzureNativeResourceGroup!
    "Size type of the virtual machine (VM). For more information, see https://docs.microsoft.com/en-us/azure/virtual-machines/sizes-general."
    sizeType: String!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this workload."
    snapshotsOfSnappableConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Whether to ignore the active protected object check."
        ignoreActiveSnappableCheck: Boolean,
        "Returns the last n elements from the list."
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
    "Name of the subnet associated with the virtual machine (VM)."
    subnetName: String!
    "List of tags associated with the virtual machine (VM)."
    tags: [AzureTag!]!
    "Native ID of the the virtual machine (VM)."
    virtuaMachineNativeId: String!
    "Application Consistent Specifications of the virtual machine (VM)."
    vmAppConsistentSpecs: VmAppConsistentSpecsInternal
    "Name of the Virtual Machine (VM)."
    vmName: String!
    "Name of the Virtual Network (VNet) associated with the virtual machine (VM)."
    vnetName: String!
}

"Paginated list of AzureNativeVirtualMachine objects."
type AzureNativeVirtualMachineConnection {
    "Total number of AzureNativeVirtualMachine objects matching the request arguments."
    count: Int!
    "List of AzureNativeVirtualMachine objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [AzureNativeVirtualMachineEdge!]!
    "List of AzureNativeVirtualMachine objects."
    nodes: [AzureNativeVirtualMachine!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the AzureNativeVirtualMachine object. This wrapper is used for pagination."
type AzureNativeVirtualMachineEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual AzureNativeVirtualMachine object wrapped by this edge."
    node: AzureNativeVirtualMachine!
}

"An Azure virtual network (VNet). VNet enables secure communication with other VNets, the internet, and on-premise networks. For more information, see https://docs.microsoft.com/en-us/azure/virtual-network/virtual-networks-overview."
type AzureNativeVirtualNetwork {
    "Name of the Virtual Network (VNet)."
    name: String!
    "Name of the resource group associated with the Virtual Network (VNet)."
    resourceGroupName: String!
}

type AzureNetworkSecurityGroupResp {
    reason: String!
    rulesStatus: AzureNetworkSecurityRulesStatus!
}

type AzureNetworkSubnetResp {
    valid: Boolean!
}

type AzureNetworkSubnetUnusedAddrResp {
    unusedAddr: Long!
}

type AzureO365ExocomputeCluster {
    acrId: String!
    aksId: String!
    aksVersion: String!
    azureAppId: String!
    azureCloudType: O365AzureCloudType!
    groupName: String!
    hostType: AzureHostType!
    id: String!
    isProvisioned: Boolean!
    kmsId: String!
    orgId: String!
    orgName: String!
    orgStatus: String!
    orgTenantId: String!
    polarisAccount: String!
    regionName: String!
    scaleRuntime: ScaleRuntime
    setupConfiguration: String!
    storageId: String!
    storageIds: ExocomputeStorageAccountIds
    subscriptionId: String!
    tenantId: String!
}

type AzureOAuthConsentKickoffResp {
    appClientId: String!
    csrfToken: String!
    govAppClientId: String!
}

type AzureRegionsResp {
    regions: [Region!]!
}

type AzureReplicationTarget {
    region: AzureNativeRegionForReplication!
    subscriptionId: String!
    subscriptionName: String!
}

type AzureResourceAvailabilityResp {
    available: Boolean!
    reason: String!
}

"Azure resource group."
type AzureResourceGroup {
    "The name of the resource group."
    name: String!
    "The native ID of the resource group."
    nativeId: String!
    "The region name of the resource group. Example: AustraliaEast."
    region: AzureNativeRegion!
    "The tags present in the resource group."
    tags: [AzureTag!]!
}

"Details of the Azure resource group if it exists."
type AzureResourceGroupInfo {
    "The region of the resource group."
    region: AzureCloudAccountRegion!
    "The name of the resource group."
    resourceGroupName: String!
    "The native ID of the Azure subscription."
    subscriptionNativeId: UUID!
    "The tags on the resource group."
    tags: [TagObject!]!
}

type AzureRoleBasedAccount implements CloudAccount {
    "The ID of this Cloud Account."
    cloudAccountId: String!
    "The type of this Cloud Provider."
    cloudProvider: CloudAccountType!
    "The connection status of this Cloud Account."
    connectionStatus: ConnectionStatusType!
    "The description of this Cloud Account."
    description: String
    "The name of this Cloud Account."
    name: String!
    "The subscription info with feature details."
    subscriptionWithFeatures: AzureSubscriptionWithFeaturesType!
}

"An Azure SQL Database. Refers to the fully managed SQL database built for the cloud. For more info, see https://azure.microsoft.com/en-us/products/azure-sql/database/."
type AzureSqlDatabaseDb implements HierarchyObject & PolarisHierarchyObject & PolarisHierarchySnappable {
    "The authorized operations on the object."
    authorizedOperations: [PolarisSnappableAuthorizedOperationsEnum!]!
    "Azure SQL Database Server of the Azure SQL Database."
    azureSqlDatabaseServer: AzureSqlDatabaseServer!
    "Details of the setup for performing backups of the Azure SQL database."
    backupSetupSpecs: CloudNativeDatabaseBackupSetupSpecs
    "Specifies the status of the setup for taking the backup of the database."
    backupSetupStatus: AzureSqlDbBackupSetupStatus!
    "Type of backup storage redundancy. Examples: LRS, ZRS, GRS."
    backupStorageRedundancy: AzureSqlBackupStorageRedundancyType!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "Name of the Azure SQL Database."
    databaseName: String!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "Name of the Elastic Pool in which the Azure SQL Database resides."
    elasticPoolName: String!
    "Specifies whether exocompute is configured for the database."
    exocomputeConfigured: Boolean!
    "The fid of the hierarchy object."
    id: UUID!
    "Specifies whether the Azure SQL Database is a relic or not. A database is a relic when it is unprotected or deleted, but the previously taken snapshots of the database continue to exist within the Rubrik ecosystem."
    isRelic: Boolean!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "Maximum size of the Azure SQL Database, in bytes."
    maximumSizeInBytes: Long!
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: PolarisSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: PolarisSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    "Persistent storage configured for storing backups. None represents that persistent storage has not been configured."
    persistentStorage: PersistentStorage
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "Azure region where the Azure SQL Database is located."
    region: AzureNativeRegion!
    "Service Tier associated with the Azure SQL Database. Examples: Basic, General Purpose."
    serviceTier: String!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this workload."
    snapshotsOfSnappableConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Whether to ignore the active protected object check."
        ignoreActiveSnappableCheck: Boolean,
        "Returns the last n elements from the list."
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
    "List of tags associated with the Azure SQL Database."
    tags: [AzureTag!]!
}

"SLA Domain configuration for Azure SQL Database DB object."
type AzureSqlDatabaseDbConfig {
    "Specifies the number of days for which the Azure SQL Database DB logs will be retained. Number of days can range from 1 to 35."
    logRetentionInDays: Int!
}

"Paginated list of AzureSqlDatabaseDb objects."
type AzureSqlDatabaseDbConnection {
    "Total number of AzureSqlDatabaseDb objects matching the request arguments."
    count: Int!
    "List of AzureSqlDatabaseDb objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [AzureSqlDatabaseDbEdge!]!
    "List of AzureSqlDatabaseDb objects."
    nodes: [AzureSqlDatabaseDb!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the AzureSqlDatabaseDb object. This wrapper is used for pagination."
type AzureSqlDatabaseDbEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual AzureSqlDatabaseDb object wrapped by this edge."
    node: AzureSqlDatabaseDb!
}

"Retrieves an Azure SQL Database Server. Refers to the server the Azure SQL Database is a part of. For more info, see https://docs.microsoft.com/en-us/azure/azure-sql/database/logical-servers."
type AzureSqlDatabaseServer implements HierarchyObject & PolarisHierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [PolarisSnappableAuthorizedOperationsEnum!]!
    "Resource Group of the Azure SQL Database Server."
    azureNativeResourceGroup: AzureNativeResourceGroup!
    "The object from where the setup for performing backups of Azure SQL Databases is inherited."
    backupSetupSourceObject: PathNode
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "Azure region where the Azure SQL Database Server is located."
    region: AzureNativeRegion!
    "Name of the Azure SQL Database Server."
    serverName: String!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "List of tags associated with the Azure SQL Database Server."
    tags: [AzureTag!]!
}

"Paginated list of AzureSqlDatabaseServer objects."
type AzureSqlDatabaseServerConnection {
    "Total number of AzureSqlDatabaseServer objects matching the request arguments."
    count: Int!
    "List of AzureSqlDatabaseServer objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [AzureSqlDatabaseServerEdge!]!
    "List of AzureSqlDatabaseServer objects."
    nodes: [AzureSqlDatabaseServer!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the AzureSqlDatabaseServer object. This wrapper is used for pagination."
type AzureSqlDatabaseServerEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual AzureSqlDatabaseServer object wrapped by this edge."
    node: AzureSqlDatabaseServer!
}

"An elastic pool for a SQL Database Server."
type AzureSqlDatabaseServerElasticPool {
    "Name of the elastic pool."
    name: String!
}

"Retrieves an Azure SQL Managed Instance Database. Refers to the database engine compatible with the latest SQL Server (Enterprise Edition) database engine. For more information, see https://docs.microsoft.com/en-us/azure/azure-sql/managed-instance/sql-managed-instance-paas-overview."
type AzureSqlManagedInstanceDatabase implements HierarchyObject & PolarisHierarchyObject & PolarisHierarchySnappable {
    "The authorized operations on the object."
    authorizedOperations: [PolarisSnappableAuthorizedOperationsEnum!]!
    "Azure SQL Managed Instance Server of the Azure SQL Managed Instance Database."
    azureSqlManagedInstanceServer: AzureSqlManagedInstanceServer!
    "Details of the setup for performing backups of the Azure SQL Managed Instance database."
    backupSetupSpecs: CloudNativeDatabaseBackupSetupSpecs
    "Specifies the status of the setup for taking the backup of the database."
    backupSetupStatus: AzureSqlDbBackupSetupStatus!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "Name of the Azure SQL Managed Instance Database."
    databaseName: String!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "Specifies whether exocompute is configured for the database."
    exocomputeConfigured: Boolean!
    "The fid of the hierarchy object."
    id: UUID!
    "Specifies whether the Azure SQL Database is a relic or not. A database is a relic when it is unprotected or deleted, but the previously taken snapshots of the database continue to exist within the Rubrik ecosystem."
    isRelic: Boolean!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: PolarisSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: PolarisSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    "Persistent storage configured for storing backups. None represents that persistent storage has not been configured."
    persistentStorage: PersistentStorage
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "Azure region where the Azure SQL Managed Instance Database is located."
    region: AzureNativeRegion!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this workload."
    snapshotsOfSnappableConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Whether to ignore the active protected object check."
        ignoreActiveSnappableCheck: Boolean,
        "Returns the last n elements from the list."
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
}

"Paginated list of AzureSqlManagedInstanceDatabase objects."
type AzureSqlManagedInstanceDatabaseConnection {
    "Total number of AzureSqlManagedInstanceDatabase objects matching the request arguments."
    count: Int!
    "List of AzureSqlManagedInstanceDatabase objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [AzureSqlManagedInstanceDatabaseEdge!]!
    "List of AzureSqlManagedInstanceDatabase objects."
    nodes: [AzureSqlManagedInstanceDatabase!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the AzureSqlManagedInstanceDatabase object. This wrapper is used for pagination."
type AzureSqlManagedInstanceDatabaseEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual AzureSqlManagedInstanceDatabase object wrapped by this edge."
    node: AzureSqlManagedInstanceDatabase!
}

"SLA Domain configuration for Azure SQL Managed Instance DB object."
type AzureSqlManagedInstanceDbConfig {
    "Specifies the number of days for which the Azure SQL Managed Instance DB logs will be retained. Number of days can range from 1 to 35."
    logRetentionInDays: Int!
}

"Retrieves an Azure SQL Managed Instance Server. Refers to the server the Azure SQL Managed Instance Database is a part of."
type AzureSqlManagedInstanceServer implements HierarchyObject & PolarisHierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [PolarisSnappableAuthorizedOperationsEnum!]!
    "Resource Group of the Azure SQL Managed Instance Server."
    azureNativeResourceGroup: AzureNativeResourceGroup!
    "The object from where the setup for performing backups of Azure SQL Managed Instance Databases is inherited."
    backupSetupSourceObject: PathNode
    "Type of backup storage redundancy. Examples: LRS, ZRS, GRS."
    backupStorageRedundancy: AzureSqlBackupStorageRedundancyType!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Name of the Instance Pool the Azure SQL Managed Instance Server belongs to."
    instancePoolName: String!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "Azure region where the Azure SQL Managed Instance Server is located."
    region: AzureNativeRegion!
    "Name of the Azure SQL Managed Instance Server."
    serverName: String!
    "Service Tier associated with the Azure SQL Managed Instance Server."
    serviceTier: String!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "Storage size of the Azure SQL Managed Instance Server, in GiB."
    storageSizeGib: Long!
    "Name of the subnet associated with the Azure SQL Managed Instance Server."
    subnetName: String!
    "List of tags associated with the Azure SQL Managed Instance Server."
    tags: [AzureTag!]!
    "Count of the vCores in the Azure SQL Managed Instance Server."
    vCoresCount: Int!
    "Name of the Virtual Network associated with the Azure SQL Managed Instance Server."
    vnetName: String!
}

"Paginated list of AzureSqlManagedInstanceServer objects."
type AzureSqlManagedInstanceServerConnection {
    "Total number of AzureSqlManagedInstanceServer objects matching the request arguments."
    count: Int!
    "List of AzureSqlManagedInstanceServer objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [AzureSqlManagedInstanceServerEdge!]!
    "List of AzureSqlManagedInstanceServer objects."
    nodes: [AzureSqlManagedInstanceServer!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the AzureSqlManagedInstanceServer object. This wrapper is used for pagination."
type AzureSqlManagedInstanceServerEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual AzureSqlManagedInstanceServer object wrapped by this edge."
    node: AzureSqlManagedInstanceServer!
}

type AzureSubscription {
    id: String!
    name: String!
}

"Paginated list of AzureSubscription objects."
type AzureSubscriptionConnection {
    "Total number of AzureSubscription objects matching the request arguments."
    count: Int!
    "List of AzureSubscription objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [AzureSubscriptionEdge!]!
    "List of AzureSubscription objects."
    nodes: [AzureSubscription!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the AzureSubscription object. This wrapper is used for pagination."
type AzureSubscriptionEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual AzureSubscription object wrapped by this edge."
    node: AzureSubscription!
}

"Missing permissions on the Azure Subscription."
type AzureSubscriptionMissingPermissions {
    "List of missing permissions on the Azure Subscription."
    missingPermissions: [String!]!
    "Native ID of the Azure Subscription."
    subscriptionNativeId: String!
}

"Azure Cloud Account Subscription with exocompute configurations for feature configured."
type AzureSubscriptionWithExoConfigs {
    "Native ID for Azure subscription."
    azureSubscriptionNativeId: String!
    "Rubrik ID for Azure subscription."
    azureSubscriptionRubrikId: String!
    "Exocompute configurations available through mapped subscription."
    exocomputeConfigs: [AzureExocomputeConfigDetails!]!
    "Feature details of subscription."
    featureDetail: AzureCloudAccountFeatureDetail!
    "Mapped Exocompute subscription for launching Exocompute."
    mappedExocomputeSubscription: AzureMappedExocomputeSubscription
    "Name of Azure subscription."
    subscriptionName: String!
}

"Azure subscription with Exocompute mapping, if present."
type AzureSubscriptionWithExocomputeMapping {
    "Azure subscription cloud account ID."
    id: String!
    "Mapped Exocompute Azure subscription details."
    mappedExocomputeSubscription: AzureMappedExocomputeSubscription
    "Azure subscription native name."
    name: String!
    "Azure subscription native ID."
    nativeId: String!
}

"Azure subscription with features."
type AzureSubscriptionWithFeaturesType {
    "Azure tenant ID."
    customerTenantId: String!
    "Feature details for the cloud account."
    featureDetails: [AzureCloudAccountFeatureDetail!]!
    "Azure subscription cloud account ID."
    id: String!
    "Azure subscription native name."
    name: String!
    "Azure subscription native ID."
    nativeId: String!
}

"Azure Tag."
type AzureTag {
    key: String!
    value: String!
}

"Specific info for Azure Target Template."
type AzureTargetTemplate implements TargetTemplate {
    cloudAccount: CloudAccount!
    cloudNativeCompanion: AzureCloudNativeTargetCompanion
    computeSettings: AzureComputeSettings
    containerNamePrefix: String!
    instanceType: InstanceTypeEnum!
    isConsolidationEnabled: Boolean!
    proxySettings: ProxySettings
    storageAccountName: String!
    "The type of this Target."
    targetType: TargetTypeEnum!
}

"Azure user-assigned Managed Identity details."
type AzureUserAssignedManagedIdentity {
    "Name of the managed identity."
    name: String!
    "Native ID of the managed identity."
    nativeId: String!
    "ID of the service principal object associated with the managed identity."
    principalId: String!
}

type AzureUserRoleResp {
    globalAdministrator: RoleStatus
    subscriptionOwner: RoleStatus
}

"Supported in v5.1+"
type BackupTaskDiagnosticInfo {
    """

    Supported in v5.1+
    The expected completion time of the task.
    """
    expectedEndTime: DateTime
    """

    Supported in v5.1+
    The scheduled start time of the task.
    """
    queueTime: DateTime
    taskStatus: DiagnosticTaskStatusEnum!
}

type BackupWindow {
    durationInHours: Int!
    startTimeAttributes: StartTimeAttributes
}

"Supported in v5.0+"
type BaseGuestCredentialDetail {
    "Required. Supported in v5.0+"
    username: String!
}

"Supported in v5.0+"
type BaseSnapshotSummary {
    "Supported in v5.0+"
    archivalLocationIds: [String!]!
    """

    Supported in v5.0+
    v5.0-v5.3: Integer value that represents the archival state of a snapshot. 0 means the snapshot is not archived. 2 means the snapshot is archived. 3 means the snapshot is downloaded from the archival location. 4 means the snapshot is in the process of being downloaded from the archival location. 6 means the snapshot is stored locally and at the archival location.
    v6.0-v7.0: Integer value that represents the archival state of a snapshot. 0 means the snapshot is not archived. 2 means the snapshot is archived. 3 means the snapshot is downloaded from the archival location. 4 means the snapshot is in the process of being downloaded from the archival location. 6 means the snapshot is stored locally and at the archival location.

    v8.0: Integer value that represents the archival state of a snapshot. 0 means the snapshot is not archived to any archival location. 2 means the snapshot is archived to any archival location. 3 means the snapshot is downloaded from the archival location. 4 means the snapshot is in the process of being downloaded from the archival location. 6 means the snapshot is stored locally and at least on one of the archival locations.
    """
    cloudState: Long
    cloudStorageTier: SnapshotCloudStorageTierEnum
    """

    Supported in v8.0
    A list of those archival location entries where cloudStorageTier is applicable.
    """
    cloudStorageTiers: [PerLocationCloudStorageTier!]!
    "Supported in v5.0+"
    consistencyLevel: String
    "Required. Supported in v5.0+"
    date: DateTime
    "Supported in v5.0+"
    expirationDate: DateTime
    "Required. Supported in v5.0+"
    id: String!
    """

    Supported in v5.0+
    Integer value representing the state of the indexing job for a snapshot. 0 means that the indexing has not begun or is in progress. 1 means indexing completed successfully. 2 means that the indexer failed to process this snapshot.
    """
    indexState: Long
    """

    Supported in v5.2+
    A Boolean that indicates whether or not custom retention is applied to the snapshot.
    """
    isCustomRetentionApplied: Boolean
    "Required. Supported in v5.0+"
    isOnDemandSnapshot: Boolean!
    """

    Supported in v5.2+
    A Boolean that indicates whether the snapshot is placed on Legal Hold. When this value is 'true', the snapshot is placed on Legal Hold.
    """
    isPlacedOnLegalHold: Boolean
    """

    Supported in v5.1+
    v5.1: A Boolean that indicates whether the snapshot is being retained under a Retention Lock SLA Domain. When this value is 'true,' the snapshot is being retained under a Retention Lock SLA Domain.
    v5.2+: A Boolean that indicates whether the snapshot is being retained under a Retention Lock SLA Domain. When this value is 'true', the snapshot is being retained under a Retention Lock SLA Domain.
    """
    isRetainedByRetentionLockSla: Boolean
    """

    Supported in v5.2+
    ID of the parent snapshot if the current snapshot is a child snapshot. Child snapshots are snapshots of objects that are part of an app, either a vCloud Director vApp or an AppBlueprint. Snapshots of the app are parent snapshots.
    """
    parentSnapshotId: String
    "Required. Supported in v5.0+"
    replicationLocationIds: [String!]!
    """

    Required. Supported in v5.0+
    v5.0-v5.1:
    v5.2+: (Deprecated) For a policy based snapshot this parameter contains the ID of the SLA Domain currently assigned to the data source of that snapshot. For an on demand snapshot this field corresponds to the SLA Domain that was assigned when the snapshot was taken. A data source, and individual snapshots, can be reassigned to a different SLA Domain, or the SLA Domain can be modified. In any of these cases this parameter can contain a stale and incorrect value. To view retention information for this snapshot, use snapshotRetentionInfo instead.
    """
    slaId: String!
    """

    Required. Supported in v5.0+
    v5.0-v5.1:
    v5.2+: (Deprecated) For a policy based snapshot this parameter contains the name of the SLA Domain currently assigned to the data source of that snapshot. For an on demand snapshot this field corresponds to the SLA Domain that was assigned when the snapshot was taken. A data source, and individual snapshots, can be reassigned to a different SLA Domain, or the SLA Domain can be modified. In any of these cases this parameter can contain a stale and incorrect value. To view retention information for this snapshot, use snapshotRetentionInfo instead.
    """
    slaName: String!
    """

    Supported in v5.2+
    Snapshot retention related information for local, archival and replication locations.
    """
    snapshotRetentionInfo: SnapshotRetentionInfo
    "Supported in v5.0+"
    sourceObjectType: String
}

type BasicSnapshotSchedule {
    frequency: Int!
    retention: Int!
    retentionUnit: RetentionUnitEnum!
}

type BatchAsyncJobStatus {
    "List of map of Rubrik object ID to error message for those object for which pre validation failed."
    errors: [AsyncJobStatusJobError!]!
    "List of map of Rubrik object ID to Job ID for object if pre validation succeeds for object. If pre validation failed, detials will be present in error field."
    jobIds: [AsyncJobStatusJobId!]!
}

"Supported in v5.0+"
type BatchAsyncRequestStatus {
    """

    Required. Supported in v5.0+
    The asynchronous request status of a batch request.
    """
    responses: [AsyncRequestStatus!]!
}

"Reply for the operation to quarantine a batch of snapshots."
type BatchQuarantineSnapshotReply {
    "Boolean which signifies whether the operation is successful."
    isBatchQuarantineSuccessful: Boolean!
}

"Reply for the operation to release a batch of snapshots from quarantine."
type BatchReleaseFromQuarantineSnapshotReply {
    "Boolean which signifies whether the operation is successful."
    isBatchReleaseFromQuarantineSuccessful: Boolean!
}

"Supported in v5.1+"
type BatchVmwareCdpLiveInfo {
    """

    Required. Supported in v5.1+
    The live CDP info for the virtual machines.
    """
    responses: [VmwareCdpLiveInfo!]!
}

"Supported in v5.3+"
type BatchVmwareVmRecoverableRanges {
    """

    Required. Supported in v5.3+
    The recoverable ranges for a set of virtual machines.
    """
    responses: [VmwareVmRecoverableRanges!]!
}

type BidirectionalReplicationSpec {
    replicationSpec1: UnidirectionalReplicationSpec
    replicationSpec2: UnidirectionalReplicationSpec
}

"Supported in v5.0+"
type BlackoutWindow {
    "Supported in v5.0+"
    endTime: String
    "Required. Supported in v5.0+"
    startTime: String!
}

"Supported in v5.0+"
type BlackoutWindowResponseInfo {
    "Required. Supported in v5.0+"
    blackoutWindowStatus: BlackoutWindowStatus
    "Required. Supported in v5.0+"
    blackoutWindows: BlackoutWindows
}

"Supported in v5.0+"
type BlackoutWindowStatus {
    "Required. Supported in v5.0+"
    isGlobalBlackoutActive: Boolean!
    "Supported in v5.0+"
    isSnappableBlackoutActive: Boolean
}

"Supported in v5.0+"
type BlackoutWindows {
    "Required. Supported in v5.0+"
    globalBlackoutWindows: [BlackoutWindow!]!
    "Supported in v5.0+"
    snappableBlackoutWindows: [BlackoutWindow!]!
}

type BlueprintCdmLocation implements BlueprintLocation {
    "the cluster"
    cluster: Cluster
    locationId: String!
    "The type of the location"
    type: BlueprintLocationTypeEnum!
}

"Paginated list of BlueprintChild objects."
type BlueprintChildConnection {
    "Total number of BlueprintChild objects matching the request arguments."
    count: Int!
    "List of BlueprintChild objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [BlueprintChildEdge!]!
    "List of BlueprintChild objects."
    nodes: [BlueprintChild!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the BlueprintChild object. This wrapper is used for pagination."
type BlueprintChildEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual BlueprintChild object wrapped by this edge."
    node: BlueprintChild!
}

"Paginated list of Blueprint objects."
type BlueprintConnection {
    "Total number of Blueprint objects matching the request arguments."
    count: Int!
    "List of Blueprint objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [BlueprintEdge!]!
    "List of Blueprint objects."
    nodes: [Blueprint!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the Blueprint object. This wrapper is used for pagination."
type BlueprintEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual Blueprint object wrapped by this edge."
    node: Blueprint!
}

"Failover metadata."
type BlueprintFailover {
    "Type of the failover."
    failoverType: FailoverTypeEnum!
    "Status of the failover (succeeded or failed)."
    status: FailoverStatusEnum!
}

"Paginated list of BlueprintNew objects."
type BlueprintNewConnection {
    "Total number of BlueprintNew objects matching the request arguments."
    count: Int!
    "List of BlueprintNew objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [BlueprintNewEdge!]!
    "List of BlueprintNew objects."
    nodes: [BlueprintNew!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the BlueprintNew object. This wrapper is used for pagination."
type BlueprintNewEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual BlueprintNew object wrapped by this edge."
    node: BlueprintNew!
}

type BlueprintRecoveryRange {
    beginTime: DateTime
    endTime: DateTime
}

type BlueprintRecoveryRanges {
    missedRecoverableRanges: [BlueprintRecoveryRange!]!
    recoverableRanges: [BlueprintRecoveryRange!]!
}

"the recovery spec of a Blueprint."
type BlueprintRecoverySpec {
    childRecoverySpecs: [ChildRecoverySpecMap!]!
    isPending: Boolean!
    planType: PlanNameEnum!
    userData: String
    version: Long!
}

"the recovery specs of a Blueprint."
type BlueprintRecoverySpecs {
    errors: [ValidateFailureReason!]!
    specs: [BlueprintRecoverySpec!]!
}

"Response from cluster bootstrap status."
type BootstrapStatusReply {
    clusterinstall: String!
    configadminuser: String!
    createtoplevelfilesystemdirs: String!
    installschema: String!
    ipconfig: String!
    ipmiconfig: String!
    "Message if failure occurred."
    message: String!
    metadatasetup: String!
    resetnodes: String!
    setupdisks: String!
    setupencryptionatrest: String!
    setuploopdevices: String!
    setuposandmetadatapartitions: String!
    startservices: String!
    "Bootstrap status of cluster."
    status: String!
}

"Supported in v5.0+"
type BootstrappableNodeInfo {
    """

    Supported in v6.0+
    Chassis ID of Rubrik node.
    """
    chassisId: String
    """

    Required. Supported in v5.0+
    Hostname of a Rubrik node.
    """
    hostname: String!
    """

    Required. Supported in v5.0+
    IPv6 address of a Rubrik node.
    """
    ipv6: String!
    """

    Supported in v6.0+
    All-Copper 10GBaseT Rubrik node.
    """
    isAllCopper: Boolean
    """

    Supported in v6.0+
    Link status of port eth0 in Rubrik node.
    """
    isBond0Eth0Enabled: Boolean
    """

    Supported in v6.0+
    Link status of port eth1 in Rubrik node.
    """
    isBond0Eth1Enabled: Boolean
    """

    Supported in v6.0+
    Link status of port eth2 in Rubrik node.
    """
    isBond1Eth2Enabled: Boolean
    """

    Supported in v6.0+
    Link status of port eth3 in Rubrik node.
    """
    isBond1Eth3Enabled: Boolean
    """

    Supported in v6.0+
    Position of Rubrik node.
    """
    nodePosition: String
    """

    Supported in v6.0+
    Deployment model of Rubrik node.
    """
    platformName: String
    """

    Supported in v5.3+
    Software version of Rubrik CDM.
    """
    version: String
}

"Supported in v5.0+"
type BootstrappableNodeInfoListResponse {
    """

    Supported in v5.0+
    List of matching objects.
    """
    data: [BootstrappableNodeInfo!]!
    """

    Supported in v5.0+
    If there is more.
    """
    hasMore: Boolean
    """

    Supported in v5.0+
    Total list responses.
    """
    total: Long
}

"Supported in v5.0+"
type BrowseResponse {
    """

    Supported in v5.0+
    The type of file, either a regular file or a directory.
    """
    fileMode: String
    """

    Supported in v5.0+
    The name of the file.
    """
    filename: String
    "Supported in v5.0+"
    lastModified: String
    """

    Supported in v5.0+
    The complete path of the file.
    """
    path: String
    "Supported in v5.0+"
    size: Long
    """

    Supported in v5.0+
    Description about the status.
    """
    statusMessage: String
    """

    Supported in v5.3+
    Reason the file is unreadable. Undefined if the file is readable.
    """
    unreadable: Int
}

"Supported in v5.0+"
type BrowseResponseListResponse {
    """

    Supported in v5.0+
    List of matching objects.
    """
    data: [BrowseResponse!]!
    """

    Supported in v5.0+
    If there is more.
    """
    hasMore: Boolean
    """

    Supported in v5.0+
    Total list responses.
    """
    total: Long
}

"Supported in v5.2+"
type BulkOracleHostDetails {
    """

    Required. Supported in v5.2+
    An array that contains all Oracle Host update details.
    """
    responses: [OracleHostDetail!]!
}

"Supported in v5.0+"
type CDMAgentStatus {
    """

    Required. Supported in v5.0+
    The agent connection status.
    """
    agentStatus: String!
    """

    Supported in v5.0+
    The reason the agent disconnected.
    """
    disconnectReason: String
}

"Supported in v5.0+"
type CDMSnappable {
    """

    Supported in v5.0
    ID of the effective SLA domain
    """
    effectiveSlaDomainId: String
    """

    Supported in v5.0
    name of the effective SLA domain
    """
    effectiveSlaDomainName: String
    """

    Supported in v5.0
    Optional field containing Polaris managed id of the effective SLA domain if it is Polaris managed.
    """
    effectiveSlaDomainPolarisManagedId: String
    effectiveSlaHolder: EffectiveSlaHolder
    """

    Supported in v5.0
    ID of the object from which the effective SLA domain is inherited
    """
    effectiveSlaSourceObjectId: String
    """

    Supported in v5.0
    Name of the object from which the effective SLA domain is inherited
    """
    effectiveSlaSourceObjectName: String
    """

    Supported in v5.2+
    The ID of the SLA Domain whose retention policy is in use.
    """
    retentionSlaDomainId: String
    slaAssignable: SlaAssignable
    slaAssignment: SnappableSlaAssignmentEnum!
}

"Snapshot of a CDM Object."
type CDMSnapshot {
    "CDM ID of the snapshot."
    cdmId: String!
    "Version of the cluster that the snapshot belongs to."
    cdmVersion: String!
    "ID of the cluster that the snapshot belongs to."
    clusterUuid: String!
    "The date the snapshot was taken. This value is formatted as YYYY/MM/DD HH:mm:ss"
    date: String!
    "Date the snapshot will expire."
    expirationDate: DateTime
    "Flag for whether the hint for expiration should be enabled."
    expiryHint: Boolean!
    "ID of the SLA."
    id: String!
    "Number of times the snapshot has attempted to be indexed."
    indexingAttempts: Long!
    "Whether the snapshot is corrupted or not."
    isCorrupted: Boolean!
    "Whether or not the snapshot was downloaded."
    isDownloadedSnapshot: Boolean!
    "Whether or not the snapshot is expired."
    isExpired: Boolean!
    "Whether or not the snapshot is indexed."
    isIndexed: Boolean!
    "Whether or not the snapshot was taken as an On Demand Snapshot"
    isOnDemandSnapshot: Boolean!
    "Whether or not the snapshot can be unindexed."
    isUnindexable: Boolean!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "The information about how long this snapshot will be retained."
    retentionInfo: String!
    "Sla domain of the snapshot."
    slaDomain: SlaConfig
    "ID of the snappable the snapshot belongs to."
    snappableId: String!
    "The type of the snappable that this snapshot belongs to."
    snappableType: String!
    "Sub objects for the snapshot."
    subObjs: [SnapshotSubObject!]!
}

"Paginated list of CDMSnapshot objects."
type CDMSnapshotConnection {
    "Total number of CDMSnapshot objects matching the request arguments."
    count: Int!
    "List of CDMSnapshot objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [CDMSnapshotEdge!]!
    "List of CDMSnapshot objects."
    nodes: [CDMSnapshot!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the CDMSnapshot object. This wrapper is used for pagination."
type CDMSnapshotEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual CDMSnapshot object wrapped by this edge."
    node: CDMSnapshot!
}

type CDMSnapshotLocationRetentionInfo {
    expirationTime: DateTime
    id: String!
    isExpirationDateCalculated: Boolean!
    isSnapshotPresent: Boolean!
    name: String!
    snapshotFrequency: SnapshotFrequencyEnum!
}

type CDMSnapshotRetentionInfo {
    archivalInfos: [CDMSnapshotLocationRetentionInfo!]
    localInfo: CDMSnapshotLocationRetentionInfo
    replicationInfos: [CDMSnapshotLocationRetentionInfo!]
}

"Cancel download job response."
type CancelJobReply {
    "Cancel message."
    message: String!
    "Status of cancel request."
    status: Boolean!
}

"Cascading archival spec info."
type CascadingArchivalSpec {
    "Archival location for snapshot on target."
    archivalLocation: Target
    "Threshold after which the snapshot will be archived."
    archivalThreshold: Duration
    "Archival tiering specification."
    archivalTieringSpec: ArchivalTieringSpec
    "Frequencies that are associated with this cascaded archival location."
    frequency: [RetentionUnitEnum!]!
}

"Backup Params configured on the management object."
type CassandraBackupParams {
    "Name of the store used to store backups."
    storeName: String!
    "Monitoring frequency used."
    watcherFrequency: Long!
}

"Cassandra Column Family information."
type CassandraColumnFamily implements CassandraKeyspaceDescendantType & CassandraKeyspacePhysicalChildType & CassandraSourceDescendantType & HierarchyObject & PolarisHierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [PolarisObjectAuthorizedOperationsEnum!]!
    "Number of backups for the column family."
    backupCount: Int
    "Backup Params of the source."
    backupParams: CassandraBackupParams
    "Mosaic cluster information"
    cluster: Cluster!
    "UUID of the Mosaic cluster."
    clusterUuid: UUID!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    id: UUID!
    isRelic: Boolean!
    "Parent keyspace connection"
    keyspace: CassandraKeyspace!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The most recent snapshot of this snappable."
    newestSnapshot: MosaicSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this snappable."
    oldestSnapshot: MosaicSnapshot
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "Date that effective SLA was assigned / inherited."
    protectionDate: String!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupBys(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Filter mosaic snapshot connection."
        filter: MosaicSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Group mosaic snapshots by field."
        groupBy: MosaicSnapshotGroupBy!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): MosaicSnapshotGroupByTypeConnection
    "The list of snapshots taken for this snappable."
    snapshots(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Filter mosaic snapshot connection."
        filter: MosaicSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Sort mosaic snapshots by field."
        sortBy: MosaicSnapshotSortBy = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): MosaicSnapshotConnection!
    "Parent source connection"
    source: CassandraSource!
}

"Paginated list of CassandraColumnFamily objects."
type CassandraColumnFamilyConnection {
    "Total number of CassandraColumnFamily objects matching the request arguments."
    count: Int!
    "List of CassandraColumnFamily objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [CassandraColumnFamilyEdge!]!
    "List of CassandraColumnFamily objects."
    nodes: [CassandraColumnFamily!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the CassandraColumnFamily object. This wrapper is used for pagination."
type CassandraColumnFamilyEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual CassandraColumnFamily object wrapped by this edge."
    node: CassandraColumnFamily!
}

"Supported in m3.2.0-m4.1.0"
type CassandraColumnObject {
    "Supported in m3.2.0-m4.1.0"
    columnName: String
    "Supported in m3.2.0-m4.1.0"
    columnType: String
}

"Cassandra Keyspace information."
type CassandraKeyspace implements CassandraSourceDescendantType & CassandraSourcePhysicalChildType & HierarchyObject & PolarisHierarchyObject {
    backupCount: Int
    "Backup Params of the source."
    backupParams: CassandraBackupParams
    "Mosaic cluster information"
    cluster: Cluster!
    "UUID of the Mosaic cluster."
    clusterUuid: UUID!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): CassandraKeyspaceDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    isRelic: Boolean!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "List of physical children"
    physicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): CassandraKeyspacePhysicalChildTypeConnection!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "Parent source connection"
    source: CassandraSource!
    "Watcher status of the keyspace."
    watcherEnabled: Boolean!
}

"Paginated list of CassandraKeyspace objects."
type CassandraKeyspaceConnection {
    "Total number of CassandraKeyspace objects matching the request arguments."
    count: Int!
    "List of CassandraKeyspace objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [CassandraKeyspaceEdge!]!
    "List of CassandraKeyspace objects."
    nodes: [CassandraKeyspace!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Paginated list of CassandraKeyspaceDescendantType objects."
type CassandraKeyspaceDescendantTypeConnection {
    "Total number of CassandraKeyspaceDescendantType objects matching the request arguments."
    count: Int!
    "List of CassandraKeyspaceDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [CassandraKeyspaceDescendantTypeEdge!]!
    "List of CassandraKeyspaceDescendantType objects."
    nodes: [CassandraKeyspaceDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the CassandraKeyspaceDescendantType object. This wrapper is used for pagination."
type CassandraKeyspaceDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual CassandraKeyspaceDescendantType object wrapped by this edge."
    node: CassandraKeyspaceDescendantType!
}

"Wrapper around the CassandraKeyspace object. This wrapper is used for pagination."
type CassandraKeyspaceEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual CassandraKeyspace object wrapped by this edge."
    node: CassandraKeyspace!
}

"Paginated list of CassandraKeyspacePhysicalChildType objects."
type CassandraKeyspacePhysicalChildTypeConnection {
    "Total number of CassandraKeyspacePhysicalChildType objects matching the request arguments."
    count: Int!
    "List of CassandraKeyspacePhysicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [CassandraKeyspacePhysicalChildTypeEdge!]!
    "List of CassandraKeyspacePhysicalChildType objects."
    nodes: [CassandraKeyspacePhysicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the CassandraKeyspacePhysicalChildType object. This wrapper is used for pagination."
type CassandraKeyspacePhysicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual CassandraKeyspacePhysicalChildType object wrapped by this edge."
    node: CassandraKeyspacePhysicalChildType!
}

"Supported in m3.2.0-m4.1.0"
type CassandraSchemaObject {
    "Supported in m3.2.0-m4.1.0"
    columns: [CassandraColumnObject!]!
    "Supported in m3.2.0-m4.1.0"
    primaryKeys: [String!]!
}

"Cassandra Source information."
type CassandraSource implements HierarchyObject & PolarisHierarchyObject {
    "Number of backups for the source."
    backupCount: Int
    "Backup Params of the source."
    backupParams: CassandraBackupParams
    "Mosaic cluster information"
    cluster: Cluster!
    "UUID of the Mosaic cluster."
    clusterUuid: UUID!
    "Configuration Params of the source."
    configParams: SourceConfigParams
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): CassandraSourceDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    isRelic: Boolean!
    lastRefreshTime: DateTime
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "Number of source nodes."
    nodeCount: Int
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "List of physical children"
    physicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): CassandraSourcePhysicalChildTypeConnection!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "Data size of source."
    size: Long
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "IP of the source."
    sourceIp: String!
    "Source connectivity status."
    status: CassandraSourceStatus!
    "Watcher status of the source."
    watcherEnabled: Boolean!
}

"Paginated list of CassandraSource objects."
type CassandraSourceConnection {
    "Total number of CassandraSource objects matching the request arguments."
    count: Int!
    "List of CassandraSource objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [CassandraSourceEdge!]!
    "List of CassandraSource objects."
    nodes: [CassandraSource!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Paginated list of CassandraSourceDescendantType objects."
type CassandraSourceDescendantTypeConnection {
    "Total number of CassandraSourceDescendantType objects matching the request arguments."
    count: Int!
    "List of CassandraSourceDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [CassandraSourceDescendantTypeEdge!]!
    "List of CassandraSourceDescendantType objects."
    nodes: [CassandraSourceDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the CassandraSourceDescendantType object. This wrapper is used for pagination."
type CassandraSourceDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual CassandraSourceDescendantType object wrapped by this edge."
    node: CassandraSourceDescendantType!
}

"Wrapper around the CassandraSource object. This wrapper is used for pagination."
type CassandraSourceEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual CassandraSource object wrapped by this edge."
    node: CassandraSource!
}

"Paginated list of CassandraSourcePhysicalChildType objects."
type CassandraSourcePhysicalChildTypeConnection {
    "Total number of CassandraSourcePhysicalChildType objects matching the request arguments."
    count: Int!
    "List of CassandraSourcePhysicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [CassandraSourcePhysicalChildTypeEdge!]!
    "List of CassandraSourcePhysicalChildType objects."
    nodes: [CassandraSourcePhysicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the CassandraSourcePhysicalChildType object. This wrapper is used for pagination."
type CassandraSourcePhysicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual CassandraSourcePhysicalChildType object wrapped by this edge."
    node: CassandraSourcePhysicalChildType!
}

"SSL Configuration on mosaic source object."
type CassandraSslOptions {
    "Whether ssl is enabled or not."
    ssl: Boolean!
    "Path to CA certificate."
    sslCaCerts: String!
    "SSL certificate requirements."
    sslCertRequirements: SourceSslCertReqsEnum!
    "Path to SSL Certificate."
    sslCertfile: String!
    "Path to SSL Key."
    sslKeyfile: String!
}

"Async reply for a submitted job."
type CcProvisionJobReply {
    "Job Id of the submitted job."
    jobId: Long!
    "Detail of submitted job including job name and function parameters."
    message: String!
    "Indicates if the operation was a success or not."
    success: Boolean!
}

type CdmClusterStatus {
    "Rubrik cluster status message."
    message: String
    "Rubrik cluster upgrade status. The value reflects the status of the Rubrik cluster at the various stages involved in an upgrade, for example, pre-check, download, upgrade scheduling, and rollback of the upgrade."
    status: CdmClusterStatusTypeEnum!
    "Status of the Rubrik cluster upgrade process including information about the tasks that have been completed and tasks that are pending or ongoing."
    statusInfo: CdmClusterStatusInfo
}

type CdmClusterStatusInfo {
    "Number of nodes where rolling upgrade is complete."
    completedNodes: String
    "Node going through rolling upgrade currently."
    currentNode: String
    "Upgrade state of the node going through the rolling upgrade currently."
    currentNodeState: String
    "The upgrade state running at the time of the query."
    currentState: String
    "Progress percentage of the current upgrade state."
    currentStateProgress: String
    "The upgrade task running at the time of the query."
    currentTask: String
    "Status of the download job."
    downloadJobStatus: String
    "Download progress."
    downloadProgress: String
    "Time, in seconds, remaining for the download to complete."
    downloadRemainingTimeEstimateInSeconds: String
    "Download package version."
    downloadVersion: String
    "A list of upgrade states that are completed."
    finishedStates: String
    "Overall upgrade progress percentage."
    overallProgress: String
    "A list of upgrade states that are pending."
    pendingStates: String
    "Total number of nodes in the Rubrik cluster"
    totalNodes: String
}

"CDM group by information."
type CdmGroupByInfo {
    "End time of the grouping."
    end: DateTime
    "Interval the grouping was made with."
    group: String!
    "Start time of the grouping."
    start: DateTime
}

"CDM Snapshot data with group by information applied to it."
type CdmGroupedSnapshot {
    "List of snapshots for a CDM object."
    cdmSnapshots: CDMSnapshotConnection!
    "Information on the grouped snapshots."
    groupByInfo: CdmGroupByInfo
}

"Paginated list of CdmGroupedSnapshot objects."
type CdmGroupedSnapshotConnection {
    "Total number of CdmGroupedSnapshot objects matching the request arguments."
    count: Int!
    "List of CdmGroupedSnapshot objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [CdmGroupedSnapshotEdge!]!
    "List of CdmGroupedSnapshot objects."
    nodes: [CdmGroupedSnapshot!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the CdmGroupedSnapshot object. This wrapper is used for pagination."
type CdmGroupedSnapshotEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual CdmGroupedSnapshot object wrapped by this edge."
    node: CdmGroupedSnapshot!
}

"Cdm Guest credential."
type CdmGuestCredential {
    "UUID of the cluster."
    clusterUuid: UUID!
    "Detail of the guest credential."
    detail: GuestCredentialDetail!
}

"Paginated list of CdmHierarchyObject objects."
type CdmHierarchyObjectConnection {
    "Total number of CdmHierarchyObject objects matching the request arguments."
    count: Int!
    "List of CdmHierarchyObject objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [CdmHierarchyObjectEdge!]!
    "List of CdmHierarchyObject objects."
    nodes: [CdmHierarchyObject!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the CdmHierarchyObject object. This wrapper is used for pagination."
type CdmHierarchyObjectEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual CdmHierarchyObject object wrapped by this edge."
    node: CdmHierarchyObject!
}

type CdmHostVolume {
    cdmId: String!
    clusterUuid: String!
    fileSystemType: String
    mountPoints: [String!]!
    size: Long
    "ID of the volume group to which this volume belongs."
    volumeGroupId: String
    "Host volume's ID."
    volumeId: String!
}

type CdmInventorySubHierarchyRoot {
    "List of children"
    childConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): CdmHierarchyObjectConnection!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): CdmHierarchyObjectConnection!
    rootEnum: InventorySubHierarchyRootEnum!
    "List of top-level descendants (with respect to RBAC)."
    topLevelDescendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): CdmHierarchyObjectConnection!
}

"Specific info for AWS target created on Cdm."
type CdmManagedAwsTarget implements Target {
    "The cluster to which this target belongs."
    cluster: Cluster!
    "Name of the Rubrik cluster that archives to this archival location."
    clusterName: String
    "Number of bytes stored on target."
    consumedBytes: Long
    "Number of failed tasks acting on this target."
    failedTasks: Int
    "Id of the AWS location."
    id: String!
    "Immutability info of Aws location."
    immutabilitySettings: AwsImmutabilitySettingsType
    "The pause/resume status of this Target."
    isActive: Boolean!
    "Whether this Target is archived."
    isArchived: Boolean!
    "The scope of location, whether Global or Local."
    locationScope: LocationScope!
    "The name of this Target."
    name: String!
    "The retrieval method of the reader target."
    readerRetrievalMethod: ReaderRetrievalMethod
    "Region of the AWS location."
    region: AwsRegion!
    "Number of running tasks acting on this target."
    runningTasks: Int
    "Status of the target."
    status: ArchivalLocationStatus!
    "Archival location to which the mapping target belongs."
    targetMapping: TargetMappingBasic
    "The type of this Target."
    targetType: TargetTypeEnum!
}

"Specific info for Azure target created on Cdm."
type CdmManagedAzureTarget implements Target {
    "The cluster to which this target belongs."
    cluster: Cluster!
    "Name of the Rubrik cluster that archives to this archival location."
    clusterName: String
    "Number of bytes stored on target."
    consumedBytes: Long
    "Number of failed tasks acting on this target."
    failedTasks: Int
    "ID of the Azure location."
    id: String!
    "Immutability info of Azure location."
    immutabilitySettings: AzureImmutabilitySettingsType
    "Instance type of the Azure location."
    instanceType: InstanceTypeEnum!
    "The pause/resume status of this Target."
    isActive: Boolean!
    "Whether this Target is archived."
    isArchived: Boolean!
    "Specifies whether Azure archival tiering is supported or not."
    isAzureTieringSupported: Boolean
    "The scope of location, whether Global or Local."
    locationScope: LocationScope!
    "The name of this Target."
    name: String!
    "The retrieval method of the reader target."
    readerRetrievalMethod: ReaderRetrievalMethod
    "Number of running tasks acting on this target."
    runningTasks: Int
    "Status of the target."
    status: ArchivalLocationStatus!
    "Archival location to which the mapping target belongs."
    targetMapping: TargetMappingBasic
    "The type of this Target."
    targetType: TargetTypeEnum!
}

"Specific info for Gcp target created on Cdm."
type CdmManagedGcpTarget implements Target {
    "The cluster to which this target belongs."
    cluster: Cluster!
    "Name of the Rubrik cluster that archives to this archival location."
    clusterName: String
    "Number of bytes stored on target."
    consumedBytes: Long
    "Number of failed tasks acting on this target."
    failedTasks: Int
    "Id of the GCP location."
    id: String!
    "The pause/resume status of this Target."
    isActive: Boolean!
    "Whether this Target is archived."
    isArchived: Boolean!
    "The scope of location, whether Global or Local."
    locationScope: LocationScope!
    "The name of this Target."
    name: String!
    "The retrieval method of the reader target."
    readerRetrievalMethod: ReaderRetrievalMethod
    "Region of the GCP location."
    region: GcpRegionEnum!
    "Number of running tasks acting on this target."
    runningTasks: Int
    "Status of the target."
    status: ArchivalLocationStatus!
    "Archival location to which the mapping target belongs."
    targetMapping: TargetMappingBasic
    "The type of this Target."
    targetType: TargetTypeEnum!
}

"Specific info for Nfs target created on Cdm."
type CdmManagedNfsTarget implements Target {
    "The cluster to which this target belongs."
    cluster: Cluster!
    "Name of the Rubrik cluster that archives to this archival location."
    clusterName: String
    "Number of bytes stored on target."
    consumedBytes: Long
    "Number of failed tasks acting on this target."
    failedTasks: Int
    "Host of the Nfs location."
    host: String!
    "Id of the Nfs location."
    id: String!
    "The pause/resume status of this Target."
    isActive: Boolean!
    "Whether this Target is archived."
    isArchived: Boolean!
    "The scope of location, whether Global or Local."
    locationScope: LocationScope!
    "The name of this Target."
    name: String!
    "The retrieval method of the reader target."
    readerRetrievalMethod: ReaderRetrievalMethod
    "Number of running tasks acting on this target."
    runningTasks: Int
    "Status of the target."
    status: ArchivalLocationStatus!
    "Archival location to which the mapping target belongs."
    targetMapping: TargetMappingBasic
    "The type of this Target."
    targetType: TargetTypeEnum!
}

"Specific info for S3Compatible created on Cdm."
type CdmManagedS3CompatibleTarget implements Target {
    "The cluster to which this target belongs."
    cluster: Cluster!
    "Name of the Rubrik cluster that archives to this archival location."
    clusterName: String
    "Number of bytes stored on target."
    consumedBytes: Long
    "Host of the S3Compatible location."
    endpoint: String!
    "Number of failed tasks acting on this target."
    failedTasks: Int
    "Id of the S3Compatible location."
    id: String!
    "The pause/resume status of this Target."
    isActive: Boolean!
    "Whether this Target is archived."
    isArchived: Boolean!
    "The scope of location, whether Global or Local."
    locationScope: LocationScope!
    "The name of this Target."
    name: String!
    "The retrieval method of the reader target."
    readerRetrievalMethod: ReaderRetrievalMethod
    "Number of running tasks acting on this target."
    runningTasks: Int
    "Status of the target."
    status: ArchivalLocationStatus!
    "Archival location to which the mapping target belongs."
    targetMapping: TargetMappingBasic
    "The type of this Target."
    targetType: TargetTypeEnum!
}

"Live mount of a MSSQL database."
type CdmMssqlDatabaseLiveMount {
    "Internal ID of the live mount."
    cdmId: String!
    "Cluster of the live mount."
    cluster: Cluster
    "Timestamp when the mount was created."
    creationDate: DateTime
    "Forever ID of the live mount."
    fid: String!
    "Status of the live mount."
    isReady: Boolean!
    "ID of the database mount request job."
    mountRequestId: String!
    "Internal ID of the mounted database."
    mountedDatabaseId: String!
    "Name of the mounted database."
    mountedDatabaseName: String!
    "Owner ID of the live mount."
    ownerId: String!
    "Recovery point of the live mount."
    recoveryPoint: DateTime
    "Source database of the live mount."
    sourceDatabase: MssqlDatabase
    "Target instance of the live mount."
    targetInstance: MssqlInstance
    "ID of the database unmount request job."
    unmountRequestId: String!
}

"Paginated list of CdmMssqlDatabaseLiveMount objects."
type CdmMssqlDatabaseLiveMountConnection {
    "Total number of CdmMssqlDatabaseLiveMount objects matching the request arguments."
    count: Int!
    "List of CdmMssqlDatabaseLiveMount objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [CdmMssqlDatabaseLiveMountEdge!]!
    "List of CdmMssqlDatabaseLiveMount objects."
    nodes: [CdmMssqlDatabaseLiveMount!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the CdmMssqlDatabaseLiveMount object. This wrapper is used for pagination."
type CdmMssqlDatabaseLiveMountEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual CdmMssqlDatabaseLiveMount object wrapped by this edge."
    node: CdmMssqlDatabaseLiveMount!
}

type CdmMssqlDbReplica {
    availabilityInfo: CdmMssqlDbReplicaAvailabilityInfo
    clusterUuid: String!
    hasPermissions: Boolean!
    instance: MssqlInstance
    instanceRootId: String!
    isArchived: Boolean!
    isStandBy: Boolean!
    recoveryModel: String!
    snapshotNeeded: Boolean!
    state: String!
}

type CdmMssqlDbReplicaAvailabilityInfo {
    availabilityMode: String!
    replicaId: String!
    role: String!
}

"Representation of a single node in an Oracle RAC."
type CdmOracleRacNode {
    "Host name of the RAC node."
    nodeName: String!
    "Connectivity status of the RAC node."
    status: HostConnectivityStatusEnum!
}

type CdmSnapshot implements GenericSnapshot {
    archivalLocations: [DataLocation!]
    cdmId: String!
    cdmVersion: String!
    "children snapshot id list"
    childSnapshots: [CdmSnapshot!]!
    cloudNativeLocations: [DataLocation!]
    cluster: Cluster!
    consistencyLevel: ConsistencyLevelEnum
    date: DateTime!
    "Db2 specific metadata for the snapshot."
    db2AppMetadata: Db2AppMetadata
    expirationDate: DateTime
    expiryHint: Boolean!
    "number of files in the snapshot"
    fileCount: Long!
    hasDelta: Boolean!
    "flag if the snapshot has image(s) converted."
    hasImageConverted: Boolean!
    id: UUID!
    indexingAttempts: Long!
    "flag if the snapshot is an anomaly."
    isAnomaly: Boolean!
    isCorrupted: Boolean!
    isDownloadedSnapshot: Boolean
    "Whether or not the snapshot is expired"
    isExpired: Boolean!
    isIndexed: Boolean!
    isOnDemandSnapshot: Boolean!
    isSapHanaIncrementalSnapshot: Boolean
    isUnindexable: Boolean!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "Contains info regarding legal hold on snapshot, null otherwise."
    legalHoldInfo: LegalHoldInfo
    localLocations: [DataLocation!]
    locations: [DataLocation!]
    "Non-null when a user has assigned a SLA to this snapshot, and the SLA assignment is in the process of being synced over to CDM"
    pendingSla: SlaDomain
    "Mapping from snapshot to delete pending action status"
    pendingSnapshotDeletion: PendingSnapshotDeletion
    replicationLocations: [DataLocation!]
    "Resource spec for a snapshot."
    resourceSpec: String
    "SAP HANA specific metadata for the snapshot"
    sapHanaAppMetadata: SapHanaAppMetadata
    "sla domain of the snapshot"
    slaDomain: SlaDomain
    "The snappableId of the snapshot."
    snappableId: String!
    snappableNew: CdmHierarchySnappableNew!
    snapshotRetentionInfo: CDMSnapshotRetentionInfo
    "VMware specific metadata for the snapshot."
    vmwareAppMetadata: VmwareAppMetadata
}

"Paginated list of CdmSnapshot objects."
type CdmSnapshotConnection {
    "Total number of CdmSnapshot objects matching the request arguments."
    count: Int!
    "List of CdmSnapshot objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [CdmSnapshotEdge!]!
    "List of CdmSnapshot objects."
    nodes: [CdmSnapshot!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the CdmSnapshot object. This wrapper is used for pagination."
type CdmSnapshotEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual CdmSnapshot object wrapped by this edge."
    node: CdmSnapshot!
}

"Specific info for Target created on and synced from cdm cluster"
type CdmTarget implements Target {
    "The cluster to which this target belongs."
    cluster: Cluster!
    "Name of the Rubrik cluster that archives to this archival location."
    clusterName: String
    "Number of bytes stored on target."
    consumedBytes: Long
    "Number of failed tasks acting on this target."
    failedTasks: Int
    id: String!
    "The pause/resume status of this Target."
    isActive: Boolean!
    "Whether this Target is archived."
    isArchived: Boolean!
    "The scope of location, whether Global or Local."
    locationScope: LocationScope!
    "The name of this Target."
    name: String!
    "The retrieval method of the reader target."
    readerRetrievalMethod: ReaderRetrievalMethod
    "Number of running tasks acting on this target."
    runningTasks: Int
    "Status of the target."
    status: ArchivalLocationStatus!
    "Archival location to which the mapping target belongs."
    targetMapping: TargetMappingBasic
    "The type of this Target."
    targetType: TargetTypeEnum!
}

"CDM upgrade availability."
type CdmUpgradeAvailabilityReply {
    "Upgrade available flag."
    isAvailable: Boolean!
    "Availability request status."
    status: UpgradeStatus
}

type CdmUpgradeInfo {
    "Operations the user are authorized to take on the cluster"
    authorizedOperations: AuthorizedOperations!
    "Cluster Job Status"
    clusterJobStatus: ClusterJobStatusTypeEnum
    "Status of cluster"
    clusterStatus: CdmClusterStatus
    "The cluster uuid."
    clusterUuid: UUID!
    "Current running state progress percentage"
    currentStateProgress: Float
    "Downloaded version of tarball"
    downloadedVersion: String
    "Finished states of upgrade"
    finishedStates: String
    "Time taken by the last upgrade."
    lastUpgradeDuration: UpgradeDurationReply
    "Overall upgrade Progress"
    overallProgress: Float
    "Pending states of upgrade"
    pendingStates: String
    "The version of the cluster before the upgrade."
    previousVersion: String
    "ScheduledUpgrade Action"
    scheduleUpgradeAction: String
    "ScheduledUpgrade timestamp"
    scheduleUpgradeAt: DateTime
    "ScheduledUpgrade Mode."
    scheduleUpgradeMode: String
    "Upgrade state machine status"
    stateMachineStatus: String
    "Last time when state machine was updated"
    stateMachineStatusAt: DateTime
    "Upgrade ending time"
    upgradeEndAt: DateTime
    "The upgrade event series id"
    upgradeEventSeriesId: String
    "Recommended upgrade version of cluster"
    upgradeRecommendationInfo: UpgradeRecommendationInfo
    "Upgrade started time"
    upgradeStartAt: DateTime
    "Version of cluster"
    version: String!
    "Version status of cluster"
    versionStatus: VersionStatusTypeEnum
}

"CDM upgrade recommendation."
type CdmUpgradeRecommendationReply {
    "Upgrade recommended flag."
    isRecommended: Boolean!
    "Status of recommendation request."
    status: UpgradeStatus
}

"CDM release detail."
type CdmUpgradeReleaseDetail {
    "The customer adoption status of the Rubrik CDM release."
    adoptionStatus: AdoptionStatus!
    "Description of CDM release."
    description: String!
    "Release date of GA version."
    gaReleaseDate: String!
    "Is this a recommended version."
    isRecommended: Boolean!
    "Is cluster upgradeable to version."
    isUpgradable: Boolean!
    "Md5Sum of the package."
    md5Sum: String!
    "Name of CDM release."
    name: String!
    "CDM package release date."
    releaseDate: String!
    "Release notes link."
    releaseNotesLink: String!
    "Size of CDM package."
    size: Long!
    "Download link to tarball."
    tarDownloadLink: String!
}

"CDM release details."
type CdmUpgradeReleaseDetailsFromSupportPortalReply {
    "Link to CDM upgrade matrix."
    compatibilityMatrixLink: String!
    "List of CDM release detail object."
    releaseDetails: [CdmUpgradeReleaseDetail!]!
    "Support portal link."
    supportSoftwareLink: String!
}

type CellData {
    displayableValue: DisplayableValue
    metadata: [Metadata!]!
}

"Certificate Information"
type Certificate {
    certificate: String!
    certificateId: Long!
    description: String!
    expiringAt: DateTime
    hasKey: Boolean!
    name: String!
    usedBy: [String!]!
}

"Paginated list of Certificate objects."
type CertificateConnection {
    "Total number of Certificate objects matching the request arguments."
    count: Int!
    "List of Certificate objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [CertificateEdge!]!
    "List of Certificate objects."
    nodes: [Certificate!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the Certificate object. This wrapper is used for pagination."
type CertificateEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual Certificate object wrapped by this edge."
    node: Certificate!
}

"Certificate Information with ID and name."
type CertificateInfo {
    "ID of the certificate."
    certificateId: Long!
    "Name of the certificate."
    name: String
}

type ChartConfig {
    aggregations: [String!]!
    chartType: ChartType!
    chartViewId: String!
    defaultChart: Boolean!
    groupBys: [String!]!
    name: String!
}

"The result data of the chart."
type ChartDataResult {
    "The data of the chart."
    chartData: [ChartPrimaryGroupBy!]!
    "Chart type of the chart."
    chartType: ChartType!
}

"The primary group by data of the chart."
type ChartPrimaryGroupBy {
    "The primary group by's metaData."
    metadata: [Metadata!]!
    "The primary group by's name."
    name: DisplayableValue
    "The secondary groupBy data."
    secondaryGroupBy: [ChartSecondaryGroupBy!]!
    "The primary of the secondary groupBy."
    value: DisplayableValue
}

"The secondary group by data of the chart."
type ChartSecondaryGroupBy {
    "The secondary group by's metaData."
    metadata: [Metadata!]!
    "The secondary group by's name."
    name: DisplayableValue
    "The value of the secondary groupBy."
    value: DisplayableValue
}

"The chart's id and its name."
type ChartViewWithName {
    "The name of the chart."
    chartName: String!
    "Chart View Type ID of the chart."
    chartViewType: ChartViewType!
}

"Archived snapshot locking related details for a snappable."
type CheckArchivedSnapshotsLockedReply {
    "Snapshot IDs are not valid for checking if they are locked. Snapshots which do not have unexpired archival copy are considered invalid."
    invalidSnapshotIds: [String!]!
    "Snapshot IDs for which the archived copy is locked."
    lockedSnapshotIds: [String!]!
    "Snapshot IDs for which the archived copy is not locked."
    unlockedSnapshotIds: [String!]!
}

type CheckGuestOsReply {
    success: Boolean!
    supportedOs: [GuestOSEnum!]!
    validationResult: [CheckGuestOsResult!]!
}

type CheckGuestOsResult {
    errorMessage: String!
    "vsphere vm instance"
    instance: VSphereVm!
    instanceId: String!
    instanceOs: GuestOSEnum!
    instanceType: String!
}

"Contains the details about RBA connectivity taskchains"
type CheckRBAConnectivityReply {
    failures: [Failure!]!
    successes: [Success!]!
}

type ChildInfo {
    vSphereVmInfo: VsphereBlueprintChildSnapshotInfo!
}

type ChildRecoverySpecMap {
    "Recovery point of the snappable."
    recoveryPoint: Long
    "the recovery spec"
    recoverySpec: RecoverySpec!
    "the fid of the recovery spec"
    recoverySpecFid: String!
    "Sla for post failover assignment."
    sla: SlaDomain
    "sla to be assigned post failover"
    slaId: String
    "the child snappable Fid"
    snappableFid: String!
    "the child snapshot Fid"
    snapshotId: String
}

type ChildVmRecoveryInfo {
    missedRecoverableRanges: [VmwareRecoverableRange!]!
    recoverableRanges: [VmwareRecoverableRange!]!
    recoveryPoints: VmwareRecoveryPoints!
    recoveryState: VmwareRecoveryState!
}

"Account-level settings for classification banners."
type ClassificationBannerSettings {
    "Color of banner on UI for accounts with classified data."
    bannerColor: BannerColor!
    "Text to be displayed on banner on UI for accounts with classified data."
    bannerText: String!
    "Determines if user has enabled classification banners"
    isBannerEnabled: Boolean!
}

"Account-level settings for classification login."
type ClassificationLoginSettings {
    "Determines if user has enabled classification login"
    isLoginEnabled: Boolean!
    "Text to be displayed on login modal for accounts with classified data."
    loginText: String!
}

type ClassificationPolicyDetail {
    analyzers: [Analyzer!]!
    colorEnum: ClassificationPolicyColor!
    createdTime: Long!
    creator: User
    deletable: Boolean!
    description: String!
    hierarchyObjectIds: [String!]!
    hierarchyObjects: [HierarchyObject!]!
    id: String!
    lastUpdatedTime: Long!
    mode: ClassificationPolicyMode!
    name: String!
    numAnalyzers: Int!
    objectStatuses: [ObjectStatus!]!
    totalObjects: Int!
    whitelists: [ClassificationPolicyWhitelistDetailedEntry!]!
}

"Paginated list of ClassificationPolicyDetail objects."
type ClassificationPolicyDetailConnection {
    "Total number of ClassificationPolicyDetail objects matching the request arguments."
    count: Int!
    "List of ClassificationPolicyDetail objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [ClassificationPolicyDetailEdge!]!
    "List of ClassificationPolicyDetail objects."
    nodes: [ClassificationPolicyDetail!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the ClassificationPolicyDetail object. This wrapper is used for pagination."
type ClassificationPolicyDetailEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual ClassificationPolicyDetail object wrapped by this edge."
    node: ClassificationPolicyDetail!
}

type ClassificationPolicySummary {
    colorEnum: ClassificationPolicyColor!
    id: String!
    name: String!
}

type ClassificationPolicyWhitelistDetailedEntry {
    nativePath: String!
    snappable: HierarchyObject!
    stdPath: String!
    updateTs: Long!
    updateUsername: String!
}

"List of objects where clearing backup credentials succeeded and failed."
type ClearCloudNativeSqlServerBackupCredentialsReply {
    "Object IDs for which credentials failed to be cleared."
    failedObjectIds: [UUID!]!
    "Object IDs for which credentials were cleared successfully."
    successObjectIds: [UUID!]!
}

"Updated service account details"
type Client {
    clientId: String!
    description: String!
    lastLogin: DateTime
    name: String!
}

"Indicates the ID and creation time of a snapshot."
type ClosestSnapshotDetail {
    "The snapshot creation time."
    date: DateTime!
    "The snapshot ID."
    id: String!
    "Whether the snapshot is anomalous or not."
    isAnomaly: Boolean!
}

"The result of a search for an unexpired snapshot closest to a point in time for a specific snappable."
type ClosestSnapshotSearchResult {
    "An error which occurred during the search."
    error: SnapshotSearchError
    "The snappable's ID."
    snappableId: String!
    "The snapshot closest to the point in time."
    snapshot: ClosestSnapshotDetail
}

"Cloud Account ID along with Features and permissions serialized in JSON format."
type CloudAccountFeaturePermission {
    "ID of the cloud account for which feature permissions are provided."
    cloudAccountId: String!
    "List of features along with the associated permissions."
    featurePermissions: [FeaturePermission!]!
}

"A NAS Cloud Direct site."
type CloudDirectSite {
    "The management endpoint URL for the site."
    endpoint: String!
    "The internal identifier for the site."
    id: String!
    "The display name for the site."
    name: String!
}

"Cloud native Account Id with its name"
type CloudNativeAccountIdWithName {
    id: String!
    name: String!
}

"Details of the setup for performing backups of a database."
type CloudNativeDatabaseBackupSetupSpecs {
    "Specifies whether backup setup is successful for the database or not."
    isSetupSuccessful: Boolean!
    "The object from where the setup specification is inherited."
    setupSourceObject: PathNode!
}

type CloudNativeFileRecoveryFeasibility {
    fileRecoveryFeasibility: FileRecoveryFeasibility!
    snapshotId: String!
}

type CloudNativeFileVersion {
    fileMode: FileModeEnum!
    lastModified: DateTime!
    sizeInBytes: Long!
    snapshot: CloudNativeSnapshotInfo!
}

"A single Label"
type CloudNativeLabel {
    labelKey: String!
    labelValue: String!
    matchAllValues: Boolean!
}

"Region where cloud native object exists."
type CloudNativeRegion {
    "Region where AWS native object exists. This field will be null if the object is not an AWS object."
    awsRegion: AwsNativeRegion
    "Region where Azure native object exists. This field will be null if the object is not an Azure object."
    azureRegion: AzureNativeRegion
    "Region where GCP native object exists. This field will be null if the object is not a GCP object."
    gcpRegion: GcpNativeRegion
}

"Recovery related details for a particular snapshot type."
type CloudNativeSnapshotDetailsForRecovery {
    "Polaris ID of the cloud account where the particular type of snapshot exists. This field is set only if file recovery is feasible. "
    cloudNativeAccountId: CloudNativeAccountIdWithName
    "Name of the cloud provider. Can be AWS/Azure/GCP. This field is set only if file recovery is feasible."
    cloudType: CloudProviderType!
    "Field specifying whether file recovery is feasible or not, and if infeasible, the reason for the same. Can have values IS_UNKNOWN, IS_FEASIBLE, IS_SNAPSHOT_EXPIRED, or IS_EXOCOMPUTE_NOT_CONFIGURED."
    fileRecoveryFeasibility: FileRecoveryFeasibility!
    "Region where the particular snapshot exists. This field is set only if file recovery is feasible."
    snapshotRegion: CloudNativeRegion!
    "Type of the snapshot. Can be SOURCE/REPLICATED/ARCHIVED."
    snapshotType: SnapshotType!
}

"Recovery related details for different snapshot types."
type CloudNativeSnapshotDetailsForRecoveryReply {
    "Details required for file recovery for different snapshot types of SOURCE, ARCHIVED and REPLICATED."
    snapshotDetails: [CloudNativeSnapshotDetailsForRecovery!]!
}

type CloudNativeSnapshotInfo {
    date: DateTime!
    id: String!
    isOnDemandSnapshot: Boolean!
}

"Script to setup backups on a SQL Server database."
type CloudNativeSqlServerSetupScript {
    "Contents of the script."
    script: String!
}

"CloudNativeTagRule represents a single tag rule"
type CloudNativeTagRule {
    "Does this tag rule apply to all cloud accounts."
    applyToAllCloudAccounts: Boolean!
    cloudNativeAccounts: [CloudNativeAccountIdWithName!]!
    effectiveSla: TagRuleEffectiveSla
    hasPermissionToModify: Boolean!
    id: String!
    name: String!
    objectType: ManagedObjectType!
    tag: TagRuleTag
}

type CloudNativeVersionedFile {
    absolutePath: String!
    displayPath: String!
    fileVersions: [CloudNativeFileVersion!]!
    filename: String!
    path: String!
}

"Paginated list of CloudNativeVersionedFile objects."
type CloudNativeVersionedFileConnection {
    "Total number of CloudNativeVersionedFile objects matching the request arguments."
    count: Int!
    "List of CloudNativeVersionedFile objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [CloudNativeVersionedFileEdge!]!
    "List of CloudNativeVersionedFile objects."
    nodes: [CloudNativeVersionedFile!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the CloudNativeVersionedFile object. This wrapper is used for pagination."
type CloudNativeVersionedFileEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual CloudNativeVersionedFile object wrapped by this edge."
    node: CloudNativeVersionedFile!
}

type Cluster {
    "The cluster's activity series."
    activitySeriesConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filters: ActivitySeriesFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Sort activity series by field."
        sortBy: ActivitySeriesSortByEnum = LastUpdated
    ): ActivitySeriesConnection!
    "The cluster's archival locations."
    archivalLocations: [ArchivalLocation!]!
    "Operations that the user is authorized to perform on the Rubrik cluster."
    authorizedOperations: AuthorizedOperations!
    "Job status of a create cluster operation."
    ccprovisionInfo: ClusterMetadata
    "Cluster upgrade information."
    cdmUpgradeInfo: CdmUpgradeInfo
    "Cloud information for this cluster."
    cloudInfo: ClusterCloudInfoReply
    "The cluster disks."
    clusterDiskConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ClusterDiskFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int
    ): ClusterDiskConnection!
    "The cluster nodes."
    clusterNodeConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int
    ): ClusterNodeConnection!
    "When the global manager connectivity was last updated."
    connectivityLastUpdated: DateTime
    "Sonar previewer config."
    datagovPreviewerConfig: PreviewerClusterConfig!
    "The cluster's default address."
    defaultAddress: String
    "Whether or not the cluster is encrypted."
    encryptionEnabled: Boolean!
    "The number of days remaining before the system fills up."
    estimatedRunway: Long!
    "The cluster's location."
    geoLocation: GeoLocation
    "The cluster's global manager connectivity status."
    globalManagerConnectivityStatus: GlobalManagerConnectivity
    "The cluster uuid."
    id: UUID!
    "Whether or not the cluster is healthy."
    isHealthy: Boolean! @deprecated(reason: "Use systemStatus instead.")
    "Lambda config."
    lambdaConfig: GetLambdaConfigReply
    "Lambda feature history."
    lambdaFeatureHistory: LambdaFeatureHistory
    "The time the cluster was last connected."
    lastConnectionTime: DateTime
    "Metadata pull scheduler."
    metadataPullScheduler: JobsReply
    "The most recent metric of a cluster."
    metric: ClusterMetric
    "The metric time series of a cluster."
    metricTimeSeries(timeRange: TimeRangeInput, unit: TimeUnitEnum!): [metricTimeSeries!]!
    "The cluster name."
    name: String!
    "Total number of protected NoSql workloads."
    noSqlSnappableCount: Int!
    "Whether the global manager connectivity is healthy."
    passesConnectivityCheck: Boolean
    "Pause status of the cluster."
    pauseStatus: ClusterPauseStatus
    "This field contains information about the various jobs that sync data from the CDM cluster to Polaris."
    polarisSyncStatus: PolarisSyncStatus!
    "The cluster product type (e.g., CDM, DATOS, etc.)."
    productType: ClusterProductEnum
    "The time the cluster was registered."
    registrationTime: DateTime!
    "The cluster's replication sources."
    replicationSources: [ReplicationSource!]!
    "The cluster's replication targets."
    replicationTargets: [ReplicationTarget!]!
    "The cluster's snappables."
    snappableConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snappables by input"
        filter: SnappableFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int
    ): SnappableConnection!
    "The total number of snapshots."
    snapshotCount: Long!
    "The cluster state."
    state: clusterState!
    "The cluster status."
    status: ClusterStatus!
    "System status of the cluster. For Mosaic clusters and Rubrik clusters running CDM versions earlier than 5.0, this value is null."
    systemStatus: ClusterSystemStatus
    "List of affected nodes in the cluster."
    systemStatusAffectedNodes: [ClusterNode!]
    "Human readable message explaining the systemStatus."
    systemStatusMessage: String
    "The cluster type."
    type: ClusterTypeEnum!
    "The software version."
    version: String
}

type ClusterArchivalSpec {
    archivalLocationId: String!
    archivalLocationName: String!
    archivalTieringSpec: ArchivalTieringSpec
    "Archives all snapshots taken with the specified frequency."
    frequencies: [RetentionUnitEnum!]!
    threshold: Int!
    thresholdUnit: RetentionUnitEnum!
}

"Cloud information for a cloud cluster."
type ClusterCloudInfoReply {
    "Customer cloud account name."
    cloudAccount: String!
    "User-friendly name for the cloud region."
    region: String!
    "ID for the cloud region."
    regionId: String!
    "Cloud vendor name."
    vendor: CcpVendorType!
}

"Paginated list of Cluster objects."
type ClusterConnection {
    "Aggregate statistics across Clusters with respect for the applied filters and pagination arguments."
    aggregateClusterStatistics: ClusterStatsAggregation!
    "Total number of Cluster objects matching the request arguments."
    count: Int!
    "List of Cluster objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [ClusterEdge!]!
    "List of Cluster objects."
    nodes: [Cluster!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

type ClusterDisk {
    capacityBytes: Long!
    clusterId: UUID!
    diskType: ClusterDiskType!
    id: String!
    isEncrypted: Boolean!
    nodeId: String
    path: String!
    status: ClusterDiskStatus!
    unallocatedBytes: Long
    usableBytes: Long
}

"Paginated list of ClusterDisk objects."
type ClusterDiskConnection {
    "Total number of ClusterDisk objects matching the request arguments."
    count: Int!
    "List of ClusterDisk objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [ClusterDiskEdge!]!
    "List of ClusterDisk objects."
    nodes: [ClusterDisk!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the ClusterDisk object. This wrapper is used for pagination."
type ClusterDiskEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual ClusterDisk object wrapped by this edge."
    node: ClusterDisk!
}

"Wrapper around the Cluster object. This wrapper is used for pagination."
type ClusterEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual Cluster object wrapped by this edge."
    node: Cluster!
}

"Cluster data with groupby info applied to it."
type ClusterGroupBy {
    "Paginated snappable data."
    clusterConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort clusters by field"
        sortBy: ClusterSortByEnum = ClusterType,
        "cluster sort order"
        sortOrder: SortOrderEnum = Desc
    ): ClusterConnection!
    "Further provide groupings for the data."
    clusterGroupBy(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "group by field"
        groupBy: ClusterGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int
    ): [ClusterGroupBy!]!
    "The data groupby info."
    groupByInfo: ClusterGroupByInfo!
}

"Paginated list of ClusterGroupBy objects."
type ClusterGroupByConnection {
    "Total number of ClusterGroupBy objects matching the request arguments."
    count: Int!
    "List of ClusterGroupBy objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [ClusterGroupByEdge!]!
    "List of ClusterGroupBy objects."
    nodes: [ClusterGroupBy!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the ClusterGroupBy object. This wrapper is used for pagination."
type ClusterGroupByEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual ClusterGroupBy object wrapped by this edge."
    node: ClusterGroupBy!
}

"Cluster interface CIDR map."
type ClusterInfCidrs {
    clusterId: String!
    clusterName: String!
    interfaceCidr: [InterfaceCidr!]!
}

type ClusterJobStatusType {
    enumValue: ClusterJobStatusTypeEnum!
}

"Metadata for a single cluster job."
type ClusterMetadata {
    "Current job status."
    jobStatus: CcpJobStatus!
    "Type of running job."
    jobType: CcpJobType!
    "Progress of job in percent."
    progress: Int!
    "Cloud vendor provider."
    vendor: CcpVendorType!
}

type ClusterMetric {
    availableCapacity: Long!
    "Ingested bytes for archived snapshots."
    ingestedArchivalStorage: Long!
    ingestedSnapshotStorage: Long!
    lastUpdateTime: DateTime!
    liveMountCapacity: Long!
    miscellaneousCapacity: Long!
    "Physical bytes for archived snapshots."
    physicalArchivalStorage: Long!
    physicalSnapshotStorage: Long!
    snapshotCapacity: Long!
    totalCapacity: Long!
    usedCapacity: Long!
}

type ClusterNode {
    brikId: String!
    clusterId: UUID!
    id: String!
    "Network interface of a Rubrik cluster node."
    interfaceCidrs: [ClusterNodeInterfaceCidr!]
    ipAddress: String
    needsInspection: Boolean
    status: String
}

"Paginated list of ClusterNode objects."
type ClusterNodeConnection {
    "Total number of ClusterNode objects matching the request arguments."
    count: Int!
    "List of ClusterNode objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [ClusterNodeEdge!]!
    "List of ClusterNode objects."
    nodes: [ClusterNode!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the ClusterNode object. This wrapper is used for pagination."
type ClusterNodeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual ClusterNode object wrapped by this edge."
    node: ClusterNode!
}

"Network interface of a Rubrik cluster node."
type ClusterNodeInterfaceCidr {
    "CIDR address for the interface."
    cidr: String!
    "Name of the interface."
    interfaceName: String!
}

"Object containing the pause or resume status for a Rubrik cluster."
type ClusterPauseStatusResult {
    "Cluster UUID."
    clusterUuid: String!
    "Specifies whether the pause or resume action was successful or not. When true, the action was successful. When false, the action failed."
    success: Boolean!
}

"Info about the cluster product types the user is entitled to."
type ClusterRegistrationProductInfoType {
    "The latest product type associated with the user. Product type can only be either Hybrid or LifeOfDevice."
    latestProductType: String!
    "Distinct cluster product types associated with the cluster registration tokens. Product type can only be either Hybrid or LifeOfDevice."
    productTypes: [String!]!
}

"Object type containing the token, public key and product type used in registering a cluster"
type ClusterRegistrationToken {
    "The product type this token should be used to register."
    productType: String!
    "The public key of the token."
    pubkey: String!
    "The JWT that will be used to register the cluster."
    token: String!
}

"Replication target specific information."
type ClusterReplicationTarget {
    "Id of replication target."
    id: String!
    "Name of replication target."
    name: String!
}

type ClusterSlaDomain implements SlaDomain {
    archivalSpec: ClusterArchivalSpec
    "List of archival specifications for SLA Domain."
    archivalSpecs: [ClusterArchivalSpec!]!
    backupWindows: [BackupWindow!]!
    baseFrequency: Duration
    "Cascading Archival Specification."
    cascadingArchivalSpec: CascadingArchivalSpec
    cdmId: String!
    cluster: Cluster
    fid: String!
    firstFullBackupWindows: [BackupWindow!]!
    id: String!
    localRetentionLimit: Duration
    name: String!
    polarisManagedId: String
    protectedObjectCount: Int!
    replicationSpec: ReplicationSpec
    replicationSpecsV2: [ReplicationSpecV2!]!
    snapshotSchedule: SnapshotSchedule
    "SLA Domain upgrade information."
    upgradeInfo: SlaUpgradeInfo
    version: String
}

"Paginated list of ClusterSlaDomain objects."
type ClusterSlaDomainConnection {
    "Total number of ClusterSlaDomain objects matching the request arguments."
    count: Int!
    "List of ClusterSlaDomain objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [ClusterSlaDomainEdge!]!
    "List of ClusterSlaDomain objects."
    nodes: [ClusterSlaDomain!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the ClusterSlaDomain object. This wrapper is used for pagination."
type ClusterSlaDomainEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual ClusterSlaDomain object wrapped by this edge."
    node: ClusterSlaDomain!
}

"Metadata for rendering a cluster sla for filter."
type ClusterSlaDomainForFilter {
    "The name of the cluster the sla belongs to"
    clusterName: String
    "The uuid of the cluster the sla belongs to"
    clusterUuid: UUID!
    "The fid of the sla"
    id: String!
    "The name of the sla"
    name: String!
}

"Paginated list of ClusterSlaDomainForFilter objects."
type ClusterSlaDomainForFilterConnection {
    "Total number of ClusterSlaDomainForFilter objects matching the request arguments."
    count: Int!
    "List of ClusterSlaDomainForFilter objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [ClusterSlaDomainForFilterEdge!]!
    "List of ClusterSlaDomainForFilter objects."
    nodes: [ClusterSlaDomainForFilter!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the ClusterSlaDomainForFilter object. This wrapper is used for pagination."
type ClusterSlaDomainForFilterEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual ClusterSlaDomainForFilter object wrapped by this edge."
    node: ClusterSlaDomainForFilter!
}

"Aggregated statistics across Clusters."
type ClusterStatsAggregation {
    "Ingested bytes for archived snapshots."
    ingestedArchivalStorage: Long!
    "Ingested bytes for local snapshots."
    ingestedSnapshotStorage: Long!
    "Physical bytes for archived snapshots."
    physicalArchivalStorage: Long!
    "Physical bytes for local snapshots."
    physicalSnapshotStorage: Long!
}

type ClusterType {
    enumValue: ClusterTypeEnum!
}

type Column {
    aggregate: Boolean!
    default: Boolean!
    dimensional: Boolean!
    displayName: String!
    name: String!
    nullable: Boolean!
    sortable: Boolean!
    type: DataTypeEnum!
}

type CommonNotificationConfig {
    hostname: String!
    networkType: NetworkProtocolTypeEnum!
    port: Int!
    securityType: SMTPSecurityTypeEnum!
    trustedCerts: String!
}

"Response of the operation to complete Azure Cloud Account OAuth."
type CompleteAzureCloudAccountOauthReply {
    "Specifies whether the OAuth authentication was completed successfully. When true, it means the authentication was successful."
    isSuccess: Boolean!
    "Subscriptions for which the OAuth user has read permission on Azure."
    subscriptions: [AzureCloudAccountSubscription!]!
}

"Number of objects sharing a compliance status."
type ComplianceFrequency {
    "Number of objects with this status."
    count: Int!
    "Compliance status."
    status: ComplianceStatusEnum!
}

type ComplianceStatus {
    enumValue: ComplianceStatusEnum!
}

type ConfigFilter {
    filter: ReportFilter!
    filterHeader: [String!]!
}

"Additional information about the connection status of the the replication pair Rubrik clusters."
type ConnectionStatusDetails {
    "Connection between source cluster and Rubrik (connected, disconnected, or not added)."
    sourceAndRubrik: ClusterConnectionStatus!
    "Connection between source and target Rubrik clusters (connected or disconnected)."
    sourceAndTarget: ConnectionStatusType!
    "Connection between target cluster and Rubrik (connected, disconnected, or not added)."
    targetAndRubrik: ClusterConnectionStatus!
}

"Upgrade context object."
type Context {
    "Status object."
    status: UpgradeStatus
}

type CountOfObjectsProtectedBySLAsResult {
    slaObjectCounts: [SLAIdToObjectCount!]!
}

type Crawl {
    analyzerGroupResults: [AnalyzerGroupResult!]!
    analyzerResults: [AnalyzerResult!]!
    crawlObj(snappableFid: String!): CrawlObj!
    crawlObjConnection: CrawlObjConnection!
    endTime: Long!
    failedObjectCount: Int!
    fileResultConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ListFileResultFiltersInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        sort: FileResultSortInput
    ): FileResultConnection!
    filesAnalyzeable: Long!
    filesAnalyzed: Long!
    filesTotal: Long!
    filesWithHits: Long!
    id: String!
    name: String!
    progress: Float!
    snappableTypeSummaries: [SnappableTypeSummary!]!
    startTime: Long!
    status: CrawlStatusEnum!
    totalHits: Int!
    user: User
}

"Paginated list of Crawl objects."
type CrawlConnection {
    "Total number of Crawl objects matching the request arguments."
    count: Int!
    "List of Crawl objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [CrawlEdge!]!
    "List of Crawl objects."
    nodes: [Crawl!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the Crawl object. This wrapper is used for pagination."
type CrawlEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual Crawl object wrapped by this edge."
    node: Crawl!
}

type CrawlObj {
    analyzerGroupResults: [AnalyzerGroupResult!]!
    analyzerResults: [AnalyzerResult!]!
    cluster: Cluster!
    crawlId: String!
    endTime: Long!
    error: String!
    fileResultConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: BrowseDirectoryFiltersInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        sort: FileResultSortInput,
        stdPath: String!
    ): FileResultConnection!
    filesAnalyzeable: Long!
    filesAnalyzed: Long!
    filesTotal: Long!
    filesWithHits: Long!
    progress: Float!
    snappable: HierarchyObject!
    snapshotFid: String!
    snapshotTime: Long!
    startTime: Long!
    status: SnappableCrawlStatus!
    totalHits: Int!
}

"Paginated list of CrawlObj objects."
type CrawlObjConnection {
    "Total number of CrawlObj objects matching the request arguments."
    count: Int!
    "List of CrawlObj objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [CrawlObjEdge!]!
    "List of CrawlObj objects."
    nodes: [CrawlObj!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the CrawlObj object. This wrapper is used for pagination."
type CrawlObjEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual CrawlObj object wrapped by this edge."
    node: CrawlObj!
}

"AWS Exocompute Configs Create Response."
type CreateAwsExocomputeConfigsReply {
    "List of exocompute configurations."
    configs: [AwsExocomputeGetConfigResponse!]!
}

"Output for CreateCloudNativeAwsStorageSetting mutation"
type CreateCloudNativeAwsStorageSettingReply {
    targetMapping: TargetMapping!
}

"Storage settings info for Azure"
type CreateCloudNativeAzureStorageSettingReply {
    targetMapping: TargetMapping!
}

"The status of Create label Rule request. It contains theid of the new label rule if request succeeds"
type CreateCloudNativeLabelRuleReply {
    labelRuleId: String!
}

"The status of Create tag Rule request. It contains theid of the new tag rule if request succeeds"
type CreateCloudNativeTagRuleReply {
    tagRuleId: String!
}

"CreateK8sAgentManifest mutation reply."
type CreateK8sAgentManifestReply {
    "K8s Agent manifest information."
    info: K8sAgentManifestInfo!
}

"Contains information about the snapshots placed on legal hold."
type CreateLegalHoldReply {
    "List of the snapshot IDs placed on legal hold."
    snapshotIds: [String!]!
}

type CreateManagedVolumeResponse {
    "Required. Status of the asynchronous job triggered when Managed Volumes are created."
    asyncRequestStatus: AsyncRequestStatus
    "Required. Summary information of the created managed volume."
    managedVolumeSummary: ManagedVolumeSummary
}

"O365 create app kickoff response"
type CreateO365AppKickoffResp {
    appClientId: String!
    csrfToken: String!
    o365TenantId: String!
}

"Reply to Create on-demand job request."
type CreateOnDemandJobReply {
    jobId: Long!
    taskchainId: String!
}

"UUID of created organization."
type CreateOrgReply {
    "UUID of created organization."
    organizationId: String!
}

"Contains the URLs for RBA installers"
type CreateRBAInstallerReply {
    debianUrl: String!
    rpmUrl: String!
    windowsUrl: String!
}

"A Recovery Plan."
type CreateRecoveryPlanReply implements HierarchyObject {
    "Recovery Plan config."
    config: RecoveryPlanConfig
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "Recovery Plan description."
    description: String!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "Recovery Plan version."
    version: Int!
}

"Service account details"
type CreateServiceAccountReply {
    accessTokenUri: String!
    clientId: String!
    clientSecret: String!
    name: String!
}

"The webhook that was created."
type CreateWebhookReply {
    "The timestamp that this webhook was created at."
    createdAt: String!
    "The user who created the webhook."
    createdBy: String!
    "A description of the webhook."
    description: String
    "The event severities that the webhook is subscribed to."
    eventSeverities: [EventSeverity!]!
    "List of webhook's subscribed events."
    eventTypes: [EventType!]!
    "ID of the created webhook."
    id: Int!
    "The name of the created webhook."
    name: String!
    "The application that will receive the webhook."
    providerType: ProviderType!
    "Describes whether the webhook is enabled or disabled."
    status: WebhookStatus!
    "The URL endpoint to the receiving application."
    url: URL!
}

"CSR Information"
type Csr {
    csr: String!
    csrId: Long!
    hostnames: [String!]!
    name: String!
}

"Paginated list of Csr objects."
type CsrConnection {
    "Total number of Csr objects matching the request arguments."
    count: Int!
    "List of Csr objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [CsrEdge!]!
    "List of Csr objects."
    nodes: [Csr!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the Csr object. This wrapper is used for pagination."
type CsrEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual Csr object wrapped by this edge."
    node: Csr!
}

"Current rolling upgrade node status information."
type CurrentStateInfo {
    "Completed stages."
    completedStates: [String!]!
    "Current stage."
    currentState: String!
    "Current task index in stage."
    currentTaskIndex: String!
    "Current task name."
    currentTaskName: String!
    "Pending stages."
    pendingStates: [String!]!
    "Current task result."
    result: String!
    "Current status."
    status: UpgradeStatus
}

type CustomAnalyzerMatch {
    endIndex: Int!
    startIndex: Int!
}

"Metadata for rendering a custom report."
type CustomReport {
    "The list of charts in the custom report."
    charts: [ReportChartType!]!
    "Time the report was created."
    createdAt: DateTime!
    "The filters applied to the data in the report."
    filters: CustomReportFilters!
    "The metrics focus of the custom report."
    focus: ReportFocusEnum!
    "ID of the custom report."
    id: Int!
    "True if report should be hidden from gallery view."
    isHidden: Boolean!
    "True if report is auto-generated and not allowed to be edited."
    isReadOnly: Boolean!
    "Name of the custom report."
    name: String!
    newestSyncDate: DateTime
    oldestSyncDate: DateTime
    "The creator of the custom report."
    owner: User!
    scheduledReportConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int
    ): ScheduledReportConnection!
    "The list of tables in the custom report."
    tables: [ReportTableType!]!
    "Time the report was last updated (i.e., saved)."
    updatedAt: DateTime!
    "Time the report was last viewed / opened by the user."
    viewedAt: DateTime!
}

"Paginated list of CustomReport objects."
type CustomReportConnection {
    "Total number of CustomReport objects matching the request arguments."
    count: Int!
    "List of CustomReport objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [CustomReportEdge!]!
    "List of CustomReport objects."
    nodes: [CustomReport!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the CustomReport object. This wrapper is used for pagination."
type CustomReportEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual CustomReport object wrapped by this edge."
    node: CustomReport!
}

"Filter configs for a report."
type CustomReportFilters {
    "List of activity object types to filter on."
    activityObjectType: [ActivityObjectTypeEnum!]
    "List of clusters to filter on."
    cluster: [Cluster!]
    clusterLocation: [String!]
    "List of cluster types to filter on."
    clusterType: [ClusterTypeEnum!]
    complianceStatus: [ComplianceStatusEnum!]
    failoverStatus: [FailoverStatusEnum!]
    failoverType: FailoverTypeEnum
    "Anomalous value to filter data on."
    isAnomaly: Boolean
    "List of activity statuses to filter on."
    lastActivityStatus: [ActivityStatusEnum!]
    "List of activity types to filter on."
    lastActivityType: [ActivityTypeEnum!]
    "List of managed ids to filter data on."
    managedId: [String!]
    "List of snappable types to filter on."
    objectType: [ObjectTypeEnum!]
    "List of policy IDs to filter on."
    policyId: [String!]
    protectionStatus: [ProtectionStatusEnum!]
    replicationSource: [String!]
    searchTerm: String
    slaDomain: [SlaDomain!]
    "The time range for sla compliance report"
    slaTimeRange: SLAComplianceTimeRangeEnum
    sonarObjectTypes: [HierarchyObjectTypeEnum!]
    source: [String!]
    targetSite: [String!]
    taskCategory: [String!]
    taskStatus: [String!]
    taskType: [String!]
    "Start and end time range to filter data on."
    timeRange: GenericTimeRange
    "List of object types to filter on for Audits."
    userAuditObjectType: [UserAuditObjectTypeEnum!]
    "List of user audit status to filter on."
    userAuditStatus: [UserAuditStatusEnum!]
    "List of user audit types to filter on."
    userAuditType: [UserAuditTypeEnum!]
}

"CustomReport data with groupby info applied to it."
type CustomReportGroupBy {
    "The data groupby info."
    groupByInfo: CustomReportGroupByInfo!
    "Paginated snappable data."
    reportConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort by field"
        sortBy: CustomReportSortByEnum = UpdateTime,
        "sort order"
        sortOrder: SortOrderEnum
    ): CustomReportConnection!
    "Further provide groupings for the data."
    reportGroupBy(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "group by field"
        groupBy: CustomReportGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int
    ): [CustomReportGroupBy!]!
}

"Paginated list of CustomReportGroupBy objects."
type CustomReportGroupByConnection {
    "Total number of CustomReportGroupBy objects matching the request arguments."
    count: Int!
    "List of CustomReportGroupBy objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [CustomReportGroupByEdge!]!
    "List of CustomReportGroupBy objects."
    nodes: [CustomReportGroupBy!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the CustomReportGroupBy object. This wrapper is used for pagination."
type CustomReportGroupByEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual CustomReportGroupBy object wrapped by this edge."
    node: CustomReportGroupBy!
}

type DailyAnalysisDetails {
    anomalyEventCount: Long!
    createdDataBytes: Long!
    createdFileCount: Long!
    day: String!
    deletedDataBytes: Long!
    deletedFileCount: Long!
    modifiedDataBytes: Long!
    modifiedFileCount: Long!
    suspiciousDataBytes: Long!
    suspiciousFileCount: Long!
}

"Daily compliance stats."
type DailyComplianceStats {
    "Number of objects by compliance status."
    counts: [ComplianceFrequency!]!
    "The date to which the stats apply."
    date: DateTime!
}

"A daily recurrence pattern (e.g. every 3 days)."
type DailyRecurrencePattern {
    "The interval at which the recurrence applies."
    interval: Int!
}

type DailySnapshotSchedule {
    basicSchedule: BasicSnapshotSchedule
}

"Supported in v6.0+"
type DataGuardGroupMember {
    """

    Required. Supported in v6.0+
    Unique name of the member Oracle database.
    """
    dbUniqueName: String!
    """

    Supported in v6.0+
    Rubrik ID of the RAC on which this database is hosted. This field is empty when the database is not hosted on a RAC environment.
    """
    racId: String
    """

    Supported in v6.0+
    Cluster name assigned to the Oracle RAC.
    """
    racName: String
    """

    Required. Supported in v6.0+
    Current role of the member Oracle database.
    """
    role: String!
    """

    Supported in v6.0+
    Rubrik ID of the standalone Oracle host on which this database is hosted. This field is empty when the database is not hosted on a standalone system.
    """
    standaloneHostId: String
    """

    Supported in v6.0+
    Name of the standalone Oracle database host.
    """
    standaloneHostName: String
}

type DataLocation {
    clusterUuid: UUID!
    createDate: DateTime!
    id: String!
    isActive: Boolean!
    isArchived: Boolean!
    "the name of the data location"
    name: String!
    type: LocationTypeEnum!
}

"Cluster specific info for supported cluster"
type DataLocationSupportedCluster {
    name: String!
    uuid: String!
    version: String!
}

"Objects containing Datastore names for a given ESXi host"
type Datastore {
    name: String!
}

"Datastores for a given ESXi host"
type DatastoreListResponse {
    data: [Datastore!]!
    hasMore: Boolean
    total: Long
}

type DayOfWeekOpt {
    day: DayOfWeek!
}

"Db2 snappable related app metadata for a snapshot."
type Db2AppMetadata {
    "Approximate DB size just around the time the snapshot is taken."
    approximateDbSizeBytes: Long
    "Backup ID set by database."
    backupId: String
    "Backup ID of the base backup."
    baseBackupId: String
    "Snapshot ID of the base backup."
    baseSnapshotId: String
    "Snapshot type for base back up: Full/Incremental/Differential."
    baseSnapshotType: Db2SnapshotType
    "Snapshot metadata information specific to Db2."
    db2SnapshotMetadata: Db2SnappableDataSnapshotMetadata
    "End time for the backup in DB."
    endTime: DateTime
    "List of files backed up as a part of this backup."
    files: [Db2DataBackupFile!]!
    "Denotes whether the backup was triggered by Rubrik or by an external agent."
    isExternalBackup: Boolean!
    "Whether the backup is triggered by Rubrik and is OnDemand."
    isRubrikTriggeredOnDemandBackup: Boolean!
    "The ID for the backup object stored in snapshot table."
    snapshotId: String
    "Snapshot type: Full/Incremental/Differential."
    snapshotType: Db2SnapshotType
    "Start time for the backup in DB."
    startTime: DateTime
}

"The SLA Domain configuration for Db2 database."
type Db2Config {
    "Frequency value for differential backup of Db2 databases."
    differentialFrequency: Duration
    "Frequency value for incremental backup of Db2 databases."
    incrementalFrequency: Duration
    "Specifies the number of days for which the Db2 database logs will be retained."
    logRetention: Duration
}

"File backed up as a part of db2 backup."
type Db2DataBackupFile {
    "Size of the backed up file in bytes."
    backupFileSizeInBytes: Long!
    "Information specific to Db2 and which is already not available in DBDataBackupFile."
    db2BackupFile: Db2SnappableDataBackupFile!
    "Backup file destination path. Path of the file in the backing storage."
    destinationPath: String!
}

"Db2 Database details object."
type Db2Database implements CdmHierarchyObject & CdmHierarchySnappableNew & Db2InstanceDescendantType & Db2InstancePhysicalChildType & HierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Id associated with Db2 database in CDM."
    cdmId: String!
    "A link to view the snappable on the CDM cluster. For dev use only."
    cdmLink: String!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "Db2 Instance parent for the given database."
    db2Instance: Db2Instance!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Whether the db2 database is a relic."
    isRelic: Boolean!
    "Time stamp of when last metadata sync happened for the Db2 database."
    lastSyncTime: DateTime
    "Latest User note information."
    latestUserNote: LatestUserNote
    "Threshold before new log backup takes place."
    logBackupThreshold: String!
    "Connection of log snapshots for given Db2 database."
    logSnapshots(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter Db2 log snapshots by input"
        filter: Db2LogSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort Db2 log snapshots by field"
        sortBy: Db2LogSnapshotSortBy,
        "sort order"
        sortOrder: SortOrderEnum
    ): Db2LogSnapshotConnection!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The list of missed snapshots for this workload."
    missedSnapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int
    ): MissedSnapshotCommonConnection
    "The list of missed snapshots for this workload."
    missedSnapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: MissedSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): MissedSnapshotGroupByConnection
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot archived to AWS."
    newestArchivedSnapshot: CdmSnapshot
    "The newest snapshot replicated to a cluster."
    newestReplicatedSnapshot: CdmSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: CdmSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: CdmSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "Uuid of the primary cluster."
    primaryClusterUuid: UUID!
    "Connection of recoverable ranges for given Db2 database."
    recoverableRanges(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter Db2 recoverable ranges by input"
        filter: Db2RecoverableRangeFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort Db2 recoverable ranges by field"
        sortBy: Db2RecoverableRangeSortBy,
        "sort order"
        sortOrder: SortOrderEnum
    ): Db2RecoverableRangeConnection!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for the snapshots of this workload."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: CdmSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): cdmSnapshotGroupByConnection
}

"Paginated list of Db2Database objects."
type Db2DatabaseConnection {
    "Total number of Db2Database objects matching the request arguments."
    count: Int!
    "List of Db2Database objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [Db2DatabaseEdge!]!
    "List of Db2Database objects."
    nodes: [Db2Database!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the Db2Database object. This wrapper is used for pagination."
type Db2DatabaseEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual Db2Database object wrapped by this edge."
    node: Db2Database!
}

"Db2 Instance details object."
type Db2Instance implements CdmHierarchyObject & HierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Id associated with Db2 instance in CDM."
    cdmId: String!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): Db2InstanceDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Timestamp when last refresh job got triggered for the Db2 instance."
    lastRefreshTime: DateTime
    "Time stamp of when last metadata sync happened for the Db2 instance."
    lastSyncTime: DateTime
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "List of physical children"
    physicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): Db2InstancePhysicalChildTypeConnection!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "Uuid of the primary cluster."
    primaryClusterUuid: UUID!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "Current status for the Db2 instance: OK, WARNING, ERROR or UNKNOWN."
    status: Db2Status!
    "Additional information about the current status for the Db2 instance."
    statusMessage: [String!]!
}

"Paginated list of Db2Instance objects."
type Db2InstanceConnection {
    "Total number of Db2Instance objects matching the request arguments."
    count: Int!
    "List of Db2Instance objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [Db2InstanceEdge!]!
    "List of Db2Instance objects."
    nodes: [Db2Instance!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Paginated list of Db2InstanceDescendantType objects."
type Db2InstanceDescendantTypeConnection {
    "Total number of Db2InstanceDescendantType objects matching the request arguments."
    count: Int!
    "List of Db2InstanceDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [Db2InstanceDescendantTypeEdge!]!
    "List of Db2InstanceDescendantType objects."
    nodes: [Db2InstanceDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the Db2InstanceDescendantType object. This wrapper is used for pagination."
type Db2InstanceDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual Db2InstanceDescendantType object wrapped by this edge."
    node: Db2InstanceDescendantType!
}

"Wrapper around the Db2Instance object. This wrapper is used for pagination."
type Db2InstanceEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual Db2Instance object wrapped by this edge."
    node: Db2Instance!
}

"Paginated list of Db2InstancePhysicalChildType objects."
type Db2InstancePhysicalChildTypeConnection {
    "Total number of Db2InstancePhysicalChildType objects matching the request arguments."
    count: Int!
    "List of Db2InstancePhysicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [Db2InstancePhysicalChildTypeEdge!]!
    "List of Db2InstancePhysicalChildType objects."
    nodes: [Db2InstancePhysicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the Db2InstancePhysicalChildType object. This wrapper is used for pagination."
type Db2InstancePhysicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual Db2InstancePhysicalChildType object wrapped by this edge."
    node: Db2InstancePhysicalChildType!
}

"Supported in v7.0+"
type Db2InstanceSummary {
    """

    Required. Supported in v7.0+
    List of IDs of databases present in this Db2 instance.
    """
    databaseIds: [String!]!
    """

    Required. Supported in v7.0+
    List of hosts that are a part of this Db2 instance.
    """
    hostIds: [String!]!
    """

    Required. Supported in v7.0+
    ID of the Db2 instance.
    """
    id: String!
    """

    Required. Supported in v7.0+
    UTC timestamp of the most recent Db2 instance refresh job.
    """
    lastRefreshTime: String!
    """

    Required. Supported in v7.0+
    Name of the Db2 instance.
    """
    name: String!
    """

    Required. Supported in v7.0+
    ID of the CDM cluster that protects the Db2 instance.
    """
    primaryClusterUuid: String!
    """

    Required. Supported in v7.0+
    UTC timestamp of the most recent Db2 instance refresh job.
    """
    protectionDate: String!
    """

    Required. Supported in v7.0+
    SLA Domain ID assigned to the Db2 instance.
    """
    slaDomainId: String!
    """

    Required. Supported in v7.0+
    Type of the SLA Domain assigned to the Db2 instance.
    """
    slaType: String!
    status: Db2InstanceSummaryStatusEnum!
    """

    Required. Supported in v7.0+
    Status messsage of the most recent Db2 instance refresh job.
    """
    statusMessage: String!
    """

    Required. Supported in v7.0+
    Username provided by the user that will be used while interacting with Db2 system.
    """
    username: String!
}

"Backup file associated with the Db2 log back object."
type Db2LogBackupFile {
    "Size of the db2 log backup."
    backupFileSizeInBytes: Long
    "The id for the Db2 log back object."
    backupId: String
    "Location of the backup file."
    destinationPath: String
    "End time for log backup."
    endTime: DateTime
}

"Db2 log snapshot object."
type Db2LogSnapshot {
    "App metadata of log snapshots in Db2."
    appMetadata: Db2LogSnapshotAppMetadata
    "The CDM fid of the Db2 snapshot object."
    cdmId: String!
    "Uuid of the CDM cluster associated with Db2 snappable."
    clusterUuid: UUID!
    "The creation date of the snapshot."
    date: DateTime
    "The polaris fid of the Db2 snapshot object."
    fid: String!
    "The internal time stamp of the Db2 snapshot object."
    internalTimestamp: Long!
    "Boolean for archival status of the Db2 snapshot object."
    isArchived: Boolean!
    "The polaris fid of the snappable on which snapshot was taken."
    snappableId: String!
    "The snappable type on which snapshot was taken."
    snappableType: String!
}

"Metadata related to the Db2 log snapshot."
type Db2LogSnapshotAppMetadata {
    "List of Backups for a Db2 log snapshot."
    backups: [Db2LogBackupFile!]
    "The ID for the backup object stored in snapshot table."
    snapshotId: String
}

"Paginated list of Db2LogSnapshot objects."
type Db2LogSnapshotConnection {
    "Total number of Db2LogSnapshot objects matching the request arguments."
    count: Int!
    "List of Db2LogSnapshot objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [Db2LogSnapshotEdge!]!
    "List of Db2LogSnapshot objects."
    nodes: [Db2LogSnapshot!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the Db2LogSnapshot object. This wrapper is used for pagination."
type Db2LogSnapshotEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual Db2LogSnapshot object wrapped by this edge."
    node: Db2LogSnapshot!
}

"Db2 recoverable range object."
type Db2RecoverableRange {
    "Id for the base full snapshot object associated."
    baseFullSnapshotId: String
    "The CDM fid of the Db2 recoverable range object."
    cdmId: String!
    "Uuid of the CDM cluster associated with Db2 snappable."
    clusterUuid: UUID!
    "The polaris fid for the Db2 database associated with the Db2 recoverable range object."
    dbId: String!
    "End time of the Db2 recoverable range object."
    endTime: DateTime
    "The polaris fid of the Db2 recoverable range object."
    fid: String!
    "Boolean for archival status of Db2 recoverable range object."
    isArchived: Boolean!
    "Start time of the Db2 recoverable range object."
    startTime: DateTime
}

"Paginated list of Db2RecoverableRange objects."
type Db2RecoverableRangeConnection {
    "Total number of Db2RecoverableRange objects matching the request arguments."
    count: Int!
    "List of Db2RecoverableRange objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [Db2RecoverableRangeEdge!]!
    "List of Db2RecoverableRange objects."
    nodes: [Db2RecoverableRange!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the Db2RecoverableRange object. This wrapper is used for pagination."
type Db2RecoverableRangeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual Db2RecoverableRange object wrapped by this edge."
    node: Db2RecoverableRange!
}

"Information specific to Db2 and which is already not available in DBDataBackupFile."
type Db2SnappableDataBackupFile {
    "PartitionNum of the backed up file in DB."
    partitionNum: Int!
    "SequenceNum of the backed up file in DB."
    sequenceNum: Int!
}

"Any snapshot metadata information specific to Db2 and which is already not part of DBDataSnapshotMetadata structure."
type Db2SnappableDataSnapshotMetadata {
    "List of serialised InternalFileInstanceInfo all the files in the snapshot."
    kvSnapshotFileInstancesInfoList: [String!]!
}

"Represents a DB parameter group in AWS."
type DbParameterGroup {
    "Amazon Resource Name (ARN) of the DB parameter group."
    arn: String!
    "Family name of the DB parameter group."
    family: String!
    "Name of the DB parameter group."
    name: String!
}

"Reply for deletion of aws compute setting"
type DeleteAwsCloudComputeSettingReply {
    success: Boolean!
}

"AWS Exocompute Configs Delete Response."
type DeleteAwsExocomputeConfigsReply {
    "Deletion status for exocompute configurations."
    deletionStatus: [AwsExocomputeConfigsDeletionStatusType!]!
}

"Response of the operation to delete Exocompute Configuration from the Azure Cloud Account."
type DeleteAzureCloudAccountExocomputeConfigurationsReply {
    "IDs of the Azure Cloud Accounts that could not be deleted."
    deletionFailedIds: [String!]!
    "IDs of the Azure Cloud Accounts that were deleted successfully."
    deletionSuccessIds: [String!]!
}

"Response of the operation to delete Azure Cloud Account."
type DeleteAzureCloudAccountReply {
    "Status of the operation to delete Azure Cloud Account."
    status: [DeleteAzureCloudAccountStatus!]!
}

"Status of the operation to delete Azure Cloud Account."
type DeleteAzureCloudAccountStatus {
    "Native ID of the Azure Subscription."
    azureSubscriptionNativeId: String!
    "Error received during deletion of Azure Cloud Account."
    error: String!
    "Specifies whether the deletion of Azure Cloud Account was successful. When true, the deletion was successful."
    isSuccess: Boolean!
}

"Response of the operation to delete Azure Cloud Account without OAuth."
type DeleteAzureCloudAccountWithoutOauthReply {
    "Status of the operation to delete Azure Cloud Account."
    status: [DeleteAzureCloudAccountStatus!]!
}

type DeleteBlueprintRecoverySpecReply {
    recoverySpecIds: [RecoverySpecId!]!
}

"Statistic result for certain file/folder"
type DiffData {
    bytesCreated: Long!
    bytesDeleted: Long!
    bytesModified: Long!
    filesCreated: Long!
    filesDeleted: Long!
    filesModified: Long!
    isDeleted: Boolean!
    isFolder: Boolean!
    lastModifiedTime: Long!
    mode: Int!
    path: String!
    suspiciousFilesAdded: Long!
    totalSize: Long!
}

"Diff fmd result."
type DiffFMDReply {
    data: [DiffData!]!
    previousSnapshotDate: Long!
    previousSnapshotId: String!
}

"Archival location disable result."
type DisableTargetReply {
    "Polaris managed location ID."
    locationId: String!
    "Ownership status of the archival location."
    status: ArchivalLocationStatus!
}

"Supported in v7.0+"
type DiscoverNasSystemResponse {
    """

    Required. Supported in v7.0+
    An array of discover NAS system summaries.
    """
    discoverNasSystemSummaries: [DiscoverNasSystemSummary!]!
}

"Supported in v7.0+"
type DiscoverNasSystemSummary {
    """

    Required. Supported in v7.0+
    The asynchronous request status of the job that discovers the NAS system.
    """
    nasDiscoverJobStatus: AsyncRequestStatus
    """

    Required. Supported in v7.0+
    ID of the NAS system.
    """
    nasSystemId: String!
}

type DisplayableValueBoolean implements DisplayableValue {
    displayValue: String!
    reportHeader: String!
    serializedValue: String!
    value: Boolean
}

type DisplayableValueDateRange implements DisplayableValue {
    displayValue: String!
    reportHeader: String!
    serializedValue: String!
    value: PastDurationEnum
}

type DisplayableValueDateTime implements DisplayableValue {
    displayValue: String!
    reportHeader: String!
    serializedValue: String!
    value: DateTime
}

type DisplayableValueFloat implements DisplayableValue {
    displayValue: String!
    reportHeader: String!
    serializedValue: String!
    value: Float
}

type DisplayableValueInteger implements DisplayableValue {
    displayValue: String!
    reportHeader: String!
    serializedValue: String!
    value: Int
}

type DisplayableValueLong implements DisplayableValue {
    displayValue: String!
    reportHeader: String!
    serializedValue: String!
    value: Long
}

type DisplayableValueNull implements DisplayableValue {
    displayValue: String!
    reportHeader: String!
    serializedValue: String!
}

type DisplayableValueString implements DisplayableValue {
    displayValue: String!
    reportHeader: String!
    serializedValue: String!
    value: String
}

"Contains information about the snapshots dissolved from legal hold."
type DissolveLegalHoldReply {
    "List of the snapshot IDs dissolved from  legal hold."
    snapshotIds: [String!]!
}

"Reply for org existence check."
type DoesOrgExistReply {
    "Result for org name existence check."
    doesOrgNameExist: Boolean!
    "Result for org url existence check."
    doesOrgUrlExist: Boolean!
}

type DownloadActiveSlaWithReplicationCsvReply {
    downloadLink: String!
    isActiveSla: Boolean!
}

"Download CDM upgrades report response."
type DownloadCdmUpgradesPdfReply {
    "Download link of the pdf report."
    downloadLink: String!
}

type DownloadCsvReply {
    "Status of queueing a download CSV job."
    isSuccessful: Boolean!
}

"The status of download cloud native files req. It contains thetaskchain id of the download job if succeeded"
type DownloadFilesReply {
    taskchainId: String!
}

"Download job progress information."
type DownloadJobInfo {
    "Event series id related to download package job."
    eventId: String!
    "Job id of download package job."
    jobInstanceId: String!
    progress: Float!
    "Time remaining for download job to complete."
    remainingTimeEstimateInSeconds: Long!
    "Status of download package job."
    status: String!
}

"Link to report"
type DownloadLink {
    "The link to the report."
    link: String!
}

"Download package response."
type DownloadPackageReply {
    jobId: String!
}

"Start download job request response."
type DownloadPackageReplyWithUuid {
    "Download package job id."
    jobId: String!
    "Cluster uuid."
    uuid: String!
}

"Download package job status information."
type DownloadPackageStatusReply {
    "Availability of CDM package."
    availability: String!
    "Download job status description."
    description: String!
    "CDM download job information."
    downloadJobInfo: DownloadJobInfo
    "MD5Sum of the CDM package."
    md5Sum: String!
    "Size of CDM package."
    size: Long!
    "CDM upgrade package version."
    version: String!
}

type DownloadResultsCsvReply {
    downloadLink: String!
}

type Duration {
    duration: Int!
    unit: RetentionUnitEnum!
}

type Ec2Blueprint implements Blueprint & HierarchyObject & HierarchySnappable & PolarisHierarchyObject & PolarisHierarchySnappable {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The list of children workload."
    childConnection: BlueprintChildConnection!
    children: [Ec2InstanceChild!]!
    "The cloud account of EC2 Blueprint"
    cloudAccount: AwsNativeAccount
    "The cluster from which this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    currentFailoverStatus: AppBlueprintFailoverStatusEnum!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    isRelic: Boolean!
    "last failover"
    lastFailover: Failover
    lastFailoverStatus: AppBlueprintLastFailoverStatusEnum!
    lastFailoverTimeMillisOpt: Long
    "last test failover"
    lastTestFailover: Failover
    lastTestFailoverStatus: AppBlueprintLastFailoverStatusEnum!
    lastTestFailoverTimeMillisOpt: Long
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot archived to AWS."
    newestArchivedSnapshot: PolarisSnapshot
    "The newest snapshot ready for failover."
    newestFailoverReadySnapshot(isTestFailover: Boolean!): PolarisSnapshot
    "The newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "The newest snapshot replicated to a cluster."
    newestReplicatedSnapshot: PolarisSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: PolarisSnapshot
    "number of child snappables of the Blueprint"
    numChildren: Int!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: PolarisSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    rmStatus: AppBlueprintRmStatusEnum!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this workload."
    snapshotsOfSnappableConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Whether to ignore the active protected object check."
        ignoreActiveSnappableCheck: Boolean,
        "Returns the last n elements from the list."
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
    status: AppBlueprintStatusEnum!
}

type Ec2BlueprintChildFailoverInstance implements BlueprintFailoverInstance {
    snappableId: String!
}

type Ec2InstanceChild implements BlueprintChild {
    bootPriority: Int!
    "failover instance of child snappable"
    failoverInstance: Ec2BlueprintChildFailoverInstance
    fid: UUID!
    "recoverySpec of child snappable"
    recoverySpec(
        "The recovery point of the snappable."
        recoveryPoint: Long
    ): RecoverySpec
    "resourceSpec of child snappable"
    resourceSpec(
        "The recovery point of the snappable."
        recoveryPoint: Long
    ): Ec2InstanceResourceSpec
    "the child snappable"
    snappable: AwsNativeEc2Instance
    snappableType: ObjectTypeEnum!
}

type Ec2InstanceNic {
    key: String!
    secGroup: SnappableSecurityGroup
    subnet: SnappableSubnet
}

type Ec2InstanceRecoverySpec implements RecoverySpec {
    availabilityZone: String
    awsNicSpecs: [AwsVMNicSpec!]!
    awsVolumeSpecs: [AwsVMVolumeSpec!]!
    dedicatedHostId: String
    hostAffinity: String
    instanceTypeId: Int!
    instanceTypeName: String!
    keyName: String
    placementGroup: String
    "Recovery point of the snappable."
    recoveryPointOpt: Long
    tenancy: AwsInstanceTenancyEnum!
    userData: String
    version: Long!
}

type Ec2InstanceResourceSpec implements ResourceSpec {
    ec2InstanceNics: [Ec2InstanceNic!]!
    ec2InstanceVolumeSpecs: [Ec2InstanceVolume!]!
    instanceType: String!
    instanceTypeMemoryMbs: Int!
    instanceTypeVCpus: Int!
    isArchived: Boolean!
    nativeId: String!
    osType: String!
    "Recovery point of the snappable."
    recoveryPointOpt: Long
    region: String!
    snappableId: String!
    snappableName: String!
    snapshotId: String!
}

type Ec2InstanceVolume {
    key: String!
    sizeGbs: Int!
}

"Supported in v5.1+"
type EffectiveSlaHolder {
    """

    Required. Supported in v5.1+
    v5.1: ID of the effective SLA domain
    v5.2+: The ID of the SLA Domain that controls the protection of the Rubrik object.
    """
    effectiveSlaDomainId: String!
    """

    Required. Supported in v5.1+
    v5.1: name of the effective SLA domain
    v5.2+: The name of the SLA Domain that controls the protection of the Rubrik object.
    """
    effectiveSlaDomainName: String!
    """

    Supported in v5.1+
    v5.1: Optional field containing Polaris managed id of the effective SLA domain if it is Polaris managed.
    v5.2+: Optional. This field contains the managed ID of of the Polaris-managed effective SLA Domain.
    """
    effectiveSlaDomainPolarisManagedId: String
    """

    Supported in v5.1+
    v5.1: ID of the object from which the effective SLA domain is inherited.
    v5.2+: The ID of the parent of the Rubrik object from which the SLA Domain that controls the protection of Rubrik object is inherited.
    """
    effectiveSlaSourceObjectId: String
    """

    Supported in v5.1+
    v5.1: Name of the object from which the effective SLA domain is inherited.
    v5.2+: The name of the parent of the Rubrik object from which the SLA Domain that controls the protection of Rubrik object is inherited.
    """
    effectiveSlaSourceObjectName: String
    """

    Supported in v5.1+
    v5.1: A Boolean that indicates whether the effective SLA Domain is Retention Locked. When this value is 'true', the effective SLA Domain is a Retention Lock SLA Domain.
    v5.2+: Indicates whether the effective SLA Domain is Retention Locked. When this value is 'true', the effective SLA domain is a Retention Lock SLA Domain.
    """
    isEffectiveSlaDomainRetentionLocked: Boolean
}

"Status of 'enable automatic upload' service on certain cluster"
type EnableAutomaticFmdUploadReply {
    clusterId: String!
    enabled: Boolean!
}

"Toggle enable/disable app consistent protection for VM"
type EnableDisableAppConsistencyReply {
    failedSnappableIds: [String!]!
    successSnappableIds: [String!]!
}

"Status of 'enable lambda service' on certain cluster"
type EnableLambdaForSnappableReply {
    diffFmdEnabled: Boolean!
    fullFmdEnabled: Boolean!
    snappableFid: String!
}

"Archival location enable result."
type EnableTargetReply {
    "Polaris managed location ID."
    locationId: String!
    "Ownership status of the archival location."
    status: ArchivalLocationStatus!
}

"A recurrence range with a start and end (e.g. repeat the pattern from 7/29/2019 until 4/13/2022)."
type EndDateRecurrenceRange {
    "The ending date of the recurrence."
    endDate: DateTime!
    "The starting date of the recurrence."
    startDate: DateTime!
}

"The status code and message describing an error."
type ErrorInfo {
    "The message describing the error."
    errorMessage: String!
    "The error's three digit status code."
    statusCode: Int!
}

type EventDigest {
    account: String!
    digestId: Int!
    digestName: String!
    eventDigestConfigJson: String!
    frequency: Int!
    includeAudits: Boolean!
    includeEvents: Boolean!
    isImmediate: Boolean!
    recipientUserId: String!
}

"Exchange DAG details object."
type ExchangeDag implements CdmHierarchyObject & HierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Backup Preference for databases present in the Exchange Dag."
    backupPreference: String!
    "ID associated with the Exchange DAG in CDM."
    cdmId: String!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): ExchangeDagDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "UUID of the primary cluster."
    primaryClusterUuid: UUID!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "Number of hosts associated with the Exchange DAG."
    totalHosts: Int!
}

"Paginated list of ExchangeDag objects."
type ExchangeDagConnection {
    "Total number of ExchangeDag objects matching the request arguments."
    count: Int!
    "List of ExchangeDag objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [ExchangeDagEdge!]!
    "List of ExchangeDag objects."
    nodes: [ExchangeDag!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Paginated list of ExchangeDagDescendantType objects."
type ExchangeDagDescendantTypeConnection {
    "Total number of ExchangeDagDescendantType objects matching the request arguments."
    count: Int!
    "List of ExchangeDagDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [ExchangeDagDescendantTypeEdge!]!
    "List of ExchangeDagDescendantType objects."
    nodes: [ExchangeDagDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the ExchangeDagDescendantType object. This wrapper is used for pagination."
type ExchangeDagDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual ExchangeDagDescendantType object wrapped by this edge."
    node: ExchangeDagDescendantType!
}

"Wrapper around the ExchangeDag object. This wrapper is used for pagination."
type ExchangeDagEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual ExchangeDag object wrapped by this edge."
    node: ExchangeDag!
}

type ExchangeDagSummary {
    backupPreference: ExchangeBackupPreferenceEnum!
    "Required. SLA Domain ID assigned to the Exchange DAG."
    configuredSlaDomainId: String!
    "Required. Type of the SLA Domain assigned to the Exchange DAG."
    configuredSlaType: String!
    "Required. ID of the Exchange DAG."
    id: String!
    "Required. Name of the Exchange DAG."
    name: String!
}

"Exchange Database details object."
type ExchangeDatabase implements CdmHierarchyObject & CdmHierarchySnappableNew & ExchangeDagDescendantType & ExchangeServerDescendantType & HierarchyObject {
    "Number of database copies which are active."
    activeCopies: Int!
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "ID associated with the Exchange Database in CDM."
    cdmId: String!
    "A link to view the snappable on the CDM cluster. For dev use only."
    cdmLink: String!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "Exchange Server parent of the database."
    exchangeServer: ExchangeServer!
    "The fid of the hierarchy object."
    id: UUID!
    "Boolean flag indicating if the database is disconnected and has snapshots present in CDM cluster."
    isRelic: Boolean!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The list of missed snapshots for this workload."
    missedSnapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int
    ): MissedSnapshotCommonConnection
    "The list of missed snapshots for this workload."
    missedSnapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: MissedSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): MissedSnapshotGroupByConnection
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot archived to AWS."
    newestArchivedSnapshot: CdmSnapshot
    "The newest snapshot replicated to a cluster."
    newestReplicatedSnapshot: CdmSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: CdmSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: CdmSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "UUID of the primary cluster."
    primaryClusterUuid: UUID!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for the snapshots of this workload."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: CdmSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): cdmSnapshotGroupByConnection
    "Total number of database copies."
    totalCopies: Int!
}

"Paginated list of ExchangeDatabase objects."
type ExchangeDatabaseConnection {
    "Total number of ExchangeDatabase objects matching the request arguments."
    count: Int!
    "List of ExchangeDatabase objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [ExchangeDatabaseEdge!]!
    "List of ExchangeDatabase objects."
    nodes: [ExchangeDatabase!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the ExchangeDatabase object. This wrapper is used for pagination."
type ExchangeDatabaseEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual ExchangeDatabase object wrapped by this edge."
    node: ExchangeDatabase!
}

"Exchange live mount."
type ExchangeLiveMount {
    "Cluster of the live mount."
    cluster: Cluster!
    "Fid of the live mount."
    id: UUID!
    "Describes if the live mount is ready."
    isReady: Boolean!
    "NodeId of the node with the live mount."
    nodeCompositeId: String!
    "Node Ip of the node with the live mount."
    nodeIp: String!
    "Source database of the live mount."
    sourceDatabase: ExchangeDatabase
    "Source snapshot of the live mount."
    sourceSnapshot: CdmSnapshot!
}

"Paginated list of ExchangeLiveMount objects."
type ExchangeLiveMountConnection {
    "Total number of ExchangeLiveMount objects matching the request arguments."
    count: Int!
    "List of ExchangeLiveMount objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [ExchangeLiveMountEdge!]!
    "List of ExchangeLiveMount objects."
    nodes: [ExchangeLiveMount!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the ExchangeLiveMount object. This wrapper is used for pagination."
type ExchangeLiveMountEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual ExchangeLiveMount object wrapped by this edge."
    node: ExchangeLiveMount!
}

"Exchange Server details object."
type ExchangeServer implements CdmHierarchyObject & HierarchyObject & PhysicalHostDescendantType & PhysicalHostPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "ID associated with the Exchange Server in CDM."
    cdmId: String!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): ExchangeServerDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "Dag parent for Exchange Server."
    exchangeDag: ExchangeDag
    "Host parent for the Exchange Server."
    host: PhysicalHost!
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "UUID of the primary cluster."
    primaryClusterUuid: UUID!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "Number of database copies present in the Exchange Server."
    totalDbs: Int!
    "Version of the Exchange Server."
    version: String!
}

"Paginated list of ExchangeServer objects."
type ExchangeServerConnection {
    "Total number of ExchangeServer objects matching the request arguments."
    count: Int!
    "List of ExchangeServer objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [ExchangeServerEdge!]!
    "List of ExchangeServer objects."
    nodes: [ExchangeServer!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Paginated list of ExchangeServerDescendantType objects."
type ExchangeServerDescendantTypeConnection {
    "Total number of ExchangeServerDescendantType objects matching the request arguments."
    count: Int!
    "List of ExchangeServerDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [ExchangeServerDescendantTypeEdge!]!
    "List of ExchangeServerDescendantType objects."
    nodes: [ExchangeServerDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the ExchangeServerDescendantType object. This wrapper is used for pagination."
type ExchangeServerDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual ExchangeServerDescendantType object wrapped by this edge."
    node: ExchangeServerDescendantType!
}

"Wrapper around the ExchangeServer object. This wrapper is used for pagination."
type ExchangeServerEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual ExchangeServer object wrapped by this edge."
    node: ExchangeServer!
}

type ExocomputeStorageAccountIds {
    ids: [String!]!
}

"Specs required for Export URL."
type ExportUrlSpecs {
    "Name of the blob."
    blobName: String!
    "SAS URI of the blob."
    blobSasUri: String!
    "Polaris account of the user."
    polarisAccount: String!
}

"A protection task."
type Failover {
    "ID of the associated appblueprint."
    appBlueprintId: UUID!
    "Name of the associated appblueprint."
    appBlueprintName: String!
    "Duration of the appflows failover job, number of millis."
    duration: Long
    "The timestamp that the job ends."
    endTime: DateTime
    "The failover job status."
    failoverStatus: FailoverStatusEnum!
    "The type of the failover job."
    failoverType: FailoverTypeEnum!
    "ID of the failover job."
    id: String!
    "The status of the last test."
    lastTestStatus: LastTestStatusEnum
    "The timestamp of the last test."
    lastTestTime: DateTime
    "The report for the failover job."
    report(
        "failover report ID"
        failoverReportId: String!
    ): FailoverReport
    "Source of the snappable associated with this appflows failover job."
    source: String!
    "The timestamp that the job starts."
    startTime: DateTime!
    "Target site of the appflows failover job."
    targetSite: String!
    taskchainId: UUID!
}

type FailoverChart {
    focus: ReportFocusEnum!
    groupBy: [FailoverGroupByEnum!]
    name: String!
}

type FailoverClusterApp implements CdmHierarchyObject & FailoverClusterTopLevelDescendantType & HierarchyObject & HostFailoverClusterDescendantType & HostFailoverClusterPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    cdmId: String!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): FailoverClusterAppDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    failoverClusterId: String!
    failoverClusterType: String
    "Get the host failover cluster object of the failover cluster app"
    hostFailoverCluster: HostFailoverCluster!
    "The fid of the hierarchy object."
    id: UUID!
    isArchived: Boolean!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "List of physical children"
    physicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): FailoverClusterAppPhysicalChildTypeConnection!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    status: FailoverClusterStatus
    vips: [String!]!
}

"Supported in v5.2+"
type FailoverClusterAppConfig {
    """

    Supported in v5.2+
    ID of the SLA Domain that is assigned to the specified failover cluster app. Existing snapshots of the object will be retained with the configuration of specified SLA Domain.
    """
    configuredSlaDomainId: String
    """

    Required. Supported in v5.2+
    The source used by the failover cluster app to perform fileset backups. Either a virtual IP address or a node order must be specified in order for the failover cluster app to perform app backup.
    """
    failoverClusterAppSource: FailoverClusterAppSource
    """

    Required. Supported in v5.2+
    Cluster ID of the failover cluster app.
    """
    failoverClusterId: String!
    failoverClusterType: FailoverClusterTypeEnum!
    """

    Required. Supported in v5.2+
    Name of the failover cluster app.
    """
    name: String!
}

"Paginated list of FailoverClusterApp objects."
type FailoverClusterAppConnection {
    "Total number of FailoverClusterApp objects matching the request arguments."
    count: Int!
    "List of FailoverClusterApp objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [FailoverClusterAppEdge!]!
    "List of FailoverClusterApp objects."
    nodes: [FailoverClusterApp!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Paginated list of FailoverClusterAppDescendantType objects."
type FailoverClusterAppDescendantTypeConnection {
    "Total number of FailoverClusterAppDescendantType objects matching the request arguments."
    count: Int!
    "List of FailoverClusterAppDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [FailoverClusterAppDescendantTypeEdge!]!
    "List of FailoverClusterAppDescendantType objects."
    nodes: [FailoverClusterAppDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the FailoverClusterAppDescendantType object. This wrapper is used for pagination."
type FailoverClusterAppDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual FailoverClusterAppDescendantType object wrapped by this edge."
    node: FailoverClusterAppDescendantType!
}

"Wrapper around the FailoverClusterApp object. This wrapper is used for pagination."
type FailoverClusterAppEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual FailoverClusterApp object wrapped by this edge."
    node: FailoverClusterApp!
}

"Paginated list of FailoverClusterAppPhysicalChildType objects."
type FailoverClusterAppPhysicalChildTypeConnection {
    "Total number of FailoverClusterAppPhysicalChildType objects matching the request arguments."
    count: Int!
    "List of FailoverClusterAppPhysicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [FailoverClusterAppPhysicalChildTypeEdge!]!
    "List of FailoverClusterAppPhysicalChildType objects."
    nodes: [FailoverClusterAppPhysicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the FailoverClusterAppPhysicalChildType object. This wrapper is used for pagination."
type FailoverClusterAppPhysicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual FailoverClusterAppPhysicalChildType object wrapped by this edge."
    node: FailoverClusterAppPhysicalChildType!
}

"Supported in v5.2+"
type FailoverClusterAppSource {
    """

    Supported in v5.2+
    Specifies an order for the failover cluster nodes. Failover cluster app backups use the failover cluster nodes in the specified order.
    """
    nodeOrders: [FailoverClusterNodeOrder!]!
    "Virtual IP addresses of the failover cluster."
    vips: [String!]!
    """

    Supported in v5.3+
    Virtual IP addresses of the failover cluster.
    """
    virtualIps: [String!]!
}

"Supported in v5.2+"
type FailoverClusterAppSummary {
    connectionStatus: FailoverClusterAppConnectionStatusEnum!
    effectiveSlaHolder: EffectiveSlaHolder
    failoverClusterAppConfig: FailoverClusterAppConfig
    """

    Supported in v5.3+
    The failover cluster name of the failover cluster app. The failover cluster is a group of hosts that provides high availability for running failover clustered applications.
    """
    failoverClusterName: String
    """

    Required. Supported in v5.2+
    ID assigned to the failover cluster app.
    """
    id: String!
    operatingSystemType: FailoverClusterOsTypeEnum
    "Required. Supported in v5.2+"
    primaryClusterId: String!
    slaAssignable: SlaAssignable
    slaAssignment: SlaAssignmentEnum
}

"Supported in v5.2+"
type FailoverClusterDetail {
    failoverClusterSummary: FailoverClusterSummary
    """

    Required. Supported in v5.2+
    Count of the number of failover cluster apps.
    """
    numApps: Int!
    """

    Required. Supported in v5.2+
    Count of the number of nodes on the failover cluster.
    """
    numNodes: Int!
}

"Supported in v5.2+"
type FailoverClusterNode {
    connectionStatus: FailoverClusterNodeConnectionStatusEnum!
    """

    Required. Supported in v5.2+
    ID of the node in the failover cluster.
    """
    id: String!
    """

    Required. Supported in v5.2+
    Name of the node in the failover cluster.
    """
    name: String!
    """

    Supported in v5.3+
    Operating system of the node in the failover cluster.
    """
    operatingSystem: String
}

"Supported in v5.2+"
type FailoverClusterNodeOrder {
    """

    Required. Supported in v5.2+
    ID of the failover cluster node.
    """
    nodeId: String!
    """

    Supported in v5.3+
    The name of the failover cluster node.
    """
    nodeName: String
    """

    Required. Supported in v5.2+
    An integer that specifies the place occupied by this node in the failover cluster app backup order.
    """
    order: Int!
}

"The connection status of a failover cluster."
type FailoverClusterStatus {
    connectivity: FailoverClusterConnectivityStatus!
    timestampMillis: DateTime
}

"Supported in v5.2+"
type FailoverClusterSummary {
    connectionStatus: FailoverClusterConnectionStatusEnum!
    effectiveSlaHolder: EffectiveSlaHolder
    """

    Required. Supported in v5.2+
    ID assigned to the failover cluster.
    """
    id: String!
    """

    Required. Supported in v5.2+
    Cluster name assigned to the failover cluster.
    """
    name: String!
    """

    Required. Supported in v5.2+
    Details of the nodes of this failover cluster.
    """
    nodes: [FailoverClusterNode!]!
    operatingSystemType: FailoverClusterOsTypeEnum
    "Required. Supported in v5.2+"
    primaryClusterId: String!
    slaAssignable: SlaAssignable
    slaAssignment: SlaAssignmentEnum
}

"Paginated list of FailoverClusterTopLevelDescendantType objects."
type FailoverClusterTopLevelDescendantTypeConnection {
    "Total number of FailoverClusterTopLevelDescendantType objects matching the request arguments."
    count: Int!
    "List of FailoverClusterTopLevelDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [FailoverClusterTopLevelDescendantTypeEdge!]!
    "List of FailoverClusterTopLevelDescendantType objects."
    nodes: [FailoverClusterTopLevelDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the FailoverClusterTopLevelDescendantType object. This wrapper is used for pagination."
type FailoverClusterTopLevelDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual FailoverClusterTopLevelDescendantType object wrapped by this edge."
    node: FailoverClusterTopLevelDescendantType!
}

"Paginated list of Failover objects."
type FailoverConnection {
    "Total number of Failover objects matching the request arguments."
    count: Int!
    "List of Failover objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [FailoverEdge!]!
    "List of Failover objects."
    nodes: [Failover!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the Failover object. This wrapper is used for pagination."
type FailoverEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual Failover object wrapped by this edge."
    node: Failover!
}

type FailoverEvent {
    message: String!
    seq: Int!
    startTime: Long!
    status: String!
}

"Appflows failover jobs data with groupby info applied to it."
type FailoverGroupBy {
    "Paginated appflows failover jobs data."
    failoverConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort appflows failover jobs by field"
        sortBy: FailoverSortByEnum = AppBlueprintName,
        "failover jobs sort order"
        sortOrder: SortOrderEnum = Desc
    ): FailoverConnection!
    failoverGroupBy(
        "group appflows failover jobs by a field"
        groupBy: FailoverGroupByEnum!
    ): [FailoverGroupBy!]!
    "The data groupby info."
    groupByInfo: FailoverGroupByInfo!
}

"Paginated list of FailoverGroupBy objects."
type FailoverGroupByConnection {
    "Total number of FailoverGroupBy objects matching the request arguments."
    count: Int!
    "List of FailoverGroupBy objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [FailoverGroupByEdge!]!
    "List of FailoverGroupBy objects."
    nodes: [FailoverGroupBy!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the FailoverGroupBy object. This wrapper is used for pagination."
type FailoverGroupByEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual FailoverGroupBy object wrapped by this edge."
    node: FailoverGroupBy!
}

type FailoverJobReport {
    elapsedTime: Long!
    endTime: Long!
    jobId: String!
    jobType: String!
    progress: Float!
    startTime: Long!
    status: String!
    steps: [FailoverStep!]!
}

"A Recovery Plan failover job status response."
type FailoverJobStatusReply {
    "Recovery Plan job error."
    error: String!
    "Recovery Plan job ID."
    jobId: Long!
    "Recovery Plan ID."
    recoveryPlanId: String!
    "Recovery Plan taskchain ID."
    taskchainId: String!
}

"Failover report."
type FailoverReport {
    expireTime: DateTime!
    id: String!
    reportUrl: String
    "status of the failover report"
    status: AppflowsBlueprintFailoverReportStatusEnum!
}

"All source sites."
type FailoverSource {
    "Source of the snappable associated with this appflows failover job."
    source: String!
}

"Paginated list of FailoverSource objects."
type FailoverSourceConnection {
    "Total number of FailoverSource objects matching the request arguments."
    count: Int!
    "List of FailoverSource objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [FailoverSourceEdge!]!
    "List of FailoverSource objects."
    nodes: [FailoverSource!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the FailoverSource object. This wrapper is used for pagination."
type FailoverSourceEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual FailoverSource object wrapped by this edge."
    node: FailoverSource!
}

type FailoverStatus {
    enumValue: FailoverStatusEnum!
}

type FailoverStep {
    elapsedTime: Long!
    message: String!
    progress: Float!
    seq: Int!
    startTime: Long!
    status: String!
    subSteps: [FailoverSubStep!]!
}

type FailoverSubStep {
    events: [FailoverEvent!]!
    message: String!
    seq: Int!
}

type FailoverTable {
    focus: ReportFocusEnum!
    groupBy: [FailoverGroupByEnum!]
    name: String!
    selectedColumns: [FailoverTableColumnEnum!]!
    sortBy: FailoverSortByEnum
    sortOrder: SortOrderEnum
}

"All target sites."
type FailoverTargetSite {
    "Target site of the appflows failover job."
    targetSite: String!
}

"Paginated list of FailoverTargetSite objects."
type FailoverTargetSiteConnection {
    "Total number of FailoverTargetSite objects matching the request arguments."
    count: Int!
    "List of FailoverTargetSite objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [FailoverTargetSiteEdge!]!
    "List of FailoverTargetSite objects."
    nodes: [FailoverTargetSite!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the FailoverTargetSite object. This wrapper is used for pagination."
type FailoverTargetSiteEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual FailoverTargetSite object wrapped by this edge."
    node: FailoverTargetSite!
}

type FailoverType {
    enumValue: FailoverTypeEnum!
}

"Contains the failure details about RBA connectivity taskchains"
type Failure {
    error: String!
    snappableId: String!
}

"Fake data"
type FakeData {
    data: String!
}

"Paginated list of FakeData objects."
type FakeDataConnection {
    "Total number of FakeData objects matching the request arguments."
    count: Int!
    "List of FakeData objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [FakeDataEdge!]!
    "List of FakeData objects."
    nodes: [FakeData!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the FakeData object. This wrapper is used for pagination."
type FakeDataEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual FakeData object wrapped by this edge."
    node: FakeData!
}

"Feature specific details for a cloud account."
type FeatureDetail {
    "IAM user access key for feature. This field has a non-empty value only for accounts with an IAM user credential provider."
    accessKey: String
    "Details for authentication server-based cloud accounts. This field is only applicable to the accounts in AWS DCA and LCK regions."
    authServerDetail: AwsAuthServerDetail
    "AWS regions. The list will be non-empty for cloud accounts on AWS GovCloud and commercial clouds."
    awsRegions: [AwsCloudAccountRegion!]!
    "Feature enum."
    feature: CloudAccountFeature!
    "Role ARN for feature. This field has a non-empty value only for CFT-based accounts."
    roleArn: String!
    "Stack ARN for feature. This field has a non-empty value only for CFT-based accounts."
    stackArn: String!
    "Feature status for a cloud account."
    status: CloudAccountStatus!
    "User ARN for feature. This field has a non-empty value only for accounts with an IAM user credential provider."
    userArn: String
}

"A flag with a dynamically computed value."
type FeatureFlag {
    "Name of the flag."
    name: FeatureFlagNameEnum!
    "Computed value of this flag."
    variant: String
}

"A collection of all feature flags"
type FeatureFlagAll {
    "List of flags."
    flags: [FeatureFlag!]!
}

"Feature along with permissions serialized in JSON format."
type FeaturePermission {
    "Name of the feature Rubrik provides to the customers. Ex- CLOUD_NATIVE_PROTECTION, CLOUD_NATIVE_ARCHIVAL"
    feature: CloudAccountFeature!
    "The permissions required for supporting the feature given by the feature field."
    permissionJson: String!
    version: Int!
}

type FederatedLoginStatus {
    enabled: Boolean!
    inventoryCardEnabled: Boolean!
}

"Envoy registration token details."
type FetchEnvoyRegTokenReply {
    "Token expiration time in `yyyy-MM-dd'T'HH:mm:ss.SSSZ` format."
    expiration: String!
    "ID of the tenant network to register envoy VMs."
    tenantNetworkId: String!
    "REST API token to access CDM API."
    token: String!
}

type FileAccessResult {
    accessType: ActivityAccessTypeEnum!
    directory: String!
    filename: String!
    nativePath: String!
    numAccesses: Int!
}

"Details of a particular file."
type FileDetails {
    "Name of the file."
    fileName: String!
}

type FileResult {
    analyzerGroupResults: [AnalyzerGroupResult!]!
    analyzerResults: [AnalyzerResult!]!
    directory: String!
    errorCode: AnalyzerErrorCodeEnum!
    filename: String!
    filesWithHits: Hits
    hits: Hits!
    lastAccessTime: Long!
    lastModifiedTime: Long!
    mode: DataGovFileModeEnum!
    nativePath: String!
    numActivities: Long!
    numActivitiesBreakdown: [ActivityResult!]!
    numActivitiesDelta: Long!
    numDescendantErrorFiles: Long!
    numDescendantFiles: Int!
    numDescendantFolders: Long!
    numDescendantSkippedExtFiles: Long!
    numDescendantSkippedSizeFiles: Long!
    openAccessFiles: Hits
    openAccessFilesWithHits: Hits
    openAccessFolders: Hits
    openAccessStaleFiles: Hits
    openAccessType: OpenAccessTypeEnum!
    owner: String!
    paginationId: String!
    size: Long!
    snappable: HierarchyObject!
    snapshotFid: String!
    snapshotTimestamp: Long!
    staleFiles: Hits
    staleFilesWithHits: Hits
    stalenessType: StalenessTypeEnum!
    stdPath: String!
}

"Paginated list of FileResult objects."
type FileResultConnection {
    "Total number of FileResult objects matching the request arguments."
    count: Int!
    "List of FileResult objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [FileResultEdge!]!
    "List of FileResult objects."
    nodes: [FileResult!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the FileResult object. This wrapper is used for pagination."
type FileResultEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual FileResult object wrapped by this edge."
    node: FileResult!
}

"Supported in v5.0+"
type FileVersion {
    """

    Supported in v5.0+
    The type of file, either a regular file or a directory.
    """
    fileMode: String
    "Supported in v5.0+"
    lastModified: String
    "Supported in v5.0+"
    size: Long
    """

    Supported in v5.0+
    The snapshot this file belongs to.
    """
    snapshotId: String
    """

    Supported in v5.0+
    The location where the file is stored, either in the cloud or locally.
    """
    source: String
}

"Supported in v5.0+"
type FilesetArraySpec {
    """

    Supported in v5.0+
    ID assigned to a proxy host for array-enabled backups. This property is only required for array-enabled backups.
    """
    proxyHostId: String
}

"Supported in v5.0+"
type FilesetDetail {
    "Supported in v5.0+"
    archiveStorage: Long
    "Supported in v5.0+"
    archivedSnapshotCount: Int
    """

    Supported in v5.0+
    Action taken if script fails. Options are "abort", "continue".
    """
    backupScriptErrorHandling: String
    """

    Supported in v5.0+
    Number of seconds after which the script is killed if it has not completed execution.
    """
    backupScriptTimeout: Long
    filesetSummary: FilesetSummary
    filesetUpdate: FilesetUpdate
    "Supported in v5.0+"
    localStorage: Long
    """

    Supported in v5.0+
    Script to run after backup of this Fileset ends.
    """
    postBackupScript: String
    """

    Supported in v5.0+
    Script to run before backup of this Fileset starts.
    """
    preBackupScript: String
    "Supported in v5.0+"
    protectionDate: DateTime
    "Required. Supported in v5.0+"
    snapshotCount: Int!
    "Supported in v5.0+"
    snapshots: [FilesetSnapshotSummary!]!
}

"Supported in v5.0+"
type FilesetDetailListResponse {
    """

    Supported in v5.0+
    List of matching objects.
    """
    data: [FilesetDetail!]!
    """

    Supported in v5.0+
    If there is more.
    """
    hasMore: Boolean
    """

    Supported in v5.0+
    Total list responses.
    """
    total: Long
}

"Supported in v5.0+"
type FilesetOptions {
    """

    Supported in v5.0+
    Include or exclude hidden folders inside locally-mounted remote file systems from backups.
    """
    allowBackupHiddenFoldersInNetworkMounts: Boolean
    """

    Supported in v5.0+
    Include or exclude locally-mounted remote file systems from backups.
    """
    allowBackupNetworkMounts: Boolean
    """

    Supported in v5.0+
    Use VSS during Windows backups.
    """
    useWindowsVss: Boolean
}

"Supported in v5.0+"
type FilesetSnapshotDetail {
    filesetSnapshotSummary: FilesetSnapshotSummary
    "Required. Supported in v5.0+"
    lastModified: String!
    "Required. Supported in v5.0+"
    size: Long!
    "Supported in v5.0+"
    verbose: FilesetSnapshotVerbose
}

"Supported in v5.0+"
type FilesetSnapshotSummary {
    baseSnapshotSummary: BaseSnapshotSummary
    "Supported in v5.0+"
    fileCount: Long
    "Required. Supported in v5.0+"
    filesetName: String!
    "Supported in v5.1+"
    snapdiffUsed: Boolean
}

"Supported in v5.0+"
type FilesetSnapshotVerbose {
    """

    Required. Supported in v5.0+
    Whether or not the fileset snapshot has fingerprint info.
    """
    hasFingerprint: Boolean!
    """

    Required. Supported in v5.0+
    List a partition paths for the fileset snapshot.
    """
    partitionPaths: [String!]!
}

"Supported in v5.0+"
type FilesetSummary {
    "Supported in v5.0+"
    arraySpec: FilesetArraySpec
    """

    Supported in v5.0+
    v5.0: The ID of the effective SLA domain for this Fileset
    v5.1+: The ID of the effective SLA Domain for this fileset.
    """
    effectiveSlaDomainId: String
    """

    Supported in v5.0+
    v5.0: The name of the effective SLA domain for this Fileset
    v5.1+: The name of the effective SLA Domain for this fileset.
    """
    effectiveSlaDomainName: String
    """

    Supported in v5.0+
    v5.0: Optional field containing Polaris managed id of the effective SLA domain if it is Polaris managed.
    v5.1+: Optional field containing Polaris managed ID of the effective SLA domain if it is Polaris managed.
    """
    effectiveSlaDomainPolarisManagedId: String
    """

    Supported in v5.1+
    A Boolean value that determines whether to recognize and dedupe hardlinks in a fileset. When 'true,' performs a hardlink deduplication. When 'false,' performs a normal backup that treats hardlinks as normal files. If not specified, this defaults to false.
    """
    enableHardlinkSupport: Boolean
    """

    Supported in v5.1+
    A Boolean value that determines whether to resolve symlink in a fileset. When 'true,' performs a symlink resolution. When 'false,' performs no symlink resolution. If not specified, this defaults to false.
    """
    enableSymlinkResolution: Boolean
    "Supported in v5.0+"
    exceptions: [String!]!
    "Supported in v5.0+"
    excludes: [String!]!
    """

    Supported in v5.2+
    ID of the failover cluster app.
    """
    failoverClusterAppId: String
    """

    Supported in v5.3+
    The name of the failover cluster app.
    """
    failoverClusterAppName: String
    filesetOptions: FilesetOptions
    "Supported in v5.0+"
    hostId: String
    "Required. Supported in v5.0+"
    hostName: String!
    "Required. Supported in v5.0+"
    includes: [String!]!
    """

    Supported in v5.1+
    An optional Boolean value that specifies whether the effective SLA Domain of a fileset is Retention Locked. When this value is 'true,' the SLA Domain is retention locked. When this value is 'false,' the SLA Domain is not Retention Locked.
    """
    isEffectiveSlaDomainRetentionLocked: Boolean
    """

    Supported in v5.0+
    v5.0: A Boolean value that determines whether to take a direct archive backup. When 'true,' performs a direct archive backup. When 'false,' performs a normal backup.
    v5.1+: A Boolean value that determines whether to take a direct archive backup. When 'true,' performs a direct archive backup. When 'false,' performs a normal backup. If not specified, this defaults to false.
    """
    isPassthrough: Boolean
    "Required. Supported in v5.0+"
    isRelic: Boolean!
    "Supported in v5.0+"
    operatingSystemType: String
    """

    Supported in v5.2+
    v5.2: Describes any pending SLA Domain assignment to this object.
    v5.3+: Describes any pending SLA Domain assignment on this object.
    """
    pendingSlaDomain: ManagedObjectPendingSlaInfo
    "Supported in v5.0+"
    shareId: String
    slaAssignable: SlaAssignable
    """

    Supported in v5.3+
    Rubrik CDM uses a prefix match to select the latest SnapMirror snapshot that matches this value during a full backup of a SnapMirror destination share.
    """
    snapMirrorLabelForFullBackup: String
    """

    Supported in v5.3+
    Rubrik CDM selects the latest SnapMirror snapshot that matches this value using a prefix match during an incremental backup of a SnapMirror destination share.
    """
    snapMirrorLabelForIncrementalBackup: String
    "Required. Supported in v5.0+"
    templateId: String!
    "Required. Supported in v5.0+"
    templateName: String!
}

type FilesetTemplate implements CdmHierarchyObject & HierarchyObject {
    allowBackupHiddenFoldersInNetworkMounts: Boolean!
    allowBackupNetworkMounts: Boolean!
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    backupScriptErrorHandling: String!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): FilesetTemplateDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    exceptions: [String!]!
    excludes: [String!]!
    "The fid of the hierarchy object."
    id: UUID!
    includes: [String!]!
    isArrayEnabled: Boolean!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    osType: FilesetOSType!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "List of physical children"
    physicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): FilesetTemplatePhysicalChildTypeConnection!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    postBackupScript: String!
    preBackupScript: String!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "Share type of this fileset template"
    shareType: ShareTypeEnum!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"Paginated list of FilesetTemplate objects."
type FilesetTemplateConnection {
    "Total number of FilesetTemplate objects matching the request arguments."
    count: Int!
    "List of FilesetTemplate objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [FilesetTemplateEdge!]!
    "List of FilesetTemplate objects."
    nodes: [FilesetTemplate!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Supported in v5.0+"
type FilesetTemplateCreate {
    """

    Supported in v5.0+
    Action taken if script fails. Options are "abort", "continue".
    """
    backupScriptErrorHandling: String
    """

    Supported in v5.0+
    Number of seconds after which the script is killed if it has not completed execution.
    """
    backupScriptTimeout: Long
    "Supported in v5.0+"
    exceptions: [String!]!
    "Supported in v5.0+"
    excludes: [String!]!
    filesetOptions: FilesetOptions
    "Required. Supported in v5.0+"
    includes: [String!]!
    """

    Supported in v5.0+
    Boolean value that determines whether the fileset is array-enabled. Set to true to indicate that the fileset is array-enabled. Set to false to indicate that the fileset is not array-enabled. When a fileset is array-enabled, the includes must be top-level LVM logical volume mount points.
    """
    isArrayEnabled: Boolean
    """

    Supported in v7.0+
    Specifies whether this is created by a Kupr Host.
    """
    isCreatedByKupr: Boolean
    """

    Supported in v7.0+
    Specifies whether the template was created for Polaris NAS.
    """
    isCreatedByPolarisNas: Boolean
    "Required. Supported in v5.0+"
    name: String!
    operatingSystemType: FilesetTemplateCreateOperatingSystemTypeEnum
    """

    Supported in v5.0+
    Script to run after backup of this fileset ends.
    """
    postBackupScript: String
    """

    Supported in v5.0+
    Script to run before backup of this fileset starts.
    """
    preBackupScript: String
    shareType: FilesetTemplateCreateShareTypeEnum
}

"Paginated list of FilesetTemplateDescendantType objects."
type FilesetTemplateDescendantTypeConnection {
    "Total number of FilesetTemplateDescendantType objects matching the request arguments."
    count: Int!
    "List of FilesetTemplateDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [FilesetTemplateDescendantTypeEdge!]!
    "List of FilesetTemplateDescendantType objects."
    nodes: [FilesetTemplateDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the FilesetTemplateDescendantType object. This wrapper is used for pagination."
type FilesetTemplateDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual FilesetTemplateDescendantType object wrapped by this edge."
    node: FilesetTemplateDescendantType!
}

"Supported in v5.0+"
type FilesetTemplateDetail {
    filesetTemplateCreate: FilesetTemplateCreate
    """

    Supported in v5.0+
    Number of hosts where this template has been applied.
    """
    hostCount: Int
    "Required. Supported in v5.0+"
    id: String!
    "Supported in v5.0+"
    isArchived: Boolean
    """

    Supported in v6.0
    Specifies whether this is created by a Kupr Host.
    """
    isCreatedByKupr: Boolean
    "Required. Supported in v5.0+"
    primaryClusterId: String!
    """

    Supported in v5.0+
    Number of shares where this template has been applied.
    """
    shareCount: Int
}

"Supported in v5.0+"
type FilesetTemplateDetailListResponse {
    """

    Supported in v5.0+
    List of matching objects.
    """
    data: [FilesetTemplateDetail!]!
    """

    Supported in v5.0+
    If there is more.
    """
    hasMore: Boolean
    """

    Supported in v5.0+
    Total list responses.
    """
    total: Long
}

"Wrapper around the FilesetTemplate object. This wrapper is used for pagination."
type FilesetTemplateEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual FilesetTemplate object wrapped by this edge."
    node: FilesetTemplate!
}

"Paginated list of FilesetTemplatePhysicalChildType objects."
type FilesetTemplatePhysicalChildTypeConnection {
    "Total number of FilesetTemplatePhysicalChildType objects matching the request arguments."
    count: Int!
    "List of FilesetTemplatePhysicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [FilesetTemplatePhysicalChildTypeEdge!]!
    "List of FilesetTemplatePhysicalChildType objects."
    nodes: [FilesetTemplatePhysicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the FilesetTemplatePhysicalChildType object. This wrapper is used for pagination."
type FilesetTemplatePhysicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual FilesetTemplatePhysicalChildType object wrapped by this edge."
    node: FilesetTemplatePhysicalChildType!
}

"Supported in v5.0+"
type FilesetUpdate {
    """

    Supported in v5.0+
    v5.0-v5.1: Assign Fileset to SLA domain
    v5.2+: Assign Fileset to SLA domain. Existing snapshots of the object will be retained with the configuration of specified SLA Domain.
    """
    configuredSlaDomainId: String
    """

    Supported in v5.2+
    Whether to force a full on the whole fileset or certain partitions of the fileset. If this is set to true and no partitionIds are provided, then a full will be forced on the whole fileset. If set to true and partitionIds are provided, then we will force a full on only those partitions.
    """
    forceFull: Boolean
    """

    Supported in v5.2+
    Assign partition ids to set the force full. In order for this to be valid input, forceFull must be set to true.
    """
    forceFullPartitionIds: [Int!]!
    """

    Supported in v5.3+
    Rubrik CDM uses a prefix match to select the latest SnapMirror snapshot that matches this value during a full backup of a SnapMirror destination share.
    """
    snapMirrorLabelForFullBackup: String
    """

    Supported in v5.3+
    Rubrik CDM selects the latest SnapMirror snapshot that matches this value using a prefix match during an incremental backup of a SnapMirror destination share.
    """
    snapMirrorLabelForIncrementalBackup: String
}

type FilterOption {
    displayValue: String!
    value: String
}

"Process delete of aws cloud account."
type FinalizeAwsCloudAccountDeletionReply {
    "Contains success response message."
    message: String
}

"Response for the operation to finalize protection for AWS cloud accounts."
type FinalizeAwsCloudAccountProtectionReply {
    "Contains success response message."
    awsChildAccounts: [AwsCloudAccount!]!
    "Contains success response message."
    message: String
}

"Detail of the Gcp Cloud Account Add operations."
type GcpCloudAccountAddProjectDetail {
    error: String!
    projectId: String!
    uuid: String!
}

"Gcp Cloud Account Add Projects Response."
type GcpCloudAccountAddProjectsReply {
    "GCP cloud account add projects details."
    details: [GcpCloudAccountAddProjectDetail!]!
}

"Details of the Gcp Cloud Account feature."
type GcpCloudAccountFeatureDetail {
    feature: CloudAccountFeature!
    status: CloudAccountStatus!
}

"List of permissions missing for project addition for projects ineligible for addition."
type GcpCloudAccountMissingPermissionsForAddition {
    missingPermissions: [String!]!
    projectId: String!
}

"Gcp Cloud Account OAuth Complete Response."
type GcpCloudAccountOAuthCompleteResponse {
    userInfo: GcpOAuthUserInfo
}

"Gcp Cloud Account OAuth Initiate Response."
type GcpCloudAccountOAuthInitiateResponse {
    clientId: String!
    redirectUrl: String!
    scope: [String!]!
    sessionId: String!
    state: String!
}

"GCP Cloud Account Project."
type GcpCloudAccountProject {
    "Rubrik ID of the GCP project."
    id: String!
    "Name of the GCP project."
    name: String!
    "The name of the organization containing the GCP Project."
    organizationName: String!
    "Native ID of the GCP Project."
    projectId: String!
    "Native Project Number of the GCP Project."
    projectNumber: Long!
    roleId: String!
    "Whether the GCP project uses global configuration for authentication."
    usesGlobalConfig: Boolean!
}

"Status of the Gcp Cloud Account delete operation."
type GcpCloudAccountProjectDeleteStatus {
    error: String!
    projectUuid: String!
    success: Boolean!
}

"Details of the Gcp Cloud Account project configured for a feature."
type GcpCloudAccountProjectDetail {
    featureDetail: GcpCloudAccountFeatureDetail
    project: GcpCloudAccountProject
}

"Status of the Gcp Cloud Account upgrade operation."
type GcpCloudAccountProjectUpgradeStatus {
    error: String!
    projectUuid: String!
    success: Boolean!
}

"Gcp List Projects For OAuth Response"
type GcpListProjectsForOAuthResponse {
    missingPermissions: [String!]
    name: String!
    projectId: String!
}

"Represents the attachment details of a GCP native disk "
type GcpNativeAttachmentDetails {
    deviceName: String!
    diskID: String!
    diskName: String!
    instanceID: String!
    instanceName: String!
    instanceZone: String!
    isBootDisk: Boolean!
    isExcluded: Boolean!
    sizeInGBs: Int!
}

type GcpNativeDisk implements GcpNativeProjectDescendantType & GcpNativeProjectLogicalChildType & HierarchyObject & PolarisHierarchyObject & PolarisHierarchySnappable {
    "Instances to which the disk is attached"
    attachedInstances: [GcpNativeAttachmentDetails!]!
    "The authorized operations on the object."
    authorizedOperations: [PolarisSnappableAuthorizedOperationsEnum!]!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    diskID: String!
    diskName: String!
    diskType: String!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "GCP Project of the Disk"
    gcpNativeProject: GcpNativeProject!
    "The fid of the hierarchy object."
    id: UUID!
    isRelic: Boolean!
    kmsKey: String!
    labels: [Label!]!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: PolarisSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: PolarisSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    projectId: String!
    region: String!
    replicaZones: [String!]!
    sizeInGBs: Int!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this workload."
    snapshotsOfSnappableConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Whether to ignore the active protected object check."
        ignoreActiveSnappableCheck: Boolean,
        "Returns the last n elements from the list."
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
    zone: String!
}

"Paginated list of GcpNativeDisk objects."
type GcpNativeDiskConnection {
    "Total number of GcpNativeDisk objects matching the request arguments."
    count: Int!
    "List of GcpNativeDisk objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [GcpNativeDiskEdge!]!
    "List of GcpNativeDisk objects."
    nodes: [GcpNativeDisk!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the GcpNativeDisk object. This wrapper is used for pagination."
type GcpNativeDiskEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual GcpNativeDisk object wrapped by this edge."
    node: GcpNativeDisk!
}

"Represents a GCP native firewall rule"
type GcpNativeFirewallRule {
    name: String!
    targetTags: [String!]!
}

type GcpNativeGCEInstance implements GcpNativeProjectDescendantType & GcpNativeProjectLogicalChildType & HierarchyObject & PolarisHierarchyObject & PolarisHierarchySnappable {
    "Attached disks"
    attachedDisks: [GcpNativeAttachmentDetails!]!
    "The authorized operations on the object."
    authorizedOperations: [PolarisSnappableAuthorizedOperationsEnum!]!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "GCP Project of the GCE Instance"
    gcpNativeProject: GcpNativeProject!
    "The fid of the hierarchy object."
    id: UUID!
    isRelic: Boolean!
    labels: [Label!]!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    machineType: String!
    "The name of the hierarchy object."
    name: String!
    nativeId: String!
    nativeName: String!
    networkHostProjectNativeId: String!
    "The newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: PolarisSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: PolarisSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    projectId: String!
    region: String!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this workload."
    snapshotsOfSnappableConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Whether to ignore the active protected object check."
        ignoreActiveSnappableCheck: Boolean,
        "Returns the last n elements from the list."
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
    vpcName: String!
    zone: String!
}

"Paginated list of GcpNativeGCEInstance objects."
type GcpNativeGCEInstanceConnection {
    "Total number of GcpNativeGCEInstance objects matching the request arguments."
    count: Int!
    "List of GcpNativeGCEInstance objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [GcpNativeGCEInstanceEdge!]!
    "List of GcpNativeGCEInstance objects."
    nodes: [GcpNativeGCEInstance!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the GcpNativeGCEInstance object. This wrapper is used for pagination."
type GcpNativeGCEInstanceEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual GcpNativeGCEInstance object wrapped by this edge."
    node: GcpNativeGCEInstance!
}

"Represents a GCP native VPC network"
type GcpNativeNetwork {
    firewallRules: [GcpNativeFirewallRule!]!
    name: String!
    nativeProjectId: String!
    subnetworks: [GcpNativeSubnetwork!]!
}

type GcpNativeProject implements HierarchyObject & PolarisHierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [PolarisObjectAuthorizedOperationsEnum!]!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    diskCount: Int!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "List of all GCE instances under this GCP project"
    gcpNativeGceInstanceConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        gceInstanceFilters: GcpNativeGceInstanceFilters,
        "Returns the last n elements from the list."
        last: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): GcpNativeGCEInstanceConnection!
    "The fid of the hierarchy object."
    id: UUID!
    lastRefreshedAt: DateTime
    "List of logical children"
    logicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): GcpNativeProjectLogicalChildTypeConnection!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    nativeId: String!
    nativeName: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    organizationName: String!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    projectNumber: String!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    status: GcpNativeProjectStatusEnum!
    vmCount: Int!
}

"Paginated list of GcpNativeProject objects."
type GcpNativeProjectConnection {
    "Total number of GcpNativeProject objects matching the request arguments."
    count: Int!
    "List of GcpNativeProject objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [GcpNativeProjectEdge!]!
    "List of GcpNativeProject objects."
    nodes: [GcpNativeProject!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the GcpNativeProject object. This wrapper is used for pagination."
type GcpNativeProjectEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual GcpNativeProject object wrapped by this edge."
    node: GcpNativeProject!
}

"Paginated list of GcpNativeProjectLogicalChildType objects."
type GcpNativeProjectLogicalChildTypeConnection {
    "Total number of GcpNativeProjectLogicalChildType objects matching the request arguments."
    count: Int!
    "List of GcpNativeProjectLogicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [GcpNativeProjectLogicalChildTypeEdge!]!
    "List of GcpNativeProjectLogicalChildType objects."
    nodes: [GcpNativeProjectLogicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the GcpNativeProjectLogicalChildType object. This wrapper is used for pagination."
type GcpNativeProjectLogicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual GcpNativeProjectLogicalChildType object wrapped by this edge."
    node: GcpNativeProjectLogicalChildType!
}

"Represents a GCP native region."
type GcpNativeRegion {
    name: String!
    zones: [String!]!
}

"Represents a GCP native subnetwork"
type GcpNativeSubnetwork {
    name: String!
    region: String!
}

type GcpOAuthUserInfo {
    domain: String!
    emailId: String!
    firstName: String!
}

type GcpPermission {
    permission: String!
}

"TOTP secret for a user."
type GenerateTotpSecretReply {
    "TOTP secret key."
    secret: String!
    "TOTP secret URI."
    secretUri: String!
}

"Paginated list of GenericSnapshot objects."
type GenericSnapshotConnection {
    "Total number of GenericSnapshot objects matching the request arguments."
    count: Int!
    "List of GenericSnapshot objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [GenericSnapshotEdge!]!
    "List of GenericSnapshot objects."
    nodes: [GenericSnapshot!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the GenericSnapshot object. This wrapper is used for pagination."
type GenericSnapshotEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual GenericSnapshot object wrapped by this edge."
    node: GenericSnapshot!
}

type GenericTimeRange {
    absoluteTimeRange: TimeRange
    relativeTimeRange: RelativeTimeRange
}

type GeoLocation {
    address: String!
    latitude: Float!
    longitude: Float!
}

type GetAppBlueprintOngoingFailoverTaskchainUuidsRsp {
    taskchains: [TaskchainInfo!]!
}

type GetAppBlueprintSnapshotCloudImagesRsp {
    snapshotCloudImages: [AppBlueprintSnapshotCloudImage!]!
}

type GetAzureHostTypeResp {
    hostType: AzureHostType!
}

type GetAzureO365ExocomputeResp {
    cluster: AzureO365ExocomputeCluster
}

"It contains the list of all label rules visible to the user"
type GetCloudNativeLabelRulesReply {
    labelRules: [LabelRule!]!
}

"It contains the list of all tag rules visible to the user"
type GetCloudNativeTagRulesReply {
    tagRules: [CloudNativeTagRule!]!
}

type GetDashboardSummaryReply {
    analyzerResults: [AnalyzerResult!]!
    policyResults: [AnalyzerGroupResult!]!
}

"get implicitly authorized ancestors response"
type GetImplicitlyAuthorizedAncestorSummariesResponse {
    objectSummaries: [ObjectSummary!]!
}

"get implicitly authorized objects response"
type GetImplicitlyAuthorizedObjectSummariesResponse {
    objectSummaries: [ObjectSummary!]!
}

"Lambda configuration details of given cluster"
type GetLambdaConfigReply {
    accountId: String!
    clusterId: String!
    defaultDiffFmdUploadPrefix: String!
    enableAutomaticFmdUpload: Boolean!
    enableFmdUploadForAllResources: Boolean!
    maxSnapshotsToUploadAutomatically: Int!
}

"Reply Object for GetLambdaMalwareScanDetail."
type GetLambdaMalwareScanDetailReply {
    output: MalwareScanDetail
}

"MFA settings for an account."
type GetMfaSettingReply {
    "Boolean value indicating whether TOTP is globally enforced."
    isTotpEnforcedGlobal: Boolean!
    "Boolean value indicating whether TOTP global enforcement is locked."
    isTotpGlobalEnforceLocked: Boolean!
    "Integer value indicating the time of remembering the MFA login in hours."
    mfaRememberHours: Int!
    "Integer value indicating the period of showing TOTP configuration reminder in hours."
    totpReminderHours: Int!
}

"Supported in m3.2.0-m4.1.0"
type GetMosaicRecoverableRangeResponse {
    """

    Supported in m3.2.0-m4.1.0
    Object with details of Any Point In Time restore Range
    """
    data: MosaicRecoverableRangeObject
    """

    Supported in m3.2.0-m4.1.0
    Response Message string
    """
    message: String
    """

    Supported in m3.2.0-m4.1.0
    Return Code
    """
    returnCode: Long
    """

    Supported in m3.2.0-m4.1.0
    Status of the request
    """
    status: Boolean
}

type GetO365ServiceStatusResp {
    lastUpdated: DateTime
    status: O365ServiceStatusIndication!
}

type GetO365StorageStatsResp {
    dailyGrowthInBytes: Long!
    estimatedThirtyDaysStorageInBytes: Long!
    liveDataSizeInBytes: Long!
    physicalDataSizeInBytes: Long!
    physicalDataSizeTimeSeries: [O365PhysicalDataSizeTimeStamp!]!
    storageEfficiencyPercent: Long!
}

"Get the health metric for the radar pipeline covering the backup, indexing, and analysis jobs"
type GetPipelineHealthReply {
    failedAnalysis: Long!
    failedBackup: Long!
    failedIndexing: Long!
    totalAnalysis: Long!
    totalBackup: Long!
    totalIndexing: Long!
}

type GetPoliciesTimelineReply {
    policyFilesHitsEntries: [TimelineEntry!]!
    policyHitsEntries: [TimelineEntry!]!
    policyOaFilesHitsEntries: [TimelineEntry!]!
    policyStaleFilesHitsEntries: [TimelineEntry!]!
    policySummaries: [ClassificationPolicySummary!]!
    totalFilesHitsEntries: [TimelineEntry!]!
    totalHitsEntries: [TimelineEntry!]!
    totalOaFilesEntries: [TimelineEntry!]!
    totalOaFilesHitsEntries: [TimelineEntry!]!
    totalOaFoldersEntries: [TimelineEntry!]!
    totalStaleFilesHitsEntries: [TimelineEntry!]!
    totalStaleOaFilesEntries: [TimelineEntry!]!
}

type GetSMTPConfigurationReply {
    defaultFromEmail: String!
    hostname: String!
    isValid: Boolean!
    port: Int!
    securityType: SMTPSecurityTypeEnum!
    trustedCerts: String!
    username: String!
}

type GetSPExplicitReply {
    applicationCallbackUrl: String!
    encryptionCertificate: String!
    signingCertificate: String!
    spEntityId: String!
}

"Supported in m3.2.0-m4.1.0"
type GetSchemaResponse {
    """

    Supported in m3.2.0-m4.1.0
    Object with schema details
    """
    data: CassandraSchemaObject
    """

    Supported in m3.2.0-m4.1.0
    Response Message string
    """
    message: String
    """

    Supported in m3.2.0-m4.1.0
    Return Code
    """
    returnCode: Long
    """

    Supported in m3.2.0-m4.1.0
    Status of the request
    """
    status: Boolean
}

"Get radar alert enablment for a snappable"
type GetSnappableAlertSettingReply {
    enabled: Boolean!
}

type GetSyslogConfigurationReply {
    conf: [SyslogConfig!]!
}

"Taskchain info reply"
type GetTaskchainInfoReply {
    account: String!
    endTime: DateTime
    error: String!
    jobId: Long!
    jobType: String!
    progress: Long!
    startTime: DateTime
    state: TaskchainStateEnum!
    taskchainId: String!
}

"Taskchain status reply"
type GetTaskchainStatusReply {
    taskchain: Taskchain
}

"TOTP status for a user."
type GetTotpStatusReply {
    "TOTP as 2FA is enabled."
    isEnabled: Boolean!
    "TOTP as 2FA is enforced."
    isEnforced: Boolean!
    isEnforcedUserLevel: Boolean!
    "Whether TOTP is supported for the user."
    isSupported: Boolean!
    "Timestamp of last TOTP configuration update."
    totpConfigUpdateAt: DateTime
    "Integer value indicating the period of showing TOTP configuration reminder in hours."
    totpReminderHours: Int!
}

type GetUserDetailReply {
    location: String!
    name: String!
    numFilesAccessible: Int!
    risk: RiskLevelTypeEnum!
}

"Get IP whitelist configuration"
type GetWhitelistReply {
    enabled: Boolean!
    ipCidrs: [String!]!
    mode: WhitelistModeEnum!
}

"Global manager connectivity status."
type GlobalManagerConnectivity {
    "URLs pinged to check connectivity."
    urls: [GlobalManagerUrl!]!
}

"URLs pinged to check connectivity."
type GlobalManagerUrl {
    "Whether or not the URL check has passed."
    isReachable: Boolean!
    "URL pinged to check connectivity."
    url: String!
}

"Supported in v5.1+"
type GlobalSearchApiResponse {
    """

    Required. Supported in v5.1+
    List of directories containing the file.
    """
    dirs: [String!]!
    """

    Required. Supported in v5.1+
    Filename of the file.
    """
    filename: String!
    """

    Required. Supported in v5.1+
    True if the returned path is not a directory.
    """
    isFile: Boolean!
    """

    Supported in v7.0+
    Last time, in seconds, this file was modified since epoch.
    """
    modifiedTime: Long
    """

    Supported in v7.0+
    Number of snapshots containing the file.
    """
    numSnapshots: Int
    """

    Supported in v7.0+
    Size, in bytes, of the file.
    """
    sizeInBytes: Long
    """

    Required. Supported in v5.1+
    Managed ID of the snappable containing the file.
    """
    snappableId: String!
    """

    Required. Supported in v5.1+
    Name of the snappable containing the file.
    """
    snappableName: String!
    """

    Supported in v7.0+
    Time latest, in milliseconds, snapshot was taken with this file since epoch.
    """
    snapshotTime: Long
}

"Supported in v5.1+"
type GlobalSearchApiResponseListResponse {
    """

    Supported in v5.1+
    List of matching objects.
    """
    data: [GlobalSearchApiResponse!]!
    """

    Supported in v5.1+
    If there is more.
    """
    hasMore: Boolean
    """

    Supported in v5.1+
    Total list responses.
    """
    total: Long
}

"Metadata for rendering a global sla."
type GlobalSla implements SlaDomain {
    archivalSpec: ArchivalSpec
    archivalSpecs: [ArchivalSpec!]!
    backupWindows: [BackupWindow!]!
    baseFrequency: Duration
    "Cascading archival specification."
    cascadingArchivalSpecs: [CascadingArchivalSpec!]!
    clusterToSyncStatusMap: [PolarisSlaSyncStatus!]!
    clusterUuid: String!
    description: String!
    firstFullBackupWindows: [BackupWindow!]!
    id: String!
    isArchived: Boolean!
    isDefault: Boolean!
    localRetentionLimit: Duration
    logConfig: LogConfigResult
    name: String!
    objectSpecificConfigs: ObjectSpecificConfigs
    objectTypes: [SLAObjectTypeEnum!]!
    "Information about Rubrik clusters where this SLA Domain is paused."
    pausedClustersInfo: PausedClustersInfo
    protectedObjectCount: Int!
    replicationSpec: ReplicationSpec
    replicationSpecsV2: [ReplicationSpecV2!]!
    snapshotSchedule: SnapshotSchedule
    snapshotScheduleLastUpdatedAt: DateTime
    stateVersion: Long!
    uiColor: String!
    "SLA Domain upgrade information."
    upgradeInfo: SlaUpgradeInfo
    version: String
}

"Metadata for rendering a sla for filter."
type GlobalSlaForFilter {
    id: String!
    name: String!
}

"Paginated list of GlobalSlaForFilter objects."
type GlobalSlaForFilterConnection {
    "Total number of GlobalSlaForFilter objects matching the request arguments."
    count: Int!
    "List of GlobalSlaForFilter objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [GlobalSlaForFilterEdge!]!
    "List of GlobalSlaForFilter objects."
    nodes: [GlobalSlaForFilter!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the GlobalSlaForFilter object. This wrapper is used for pagination."
type GlobalSlaForFilterEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual GlobalSlaForFilter object wrapped by this edge."
    node: GlobalSlaForFilter!
}

type Group {
    groupId: String!
    roles: [Role!]!
    users: [User!]!
}

type GroupCount {
    count: Int!
    group: String!
}

type GroupCountListWithTotal {
    groupList: [GroupCount!]!
    totalCount: Int!
}

"Supported in v5.0+"
type GuestCredentialDetail {
    baseGuestCredentialDetail: BaseGuestCredentialDetail
    "Supported in v5.0+"
    domain: String
    "Required. Supported in v5.0+"
    id: String!
}

"Supported in v5.0+"
type GuestCredentialDetailListResponse {
    """

    Supported in v5.0+
    List of matching objects.
    """
    data: [GuestCredentialDetail!]!
    """

    Supported in v5.0+
    If there is more.
    """
    hasMore: Boolean
    """

    Supported in v5.0+
    Total list responses.
    """
    total: Long
}

"Supported in v6.0+"
type HashDetail {
    """

    Required. Supported in v6.0+
    Hash algorithm type.
    """
    hashType: String!
    """

    Required. Supported in v6.0+
    Hash value of the content at path.
    """
    hashValue: String!
}

"Supported in v5.2+"
type HdfsBaseConfig {
    """

    Supported in v5.2+
    API token to access Hdfs.
    """
    apiToken: String
    """

    Required. Supported in v5.2+
    List of Hdfs Namenode Hosts.
    """
    hosts: [HdfsHost!]!
    """

    Supported in v5.2+
    Ticket Cache Path of Kerberos Ticket.
    """
    kerberosTicket: String
    """

    Supported in v5.2+
    Logical name for nameservice for Hdfs HA.
    """
    nameservices: String
    """

    Supported in v5.2+
    Username to access Hdfs API.
    """
    username: String
}

"Supported in v5.2+"
type HdfsHost {
    """

    Required. Supported in v5.2+
    Hostname or Ip of Namenode.
    """
    hostname: String!
    """

    Required. Supported in v5.2+
    Port number of Namenode.
    """
    port: Int!
}

"Paginated list of HierarchyObject objects."
type HierarchyObjectConnection {
    "Total number of HierarchyObject objects matching the request arguments."
    count: Int!
    "List of HierarchyObject objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [HierarchyObjectEdge!]!
    "List of HierarchyObject objects."
    nodes: [HierarchyObject!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the HierarchyObject object. This wrapper is used for pagination."
type HierarchyObjectEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual HierarchyObject object wrapped by this edge."
    node: HierarchyObject!
}

"Paginated list of HierarchySnappable objects."
type HierarchySnappableConnection {
    "Total number of HierarchySnappable objects matching the request arguments."
    count: Int!
    "List of HierarchySnappable objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [HierarchySnappableEdge!]!
    "List of HierarchySnappable objects."
    nodes: [HierarchySnappable!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the HierarchySnappable object. This wrapper is used for pagination."
type HierarchySnappableEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual HierarchySnappable object wrapped by this edge."
    node: HierarchySnappable!
}

type HierarchySnappableFileVersion {
    fileMode: FileModeEnum!
    lastModified: DateTime!
    size: Long!
    snapshot: CdmSnapshot
    snapshotId: String!
    source: FileVersionSourceEnum!
}

type Hits {
    permittedHits: Int!
    permittedHitsDelta: Int!
    totalHits: Int!
    totalHitsDelta: Int!
    violations: Int!
    violationsDelta: Int!
}

"The connection status of a host"
type HostConnectionStatus {
    connectivity: HostConnectivityStatusEnum!
    timestampMillis: DateTime
}

"Supported in v5.0+"
type HostConnectivitySummary {
    "Required. Supported in v5.0+"
    action: String!
    "Required. Supported in v5.0+"
    status: String!
}

"Supported in v5.0+"
type HostDetail {
    """

    Supported in v5.0+
    v5.0-v5.2:
    v5.3+: ID of the Rubrik Backup Service (RBS) installed on the host.
    """
    agentId: String
    """

    Supported in v5.0+
    v5.0-v5.2:
    v5.3+: Indicates if compression is enabled while transferring data between the host and the Rubrik cluster.
    """
    compressionEnabled: Boolean
    hostSummary: HostSummary
    hostVfdDriverState: HostVfdStateEnum!
    hostVfdEnabled: HostVfdInstallConfigEnum
    """

    Supported in v5.2+
    v5.2: Specifies whether the host is an Oracle host. When the host is an Oracle host, the UI displays the Oracle discovery fields.
    v5.3: Specifies whether this is an Oracle host. This indicates whether to show Oracle discovery fields in the UI.
    v6.0+: Specifies whether this is an Oracle host. This indicates whether to show Oracle discovery fields in the UI.
    """
    isOracleHost: Boolean
    """

    Required. Supported in v5.0+
    A relic host is deleted, but still may have snapshots associated with its children (e.g. Fileset).
    """
    isRelic: Boolean!
    """

    Required. Supported in v5.0+
    v5.0-v5.2: Boolean value that indicates whether the CBT driver is installed for SQL Server instances on the specified Windows host. Set to true when the CBT driver is installed. Set to false when the CBT driver is not installed
    v5.3: Indicates if the CBT driver is installed for SQL Server instances on the specified Windows host. Set to true when the CBT driver is installed. Set to false when the CBT driver is not installed
    v6.0+: Indicates if the CBT driver is installed for SQL Server instances on the specified Windows host. Set to true when the CBT driver is installed. Set to false when the CBT driver is not installed.
    """
    mssqlCbtDriverInstalled: Boolean!
    """

    Supported in v5.0+
    Specifies the Oracle username for an account with query privileges.
    """
    oracleQueryUser: String
    """

    Supported in v5.0+
    Specifies the Oracle username for an account with sysdba privileges.
    """
    oracleSysDbaUser: String
}

"Supported in v5.0+"
type HostDetailListResponse {
    """

    Supported in v5.0+
    List of matching objects.
    """
    data: [HostDetail!]!
    """

    Supported in v5.0+
    If there is more.
    """
    hasMore: Boolean
    """

    Supported in v5.0+
    Total list responses.
    """
    total: Long
}

"Supported in v5.0+"
type HostDiagnosisSummary {
    "Supported in v5.0+"
    connectivity: [HostConnectivitySummary!]!
}

type HostFailoverCluster implements CdmHierarchyObject & FailoverClusterTopLevelDescendantType & HierarchyObject {
    "The list of Hosts making up this Host Failover Cluster."
    allNodes: [PhysicalHost!]!
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    cdmId: String!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): HostFailoverClusterDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    isArchived: Boolean!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The OS Type of this Host Failover Cluster"
    nodesOsType: GuestOsTypeEnum
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "List of physical children"
    physicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): HostFailoverClusterPhysicalChildTypeConnection!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    status: FailoverClusterStatus
}

"Paginated list of HostFailoverCluster objects."
type HostFailoverClusterConnection {
    "Total number of HostFailoverCluster objects matching the request arguments."
    count: Int!
    "List of HostFailoverCluster objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [HostFailoverClusterEdge!]!
    "List of HostFailoverCluster objects."
    nodes: [HostFailoverCluster!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Paginated list of HostFailoverClusterDescendantType objects."
type HostFailoverClusterDescendantTypeConnection {
    "Total number of HostFailoverClusterDescendantType objects matching the request arguments."
    count: Int!
    "List of HostFailoverClusterDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [HostFailoverClusterDescendantTypeEdge!]!
    "List of HostFailoverClusterDescendantType objects."
    nodes: [HostFailoverClusterDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the HostFailoverClusterDescendantType object. This wrapper is used for pagination."
type HostFailoverClusterDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual HostFailoverClusterDescendantType object wrapped by this edge."
    node: HostFailoverClusterDescendantType!
}

"Wrapper around the HostFailoverCluster object. This wrapper is used for pagination."
type HostFailoverClusterEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual HostFailoverCluster object wrapped by this edge."
    node: HostFailoverCluster!
}

"Paginated list of HostFailoverClusterPhysicalChildType objects."
type HostFailoverClusterPhysicalChildTypeConnection {
    "Total number of HostFailoverClusterPhysicalChildType objects matching the request arguments."
    count: Int!
    "List of HostFailoverClusterPhysicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [HostFailoverClusterPhysicalChildTypeEdge!]!
    "List of HostFailoverClusterPhysicalChildType objects."
    nodes: [HostFailoverClusterPhysicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the HostFailoverClusterPhysicalChildType object. This wrapper is used for pagination."
type HostFailoverClusterPhysicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual HostFailoverClusterPhysicalChildType object wrapped by this edge."
    node: HostFailoverClusterPhysicalChildType!
}

"Supported in v5.3+"
type HostInfo {
    """

    Required. Supported in v5.3+
    Name of the host.
    """
    hostname: String!
    """

    Required. Supported in v5.3+
    The managed id of the host.
    """
    id: String!
    """

    Required. Supported in v5.3+
    Oracle discovery user.
    """
    oracleQueryUser: String!
    """

    Required. Supported in v5.3+
    Oracle sysdba user to use on the host.
    """
    oracleSysDbaUser: String!
}

type HostShare implements CdmHierarchyObject & HierarchyObject & PhysicalHostDescendantType & PhysicalHostPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): HostShareDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "List of physical children"
    physicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): HostSharePhysicalChildTypeConnection!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"Paginated list of HostShare objects."
type HostShareConnection {
    "Total number of HostShare objects matching the request arguments."
    count: Int!
    "List of HostShare objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [HostShareEdge!]!
    "List of HostShare objects."
    nodes: [HostShare!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Paginated list of HostShareDescendantType objects."
type HostShareDescendantTypeConnection {
    "Total number of HostShareDescendantType objects matching the request arguments."
    count: Int!
    "List of HostShareDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [HostShareDescendantTypeEdge!]!
    "List of HostShareDescendantType objects."
    nodes: [HostShareDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the HostShareDescendantType object. This wrapper is used for pagination."
type HostShareDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual HostShareDescendantType object wrapped by this edge."
    node: HostShareDescendantType!
}

"Wrapper around the HostShare object. This wrapper is used for pagination."
type HostShareEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual HostShare object wrapped by this edge."
    node: HostShare!
}

"Paginated list of HostSharePhysicalChildType objects."
type HostSharePhysicalChildTypeConnection {
    "Total number of HostSharePhysicalChildType objects matching the request arguments."
    count: Int!
    "List of HostSharePhysicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [HostSharePhysicalChildTypeEdge!]!
    "List of HostSharePhysicalChildType objects."
    nodes: [HostSharePhysicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the HostSharePhysicalChildType object. This wrapper is used for pagination."
type HostSharePhysicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual HostSharePhysicalChildType object wrapped by this edge."
    node: HostSharePhysicalChildType!
}

"Supported in v5.0+"
type HostSummary {
    """

    Supported in v5.1+
    A user-specified string that returns this host in searches.
    """
    alias: String
    "Supported in v5.2+"
    hdfsBaseConfig: HdfsBaseConfig
    """

    Required. Supported in v5.0+
    Deprecated. Please use 'name' instead.
    """
    hostname: String!
    """

    Required. Supported in v5.0+
    v5.0-v5.2:
    v5.3+: Unique identifier for host.
    """
    id: String!
    mssqlCbtEffectiveStatus: MssqlCbtEffectiveStatusTypeEnum
    mssqlCbtEnabled: MssqlCbtStatusTypeEnum
    """

    Supported in v5.0+
    v5.0-v5.2:
    v5.3+: IP address or hostname of the host.
    """
    name: String
    "Supported in v5.0+"
    nasBaseConfig: NasBaseConfig
    """

    Supported in v5.0+
    v5.0-v5.2:
    v5.3+: Operating system of the host. One of Windows, Linux, AIX, HPUX, and SunOS.
    """
    operatingSystem: String
    """

    Supported in v5.0+
    v5.0-v5.2:
    v5.3+: The operating system of the host. Possible choices are Windows, Linux, AIX, HPUX, SunOS.
    """
    operatingSystemType: String
    """

    Supported in v5.0+
    The ID of the organization to which the host is assigned (set by envoy).
    """
    organizationId: String
    """

    Supported in v5.0+
    The name of the organization to which the host is assigned (set by envoy).
    """
    organizationName: String
    """

    Supported in v5.0+
    v5.0-v5.2:
    v5.3+: ID of the Rubrik cluster to which the host belongs.
    """
    primaryClusterId: String
    """

    Supported in v5.0+
    v5.0-v5.2:
    v5.3+: Specifies the connect status for the host. Status is Refreshing while discovery is running or Connected once discovery was successful and the host is available.
    """
    status: String
}

"Supported in v5.0+"
type HostVfdInstallResponse {
    "Supported in v5.0+"
    errorInfo: String
    "Required. Supported in v5.0+"
    hostId: String!
    hostVfdDriverState: HostVfdStateEnum!
}

"Supported in v5.0+"
type HostVolumeSummary {
    """

    Required. Supported in v5.0+
    v5.0-v5.2: A boolean value that describes whether a volume is present on the host. When 'true', the volume is present. When 'false', the volume is not present. Volumes that are not present on the host are still included in snapshots and trigger warnings until the missing volumes are excluded from snapshots.
    v5.3+: Indicates whether a volume is present on the host. When 'true', the volume is present. When 'false', the volume is not present. Volumes that are not present on the host are still included in snapshots and trigger warnings until the missing volumes are excluded from snapshots.
    """
    isCurrentlyPresentOnSystem: Boolean!
    """

    Required. Supported in v5.0+
    v5.0-v5.2: Windows ID on the Host
    v5.3+: The unique ID of the volume on the Windows host.
    """
    naturalId: String!
    """

    Supported in v5.0+
    v5.0-v5.2: The Volume Group ID of the volume.
    v5.3+: The unique ID of the Volume Group.
    """
    volumeGroupId: String
    volumeGroupSnapshotVolumeSummary: VolumeGroupSnapshotVolumeSummary
}

type HourlySnapshotSchedule {
    basicSchedule: BasicSnapshotSchedule
}

type HyperVCluster implements CdmHierarchyObject & HierarchyObject & HyperVSCVMMDescendantType & HyperVSCVMMLogicalChildType & HyperVTopLevelDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "Connectivity Status of HyperV Cluster."
    connectionStatus: HyperVHostStatusType!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): HyperVClusterDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "List of logical children"
    logicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): HyperVClusterLogicalChildTypeConnection!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"Paginated list of HyperVClusterDescendantType objects."
type HyperVClusterDescendantTypeConnection {
    "Total number of HyperVClusterDescendantType objects matching the request arguments."
    count: Int!
    "List of HyperVClusterDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [HyperVClusterDescendantTypeEdge!]!
    "List of HyperVClusterDescendantType objects."
    nodes: [HyperVClusterDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the HyperVClusterDescendantType object. This wrapper is used for pagination."
type HyperVClusterDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual HyperVClusterDescendantType object wrapped by this edge."
    node: HyperVClusterDescendantType!
}

"Paginated list of HyperVClusterLogicalChildType objects."
type HyperVClusterLogicalChildTypeConnection {
    "Total number of HyperVClusterLogicalChildType objects matching the request arguments."
    count: Int!
    "List of HyperVClusterLogicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [HyperVClusterLogicalChildTypeEdge!]!
    "List of HyperVClusterLogicalChildType objects."
    nodes: [HyperVClusterLogicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the HyperVClusterLogicalChildType object. This wrapper is used for pagination."
type HyperVClusterLogicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual HyperVClusterLogicalChildType object wrapped by this edge."
    node: HyperVClusterLogicalChildType!
}

"HyperV live mount."
type HyperVLiveMount {
    "Cluster of the live mount."
    cluster: Cluster!
    "Fid of the live mount."
    id: UUID!
    "Describes if the live mount is ready."
    isVmReady: Boolean!
    "Specification of the live mount in JSON string."
    mountSpec: String!
    "Power Status of HyperV Live Mount."
    mountedVmStatus: HypervMountedVmStatusType!
    "Name of the live mount."
    name: String!
    "Source snapshot of the live mount."
    sourceSnapshot: CdmSnapshot!
    "Name of the source HyperV VM."
    sourceVm: String!
}

"Paginated list of HyperVLiveMount objects."
type HyperVLiveMountConnection {
    "Total number of HyperVLiveMount objects matching the request arguments."
    count: Int!
    "List of HyperVLiveMount objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [HyperVLiveMountEdge!]!
    "List of HyperVLiveMount objects."
    nodes: [HyperVLiveMount!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the HyperVLiveMount object. This wrapper is used for pagination."
type HyperVLiveMountEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual HyperVLiveMount object wrapped by this edge."
    node: HyperVLiveMount!
}

type HyperVSCVMM implements CdmHierarchyObject & HierarchyObject & HyperVTopLevelDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "Connectivity Status of SCVMM Host."
    connectionStatus: HyperVHostStatusType!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): HyperVSCVMMDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "Name or IP Address of SCVMM Host."
    hostName: String!
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "List of logical children"
    logicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): HyperVSCVMMLogicalChildTypeConnection!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    runAsAccount: String!
    shouldDeployAgent: Boolean!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    status: HyperVStatus!
}

"Paginated list of HyperVSCVMM objects."
type HyperVSCVMMConnection {
    "Total number of HyperVSCVMM objects matching the request arguments."
    count: Int!
    "List of HyperVSCVMM objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [HyperVSCVMMEdge!]!
    "List of HyperVSCVMM objects."
    nodes: [HyperVSCVMM!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Paginated list of HyperVSCVMMDescendantType objects."
type HyperVSCVMMDescendantTypeConnection {
    "Total number of HyperVSCVMMDescendantType objects matching the request arguments."
    count: Int!
    "List of HyperVSCVMMDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [HyperVSCVMMDescendantTypeEdge!]!
    "List of HyperVSCVMMDescendantType objects."
    nodes: [HyperVSCVMMDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the HyperVSCVMMDescendantType object. This wrapper is used for pagination."
type HyperVSCVMMDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual HyperVSCVMMDescendantType object wrapped by this edge."
    node: HyperVSCVMMDescendantType!
}

"Wrapper around the HyperVSCVMM object. This wrapper is used for pagination."
type HyperVSCVMMEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual HyperVSCVMM object wrapped by this edge."
    node: HyperVSCVMM!
}

"Paginated list of HyperVSCVMMLogicalChildType objects."
type HyperVSCVMMLogicalChildTypeConnection {
    "Total number of HyperVSCVMMLogicalChildType objects matching the request arguments."
    count: Int!
    "List of HyperVSCVMMLogicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [HyperVSCVMMLogicalChildTypeEdge!]!
    "List of HyperVSCVMMLogicalChildType objects."
    nodes: [HyperVSCVMMLogicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the HyperVSCVMMLogicalChildType object. This wrapper is used for pagination."
type HyperVSCVMMLogicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual HyperVSCVMMLogicalChildType object wrapped by this edge."
    node: HyperVSCVMMLogicalChildType!
}

type HyperVServer implements CdmHierarchyObject & HierarchyObject & HyperVClusterDescendantType & HyperVClusterLogicalChildType & HyperVSCVMMDescendantType & HyperVSCVMMLogicalChildType & HyperVTopLevelDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "Connectivity Status of HyperV Host."
    connectionStatus: HyperVHostStatusType!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): HyperVServerDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "List of logical children"
    logicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): HyperVServerLogicalChildTypeConnection!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    status: HyperVStatus!
}

"Paginated list of HyperVServerDescendantType objects."
type HyperVServerDescendantTypeConnection {
    "Total number of HyperVServerDescendantType objects matching the request arguments."
    count: Int!
    "List of HyperVServerDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [HyperVServerDescendantTypeEdge!]!
    "List of HyperVServerDescendantType objects."
    nodes: [HyperVServerDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the HyperVServerDescendantType object. This wrapper is used for pagination."
type HyperVServerDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual HyperVServerDescendantType object wrapped by this edge."
    node: HyperVServerDescendantType!
}

"Paginated list of HyperVServerLogicalChildType objects."
type HyperVServerLogicalChildTypeConnection {
    "Total number of HyperVServerLogicalChildType objects matching the request arguments."
    count: Int!
    "List of HyperVServerLogicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [HyperVServerLogicalChildTypeEdge!]!
    "List of HyperVServerLogicalChildType objects."
    nodes: [HyperVServerLogicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the HyperVServerLogicalChildType object. This wrapper is used for pagination."
type HyperVServerLogicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual HyperVServerLogicalChildType object wrapped by this edge."
    node: HyperVServerLogicalChildType!
}

"Additional information about the status of a Hyperv SCVMM."
type HyperVStatus {
    connectivity: String!
    timestampMillis: DateTime
}

"Paginated list of HyperVTopLevelDescendantType objects."
type HyperVTopLevelDescendantTypeConnection {
    "Total number of HyperVTopLevelDescendantType objects matching the request arguments."
    count: Int!
    "List of HyperVTopLevelDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [HyperVTopLevelDescendantTypeEdge!]!
    "List of HyperVTopLevelDescendantType objects."
    nodes: [HyperVTopLevelDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the HyperVTopLevelDescendantType object. This wrapper is used for pagination."
type HyperVTopLevelDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual HyperVTopLevelDescendantType object wrapped by this edge."
    node: HyperVTopLevelDescendantType!
}

type HyperVVirtualMachine implements CdmHierarchyObject & CdmHierarchySnappableNew & HierarchyObject & HyperVClusterDescendantType & HyperVSCVMMDescendantType & HyperVServerDescendantType & HyperVServerLogicalChildType & HyperVTopLevelDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    cdmId: String!
    "A link to view the snappable on the CDM cluster. For dev use only."
    cdmLink: String!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "HyperV VM Live Count Connection."
    hypervVmMountCount: Int!
    "The fid of the hierarchy object."
    id: UUID!
    isRelic: Boolean!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The list of missed snapshots for this workload."
    missedSnapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int
    ): MissedSnapshotCommonConnection
    "The list of missed snapshots for this workload."
    missedSnapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: MissedSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): MissedSnapshotGroupByConnection
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot archived to AWS."
    newestArchivedSnapshot: CdmSnapshot
    "The newest snapshot replicated to a cluster."
    newestReplicatedSnapshot: CdmSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: CdmSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: CdmSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "Stats for HyperV VM (e.g., capacity)."
    reportSnappable: Snappable
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for the snapshots of this workload."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: CdmSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): cdmSnapshotGroupByConnection
}

"Paginated list of HyperVVirtualMachine objects."
type HyperVVirtualMachineConnection {
    "Total number of HyperVVirtualMachine objects matching the request arguments."
    count: Int!
    "List of HyperVVirtualMachine objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [HyperVVirtualMachineEdge!]!
    "List of HyperVVirtualMachine objects."
    nodes: [HyperVVirtualMachine!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the HyperVVirtualMachine object. This wrapper is used for pagination."
type HyperVVirtualMachineEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual HyperVVirtualMachine object wrapped by this edge."
    node: HyperVVirtualMachine!
}

"Supported in v5.0+"
type HypervHostSummary {
    """

    Required. Supported in v5.0+
    IP Address or the hostname using which the host was added.
    """
    hostname: String!
    """

    Required. Supported in v5.0+
    The ID of the Hyper-V host.
    """
    id: String!
    "Required. Supported in v5.0+"
    primaryClusterId: String!
    slaAssignable: SlaAssignable
}

"Supported in v5.0+"
type HypervHostSummaryListResponse {
    """

    Supported in v5.0+
    List of matching objects.
    """
    data: [HypervHostSummary!]!
    """

    Supported in v5.0+
    If there is more.
    """
    hasMore: Boolean
    """

    Supported in v5.0+
    Total list responses.
    """
    total: Long
}

"Supported in v5.0+"
type HypervScvmmDetail {
    hypervScvmmSummary: HypervScvmmSummary
    hypervScvmmUpdate: HypervScvmmUpdate
}

"Supported in v5.0+"
type HypervScvmmSummary {
    """

    Required. Supported in v5.0+
    The ID of the Hyper-V SCVMM.
    """
    id: String!
    "Required. Supported in v5.0+"
    primaryClusterId: String!
    """

    Required. Supported in v5.0+
    The RunAs account which will be used to install connector on hosts.
    """
    runAsAccount: String!
    """

    Required. Supported in v5.0+
    Flag to specify if Rubrik can deploy connector to hosts. If true, Rubrik tries to deploy connector to the hyperv hosts. If false, Rubrik deployment of connector will be handled by the client.
    """
    shouldDeployAgent: Boolean!
    slaAssignable: SlaAssignable
    """

    Required. Supported in v5.0+
    Connection status of the SCVMM server.
    """
    status: String!
}

"Supported in v5.0+"
type HypervScvmmUpdate {
    """

    Supported in v5.0+
    v5.0-v5.1: Assign this SCVMM to the given SLA domain.
    v5.2+: Assign this SCVMM to the given SLA domain. Existing snapshots of the object will be retained with the configuration of specified SLA Domain.
    """
    configuredSlaDomainId: String
    """

    Supported in v5.0+
    Name of the SCVMM host.
    """
    hostname: String
    """

    Supported in v5.0+
    The RunAs account which will be used to install connector on hosts.
    """
    runAsAccount: String
    """

    Supported in v5.0+
    Flag to specify if Rubrik can deploy connector to hosts. If true, Rubrik tries to deploy connector to the hyperv hosts. If false, Rubrik deployment of connector will be handled by the client.
    """
    shouldDeployAgent: Boolean
}

"Supported in v5.0+"
type HypervVirtualMachineMountDetail {
    hypervVirtualMachineMountSummary: HypervVirtualMachineMountSummary
}

"Supported in v5.0+"
type HypervVirtualMachineMountSummary {
    "Supported in v5.0+"
    hostId: String
    "Supported in v5.0+"
    hostName: String
    "Required. Supported in v5.0+"
    id: String!
    "Required. Supported in v5.0+"
    isReady: Boolean!
    "Supported in v5.0+"
    mountRequestId: String
    "Supported in v5.0+"
    mountedVmId: String
    "Supported in v5.0+"
    mountedVmName: String
    powerStatus: HypervVirtualMachineMountSummaryPowerStatusEnum!
    "Required. Supported in v5.0+"
    snapshotDate: DateTime
    "Supported in v5.0+"
    unmountRequestId: String
    "Required. Supported in v5.0+"
    vmId: String!
    "Required. Supported in v5.0+"
    vmName: String!
}

type IdentityProvider {
    entityId: String!
    expirationDate: DateTime
    name: String!
    signInUrl: String!
    signOutUrl: String!
    spInitiatedSignInUrl: String!
    spInitiatedTestUrl: String!
}

"Supported in v6.0+"
type IndicatorOfCompromise {
    iocType: IndicatorOfCompromiseTypeEnum!
    """

    Required. Supported in v6.0+
    Type specific payload.
    """
    iocValue: String!
}

type InfrastructureChart {
    focus: ReportFocusEnum!
    groupBy: [ClusterGroupByEnum!]
    name: String!
}

type InfrastructureTable {
    focus: ReportFocusEnum!
    groupBy: [ClusterGroupByEnum!]
    name: String!
    selectedColumns: [InfrastructureTableColumnEnum!]!
    sortBy: ClusterSortByEnum
    sortOrder: SortOrderEnum
}

type InstalledVersionGroupCount {
    count: Int!
    group: String!
    isUpgradeRecommended: Boolean!
}

"Interface CIDR Info."
type InterfaceCidr {
    cidr: String!
    interfaceType: InterfaceTypeEnum!
    selected: Boolean!
}

type InternalBulkUpdateHostResponse {
    items: [HostDetail!]!
}

type InternalChangeVfdOnHostResponse {
    items: [HostVfdInstallResponse!]!
}

type InventoryRoot {
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): HierarchyObjectConnection!
}

type InventorySubHierarchyRoot {
    "List of children"
    childConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): HierarchyObjectConnection!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): HierarchyObjectConnection!
    rootEnum: InventorySubHierarchyRootEnum!
    "List of top-level descendants (with respect to RBAC)."
    topLevelDescendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): HierarchyObjectConnection!
}

"Link to download investigation results as CSV."
type InvestigationCsvDownloadLinkReply {
    "Link for the CSV file which can be downloaded."
    downloadLink: String!
}

"It checks if the rule name is unique or not"
type IsCloudNativeTagRuleNameUniqueReply {
    isUnique: Boolean!
}

"Specifies whether the volume snapshot is restorable."
type IsVolumeSnapshotRestorableReply {
    "Specifies whether the EBS volume snapshot is restorable. The snapshot would be restorable only if the EBS volume exists in the AWS account, and is attached to exactly one EC2 instance."
    isRestorable: Boolean!
}

type Issue {
    events: [IssueEvent!]!
    fileResult: FileResult!
    id: String!
    latestPolicyObj: PolicyObj!
    openTime: Long!
    paginationId: String!
    policies: [ClassificationPolicySummary!]!
    resolvedTime: Long!
    violations: Int!
}

"Paginated list of Issue objects."
type IssueConnection {
    "Total number of Issue objects matching the request arguments."
    count: Int!
    "List of Issue objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [IssueEdge!]!
    "List of Issue objects."
    nodes: [Issue!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the Issue object. This wrapper is used for pagination."
type IssueEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual Issue object wrapped by this edge."
    node: Issue!
}

type IssueEvent {
    snapshotFid: String!
    timestamp: Long!
    type: IssueEventTypeEnum!
    violations: Int!
    violationsDelta: Int!
}

type JobMetadata {
    createdAt: DateTime
    currentInstance: Int!
    id: Long!
    info: String!
    jobType: String!
    lastFailure: DateTime
    lastOwner: String!
    lastSkipped: DateTime
    lastSuccess: DateTime
    logLevel: LogLevelEnum!
    numScheduledRuns: Int!
    numSuccessfulRuns: Int!
    owner: String!
    progress: String!
    progressedAt: DateTime
    retryAttempts: Int!
    startTime: DateTime
    startedAt: DateTime
    state: String!
    updatedAt: DateTime
}

type JobReply {
    clusterName: String!
    clusterUuid: String!
    customerAccount: String!
    metadata: JobMetadata
    version: String!
}

type JobsReply {
    jobs: [JobReply!]!
}

"Basic information about Rubrik Kubernetes Agent manifest."
type K8sAgentManifestInfo {
    "UUID of the kubernetes Cluster."
    clusterId: UUID!
    "SignedURL containing the created manifest."
    signedUrl: String!
}

type K8sCluster implements HierarchyObject & PolarisHierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Information about the Kubernetes cluster."
    clusterInfo: K8sClusterInfo!
    "List of IPs for the Kubernetes cluster."
    clusterIp: [String!]!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): K8sClusterDescendantConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Namespaces belonging to the Kubernetes cluster."
    k8sDescendantNamespaces(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): K8sNamespaceConnection!
    lastRefreshTime: DateTime
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "Range of ports that are allowed to be accessed."
    rbsPortRanges: [K8sRbsInfo!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    status: K8sClusterStatus!
}

"Paginated list of K8sCluster objects."
type K8sClusterConnection {
    "Total number of K8sCluster objects matching the request arguments."
    count: Int!
    "List of K8sCluster objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [K8sClusterEdge!]!
    "List of K8sCluster objects."
    nodes: [K8sCluster!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Paginated list of K8sClusterDescendant objects."
type K8sClusterDescendantConnection {
    "Total number of K8sClusterDescendant objects matching the request arguments."
    count: Int!
    "List of K8sClusterDescendant objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [K8sClusterDescendantEdge!]!
    "List of K8sClusterDescendant objects."
    nodes: [K8sClusterDescendant!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the K8sClusterDescendant object. This wrapper is used for pagination."
type K8sClusterDescendantEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual K8sClusterDescendant object wrapped by this edge."
    node: K8sClusterDescendant!
}

"Wrapper around the K8sCluster object. This wrapper is used for pagination."
type K8sClusterEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual K8sCluster object wrapped by this edge."
    node: K8sCluster!
}

type K8sClusterInfo {
    associatedCdm: Cluster
    k8sVersion: String
    kuprClusterUUID: UUID!
    port: Int!
    type: K8sClusterDBType!
}

type K8sNamespace implements HierarchyObject & HierarchySnappable & K8sClusterDescendant & PolarisHierarchyObject & PolarisHierarchySnappable {
    apiVersion: String!
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    clusterScoped: Boolean!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "object id"
    id: UUID!
    "Namespace is archived and has > 1 snapshots."
    isRelic: Boolean!
    "Kubernetes cluster ID."
    k8sClusterID: String!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "Name of the namespace."
    namespaceName: String!
    "The newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: PolarisSnapshot
    "Number of persistent volume claims."
    numPvcs: Int!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "Number of workloads."
    numWorkloads: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: PolarisSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    resouceVersion: String!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this workload."
    snapshotsOfSnappableConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Whether to ignore the active protected object check."
        ignoreActiveSnappableCheck: Boolean,
        "Returns the last n elements from the list."
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
}

"Paginated list of K8sNamespace objects."
type K8sNamespaceConnection {
    "Total number of K8sNamespace objects matching the request arguments."
    count: Int!
    "List of K8sNamespace objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [K8sNamespaceEdge!]!
    "List of K8sNamespace objects."
    nodes: [K8sNamespace!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the K8sNamespace object. This wrapper is used for pagination."
type K8sNamespaceEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual K8sNamespace object wrapped by this edge."
    node: K8sNamespace!
}

type K8sRbsInfo {
    kuprClusterUUID: UUID!
    maxPort: Int!
    minPort: Int!
}

"Represents a fully qualified GCP native KMS Crypto Key"
type KMSCryptoKey {
    key: String!
    keyRing: String!
    location: String!
    projectNativeId: String!
}

"A Key management system (KMS) key in AWS realm."
type KmsEncryptionKey {
    "Aliases of KMS key."
    aliases: [String!]!
    "Amazon Resource Name (ARN) of the KMS key."
    arn: String!
    "ID of KMS key."
    id: String!
}

type Label {
    key: String!
    value: String!
}

"A single Label Rule"
type LabelRule {
    Label: CloudNativeLabel
    "Does this tag rule apply to all cloud accounts."
    applyToAllCloudAccounts: Boolean!
    cloudNativeAccounts: [CloudNativeAccountIdWithName!]!
    effectiveSla: TagRuleEffectiveSla
    hasPermissionToModify: Boolean!
    id: String!
    name: String!
    objectType: ManagedObjectType!
}

"History of Radar and Sonar features."
type LambdaFeatureHistory {
    "True is Radar was ever enabled."
    wasRadarEverEnabled: Boolean!
    "True is Sonar was ever enabled."
    wasSonarEverEnabled: Boolean!
}

type LambdaSettings {
    anomalyThreshold: Float
    isAnomalyAlertEnabled: Boolean
    ransomwareThreshold: Float
}

type LastTestStatus {
    enumValue: LastTestStatusEnum!
}

"Latest user note information."
type LatestUserNote {
    "Object ID where note is attached."
    objectId: String!
    "User note attachment time."
    time: DateTime!
    "Name of the user who attached the note."
    userName: String
    "User note text."
    userNote: String
}

"Ldap Integration Information"
type LdapIntegration {
    "BaseDn for your LDAP integration."
    baseDn: String!
    "BindUserName for your LDAP integration."
    bindUserName: String!
    "Dynamic DNS name for your LDAP integration."
    dynamicDnsName: String!
    "Group member attribute for your LDAP integration."
    groupMemberAttr: String
    "Group membership attribute for your LDAP integration."
    groupMembershipAttr: String
    "Group search filter for your LDAP integration."
    groupSearchFilter: String
    "ID for your LDAP integration."
    id: String!
    "Whether TOTP as 2FA is enforced for the LDAP integration."
    isTotpEnforced: Boolean!
    "LdapServers for your LDAP integration."
    ldapServers: [LdapServer!]!
    "Name for your LDAP integration."
    name: String!
    "TrustedCerts for your LDAP integration."
    trustedCerts: String
    "User name attribute for your LDAP integration."
    userNameAttr: String
    "User search filter for your LDAP integration."
    userSearchFilter: String
}

"Paginated list of LdapIntegration objects."
type LdapIntegrationConnection {
    "Total number of LdapIntegration objects matching the request arguments."
    count: Int!
    "List of LdapIntegration objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [LdapIntegrationEdge!]!
    "List of LdapIntegration objects."
    nodes: [LdapIntegration!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the LdapIntegration object. This wrapper is used for pagination."
type LdapIntegrationEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual LdapIntegration object wrapped by this edge."
    node: LdapIntegration!
}

"Ldap Server Information"
type LdapServer {
    "Hostname for the LDAP server."
    hostname: String!
    "Port used by the LDAP server."
    port: Int!
    "Whether the LDAP server uses TLS."
    useTls: Boolean!
}

"TOTP status for a LDAP principal."
type LdapTotpStatus {
    "TOTP as 2FA is enabled."
    isEnabled: Boolean!
    "TOTP as 2FA is enforced."
    isEnforced: Boolean!
    "Whether TOTP is supported for the LDAP principal."
    isSupported: Boolean!
}

"Contains information about the legal hold placed on the Snapshot."
type LegalHoldInfo {
    "Boolean which describes whether snapshot has to be held in place."
    shouldHoldInPlace: Boolean!
}

"LegalHoldSnappableDetails."
type LegalHoldSnappableDetail {
    "Snappable id."
    id: String!
    "Snappable name."
    name: String!
    "Snappable type."
    snappableType: ManagedObjectType!
    "Snapshots count with legal hold."
    snapshotCount: Int!
    "Snapshot details."
    snapshotDetails: [LegalHoldSnapshotDetail!]!
}

"Paginated list of LegalHoldSnappableDetail objects."
type LegalHoldSnappableDetailConnection {
    "Total number of LegalHoldSnappableDetail objects matching the request arguments."
    count: Int!
    "List of LegalHoldSnappableDetail objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [LegalHoldSnappableDetailEdge!]!
    "List of LegalHoldSnappableDetail objects."
    nodes: [LegalHoldSnappableDetail!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the LegalHoldSnappableDetail object. This wrapper is used for pagination."
type LegalHoldSnappableDetailEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual LegalHoldSnappableDetail object wrapped by this edge."
    node: LegalHoldSnappableDetail!
}

"LegalHoldSnapshotDetails."
type LegalHoldSnapshotDetail {
    "Snapshot id."
    id: String!
    "Legal hold time."
    legalHoldTime: DateTime
    "Snapshot time."
    snapshotTime: DateTime
    "Snapshot type."
    type: SnapshotTypeEnum!
}

"Paginated list of LegalHoldSnapshotDetail objects."
type LegalHoldSnapshotDetailConnection {
    "Total number of LegalHoldSnapshotDetail objects matching the request arguments."
    count: Int!
    "List of LegalHoldSnapshotDetail objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [LegalHoldSnapshotDetailEdge!]!
    "List of LegalHoldSnapshotDetail objects."
    nodes: [LegalHoldSnapshotDetail!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the LegalHoldSnapshotDetail object. This wrapper is used for pagination."
type LegalHoldSnapshotDetailEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual LegalHoldSnapshotDetail object wrapped by this edge."
    node: LegalHoldSnapshotDetail!
}

"Supported in v5.0+"
type Link {
    """

    Required. Supported in v5.0+
    v5.0: The link's destination.
    v5.1+: The destination of the link.
    """
    href: String!
    """

    Required. Supported in v5.0+
    v5.0: The relation of this link's destination to the current resource.
    v5.1+: The relation of the destination of this link to the current resource.
    """
    rel: String!
}

type LinuxFileset implements CdmHierarchyObject & CdmHierarchySnappableNew & FailoverClusterAppDescendantType & FailoverClusterAppPhysicalChildType & FailoverClusterTopLevelDescendantType & FilesetTemplateDescendantType & FilesetTemplatePhysicalChildType & HierarchyObject & HierarchySnappable & HostFailoverClusterDescendantType & HostFailoverClusterPhysicalChildType & PhysicalHostDescendantType & PhysicalHostPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    cdmId: String!
    "A link to view the snappable on the CDM cluster. For dev use only."
    cdmLink: String!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    failoverClusterApp: FailoverClusterApp
    hardlinkSupportEnabled: Boolean!
    host: PhysicalHost
    "The fid of the hierarchy object."
    id: UUID!
    isPassThrough: Boolean!
    isRelic: Boolean!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The list of missed snapshots for this workload."
    missedSnapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int
    ): MissedSnapshotCommonConnection
    "The list of missed snapshots for this workload."
    missedSnapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: MissedSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): MissedSnapshotGroupByConnection
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot archived to AWS."
    newestArchivedSnapshot: CdmSnapshot
    "The newest snapshot replicated to a cluster."
    newestReplicatedSnapshot: CdmSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: CdmSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: CdmSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    pathExceptions: [String!]!
    pathExcluded: [String!]!
    pathIncluded: [String!]!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for the snapshots of this workload."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: CdmSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): cdmSnapshotGroupByConnection
    symlinkResolutionEnabled: Boolean!
}

"Response to list CIDRs for compute settings."
type ListCidrsForComputeSettingReply {
    "List of cluster interface CIDR map."
    clusterInterfaceCidrs: [ClusterInfCidrs!]!
}

"""

Supported in m3.2.0-m4.1.0
Response object for list store on mosaic.
"""
type ListStoreResponse {
    """

    Supported in m3.2.0-m4.1.0
    Object with Response from ListStore
    """
    data: [MosaicStoreObject!]!
    """

    Supported in m3.2.0-m4.1.0
    Error message in case of failure
    """
    message: String
    """

    Supported in m3.2.0-m4.1.0
    Return Code
    """
    returnCode: Long
    """

    Supported in m3.2.0-m4.1.0
    Status of the request
    """
    status: Boolean
}

"List of locations where customer's GCP disks are present"
type ListStoredDiskLocationsReply {
    regions: [String!]!
    zones: [String!]!
}

"""

Supported in m3.2.0-m4.1.0
Response object for list version on mosaic.
"""
type ListVersionResponse {
    """

    Supported in m3.2.0-m4.1.0
    Object with Response from ListVersion
    """
    data: [MosaicVersionObject!]!
    """

    Supported in m3.2.0-m4.1.0
    Error message in case of failure
    """
    message: String
    """

    Supported in m3.2.0-m4.1.0
    Return Code
    """
    returnCode: Long
    """

    Supported in m3.2.0-m4.1.0
    Status of the request
    """
    status: Boolean
}

"Location Path Point."
type LocationPathPoint {
    "Managed ID."
    managedId: String!
    "Location name."
    name: String!
}

type LogConfigResult {
    slaLogFrequencyConfig: SlaLogFrequencyConfigResult
}

"Supported in v6.0+"
type MalwareMatch {
    """

    Required. Supported in v6.0+
    Index into MalwareScanConfig.indicators_of_compromise.
    """
    indicatorIndex: Int!
    "Required. Supported in v6.0+"
    paths: [PathInfo!]!
}

"""

Represents the configuration and stats for a
malware scan.
"""
type MalwareScan {
    "The details/configuration of the threat hunt."
    huntDetails: ThreatHuntDetails!
    "The internal ID for the malware scan."
    scanId: String!
    "The stats based on results of the threat hunt."
    stats: PolarisMalwareScanStats
    "Status of the MalwareScan."
    status: MalwareScanStatus!
}

"Supported in v6.0+"
type MalwareScanConfig {
    """

    Supported in v6.0+
    Criteria to restrict files to scan.
    """
    fileScanCriteria: MalwareScanFileCriteria
    """

    Required. Supported in v6.0+
    List of IOCs to scan for.
    """
    indicatorsOfCompromise: [IndicatorOfCompromise!]!
    """

    Supported in v6.0+
    Maximum number of matches per shapshot, per IOC.  Scanning for an Indicator Of Compromise within a snapshot will terminate once this many matches have been detected. Defaults to one.
    """
    maxMatchesPerSnapshot: Int
    """

    Supported in v6.0+
    Name of this scan.
    """
    name: String
    """

    Supported in v6.0+
    Notes to describe this scan.
    """
    notes: String
    """

    Required. Supported in v6.0+
    Snappable IDs to scan for malware.
    """
    objectIds: [String!]!
    """

    Supported in v6.0+
    Additional information required for files with malware matches.
    """
    requestedMatchDetails: RequestedMatchDetails
    """

    Supported in v6.0+
    Specifies whether features that rely on the accuracy of filesystem metadata, like creation time and modification time of files, are enabled or not. These features include backend optimizations to skip re-scanning files that have not changed across snapshots, as indicated by the unchanged timestamps of files. This flag also gates access to some filters that can be specified in this API. Note that this flag should be used with caution, as relying on file timestamps may make the system vulnerable to adversarial techniques such as timestamp manipulation.
    """
    shouldTrustFilesystemTimeInfo: Boolean
    """

    Supported in v6.0+
    Limit which snapshots to include in the malware scan.
    """
    snapshotScanLimit: MalwareScanSnapshotLimit
}

"Paginated list of MalwareScan objects."
type MalwareScanConnection {
    "Total number of MalwareScan objects matching the request arguments."
    count: Int!
    "List of MalwareScan objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [MalwareScanEdge!]!
    "List of MalwareScan objects."
    nodes: [MalwareScan!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Supported in v6.0+"
type MalwareScanDetail {
    """

    Required. Supported in v6.0+
    The malware scan config.
    """
    config: MalwareScanConfig
    """

    Supported in v6.0+
    The end time of the scan.
    """
    endTime: DateTime
    """

    Required. Supported in v6.0+
    The malware scan ID.
    """
    id: String!
    """

    Required. Supported in v6.0+
    A array of object ID and list of snapshot IDs which are the the target of the scan.
    """
    snapshots: [ObjectIdToSnapshotIds!]!
    """

    Supported in v6.0+
    The start time of the scan.
    """
    startTime: DateTime
}

"Supported in v6.0+"
type MalwareScanDetailListResponse {
    """

    Supported in v6.0+
    List of matching objects.
    """
    data: [MalwareScanDetail!]!
    """

    Supported in v6.0+
    If there is more.
    """
    hasMore: Boolean
    """

    Supported in v6.0+
    Total list responses.
    """
    total: Int
}

"Wrapper around the MalwareScan object. This wrapper is used for pagination."
type MalwareScanEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual MalwareScan object wrapped by this edge."
    node: MalwareScan!
}

"Supported in v6.0+"
type MalwareScanFileCriteria {
    """

    Supported in v6.0+
    Specify the smallest and largest files to scan.
    """
    fileSizeLimits: MalwareScanFileSizeLimits
    """

    Supported in v6.0+
    Specify limits around file creation and modification time. The top-level API field `shouldTrustFilesystemTimeInfo` must be set to true when this field is specified.
    """
    fileTimeLimits: MalwareScanFileTimeLimits
    """

    Supported in v6.0+
    Please see /fileset_template for a detailed description of how includes, excludes, and exceptions are interpreted.
    """
    pathFilter: MalwareScanPathFilter
}

"Supported in v6.0+"
type MalwareScanFileSizeLimits {
    """

    Supported in v6.0+
    Maximum size of files to scan. Files that are bigger than this size are ignored.
    """
    maximumSizeInBytes: Long
    """

    Supported in v6.0+
    Minimum size of files to scan. Files smaller than this size are ignored.
    """
    minimumSizeInBytes: Long
}

"Supported in v6.0+"
type MalwareScanFileTimeLimits {
    """

    Supported in v6.0+
    Earliest file creation time.  Any files created before this time will be elided.
    """
    earliestCreationTime: DateTime
    """

    Supported in v6.0+
    Earliest file modification time.  Any files last modified before this time will be elided.
    """
    earliestModificationTime: DateTime
    """

    Supported in v6.0+
    Latest file creation time.  Any files created after this time will be elided.
    """
    latestCreationTime: DateTime
    """

    Supported in v6.0+
    Latest file modification time.  Any files modified after this time will be elided.
    """
    latestModificationTime: DateTime
}

"Supported in v6.0+"
type MalwareScanInSnapshotResult {
    """

    Supported in v6.0+
    ID of the most recent job run against this snapshot, if any.
    """
    lastJobId: String
    """

    Required. Supported in v6.0+
    List of malware matches found in this snapshot.
    """
    matches: [MalwareMatch!]!
    """

    Supported in v6.0+
    Stats collected during the scan.  Note that the stats capture what was actually scanned.  It's possible a scan for a snapshot terminates early;  it's also possible a scan is retried after an error. This means the counts could be less than or more than the actual count of entites (files, bytes, etc.) in the snapshot.
    """
    scanStats: MalwareScanStats
    """

    Required. Supported in v6.0+
    Date of the snapshot.
    """
    snapshotDate: DateTime
    """

    Required. Supported in v6.0+
    ID of the snapshot.
    """
    snapshotId: String!
    status: MalwareScanInSnapshotStatusEnum!
}

"""

Supported in v6.0+
Please see v1/fileset_template API doc for a detailed description of how includes, excludes, & exceptions are interpreted.
"""
type MalwareScanPathFilter {
    """

    Supported in v6.0+
    Paths to exempt from exclusion.
    """
    exceptions: [String!]!
    """

    Supported in v6.0+
    Paths to exclude.
    """
    excludes: [String!]!
    """

    Supported in v6.0+
    Paths to include.
    """
    includes: [String!]!
}

"Supported in v6.0+"
type MalwareScanResult {
    "Required. Supported in v6.0+"
    objectId: String!
    "Required. Supported in v6.0+"
    snapshotResults: [MalwareScanInSnapshotResult!]!
}

"Supported in v6.0+"
type MalwareScanResults {
    """

    Required. Supported in v6.0+
    ID of the malware detection.
    """
    id: String!
    """

    Required. Supported in v6.0+
    List of IOCs to scan for.
    """
    indicatorsOfCompromise: [IndicatorOfCompromise!]!
    "Required. Supported in v6.0+"
    results: [MalwareScanResult!]!
}

"Supported in v6.0+"
type MalwareScanSnapshotLimit {
    """

    Supported in v6.0+
    Maximum snapshot time.  Any snapshots taken after this time will be elided.
    """
    endTime: DateTime
    """

    Supported in v6.0+
    Maximum number of snapshots to scan per object.  The snapshots of each object are scanned in reverse chronological order, so this is equivalent to scan-last-n-snapshots.
    """
    maxSnapshotsPerObject: Int
    """

    Supported in v6.0+
    A array of object ID and list of snapshots of that object to scan. If this field is specified, none of the other `MalwareScanSnapshotLimit` fields may be specified.
    """
    snapshotsToScanPerObject: [ObjectIdToSnapshotIds!]!
    """

    Supported in v6.0+
    Minimum snapshot time.  Any snapshots taken before this time will be elided.
    """
    startTime: DateTime
}

"Supported in v6.0+"
type MalwareScanStats {
    """

    Required. Supported in v6.0+
    The number of files encountered during the scan.  This may be less than the total number of files in the snapshot if the scan terminates early.
    """
    numFiles: Long!
    """

    Required. Supported in v6.0+
    The number of files scanned.
    """
    numFilesScanned: Long!
    """

    Required. Supported in v6.0+
    The total file size of the files scanned.  This may differ from the actual number of bytes read as part of the scan.  For example a YARA rule might only need to read a part of a file at a specific offset, whereas other rules might need to read the entire file to compute a hash.
    """
    totalFilesScannedSizeBytes: Long!
}

"Supported in v5.0+"
type ManagedHierarchyObjectAncestor {
    "Required. Supported in v5.0+"
    id: String!
    "Required. Supported in v5.0+"
    name: String!
}

"Supported in v5.2+"
type ManagedObjectPendingSlaInfo {
    "Supported in v5.2+"
    isPendingSlaDomainRetentionLocked: Boolean
    """

    Required. Supported in v5.2+
    Managed ID of the object.
    """
    objectId: String!
    "Required. Supported in v5.2+"
    pendingSlaDomainId: String!
    "Required. Supported in v5.2+"
    pendingSlaDomainName: String!
}

"Supported in v5.2+"
type ManagedObjectSlaInfo {
    "Required. Supported in v5.2+"
    configuredSlaDomainId: String!
    "Required. Supported in v5.2+"
    configuredSlaDomainName: String!
    "Required. Supported in v5.2+"
    effectiveSlaDomainId: String!
    "Required. Supported in v5.2+"
    effectiveSlaDomainName: String!
    "Supported in v5.2+"
    effectiveSlaDomainSourceId: String
    "Supported in v5.2+"
    effectiveSlaDomainSourceName: String
    "Supported in v5.2+"
    effectiveSlaPolarisManagedId: String
    "Supported in v5.2+"
    isEffectiveSlaDomainRetentionLocked: Boolean
    """

    Required. Supported in v5.2+
    Managed ID of the object.
    """
    objectId: String!
    slaAssignment: SlaAssignmentEnum!
}

"Managed Volume information."
type ManagedVolume implements CdmHierarchyObject & CdmHierarchySnappableNew & HierarchyObject {
    "Mount protocol used for Managed Volume."
    applicationTag: ManagedVolumeApplicationTagEnum
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The ID of the snappable on the Rubrik CDM cluster."
    cdmId: String!
    "A link to view the snappable on the CDM cluster. For dev use only."
    cdmLink: String!
    "Export channels of Managed Volume."
    channels: [ManagedVolumeExportChannel!]!
    "Client configuration related to backup scripts."
    clientConfig: ManagedVolumeSlaClientConfig
    "Allowed host names."
    clientNamePatterns: [String!]!
    "Cdm cluster information."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): ManagedVolumeDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "Host of SLA Managed Volume."
    host: SlaManagedVolumeHost!
    "The fid of the hierarchy object."
    id: UUID!
    "If the managed volume is in relic state."
    isRelic: Boolean!
    "Flag for readable or writable state of the Managed Volume."
    isWritable: Boolean!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "Logical size used by the Managed Volume in bytes."
    logicalUsedSize: Long!
    "The list of missed snapshots for this workload."
    missedSnapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int
    ): MissedSnapshotCommonConnection
    "The list of missed snapshots for this workload."
    missedSnapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: MissedSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): MissedSnapshotGroupByConnection
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot archived to AWS."
    newestArchivedSnapshot: CdmSnapshot
    "The newest snapshot replicated to a cluster."
    newestReplicatedSnapshot: CdmSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: CdmSnapshot
    "Number of channels in the Managed Volume."
    numChannels: Int!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: CdmSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "List of physical children"
    physicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): ManagedVolumePhysicalChildTypeConnection!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "Physical size used by the Managed Volume in bytes."
    physicalUsedSize: Long!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "Mount protocol used for Managed Volume."
    protocol: ManagedVolumeShareTypeEnum!
    "Size provisioned for the Managed Volume in bytes."
    provisionedSize: Long!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "SMB share details of the Managed Volume."
    smbShare: ManagedVolumeSmbShare
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for the snapshots of this workload."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: CdmSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): cdmSnapshotGroupByConnection
    "State of the Managed Volume."
    state: ManagedVolumeStateEnum!
    "Subnet of the Managed Volume."
    subnet: String
}

"Supported in v5.0+"
type ManagedVolumeChannelConfig {
    """

    Supported in v5.3+
    Directory path on the host machine used to export the NFS mount or SMB share.
    """
    hostMountPoint: String
    """

    Required. Supported in v5.0+
    v5.0-v7.0: IP address of channel export.
    v8.0: IP address of the channel export.
    """
    ipAddress: String!
    """

    Required. Supported in v5.0+
    The path of the NFS mount if exported over NFS, or the SMB share name if exported over SMB.
    """
    mountPoint: String!
}

"Paginated list of ManagedVolume objects."
type ManagedVolumeConnection {
    "Total number of ManagedVolume objects matching the request arguments."
    count: Int!
    "List of ManagedVolume objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [ManagedVolumeEdge!]!
    "List of ManagedVolume objects."
    nodes: [ManagedVolume!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Paginated list of ManagedVolumeDescendantType objects."
type ManagedVolumeDescendantTypeConnection {
    "Total number of ManagedVolumeDescendantType objects matching the request arguments."
    count: Int!
    "List of ManagedVolumeDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [ManagedVolumeDescendantTypeEdge!]!
    "List of ManagedVolumeDescendantType objects."
    nodes: [ManagedVolumeDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the ManagedVolumeDescendantType object. This wrapper is used for pagination."
type ManagedVolumeDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual ManagedVolumeDescendantType object wrapped by this edge."
    node: ManagedVolumeDescendantType!
}

"Wrapper around the ManagedVolume object. This wrapper is used for pagination."
type ManagedVolumeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual ManagedVolume object wrapped by this edge."
    node: ManagedVolume!
}

"Supported in v5.0+"
type ManagedVolumeExport {
    """

    Required. Supported in v5.0+
    Channels of this export.
    """
    channels: [ManagedVolumeChannelConfig!]!
    "Required. Supported in v5.0+"
    config: ManagedVolumeExportConfig
    """

    Required. Supported in v5.0+
    v5.0-v7.0: Is export active.
    v8.0: Indicates if export is active.
    """
    isActive: Boolean!
}

"Export channel metadata of the Managed Volume."
type ManagedVolumeExportChannel {
    "Export date of the Managed Volume channel."
    exportDateOpt: DateTime!
    "Id of the Managed Volume export channel."
    id: String!
    "Image size of the channel."
    imageSizeOpt: Int!
    "If true, capacity warning will be enabled."
    isWarningCapacityEnabled: Boolean!
    "The mount directory of the channel."
    mountDir: String!
    "Id of the node on which channel data is stored."
    mountNodeId: String!
    "If Managed Volume metadata disks needs refreshing."
    needsMetadataRefreshOpt: Boolean!
    "SMB share name of the channel."
    smbOriginalShareNameOpt: String!
    "Statistics of the Managed Volume."
    stats: ManagedVolumeExportChannelStats!
}

"Stats of the Managed Volume."
type ManagedVolumeExportChannelStats {
    "Total size in bytes."
    totalSize: Long!
    "Used size in bytes."
    usedSize: Long!
}

"Supported in v5.0+"
type ManagedVolumeExportConfig {
    managedVolumePatchConfig: ManagedVolumePatchConfig
    shareType: ManagedVolumeShareTypeEnum
    """

    Supported in v5.0+
    v5.0-v7.0: IP subnet that specifies an outgoing VLAN interface for a Rubrik node. This is a required value when creating a managed volume on a Rubrik node that has multiple VLAN interfaces.
    v8.0: IP subnet specifing an outgoing VLAN interface for a Rubrik node. This is a required value when creating a Managed Volume on a Rubrik node that has multiple VLAN interfaces.
    """
    subnet: String
}

"Supported in v5.0+"
type ManagedVolumePatchConfig {
    """

    Supported in v5.0+
    v5.0-v5.3: List of host patterns. A host pattern describes a set of hosts who can mount the host. It can either be a host name, a network in CIDR notation or hostnames matching wildcards * or ?
    v6.0-v7.0: List of host patterns. A host pattern describes a set of hosts who can mount the host. It can either be a host name, a network in CIDR notation or hostnames matching wildcards * or ?.
    v8.0: List of host patterns. A host pattern describes a set of hosts that can mount the host. It can either be a host name, a network in CIDR notation or hostnames matching wildcards * or ?.
    """
    hostPatterns: [String!]!
    """

    Supported in v5.0+
    v5.0-v7.0: List of node-ids to use for mounting this managed volume channels. Caller should specify at least one node per channel in the managed volume. If the nodeHint is not provided, system will randomly select a subset of nodes in cluster to mount the channels.
    v8.0: List of node-IDs to use for mounting the channels of this Managed Volume. Caller should specify at least one node per channel in the Managed Volume. If nodeHint is not provided, the system randomly selects a subset of Rubrik cluster nodes to mount the channels.
    """
    nodeHint: [String!]!
    """

    Supported in v5.0+
    v5.0-v5.3: Valid Active Directory domain name for users accessing this managed volume over SMB
    v6.0-v7.0: Valid Active Directory domain name for users accessing this managed volume over SMB.
    v8.0: Valid Active Directory domain name for users accessing this Managed Volume over SMB.
    """
    smbDomainName: String
    """

    Supported in v5.0+
    v5.0-v5.3: List of valid SMB host IP addresses that can access the SMB share for this managed volume. This parameter is required when the value of shareType is SMB
    v6.0-v7.0: List of valid SMB host IP addresses that can access the SMB share for this managed volume. This parameter is required when the value of shareType is SMB.
    v8.0: List of valid SMB host IP addresses that can access the SMB share for this Managed Volume. This parameter is required when the value of shareType is SMB.
    """
    smbValidIps: [String!]!
    """

    Supported in v5.0+
    v5.0-v5.3: List of valid usersnames in the domain that can access the SMB share for this managed volume. This parameter is required when the value of shareType is SMB
    v6.0-v7.0: List of valid usersnames in the domain that can access the SMB share for this managed volume. This parameter is required when the value of shareType is SMB.
    v8.0: List of valid usersnames in the domain that can access the SMB share for this Managed Volume. This parameter is required when the value of shareType is SMB.
    """
    smbValidUsers: [String!]!
}

"Paginated list of ManagedVolumePhysicalChildType objects."
type ManagedVolumePhysicalChildTypeConnection {
    "Total number of ManagedVolumePhysicalChildType objects matching the request arguments."
    count: Int!
    "List of ManagedVolumePhysicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [ManagedVolumePhysicalChildTypeEdge!]!
    "List of ManagedVolumePhysicalChildType objects."
    nodes: [ManagedVolumePhysicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the ManagedVolumePhysicalChildType object. This wrapper is used for pagination."
type ManagedVolumePhysicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual ManagedVolumePhysicalChildType object wrapped by this edge."
    node: ManagedVolumePhysicalChildType!
}

"Client configuration related to backup scripts."
type ManagedVolumeSlaClientConfig {
    "Backup script configuration."
    backupScript: ManagedVolumeSlaScriptConfig!
    "Host mount path for the channels."
    channelHostMountPaths: [String!]!
    "Post failed backup script configuration."
    failedPostBackupScript: ManagedVolumeSlaScriptConfig
    "Pre backup script configuration."
    preBackupScript: ManagedVolumeSlaScriptConfig
    "Cancel backup if pre backup script fails."
    shouldCancelBackupOnPreBackupScriptFailure: Boolean!
    "Post successful backup script configuration."
    successfulPostBackupScript: ManagedVolumeSlaScriptConfig
    "Client username."
    username: String!
}

"Backup script configurations."
type ManagedVolumeSlaScriptConfig {
    "Full command with arguments to execute the script."
    scriptCommand: String!
    "Timeout for the script in seconds."
    timeout: Long!
}

"SMB share information of the channel."
type ManagedVolumeSmbShare {
    "List of active directory groups."
    activeDirectoryGroups: [String!]!
    "Domain name of the Managed Volume."
    domainName: String!
    "List of valid IPs."
    validIps: [String!]!
    "List of valid users."
    validUsers: [String!]!
}

"Supported in v5.0+"
type ManagedVolumeSummary {
    applicationTag: ManagedVolumeApplicationTagEnum
    """

    Required. Supported in v5.0+
    v5.0-v5.3: List of host patterns. A host pattern describes a set of hosts who can mount the host. It can either be a host name, a network in CIDR notation or hostnames matching wildcards * or ?
    v6.0-v7.0: List of host patterns. A host pattern describes a set of hosts who can mount the host. It can either be a host name, a network in CIDR notation or hostnames matching wildcards * or ?.
    v8.0: List of host patterns. A host pattern describes a set of hosts that can mount the host. It can either be a host name, a network in CIDR notation or hostnames matching wildcards * or ?.
    """
    hostPatterns: [String!]!
    """

    Required. Supported in v5.0+
    v5.0-v5.3: Indicates whether the managed volume is deleted
    v6.0-v7.0: Indicates whether the managed volume is deleted.
    v8.0: Indicates if the Managed Volume is deleted.
    """
    isDeleted: Boolean!
    """

    Required. Supported in v5.0+
    v5.0-v7.0: Is managed volume a relic.
    v8.0: Indicates if the Managed Volume is a relic.
    """
    isRelic: Boolean!
    """

    Required. Supported in v5.0+
    v5.0-v5.3: Indicates whether managed volume is open for writes
    v6.0-v7.0: Indicates whether managed volume is open for writes.
    v8.0: Indicates if the Managed Volume is open for writes.
    """
    isWritable: Boolean!
    """

    Supported in v5.0+
    v5.0-v7.0: List of links for the managed volume.
    v8.0: List of links for the Managed Volume.
    """
    links: [Link!]!
    "Supported in v5.0+"
    mainExport: ManagedVolumeExport
    mvType: ManagedVolumeTypeEnum
    """

    Required. Supported in v5.0+
    v5.0-v7.0: Number of channels to divide the volume into. Each channel provides a unique share to write to.
    v8.0: Number of channels to divide the Managed Volume into. Each channel provides a unique share for writing.
    """
    numChannels: Int!
    """

    Supported in v5.3+
    Describes any pending SLA Domain assignment on this object.
    """
    pendingSlaDomain: ManagedObjectPendingSlaInfo
    """

    Required. Supported in v5.0+
    v5.0-v7.0: Combined total of in-progress snapshots and pending snapshots.
    v8.0: Combined total of in-progress and pending snapshots.
    """
    pendingSnapshotCount: Int!
    shareType: ManagedVolumeShareTypeEnum!
    """

    Supported in v5.3+
    The additional details specific to SLA Managed Volumes.
    """
    slaManagedVolumeDetails: SlaManagedVolumeDetail
    """

    Supported in v5.0+
    v5.0-v5.3: Valid Active Directory domain name for users accessing this managed volume over SMB
    v6.0-v7.0: Valid Active Directory domain name for users accessing this managed volume over SMB.
    v8.0: Valid Active Directory domain name for users accessing this Managed Volume over SMB.
    """
    smbDomainName: String
    """

    Supported in v5.0+
    v5.0-v5.3: List of valid SMB host IP addresses that can access the SMB share for this managed volume. This parameter is required when the value of shareType is SMB
    v6.0-v7.0: List of valid SMB host IP addresses that can access the SMB share for this managed volume. This parameter is required when the value of shareType is SMB.
    v8.0: List of valid SMB host IP addresses that can access the SMB share for this Managed Volume. This parameter is required when the value of shareType is SMB.
    """
    smbValidIps: [String!]!
    """

    Supported in v5.0+
    v5.0-v5.3: List of valid usersnames in the domain that can access the SMB share for this managed volume. This parameter is required when the value of shareType is SMB
    v6.0-v7.0: List of valid usersnames in the domain that can access the SMB share for this managed volume. This parameter is required when the value of shareType is SMB.
    v8.0: List of valid usersnames in the domain that can access the SMB share for this Managed Volume. This parameter is required when the value of shareType is SMB.
    """
    smbValidUsers: [String!]!
    snappable: CDMSnappable
    """

    Required. Supported in v5.0+
    Number of snapshots.
    """
    snapshotCount: Int!
    state: ManagedVolumeStateEnum!
    """

    Supported in v5.0+
    v5.0-v7.0: Specify the subnet associated with the managed volume.
    v8.0: Specifies the subnet associated with the Managed Volume.
    """
    subnet: String
    """

    Required. Supported in v5.0+
    v5.0-v7.0: Used capacity for the volume across all the channels in bytes.
    v8.0: Used capacity, in bytes, for the Managed Volume across all channels.
    """
    usedSize: Long!
    """

    Required. Supported in v5.0+
    v5.0-v7.0: Maximum capacity for the volume across all the channels in bytes.
    v8.0: Maximum capacity, in bytes, for the Managed Volume across all channels.
    """
    volumeSize: Long!
}

"Response of the operation to map Azure cloud accounts to an exocompute subscription."
type MapAzureCloudAccountExocomputeSubscriptionReply {
    "Specifies whether the mapping was completed successfully."
    isSuccess: Boolean!
}

"Response of the operation to map Azure cloud accounts to a persistent storage location."
type MapAzureCloudAccountToPersistentStorageLocationReply {
    "Specifies whether the mapping was completed successfully."
    isSuccess: Boolean!
}

type Metadata {
    key: String!
    value: Value
}

type MinuteSnapshotSchedule {
    basicSchedule: BasicSnapshotSchedule
}

"Supported in v5.0+"
type MissedSnapshot {
    "Required. Supported in v5.0+"
    archivalLocationType: [String!]!
    "Required. Supported in v5.0+"
    missedSnapshotTime: DateTime
    "Required. Supported in v5.0+"
    missedSnapshotTimeUnits: [MissedSnapshotTimeUnitConfig!]!
}

"The missed snapshot object associated with the vm"
type MissedSnapshotCommon {
    archivalLocationType: [String!]!
    date: DateTime!
}

"Paginated list of MissedSnapshotCommon objects."
type MissedSnapshotCommonConnection {
    "Total number of MissedSnapshotCommon objects matching the request arguments."
    count: Int!
    "List of MissedSnapshotCommon objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [MissedSnapshotCommonEdge!]!
    "List of MissedSnapshotCommon objects."
    nodes: [MissedSnapshotCommon!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the MissedSnapshotCommon object. This wrapper is used for pagination."
type MissedSnapshotCommonEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual MissedSnapshotCommon object wrapped by this edge."
    node: MissedSnapshotCommon!
}

"Missed Snapshot data with groupby info applied to it."
type MissedSnapshotGroupBy {
    "The data groupby info."
    groupByInfo: MissedSnapshotGroupByInfo!
    "Paginated missed snapshot data."
    missedSnapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the first n elements from the list."
        first: Int,
        "sort snapshots by field"
        sortBy: MissedSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): MissedSnapshotCommonConnection!
    "Further provide groupings for the data."
    missedSnapshotGroupBy(
        "group snapshots by field"
        groupBy: MissedSnapshotGroupByEnum!
    ): [MissedSnapshotGroupBy!]!
}

"Paginated list of MissedSnapshotGroupBy objects."
type MissedSnapshotGroupByConnection {
    "Total number of MissedSnapshotGroupBy objects matching the request arguments."
    count: Int!
    "List of MissedSnapshotGroupBy objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [MissedSnapshotGroupByEdge!]!
    "List of MissedSnapshotGroupBy objects."
    nodes: [MissedSnapshotGroupBy!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the MissedSnapshotGroupBy object. This wrapper is used for pagination."
type MissedSnapshotGroupByEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual MissedSnapshotGroupBy object wrapped by this edge."
    node: MissedSnapshotGroupBy!
}

"Supported in v5.0+"
type MissedSnapshotListResponse {
    """

    Supported in v5.0+
    List of matching objects.
    """
    data: [MissedSnapshot!]!
    """

    Supported in v5.0+
    If there is more.
    """
    hasMore: Boolean
    """

    Supported in v5.0+
    Total list responses.
    """
    total: Long
}

"Supported in v5.0+"
type MissedSnapshotTimeUnitConfig {
    dayOfTime: MissedSnapshotDayOfTimeUnitEnum
    "Required. Supported in v5.0+"
    frequency: Int!
    "Required. Supported in v5.0+"
    retention: Int!
    timeUnit: SlaTimeUnitEnum!
}

"Backup parameters configured on the management object."
type MongodbBackupParams {
    "Name of the store used to store backups."
    storeName: String!
    "Monitoring frequency used by watcher."
    watcherFrequency: Long!
}

"Information about MongoDB Collection."
type MongodbCollection implements HierarchyObject & MongodbDatabaseDescendantType & MongodbDatabasePhysicalChildType & MongodbSourceDescendantType & PolarisHierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [PolarisObjectAuthorizedOperationsEnum!]!
    "Number of backups for the MongoDB collection."
    backupCount: Int
    "Backup parameters for the MongoDB collection."
    backupParams: MongodbBackupParams
    "Mosaic cluster information"
    cluster: Cluster!
    "UUID of the Mosaic cluster."
    clusterUuid: UUID!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "Parent database connection"
    database: MongodbDatabase!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    id: UUID!
    isRelic: Boolean!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The most recent snapshot of this snappable."
    newestSnapshot: MosaicSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this snappable."
    oldestSnapshot: MosaicSnapshot
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "Group By paginated list for mongodb snapshots."
    snapshotGroupBys(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Filter mosaic snapshot connection."
        filter: MosaicSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Group mosaic snapshots by field."
        groupBy: MosaicSnapshotGroupBy!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): MosaicSnapshotGroupByTypeConnection
    "Paginated list of snapshots for Mongodb collection."
    snapshots(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Filter mosaic snapshot connection."
        filter: MosaicSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Sort mosaic snapshots by field."
        sortBy: MosaicSnapshotSortBy = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): MosaicSnapshotConnection!
    "Parent source connection"
    source: MongodbSource!
}

"Paginated list of MongodbCollection objects."
type MongodbCollectionConnection {
    "Total number of MongodbCollection objects matching the request arguments."
    count: Int!
    "List of MongodbCollection objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [MongodbCollectionEdge!]!
    "List of MongodbCollection objects."
    nodes: [MongodbCollection!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the MongodbCollection object. This wrapper is used for pagination."
type MongodbCollectionEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual MongodbCollection object wrapped by this edge."
    node: MongodbCollection!
}

"Information about MongoDB Database."
type MongodbDatabase implements HierarchyObject & MongodbSourceDescendantType & MongodbSourcePhysicalChildType & PolarisHierarchyObject {
    backupCount: Int
    "Backup parameters for the MongoDB database."
    backupParams: MongodbBackupParams
    "Mosaic cluster information"
    cluster: Cluster!
    "UUID of the Nosql cluster."
    clusterUuid: UUID!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): MongodbDatabaseDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    isRelic: Boolean!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "List of physical children"
    physicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): MongodbDatabasePhysicalChildTypeConnection!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "Parent source connection"
    source: MongodbSource!
    "Watcher status of this MongoDB database."
    watcherEnabled: Boolean!
}

"Paginated list of MongodbDatabase objects."
type MongodbDatabaseConnection {
    "Total number of MongodbDatabase objects matching the request arguments."
    count: Int!
    "List of MongodbDatabase objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [MongodbDatabaseEdge!]!
    "List of MongodbDatabase objects."
    nodes: [MongodbDatabase!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Paginated list of MongodbDatabaseDescendantType objects."
type MongodbDatabaseDescendantTypeConnection {
    "Total number of MongodbDatabaseDescendantType objects matching the request arguments."
    count: Int!
    "List of MongodbDatabaseDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [MongodbDatabaseDescendantTypeEdge!]!
    "List of MongodbDatabaseDescendantType objects."
    nodes: [MongodbDatabaseDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the MongodbDatabaseDescendantType object. This wrapper is used for pagination."
type MongodbDatabaseDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual MongodbDatabaseDescendantType object wrapped by this edge."
    node: MongodbDatabaseDescendantType!
}

"Wrapper around the MongodbDatabase object. This wrapper is used for pagination."
type MongodbDatabaseEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual MongodbDatabase object wrapped by this edge."
    node: MongodbDatabase!
}

"Paginated list of MongodbDatabasePhysicalChildType objects."
type MongodbDatabasePhysicalChildTypeConnection {
    "Total number of MongodbDatabasePhysicalChildType objects matching the request arguments."
    count: Int!
    "List of MongodbDatabasePhysicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [MongodbDatabasePhysicalChildTypeEdge!]!
    "List of MongodbDatabasePhysicalChildType objects."
    nodes: [MongodbDatabasePhysicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the MongodbDatabasePhysicalChildType object. This wrapper is used for pagination."
type MongodbDatabasePhysicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual MongodbDatabasePhysicalChildType object wrapped by this edge."
    node: MongodbDatabasePhysicalChildType!
}

"Host description for MongoDB source object."
type MongodbHost {
    "Host address of MongoDB."
    hostname: String!
    "Port on which MongoDB is running."
    port: String!
}

"Information about MongoDB Source."
type MongodbSource implements HierarchyObject & PolarisHierarchyObject {
    "Number of backups for the MongoDB source cluster."
    backupCount: Int
    "Backup Parameters for the MongoDB source cluster."
    backupParams: MongodbBackupParams
    "Information about NoSql cluster for this MongoDB cluster"
    cluster: Cluster!
    "UUID of the Nosql cluster."
    clusterUuid: UUID!
    "Configuration Params for the MongoDB source cluster."
    configParams: MongodbSourceConfigParams
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): MongodbSourceDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "Number of nodes in MongoDB source node."
    nodeCount: Int
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "List of physical children"
    physicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): MongodbSourcePhysicalChildTypeConnection!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "Overall data size of MongoDB source cluster in bytes."
    size: Long
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "IP of the MongoDB source."
    sourceIp: String!
    "Source connectivity status."
    status: MongodbSourceStatus!
    "Watcher status for the MongoDB source cluster."
    watcherEnabled: Boolean!
}

"Configuration parameters for the MongoDB source object."
type MongodbSourceConfigParams {
    "We do not backup the secondary nodes if this configuration is true."
    ignoreSecondaries: [MongodbHost!]!
    "List of seed hosts for establishing connection to source cluster."
    mongodbHosts: [MongodbHost!]!
    "Username for MongoDB source ."
    sourceDbUser: String!
    "SSH user name for the source nodes."
    sourceNodeUser: String!
    "SSH Port."
    sourceSshPort: Int!
    "SSL configuration for the source cluster."
    sslOptions: MongodbSslOptions
}

"Paginated list of MongodbSource objects."
type MongodbSourceConnection {
    "Total number of MongodbSource objects matching the request arguments."
    count: Int!
    "List of MongodbSource objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [MongodbSourceEdge!]!
    "List of MongodbSource objects."
    nodes: [MongodbSource!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Paginated list of MongodbSourceDescendantType objects."
type MongodbSourceDescendantTypeConnection {
    "Total number of MongodbSourceDescendantType objects matching the request arguments."
    count: Int!
    "List of MongodbSourceDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [MongodbSourceDescendantTypeEdge!]!
    "List of MongodbSourceDescendantType objects."
    nodes: [MongodbSourceDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the MongodbSourceDescendantType object. This wrapper is used for pagination."
type MongodbSourceDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual MongodbSourceDescendantType object wrapped by this edge."
    node: MongodbSourceDescendantType!
}

"Wrapper around the MongodbSource object. This wrapper is used for pagination."
type MongodbSourceEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual MongodbSource object wrapped by this edge."
    node: MongodbSource!
}

"Paginated list of MongodbSourcePhysicalChildType objects."
type MongodbSourcePhysicalChildTypeConnection {
    "Total number of MongodbSourcePhysicalChildType objects matching the request arguments."
    count: Int!
    "List of MongodbSourcePhysicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [MongodbSourcePhysicalChildTypeEdge!]!
    "List of MongodbSourcePhysicalChildType objects."
    nodes: [MongodbSourcePhysicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the MongodbSourcePhysicalChildType object. This wrapper is used for pagination."
type MongodbSourcePhysicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual MongodbSourcePhysicalChildType object wrapped by this edge."
    node: MongodbSourcePhysicalChildType!
}

"SSL Configuration for MongoDB source object."
type MongodbSslOptions {
    "Whether ssl is enabled or not."
    ssl: Boolean!
    "Path to CA certificate."
    sslCaCerts: String!
    "SSL certificate requirements."
    sslCertRequirements: SourceSslCertReqsEnum!
    "Path to SSL Certificate."
    sslCertfile: String!
    "Path to SSL Key."
    sslKeyfile: String!
}

type MonthlySnapshotSchedule {
    basicSchedule: BasicSnapshotSchedule
    dayOfMonth: DayOfMonth!
}

"Supported in m3.2.0-m4.1.0"
type MosaicAsyncResponse {
    """

    Supported in m3.2.0-m4.1.0
    Mosaic Job ID of submitted job in case of successful job submission. This job id can be used to track progress of the request.
    """
    data: String
    """

    Supported in m3.2.0-m4.1.0
    Error message in case of failure
    """
    message: String
    """

    Supported in m3.2.0-m4.1.0
    Return Code from Mosaic
    """
    returnCode: Long
    """

    Supported in m3.2.0-m4.1.0
    Status of the request
    """
    status: Boolean
}

"Supported in m3.2.0-m4.1.0"
type MosaicRecoverableRangeObject {
    "Supported in m3.2.0-m4.1.0"
    earliestTimestamp: String
    "Supported in m3.2.0-m4.1.0"
    latestTimestamp: String
}

"Supported in m3.2.0-m4.1.0"
type MosaicRecoveryRangeObject {
    """

    Supported in m3.2.0-m4.1.0
    Start timestamp of recovery range
    """
    earliestTimestamp: String
    """

    Supported in m3.2.0-m4.1.0
    End timestamp of recovery range
    """
    latestTimestamp: String
}

"Supported in m3.2.0-m4.1.0"
type MosaicRecoveryRangeResponse {
    """

    Supported in m3.2.0-m4.1.0
    Object with details of Any Point In Time restore Range
    """
    data: MosaicRecoveryRangeObject
    """

    Supported in m3.2.0-m4.1.0
    Response Message string
    """
    message: String
    """

    Supported in m3.2.0-m4.1.0
    Return Code
    """
    returnCode: Long
    """

    Supported in m3.2.0-m4.1.0
    Status of the request
    """
    status: Boolean
}

"Mosaic Snapshot information."
type MosaicSnapshot {
    "ID of the Mosaic cluster."
    clusterUuid: UUID!
    "Snapshot size information."
    dbInfo: String
    "Time of expiration."
    expirationTime: DateTime
    "ID of the snapshot."
    id: String!
    "Duration of the snapshot job."
    jobDuration: Int
    "Sla domain of the snapshot."
    slaDomain: SlaDomain
    snappableId: String!
    "Snapshot type."
    snapshotType: MosaicSnapshotType!
    "Time of the snapshot version."
    version: DateTime!
    "State of the snapshot version."
    versionState: String
}

"Paginated list of MosaicSnapshot objects."
type MosaicSnapshotConnection {
    "Total number of MosaicSnapshot objects matching the request arguments."
    count: Int!
    "List of MosaicSnapshot objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [MosaicSnapshotEdge!]!
    "List of MosaicSnapshot objects."
    nodes: [MosaicSnapshot!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the MosaicSnapshot object. This wrapper is used for pagination."
type MosaicSnapshotEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual MosaicSnapshot object wrapped by this edge."
    node: MosaicSnapshot!
}

"Mosaic Snapshot data with group by info applied to it."
type MosaicSnapshotGroupByType {
    "Further provide groupings for the data."
    allSnapshotGroupBys(
        "Group mosaic snapshots by field."
        groupBy: MosaicSnapshotGroupBy!
    ): [MosaicSnapshotGroupByType!]!
    "The data group by info."
    groupByInfo: MosaicSnapshotGroupByInfo!
    "Paginated snapshot data."
    snapshots(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Sort mosaic snapshots by field."
        sortBy: MosaicSnapshotSortBy = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): MosaicSnapshotConnection!
}

"Paginated list of MosaicSnapshotGroupByType objects."
type MosaicSnapshotGroupByTypeConnection {
    "Total number of MosaicSnapshotGroupByType objects matching the request arguments."
    count: Int!
    "List of MosaicSnapshotGroupByType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [MosaicSnapshotGroupByTypeEdge!]!
    "List of MosaicSnapshotGroupByType objects."
    nodes: [MosaicSnapshotGroupByType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the MosaicSnapshotGroupByType object. This wrapper is used for pagination."
type MosaicSnapshotGroupByTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual MosaicSnapshotGroupByType object wrapped by this edge."
    node: MosaicSnapshotGroupByType!
}

"Response object for list store on mosaic."
type MosaicStorageLocation {
    "Count of backups stored in storage location."
    backupCount: Int!
    "UUID of Mosaic Cluster."
    clusterUuid: String!
    "Various parameters used for connecting with store."
    connectionParameters: MosaicStoreConnectionParameters
    "Fid of Mosaic Storage Locations."
    fid: String!
    "Geographic Location of Store."
    geographicLocation: String!
    "Mosaic ID of Storage Location."
    id: String!
    "Space consumed on storage location."
    spaceConsumedBytes: Long!
    "Name of Storage Location."
    storageLocationName: String!
    "Connection Status of Mosaic with Store."
    storeConnectionStatus: MosaicStoreConnectionStatus!
    "Type of Mosaic Store."
    storeType: MosaicStoreType!
}

"Response object for list store on mosaic."
type MosaicStoreConnectionParameters {
    "NFS server IP."
    nfsServer: String!
    "Mount Path on NFS Server."
    nfsServerMountPath: String!
    "URL of store."
    storeUrl: String!
}

"""

Supported in m3.2.0-m4.1.0
Object for stores added on mosaic.
"""
type MosaicStoreObject {
    """

    Required. Supported in m3.2.0-m4.1.0
    UUID of the store
    """
    id: String!
    """

    Supported in m3.2.0-m4.1.0
    Metadata information for store
    """
    storeMetadata: StoreMetadata
    """

    Required. Supported in m3.2.0-m4.1.0
    Name of the store
    """
    storeName: String!
    storeType: MosaicStoreObjectStoreTypeEnum!
    """

    Required. Supported in m3.2.0-m4.1.0
    Store path/url.
    """
    storeUrl: String!
    """

    Supported in m3.2.0-m4.1.0
    Url for nfs server.
    """
    surlNfs: String
}

"""

Supported in m3.2.0-m4.1.0
Object for mosaic versions.
"""
type MosaicVersionObject {
    """

    Supported in m3.2.0-m4.1.0
    Information of version space
    """
    dbInfo: String
    """

    Supported in m3.2.0-m4.1.0
    Expiration time of the version
    """
    expirationTime: Int
    """

    Supported in m3.2.0-m4.1.0
    UUID of group policy
    """
    groupPolicyId: String
    """

    Supported in m3.2.0-m4.1.0
    UUID of the version
    """
    id: String
    """

    Supported in m3.2.0-m4.1.0
    Type of interval
    """
    intervalType: Int
    """

    Supported in m3.2.0-m4.1.0
    Duration of the backup job
    """
    jobDuration: Int
    """

    Supported in m3.2.0-m4.1.0
    Need sstable loader
    """
    needSstableLoaderStr: String
    """

    Supported in m3.2.0-m4.1.0
    Replica set
    """
    rsList: String
    """

    Supported in m3.2.0-m4.1.0
    Name of the management object
    """
    sourceMgmtObj: String
    """

    Supported in m3.2.0-m4.1.0
    Name of the source
    """
    sourceName: String
    """

    Supported in m3.2.0-m4.1.0
    Type of the source
    """
    sourceType: String
    """

    Supported in m3.2.0-m4.1.0
    UUID of system policy
    """
    systemPolicyId: String
    """

    Supported in m3.2.0-m4.1.0
    Timestamp of the version
    """
    timestamp: Int
    versionState: MosaicVersionObjectVersionStateEnum
}

"Details about the mounted volume."
type MountedVolume {
    "Volume's file system type."
    fileSystemType: String!
    "Mount path in host."
    hostMountPath: String
    "Id of the mounted volume."
    id: String!
    "Volume's mount points."
    originalMountPoints: [String!]!
    "Size of the mounted volume."
    size: Long!
    "Volume's Smb Path."
    smbPath: String
}

type MssqlAvailabilityGroup implements CdmHierarchyObject & HierarchyObject & MssqlTopLevelDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "CopyOnly flag of the availability group."
    copyOnly: Boolean!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): MssqlAvailabilityGroupDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "Boolean flag indicating if the availability group derives log backup configurations from SLA."
    hasLogConfigFromSla: Boolean!
    "The fid of the hierarchy object."
    id: UUID!
    "The list of instances associated with an Availability Group."
    instances: [MssqlInstance!]!
    "Latest User note information."
    latestUserNote: LatestUserNote
    logBackupFrequencyInSeconds: Long!
    logBackupRetentionInHours: Int!
    "List of logical children"
    logicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): MssqlAvailabilityGroupLogicalChildTypeConnection!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"Paginated list of MssqlAvailabilityGroupDescendantType objects."
type MssqlAvailabilityGroupDescendantTypeConnection {
    "Total number of MssqlAvailabilityGroupDescendantType objects matching the request arguments."
    count: Int!
    "List of MssqlAvailabilityGroupDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [MssqlAvailabilityGroupDescendantTypeEdge!]!
    "List of MssqlAvailabilityGroupDescendantType objects."
    nodes: [MssqlAvailabilityGroupDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the MssqlAvailabilityGroupDescendantType object. This wrapper is used for pagination."
type MssqlAvailabilityGroupDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual MssqlAvailabilityGroupDescendantType object wrapped by this edge."
    node: MssqlAvailabilityGroupDescendantType!
}

"Paginated list of MssqlAvailabilityGroupLogicalChildType objects."
type MssqlAvailabilityGroupLogicalChildTypeConnection {
    "Total number of MssqlAvailabilityGroupLogicalChildType objects matching the request arguments."
    count: Int!
    "List of MssqlAvailabilityGroupLogicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [MssqlAvailabilityGroupLogicalChildTypeEdge!]!
    "List of MssqlAvailabilityGroupLogicalChildType objects."
    nodes: [MssqlAvailabilityGroupLogicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the MssqlAvailabilityGroupLogicalChildType object. This wrapper is used for pagination."
type MssqlAvailabilityGroupLogicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual MssqlAvailabilityGroupLogicalChildType object wrapped by this edge."
    node: MssqlAvailabilityGroupLogicalChildType!
}

"Supported in v5.2+"
type MssqlBackup {
    """

    Required. Supported in v5.2+
    The unique identifier for the object.
    """
    backupId: String!
    """

    Required. Supported in v5.2+
    The total uncompressed size of the files in bytes.
    """
    backupSize: Long!
    backupType: MssqlBackupTypeEnum!
    """

    Required. Supported in v5.2+
    Timestamp of the backup.
    """
    date: DateTime
    """

    Required. Supported in v5.2+
    LSN of the backup.
    """
    lsn: String!
    """

    Required. Supported in v5.2+
    The file path the backup will be stored at in downloaded zip files containing it.
    """
    path: String!
    """

    Required. Supported in v5.2+
    GUID of the recovery fork attached to the LSN.
    """
    recoveryForkGuid: String!
}

"Supported in v5.2+"
type MssqlBackups {
    """

    Required. Supported in v5.2+
    A list of snapshots and logs.
    """
    items: [MssqlBackup!]!
}

"The SLA Domain configuration for SQL Server database."
type MssqlConfig {
    "Frequency value for log backups of SQL Server databases."
    frequency: Duration
    "Specifies the duration for which the logs will be retained."
    logRetention: Duration
}

type MssqlDatabase implements CdmHierarchyObject & CdmHierarchySnappableNew & HierarchyObject & MssqlAvailabilityGroupDescendantType & MssqlAvailabilityGroupLogicalChildType & MssqlInstanceDescendantType & MssqlInstanceLogicalChildType & MssqlTopLevelDescendantType & PhysicalHostDescendantType & WindowsClusterDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "List of snapshots taken for a CDM snappable grouped by attributes."
    cdmGroupedSnapshots(
        "Filter CDM snapshots."
        CdmSnapshotFilter: [CdmSnapshotFilter!],
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: CdmSnapshotGroupByEnum!,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmGroupedSnapshotConnection!
    cdmId: String!
    "A link to view the snappable on the CDM cluster. For dev use only."
    cdmLink: String!
    "The newest snapshot taken for a CDM snappable."
    cdmNewestSnapshot: CDMSnapshot
    "The oldest snapshot taken for a CDM snappable."
    cdmOldestSnapshot: CDMSnapshot
    "The count of on demand snapshots for an MSSQL database."
    cdmOnDemandSnapshotCount: Int!
    "The list of snapshots taken for an MSSQL database."
    cdmSnapshots(
        "Filter CDM snapshots."
        CdmSnapshotFilter: [CdmSnapshotFilter!],
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the first n elements from the list."
        first: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CDMSnapshotConnection!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    copyOnly: Boolean!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "Boolean flag indicating if the database derives log backup configurations from SLA."
    hasLogConfigFromSla: Boolean!
    hasPermissions: Boolean!
    "The fid of the hierarchy object."
    id: UUID!
    isInAvailabilityGroup: Boolean!
    isLogShippingSecondary: Boolean!
    isOnline: Boolean!
    isRelic: Boolean!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "List of live mounts for a MSSQL database."
    liveMounts(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Filters for Mssql database live mounts."
        filters: [MssqlDatabaseLiveMountFilterInput!],
        "Returns the first n elements from the list."
        first: Int,
        "Sort by argument for Mssql database live mounts."
        sortBy: MssqlDatabaseLiveMountSortByInput
    ): CdmMssqlDatabaseLiveMountConnection!
    logBackupFrequencyInSeconds: Float!
    logBackupRetentionInHours: Int!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The list of missed snapshots for this workload."
    missedSnapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int
    ): MissedSnapshotCommonConnection
    "The list of missed snapshots for this workload."
    missedSnapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: MissedSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): MissedSnapshotGroupByConnection
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot archived to AWS."
    newestArchivedSnapshot: CdmSnapshot
    "The newest snapshot replicated to a cluster."
    newestReplicatedSnapshot: CdmSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: CdmSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: CdmSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    postBackupScript: String!
    preBackupScript: String!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    recoveryModel: String!
    replicas: [CdmMssqlDbReplica!]!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for the snapshots of this workload."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: CdmSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): cdmSnapshotGroupByConnection
    unprotectableReasons: [String!]!
}

"Paginated list of MssqlDatabase objects."
type MssqlDatabaseConnection {
    "Total number of MssqlDatabase objects matching the request arguments."
    count: Int!
    "List of MssqlDatabase objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [MssqlDatabaseEdge!]!
    "List of MssqlDatabase objects."
    nodes: [MssqlDatabase!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the MssqlDatabase object. This wrapper is used for pagination."
type MssqlDatabaseEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual MssqlDatabase object wrapped by this edge."
    node: MssqlDatabase!
}

"Supported in v5.0+"
type MssqlDbDefaults {
    """

    Required. Supported in v5.0+
    v5.0-v5.2: True to enable CBT based backup, false to disable.
    v5.3+: True to enable a CBT-based backup, false to disable a CBT-based backup.
    """
    cbtStatus: Boolean!
    "Required. Supported in v5.0+"
    logBackupFrequencyInSeconds: Long!
    "Supported in v5.3+"
    logRetentionTimeInHours: Int
    """

    Supported in v7.0+
    Use the default backup location configured in SQL Server for file-based log backups.
    """
    shouldUseDefaultBackupLocation: Boolean
}

"Supported in v5.0+"
type MssqlDbDetail {
    "Supported in v5.0+"
    archiveStorage: Long
    blackoutWindowResponseInfo: BlackoutWindowResponseInfo
    "Supported in v5.0+"
    isLocal: Boolean
    """

    Supported in v5.0+
    This field is deprecated. Use the isStandby field on the replicas list instead. This field will continue to work for non-availability databases, but it is meaningless for availability databases.
    """
    isStandby: Boolean
    latestRecoveryPointV50: String
    latestRecoveryPointV51: String
    latestRecoveryPointV52: String
    latestRecoveryPointV53: String
    latestRecoveryPointV60: DateTime
    latestRecoveryPointV70: DateTime
    latestRecoveryPointV80: DateTime
    "Supported in v5.0+"
    localStorage: Long
    "Supported in v5.0+"
    maxDataStreams: Int
    mssqlDbSummary: MssqlDbSummary
    oldestRecoveryPointV50: String
    oldestRecoveryPointV51: String
    oldestRecoveryPointV52: String
    oldestRecoveryPointV53: String
    oldestRecoveryPointV60: DateTime
    oldestRecoveryPointV70: DateTime
    oldestRecoveryPointV80: DateTime
    "Supported in v5.0+"
    postBackupScript: MssqlScriptDetail
    "Supported in v5.0+"
    preBackupScript: MssqlScriptDetail
    protectionDateV50: String
    protectionDateV51: String
    protectionDateV52: String
    protectionDateV53: String
    protectionDateV60: DateTime
    protectionDateV70: DateTime
    protectionDateV80: DateTime
    """

    Supported in v5.0+
    This field is deprecated. Use the recoveryForkGuid field on the replicas list instead. This field will continue to work for non-availability databases, but it is meaningless for availability databases.
    """
    recoveryForkGuid: String
    "Required. Supported in v5.0+"
    snapshotCount: Int!
}

"Supported in v5.0+"
type MssqlDbReplica {
    """

    Supported in v5.0+
    For an availability database, provides additional information about a database replica.
    """
    availabilityInfo: MssqlDbReplicaAvailabilityInfo
    """

    Required. Supported in v5.0+
    `True` when the Rubrik cluster has sufficient permissions to perform all necessary operations.
    """
    hasPermissions: Boolean!
    """

    Required. Supported in v5.0+
    ID of the SQL Server instance managing the replica.
    """
    instanceId: String!
    """

    Required. Supported in v5.0+
    Name of the SQL Server instance managing the replica.
    """
    instanceName: String!
    """

    Required. Supported in v5.0+
    Deprecated. Please use 'isDeleted' instead.
    """
    isArchived: Boolean!
    """

    Required. Supported in v5.0+
    `True` when the replica is deleted.
    """
    isDeleted: Boolean!
    """

    Required. Supported in v5.0+
    `True` when the replica is in standby mode.
    """
    isStandby: Boolean!
    """

    Supported in v5.0+
    The recovery fork GUID of the replica.
    """
    recoveryForkGuid: String
    recoveryModel: MssqlDbReplicaRecoveryModelEnum!
    "Required. Supported in v5.0+"
    rootProperties: MssqlRootProperties
    """

    Required. Supported in v5.0+
    The state of the replica.
    """
    state: String!
}

"Supported in v5.0+"
type MssqlDbReplicaAvailabilityInfo {
    role: MssqlDbReplicaAvailabilityInfoRoleEnum!
}

"Supported in v5.0+"
type MssqlDbSummary {
    """

    Supported in v5.0+
    For an availability database, the ID of the availability group that the database belongs to.
    """
    availabilityGroupId: String
    """

    Required. Supported in v5.0+
    Boolean value that specifies whether or not to perform copy-only backups of the database. When true, database backups are copy-only backups. When false, database backups are full backups.
    """
    copyOnly: Boolean!
    """

    Supported in v5.1+
    Information about the current backup task.
    """
    currentBackupTaskInfo: BackupTaskDiagnosticInfo
    """

    Supported in v7.0+
    A boolean value that specifies whether the database derives the log backup configurations from SLA.
    """
    hasLogConfigFromSla: Boolean
    """

    Required. Supported in v5.0+
    v5.0: Boolean value that specifies whether the cluster has permission to backup the database.
    v5.1: Boolean value that specifies whether the cluster has permission to back up the database.
    v5.2+: A Boolean value that specifies whether the cluster has permission to back up the database. When this value is 'true', the cluster has permission to back up the database.
    """
    hasPermissions: Boolean!
    "Required. Supported in v5.0+"
    id: String!
    """

    Supported in v5.1+
    True/false value indicating if backup task information is included in the response.
    """
    includeBackupTaskInfo: Boolean
    """

    Supported in v5.0+
    This field is deprecated. Use the instanceId field on the replicas list instead. This field will continue to work for non-availability databases, but it is meaningless for availability databases.
    """
    instanceId: String
    """

    Supported in v5.0+
    This field is deprecated. Use the instanceName field on the replicas list instead. This field will continue to work for non-availability databases, but it is meaningless for availability databases.
    """
    instanceName: String
    "Required. Supported in v5.0+"
    isInAvailabilityGroup: Boolean!
    """

    Required. Supported in v5.0+
    Boolean value that specifies whether a database object is a Live Mount. Value is 'true' when the database object is a Live Mount.
    """
    isLiveMount: Boolean!
    """

    Required. Supported in v5.0+
    Boolean value that specifies whether a database object represents a secondary database. Value is 'true' when the database object represents a secondary database in a log shipping configuration.
    """
    isLogShippingSecondary: Boolean!
    """

    Required. Supported in v5.0+
    v5.0-v5.1: Boolean value that specifies whether the database state is ONLINE.
    v5.2+: A Boolean value that specifies whether the database is in the ONLINE state. When this value is 'true', the database is in the ONLINE state.
    """
    isOnline: Boolean!
    "Required. Supported in v5.0+"
    isRelic: Boolean!
    """

    Supported in v5.1+
    v5.1: The timestamp of the previous snapshot
    v5.2-v5.3: The timestamp of the previous snapshot. Only available in the /v1/mssql/db endpoint request body. The information will not be available for other endpoints.
    v6.0+: The timestamp of the previous snapshot.. Only available in the /v1/mssql/db endpoint request body. The information will not be available for other endpoints.
    """
    lastSnapshotTime: DateTime
    "Required. Supported in v5.0+"
    logBackupFrequencyInSeconds: Int!
    """

    Required. Supported in v5.0+
    Hours to keep a log backup. A value of -1 indicates that a log will only expire when the preceding snapshots have expired.
    """
    logBackupRetentionHours: Int!
    "Required. Supported in v5.0+"
    name: String!
    """

    Supported in v5.1+
    v5.1: An integer that specifies the number of missed snapshots.
    v5.2+: An integer that specifies the number of missed snapshots. Only available in the /v1/mssql/db endpoint request body. The information will not be available for other endpoints.
    """
    numMissedSnapshot: Int
    """

    Supported in v5.2+
    v5.2: Describes any pending SLA assignment on this object.
    v5.3+: Describes any pending SLA Domain assignment on this object.
    """
    pendingSlaDomain: ManagedObjectPendingSlaInfo
    "Required. Supported in v5.0+"
    primaryClusterId: String!
    recoveryModel: MssqlDbSummaryRecoveryModelEnum
    """

    Required. Supported in v5.0+
    List of replicas of this database. An availability database may have multiple replicas, while other databases will have only one replica.
    """
    replicas: [MssqlDbReplica!]!
    "Required. Supported in v5.0+"
    rootProperties: MssqlRootProperties
    snappable: CDMSnappable
    """

    Supported in v5.0+
    This field is deprecated. Use the state field on the replicas list instead. This field will continue to work for non-availability databases, but it is meaningless for availability databases.
    """
    state: String
    "A list of reasons that a SQL Server database cannot be protected by Rubrik."
    unprotectableReasonsV50: [MssqlUnprotectableReason!]!
    "A list of reasons that a SQL Server database cannot be protected by the Rubrik CDM."
    unprotectableReasonsV51: [String!]!
    "A list of reasons that a SQL Server database cannot be protected by the Rubrik CDM."
    unprotectableReasonsV52: [String!]!
    "A list of reasons that a SQL Server database cannot be protected by the Rubrik CDM."
    unprotectableReasonsV53: [String!]!
    "A list of reasons that a SQL Server database cannot be protected by the Rubrik CDM."
    unprotectableReasonsV60: [String!]!
    "A list of reasons that a SQL Server database cannot be protected by the Rubrik CDM."
    unprotectableReasonsV70: [String!]!
    "A list of reasons that a SQL Server database cannot be protected by the Rubrik CDM."
    unprotectableReasonsV80: [String!]!
}

type MssqlInstance implements CdmHierarchyObject & HierarchyObject & MssqlTopLevelDescendantType & PhysicalHostDescendantType & PhysicalHostPhysicalChildType & WindowsClusterDescendantType & WindowsClusterLogicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): MssqlInstanceDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "Boolean flag indicating if the instance derives log backup configurations from SLA."
    hasLogConfigFromSla: Boolean!
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    logBackupFrequencyInSeconds: Long!
    logBackupRetentionInHours: Int!
    "List of logical children"
    logicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): MssqlInstanceLogicalChildTypeConnection!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    unprotectableReasons: [String!]!
}

"Paginated list of MssqlInstanceDescendantType objects."
type MssqlInstanceDescendantTypeConnection {
    "Total number of MssqlInstanceDescendantType objects matching the request arguments."
    count: Int!
    "List of MssqlInstanceDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [MssqlInstanceDescendantTypeEdge!]!
    "List of MssqlInstanceDescendantType objects."
    nodes: [MssqlInstanceDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the MssqlInstanceDescendantType object. This wrapper is used for pagination."
type MssqlInstanceDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual MssqlInstanceDescendantType object wrapped by this edge."
    node: MssqlInstanceDescendantType!
}

"Paginated list of MssqlInstanceLogicalChildType objects."
type MssqlInstanceLogicalChildTypeConnection {
    "Total number of MssqlInstanceLogicalChildType objects matching the request arguments."
    count: Int!
    "List of MssqlInstanceLogicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [MssqlInstanceLogicalChildTypeEdge!]!
    "List of MssqlInstanceLogicalChildType objects."
    nodes: [MssqlInstanceLogicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the MssqlInstanceLogicalChildType object. This wrapper is used for pagination."
type MssqlInstanceLogicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual MssqlInstanceLogicalChildType object wrapped by this edge."
    node: MssqlInstanceLogicalChildType!
}

"Supported in v5.0+"
type MssqlInstanceSummary {
    """

    Supported in v5.0+
    The address of the instance in a Windows server failover cluster, populated only if it belongs to one.
    """
    clusterInstanceAddress: String
    """

    Supported in v5.0+
    SLA Domain ID assigned to instance.
    """
    configuredSlaDomainId: String
    """

    Supported in v5.0+
    SLA Domain name assigned to instance.
    """
    configuredSlaDomainName: String
    """

    Supported in v5.2+
    Specifies whether the SLA Domain is used for protection or retention.
    """
    configuredSlaDomainType: String
    "Required. Supported in v5.0+"
    id: String!
    "Supported in v5.0+"
    internalTimestamp: Long
    """

    Supported in v5.1+
    Boolean value that identifies a Retention Lock SLA Domain. Value is true when the SLA Domain assigned to the instance is Retention Locked and false when it is not.
    """
    isRetentionLocked: Boolean
    mssqlNonSlaProperties: MssqlNonSlaProperties
    mssqlSlaRelatedProperties: MssqlSlaRelatedProperties
    "Supported in v5.0+"
    name: String
    "Required. Supported in v5.0+"
    primaryClusterId: String!
    protectionDateV50: String
    protectionDateV51: String
    protectionDateV52: String
    protectionDateV53: String
    protectionDateV60: DateTime
    protectionDateV70: DateTime
    protectionDateV80: DateTime
    "Required. Supported in v5.0+"
    rootProperties: MssqlRootProperties
    "A list of reasons that all the SQL Server databases in a SQL Server instance cannot be protected by Rubrik."
    unprotectableReasonsV50: [MssqlUnprotectableReason!]!
    "A list of reasons that all the SQL Server databases in a SQL Server instance cannot be protected by the Rubrik CDM."
    unprotectableReasonsV51: [String!]!
    "A list of reasons that all the SQL Server databases in a SQL Server instance cannot be protected by the Rubrik CDM."
    unprotectableReasonsV52: [String!]!
    "A list of reasons that all the SQL Server databases in a SQL Server instance cannot be protected by the Rubrik CDM."
    unprotectableReasonsV53: [String!]!
    "A list of reasons that all the SQL Server databases in a SQL Server instance cannot be protected by the Rubrik CDM."
    unprotectableReasonsV60: [String!]!
    "A list of reasons that all the SQL Server databases in a SQL Server instance cannot be protected by the Rubrik CDM."
    unprotectableReasonsV70: [String!]!
    "A list of reasons that all the SQL Server databases in a SQL Server instance cannot be protected by the Rubrik CDM."
    unprotectableReasonsV80: [String!]!
    "Supported in v5.0+"
    version: String
}

"Supported in v5.0+"
type MssqlInstanceSummaryListResponse {
    """

    Supported in v5.0+
    List of matching objects.
    """
    data: [MssqlInstanceSummary!]!
    """

    Supported in v5.0+
    If there is more.
    """
    hasMore: Boolean
    """

    Supported in v5.0+
    Total list responses.
    """
    total: Long
}

"Supported in v5.3+"
type MssqlLogShippingDetailV2 {
    "Required. Supported in v5.3+"
    links: MssqlLogShippingLinks
    mssqlLogShippingSummaryV2: MssqlLogShippingSummaryV2
    """

    Supported in v5.3+
    Specifies whether to automatically disconnect users from a secondary database in standby mode when a restore operation is performed. If this value is set to false and users remain connected, any scheduled restore operations fail. This value is returned only when the secondary database is in standby mode.
    """
    shouldDisconnectStandbyUsers: Boolean
}

"Supported in v5.0+"
type MssqlLogShippingLinks {
    "Required. Supported in v5.0+"
    primaryDatabase: Link
    "Supported in v5.0+"
    secondaryDatabase: Link
    "Required. Supported in v5.0+"
    secondaryInstance: Link
    "Supported in v5.0+"
    seedRequest: Link
}

"Supported in v5.0+"
type MssqlLogShippingStatusInfo {
    """

    Required. Supported in v5.0+
    v5.0-v5.2: Detailed message describing the current status of the log shipping configuration.
    v5.3+: Detailed message describing the status of the log shipping configuration.
    """
    message: String!
    status: MssqlLogShippingStatusEnum!
}

"Supported in v5.0+"
type MssqlLogShippingSummary {
    """

    Required. Supported in v5.0+
    v5.0-v5.2: The ID assigned to the log shipping configuration object.
    v5.3+: ID assigned to the log shipping configuration object.
    """
    id: String!
    """

    Supported in v5.0+
    v5.0-v5.2: The number of milliseconds between the time the latest backup was applied to the secondary database and when that backup was taken on the primary database.
    v5.3+: Number of milliseconds elapsed since the latest backup was applied to the secondary database and the time the backup was taken on the primary database.
    """
    lagTime: Long
    """

    Supported in v5.0+
    v5.0-v5.2: The timestamp of the last transaction that was applied using the specified log shipping configuration object.
    v5.3+: Timestamp of the last transaction applied using the specified log shipping configuration object.
    """
    lastAppliedPoint: DateTime
    """

    Required. Supported in v5.0+
    v5.0-v5.2: The location of a specified secondary database in the format "host/instance".
    v5.3+: Location of a specified secondary database. Location uses this format: "host/instance".
    """
    location: String!
    """

    Required. Supported in v5.0+
    v5.0-v5.2: The ID of the primary database.
    v5.3+: ID of the primary database.
    """
    primaryDatabaseId: String!
    """

    Supported in v5.2+
    v5.2: Configured log backup frequency of the primary database, in seconds.
    v5.3+: Log backup frequency, in seconds, of the primary database.
    """
    primaryDatabaseLogBackupFrequency: Long
    """

    Required. Supported in v5.0+
    v5.0-v5.2: The name of the primary database.
    v5.3+: Name of the primary database.
    """
    primaryDatabaseName: String!
    """

    Supported in v5.0+
    v5.0-v5.2: The ID of the secondary database.
    v5.3+: ID of the secondary database.
    """
    secondaryDatabaseId: String
    """

    Required. Supported in v5.0+
    v5.0-v5.2: The name of the secondary database.
    v5.3+: Name of the secondary database.
    """
    secondaryDatabaseName: String!
    """

    Supported in v5.0+
    The current state of the secondary database.
    """
    state: String
    "Required. Supported in v5.0+"
    status: MssqlLogShippingStatusInfo
}

"Supported in v5.3+"
type MssqlLogShippingSummaryV2 {
    """

    Supported in v5.3+
    Maximum number of makeup reseed attempts during a 24 hour period.
    """
    makeupReseedLimit: Int
    mssqlLogShippingSummary: MssqlLogShippingSummary
}

"MSSQL Log shipping target."
type MssqlLogShippingTarget {
    "Internal ID of the log shipping target."
    cdmId: String!
    "Cluster of the log shipping target."
    cluster: Cluster
    "Forever ID of the log shipping target."
    fid: String!
    "Lag time of the log shipping target."
    lagTimeFromPrimary: Long!
    "Last applied point of the log shipping target."
    lastAppliedPoint: DateTime
    "Location of the log shipping target."
    location: String!
    "Frequency that the primary database takes log backups."
    logFrequency: Long!
    "Primary cluster of the log shipping target."
    primaryCluster: Cluster
    "Primary database of the log shipping target."
    primaryDatabase: MssqlDatabase
    "Secondary database of the log shipping target."
    secondaryDatabase: MssqlDatabase
    "Secondary instance of the log shipping target."
    secondaryInstance: MssqlInstance
    "State of the log shipping target."
    state: String!
    "Status of the log shipping target."
    status: String!
}

"Paginated list of MssqlLogShippingTarget objects."
type MssqlLogShippingTargetConnection {
    "Total number of MssqlLogShippingTarget objects matching the request arguments."
    count: Int!
    "List of MssqlLogShippingTarget objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [MssqlLogShippingTargetEdge!]!
    "List of MssqlLogShippingTarget objects."
    nodes: [MssqlLogShippingTarget!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the MssqlLogShippingTarget object. This wrapper is used for pagination."
type MssqlLogShippingTargetEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual MssqlLogShippingTarget object wrapped by this edge."
    node: MssqlLogShippingTarget!
}

"Supported in v5.0+"
type MssqlMissedRecoverableRange {
    "Required. Supported in v5.0+"
    beginTime: DateTime
    "Required. Supported in v5.0+"
    description: String!
    "Required. Supported in v5.0+"
    endTime: DateTime
    "Required. Supported in v5.0+"
    errorType: String!
    "Supported in v5.0+"
    firstError: MssqlMissedRecoverableRangeError
    "Supported in v5.0+"
    lastError: MssqlMissedRecoverableRangeError
}

"Supported in v5.0+"
type MssqlMissedRecoverableRangeError {
    "Supported in v5.0+"
    eventMessage: String
    "Supported in v5.0+"
    eventSeriesId: String
    "Required. Supported in v5.0+"
    time: DateTime
}

"Supported in v5.0+"
type MssqlMissedRecoverableRangeListResponse {
    """

    Supported in v5.0+
    List of matching objects.
    """
    data: [MssqlMissedRecoverableRange!]!
    """

    Supported in v5.0+
    If there is more.
    """
    hasMore: Boolean
    """

    Supported in v5.0+
    Total list responses.
    """
    total: Long
}

"Supported in v5.0"
type MssqlNonSlaProperties {
    """

    Supported in v5.0
    Boolean value that specifies whether or not to perform copy-only backups of the database. When true, database backups are copy-only backups. When false, database backups are full backups.
    """
    copyOnly: Boolean
    """

    Supported in v5.0
    Seconds between two log backups. A value of 0 disables log backup.
    """
    logBackupFrequencyInSeconds: Int
    """

    Supported in v5.0
    Number of hours to retain a log backup. When the value is set to -1 the Rubrik cluster retains the log backup until the database snapshots that precede the log backup have expired.
    """
    logRetentionHours: Int
}

"Supported in v5.0+"
type MssqlRecoverableRange {
    "Required. Supported in v5.0+"
    beginTime: DateTime
    "Required. Supported in v5.0+"
    endTime: DateTime
    "Required. Supported in v5.0+"
    isMountAllowed: Boolean!
    "Required. Supported in v5.0+"
    status: String!
}

"Supported in v5.0+"
type MssqlRecoverableRangeListResponse {
    """

    Supported in v5.0+
    List of matching objects.
    """
    data: [MssqlRecoverableRange!]!
    """

    Supported in v5.0+
    If there is more.
    """
    hasMore: Boolean
    """

    Supported in v5.0+
    Total list responses.
    """
    total: Long
}

"Supported in v5.0+"
type MssqlRestoreEstimateResult {
    """

    Required. Supported in v5.0+
    v5.0-v5.2: Estimate of number of bytes that need to be downloaded from the cloud.
    v5.3+: Estimate of the number of bytes to be downloaded from the cloud.
    """
    bytesFromCloud: Long!
}

"Supported in v5.0+"
type MssqlRestoreFile {
    """

    Required. Supported in v5.0+
    Original file ID of the database file to be restored.
    """
    fileId: Long!
    fileType: MssqlDatabaseFileTypeEnum!
    """

    Required. Supported in v5.0+
    Logical name of the database file to be restored.
    """
    logicalName: String!
    """

    Required. Supported in v5.0+
    Original filename of the database file to be restored.
    """
    originalName: String!
    """

    Required. Supported in v5.0+
    v5.0-v5.2: Original path of the database file to be restored.
    v5.3+: Original path to the database file to be restored.
    """
    originalPath: String!
}

"Supported in v5.0+"
type MssqlRootProperties {
    """

    Supported in v5.0+
    ID of the root of this object.
    """
    rootId: String
    """

    Required. Supported in v5.0+
    Name of the root of this object.
    """
    rootName: String!
    """

    Supported in v5.3+
    Role of the root object for this object if the root object is a Host and part of a **_MssqlAvailabilityGroup_**.
    """
    rootRole: String
    rootType: MssqlRootPropertiesRootTypeEnum!
}

"Supported in v5.0+"
type MssqlScriptDetail {
    scriptErrorAction: ScriptErrorActionEnum!
    """

    Required. Supported in v5.0+
    The script to be run.
    """
    scriptPath: String!
    """

    Required. Supported in v5.0+
    Time (in ms) after which the script will be terminated if it has not completed.
    """
    timeoutMs: Long!
}

"Supported in v5.1+"
type MssqlSlaRelatedProperties {
    """

    Supported in v5.1+
    Boolean value that specifies whether or not to perform copy-only backups of the database. When true, database backups are copy-only backups. When false, database backups are full backups.
    """
    copyOnly: Boolean
    """

    Supported in v7.0+
    A boolean value specifying whether the database obtains the log backup configurations from the SLA Domain.
    """
    hasLogConfigFromSla: Boolean
    """

    Supported in v5.1+
    Seconds between two log backups. A value of 0 disables log backup.
    """
    logBackupFrequencyInSeconds: Int
    """

    Supported in v5.1+
    Number of hours to retain a log backup. When the value is set to -1 the Rubrik cluster retains the log backup until the database snapshots that precede the log backup have expired.
    """
    logRetentionHours: Int
}

"Paginated list of MssqlTopLevelDescendantType objects."
type MssqlTopLevelDescendantTypeConnection {
    "Total number of MssqlTopLevelDescendantType objects matching the request arguments."
    count: Int!
    "List of MssqlTopLevelDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [MssqlTopLevelDescendantTypeEdge!]!
    "List of MssqlTopLevelDescendantType objects."
    nodes: [MssqlTopLevelDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the MssqlTopLevelDescendantType object. This wrapper is used for pagination."
type MssqlTopLevelDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual MssqlTopLevelDescendantType object wrapped by this edge."
    node: MssqlTopLevelDescendantType!
}

"Supported in v5.0"
type MssqlUnprotectableReason {
    """

    Required. Supported in v5.0
    A reason that a SQL Server database or instance cannot be protected by Rubrik.
    """
    message: String!
    unprotectableType: MssqlUnprotectableTypeEnum!
}

type Mutation {
    "Acknowledges and resets cluster status."
    ackAndResetStatus(
        "Cluster state to be acknowledged and reset"
        AckClusterStatus: AckClusterStatus!,
        "Cluster uuid"
        clusterUuid: UUID!
    ): Boolean!
    activateUser(
        "List of IDs."
        ids: [String!]!
    ): [String!]!
    "Add AD Groups to O365 hierarchy."
    addADGroupsToHierarchy(
        "List of Azure natural IDs of AD Groups."
        naturalIds: [UUID!]!,
        orgId: UUID!
    ): RequestStatus!
    "Validates and adds an authentication server-based AWS cloud account. When validation succeeds, the AWS cloud account is added and the features specified in the request are enabled. When validation fails, an error is not returned, but the cause of the failure is specified in the \"message\" field of the response object."
    addAwsAuthenticationServerBasedCloudAccount(
        "Input to add authentication server-based AWS cloud account for native protection."
        input: AddAwsAuthenticationServerBasedCloudAccountInput!
    ): AddAwsAuthenticationServerBasedCloudAccountReply!
    "Adds an IAM user-based AWS cloud account and enables the features specified in the input after successful validation of the request."
    addAwsIamUserBasedCloudAccount(
        "Input to add IAM user-based AWS cloud account for native protection."
        input: AddAwsIamUserBasedCloudAccountInput!
    ): AddAwsIamUserBasedCloudAccountReply!
    "Add the Azure Subscriptions cloud account for the given feature."
    addAzureCloudAccount(
        "Input for adding an Azure Cloud Account."
        input: AddAzureCloudAccountInput!
    ): AddAzureCloudAccountReply!
    "Add Exocompute configurations for an Azure Cloud Account."
    addAzureCloudAccountExocomputeConfigurations(
        "Input for adding Exocompute configurations for an Azure Cloud Account."
        input: AddAzureCloudAccountExocomputeConfigurationsInput!
    ): AddAzureCloudAccountExocomputeConfigurationsReply!
    "Add the Azure Subscription cloud account for the given feature without OAuth."
    addAzureCloudAccountWithoutOauth(
        "Input for adding an Azure Cloud Account without OAuth."
        input: AddAzureCloudAccountWithoutOauthInput!
    ): AddAzureCloudAccountWithoutOauthReply!
    "Add Certificate"
    addCertificate(
        "Certificate"
        certificate: String!,
        "CSR id"
        csrId: Long,
        "Certificate description"
        description: String,
        "Certificate name"
        name: String!,
        "Certificate private key"
        privateKey: String
    ): Long!
    "Add credentials for the user in the databases with authorization to perform backups."
    addCloudNativeSqlServerBackupCredentials(
        "Input required to add credentials for performing SQL Server backups."
        input: AddCloudNativeSqlServerBackupCredentialsInput!
    ): AddCloudNativeSqlServerBackupCredentialsReply!
    "Mutation to add a new Db2 instance."
    addDb2Instance(
        "UUID used to identify the cluster the request goes to"
        clusterUuid: String!,
        "The request object containing parameters like username, password, and list of hosts required to add a Db2 instance to the Rubrik cluster."
        db2InstanceRequestConfig: Db2InstanceRequestConfigInput!
    ): AddDb2InstanceResponse!
    "Add account level inventory workloads."
    addInventoryWorkloads(
        "Inventory workloads to add for an account."
        input: AddInventoryWorkloadsInput!
    ): Boolean!
    """

    Create a Managed Volume

    Supported in v8.0
    Start an asynchronous job to create a Managed Volume stack.
    """
    addManagedVolume(
        "Input for V1CreateManagedVolumeV1"
        input: CreateManagedVolumeV1Input!
    ): CreateManagedVolumeResponse!
    """

    Add a New Store

    Supported in m3.2.0-m4.1.0
    Add a new store to Mosaic cluster.
    """
    addMosaicStore(
        "Input for V2AddMosaicStore"
        input: AddMosaicStoreInput!
    ): MosaicAsyncResponse!
    addO365Org(exocomputeClusterId: String!, o365AppTypes: [String!]!, stateToken: String!, tenantId: String!): AddO365OrgResponse!
    "Add policies to objects."
    addPolicyObjects(objectIds: [String!]!, policyIds: [String!]!): String!
    addRoleAssignments(adGroupIds: [String!], roleIds: [String!]!, userIds: [String!]): Boolean!
    addSapHanaSystem(
        "UUID used to identify the cluster the request goes to"
        clusterUuid: String!,
        "Add a SAP HANA system to the Rubrik cluster. Contains parameters like username, list of hosts, password required while adding a SAP HANA system."
        sapHanaSystem: SapHanaSystemConfigInput!
    ): SapHanaAddSystemResponse!
    addSyslogConfiguration(
        "Host name for your SMTP configuration"
        hostName: String!,
        "Network type to use"
        networkProtocolType: NetworkProtocolTypeEnum!,
        "Port number for your SMTP configuration"
        port: Int!,
        "Syslog facility to filter for syslog"
        syslogFacility: SyslogFacilityTypeEnum!,
        "Syslog severity to filter for syslog"
        syslogSeverity: SyslogSeverityTypeEnum!,
        "Trusted certificate to use for your SMTP configuration"
        trustedCerts: String!,
        "Use TLS or not"
        useTLS: Boolean!
    ): Boolean!
    "Add Vm App consistent specs info"
    addVmAppConsistentSpecs(
        "Input required to add Azure native virtual machine application consistency specifications."
        input: AddVmAppConsistentSpecsInput!
    ): AddVmAppConsistentSpecsReply!
    "Archive a crawl"
    archiveCrawl(crawlId: String!): String!
    "Archive a Kubernetes cluster."
    archiveK8sCluster(
        "UUID of Kubernetes Cluster to Archive."
        input: ArchiveK8sClusterInput!
    ): UUID!
    "Archive Recovery Plan."
    archiveRecoveryPlan(
        "Archive Recovery Plan configuration."
        recoveryPlanConfig: ArchiveRecoveryPlanInput!
    ): Void
    "Assign SLA domain properties to Mssql objects."
    assignMssqlSlaDomainProperties(
        "Input for V1AssignMssqlSlaProperties"
        input: AssignMssqlSlaPropertiesInput!
    ): ResponseSuccess!
    "Assign SLA domain properties to Mssql objects."
    assignMssqlSlaDomainPropertiesAsync(
        "Input for V2AssignMssqlSlaPropertiesAsync"
        input: AssignMssqlSlaPropertiesAsyncInput!
    ): V2AssignMssqlSlaPropertiesAsyncResponse!
    "Assign protection to cassandra objects."
    assignProtection(
        "Corresponds to the assignment type for the global SLA"
        globalSlaAssignType: SlaAssignTypeEnum!,
        "Corresponds to optional global SLA forever UUID in Polaris tables"
        globalSlaOptionalFid: UUID,
        "Arguments for protection backup."
        input: MosaicSlaInfoInput!,
        "Provide list of object forever IDS you want to assign Global SLA"
        objectIds: [UUID!]!
    ): SlaAssignResult!
    assignRetentionSLAToSnappables(
        "Provide optional snappable type under the object for SLA assignment. This is meant to be used only for objects that support multiple snappable hierarchies. This allows an SLA to be set for one/more specific snappable types under the object, instead of applying the SLA for all the snappable types. For example, an AWS account object can potentially have 2 different snappable types under it - AwsNativeEc2Instance and AwsNativeRdsInstance. This field can be set with the appropriate type so that the SLA only gets applied to snappables of the selected type under that account. If the SLA must be applicable for all the snappable types under the object, then this field can be set to `AllSubHierarchyType` or left blank. This field must either be left blank or set to `AllSubHierarchyType` when assigning SLA to a snappable or to an object that does not support multiple snappable types."
        applicableSnappableType: SnappableLevelHierarchyTypeEnum,
        "Corresponds to the assignment type for the global SLA"
        globalSlaAssignType: SlaAssignTypeEnum!,
        "Corresponds to optional global SLA forever UUID in Polaris tables"
        globalSlaOptionalFid: UUID,
        "Provide list of object forever IDS you want to assign Global SLA"
        objectIds: [UUID!]!,
        "Boolean value to indicate if the new configuration keeps existing, non-policy snapshots of data sources retained by this SLA Domain."
        shouldApplyToNonPolicySnapshots: Boolean,
        "Optional User note."
        userNote: String
    ): SlaAssignResult!
    assignRetentionSLAToSnapshots(
        "Corresponds to the assignment type for the global SLA"
        globalSlaAssignType: SlaAssignTypeEnum!,
        "Corresponds to optional global SLA forever UUID in Polaris tables"
        globalSlaOptionalFid: UUID,
        "List of UUIDs of objects"
        snapshotFids: [UUID!]!,
        "Optional User note."
        userNote: String
    ): SlaAssignResult!
    assignSla(
        "Assign SLA Domain Request."
        input: AssignSlaInput!
    ): SlaAssignResult!
    assignSlasForSnappableHierarchies(
        "Provide optional snappable types under the object for SLA assignment. This is meant to be used only for objects that support multiple snappable hierarchies. See 'applicableSnappableType' for more details. If more than one is provided, the SLA will be assigned to all."
        applicableSnappableTypes: [SnappableLevelHierarchyTypeEnum!],
        "Choose what to do with existing snapshot in case of do not protect slas"
        globalExistingSnapshotRetention: GlobalExistingSnapshotRetentionEnum,
        "Corresponds to the assignment type for the global SLA"
        globalSlaAssignType: SlaAssignTypeEnum!,
        "Corresponds to optional global SLA forever UUID in Polaris tables"
        globalSlaOptionalFid: UUID,
        "Provide list of object forever IDS you want to assign Global SLA"
        objectIds: [UUID!]!,
        "Boolean value to indicate whether to apply changes made to the SLA to existing snapshots."
        shouldApplyToExistingSnapshots: Boolean,
        "Boolean value to indicate if the new configuration keeps existing, non-policy snapshots of data sources retained by this SLA Domain."
        shouldApplyToNonPolicySnapshots: Boolean,
        "Optional User note."
        userNote: String
    ): [SlaAssignResult!]!
    azureOAuthConsentComplete(azureAppID: String, azureAppSecret: String, azureCloudType: O365AzureCloudType!, code: String!, redirectUrl: String!, stateToken: String!, tenantId: String!): RequestStatus!
    azureOAuthConsentKickoff: AzureOAuthConsentKickoffResp!
    "backup mailbox snappable"
    backupO365Mailbox(
        "The list of mailbox UUIDs to backup."
        mailboxIds: [UUID!]!
    ): BatchAsyncJobStatus!
    "backup onedrive snappable"
    backupO365Onedrive(
        "The list of onedrive UUIDs to backup."
        onedriveUUIDs: [UUID!]!
    ): BatchAsyncJobStatus!
    "backup sharepoint snappable"
    backupO365SharepointDrive(
        "The list of sharepoint UUIDs to backup."
        sharepointDriveUUIDs: [UUID!]!
    ): BatchAsyncJobStatus!
    "Take on-demand snapshot for SharePoint list."
    backupO365SharepointList(input: BackupO365SharePointListInput!): CreateOnDemandJobReply!
    "backup O365Team snappable"
    backupO365Team(
        "The list of team UUIDs to backup."
        teamUUIDs: [UUID!]!
    ): BatchAsyncJobStatus!
    batchDeassignRoleFromUserGroups(userGroupToRoles: [UserGroupToRolesInput!]!): Boolean!
    "Batch quarantine snapshots."
    batchQuarantineSnapshot(
        "Config to batch quarantine snapshot."
        input: BatchQuarantineSnapshotInput!
    ): BatchQuarantineSnapshotReply!
    "Release snapshots from quarantine."
    batchReleaseFromQuarantineSnapshot(
        "Config to batch release from quarantine snapshot."
        input: BatchReleaseFromQuarantineSnapshotInput!
    ): BatchReleaseFromQuarantineSnapshotReply!
    blueprintFailoverReportGenerate(failoverReportGeneratorJobConfig: BlueprintFailoverReportGeneratorJobInfo!): CreateOnDemandJobReply!
    "Bootstrap a cluster."
    bootstrapClusterAsync(
        "BootstrapClusterReqInput params."
        input: bootstrapClusterInput!
    ): CcProvisionJobReply!
    "List snapshots and logs from a Mssql Database. This endpoint is only used to fetch data, but uses a mutation instead of a query due to limitations with the CDM API."
    browseMssqlDatabaseSnapshot(
        "Input for V1BrowseMssqlBackupFiles"
        input: BrowseMssqlBackupFilesInput!
    ): MssqlBackups!
    "Cancel multiple failovers."
    bulkCancelFailovers(
        "List of blueprint ids."
        cancelFailoversConfig: BulkCancelFailoversInput!
    ): Void
    "Install or uninstall volume filter driver on hosts."
    bulkChangeVfdOnHost(
        "Input for InternalChangeVfdOnHost"
        input: ChangeVfdOnHostInput!
    ): InternalChangeVfdOnHostResponse!
    bulkCreateFilesetTemplates(
        "UUID used to identify the cluster the request goes to"
        clusterUuid: String!,
        "Provide an array containing a separate object for each fileset template definition."
        definitions: [FilesetTemplateCreateInput!]!
    ): FilesetTemplateDetailListResponse!
    bulkCreateFilesets(
        "UUID used to identify the cluster the request goes to"
        clusterUuid: String!,
        "For each fileset, specify a template id along with either host id or share id. If a share id is provided, the host id will be inferred from the host share."
        definitions: [FilesetCreateInput!]!
    ): FilesetDetailListResponse!
    "Take a bulk on-demand backup of a Microsoft SQL Database."
    bulkCreateOnDemandMssqlBackup(
        "Input for V1CreateOnDemandMssqlBatchBackupV1"
        input: CreateOnDemandMssqlBatchBackupV1Input!
    ): AsyncRequestStatus!
    "Bulk Delete cassandra sources."
    bulkDeleteCassandraSources(
        "UUID used to identify the cluster the request goes to"
        clusterUuid: String!,
        "List of names of sources to be deleted."
        sourceData: BulkDeleteSourceRequestInput!
    ): MosaicAsyncResponse!
    bulkDeleteFilesetTemplates(
        "Provide an array with the ID of each fileset template to remove."
        ids: [String!]!,
        "Flag to indicate whether to convert snapshots of filesets of the deleted templates to relics or to delete them. Applies to all templates being deleted. Default is true."
        preserveSnapshots: Boolean
    ): ResponseSuccess!
    bulkDeleteFilesets(
        "Provide a comma-separated list of fileset IDs."
        ids: [String!]!,
        "Flag to indicate whether to convert snapshots of all deleted filesets to relics or to delete them. Applies to all filesets. Default is true."
        preserveSnapshots: Boolean
    ): ResponseSuccess!
    bulkDeleteHosts(
        "Provide the ID of each host to deregister."
        ids: [String!]!
    ): ResponseSuccess!
    """

    Bulk Delete Sources

    Supported in m3.2.0-m4.1.0.
    """
    bulkDeleteMongodbSources(
        "Input for V2BulkDeleteMosaicSources"
        input: BulkDeleteMosaicSourcesInput!
    ): MosaicAsyncResponse!
    bulkEditFilesetTemplates(
        "Provide an array containing a separate object for each fileset template being modified."
        definitions: [FilesetTemplatePatchInput!]!
    ): FilesetTemplateDetailListResponse!
    bulkEditHosts(
        "Properties to update for each host."
        hostUpdateProperties: [HostUpdateIdInput!]!
    ): InternalBulkUpdateHostResponse!
    bulkRegisterHosts(
        "UUID used to identify the cluster the request goes to"
        clusterUuid: String!,
        "Array containing a registration definition for each host."
        hosts: [HostRegisterInput!]!
    ): HostDetailListResponse!
    """

    Update multiple Exchange DAGs

    Supported in v8.0
    Update multiple Exchange DAGs with the specified properties.
    """
    bulkUpdateExchangeDag(
        "Input for V1BulkUpdateExchangeDag"
        input: BulkUpdateExchangeDagInput!
    ): V1BulkUpdateExchangeDagResponse!
    "Update multiple Microsoft SQL databases with the specified properties."
    bulkUpdateMssqlDbs(
        "Input for V1BulkUpdateMssqlDbV1"
        input: BulkUpdateMssqlDbV1Input!
    ): V1BulkUpdateMssqlDbV1Response!
    """

    Update Oracle Hosts

    Supported in v5.2+
    Update properties to Oracle Host objects.
    """
    bulkUpdateOracleHosts(
        "Input for V1BulkUpdateOracleHost"
        input: BulkUpdateOracleHostInput!
    ): BulkOracleHostDetails!
    """

    Update SnapMirror Cloud objects

    Supported in v7.0+
    Update properties of the specified SnapMirror Cloud objects.
    """
    bulkUpdateSnapMirrorCloud(
        "Input for V1BulkUpdateSnapMirrorCloud"
        input: BulkUpdateSnapMirrorCloudInput!
    ): V1BulkUpdateSnapMirrorCloudResponse!
    cancelActivitySeries(
        "The id of the activity series"
        activitySeriesId: UUID!,
        "The ID of the cluster."
        clusterUuid: UUID!
    ): Boolean!
    cancelBlueprintFailover(taskchainId: UUID!): Result!
    "Cancels download package job of a cluster."
    cancelDownloadPackage(
        "Cluster uuid"
        clusterUuid: UUID!
    ): CancelJobReply!
    "Cancel an in-progress threat hunt."
    cancelPolarisMalwareDetection(
        "The details of the threat hunt to cancel."
        input: CancelPolarisMalwareDetectionInput!
    ): Void
    "Cancels scheduled upgrade job of a cluster."
    cancelScheduledUpgrade(
        "Cluster uuid"
        clusterUuid: UUID!
    ): CancelJobReply!
    cancelTaskchain(taskchainId: String!): RequestStatus!
    changePassword(
        "User credentials required to change a user's password."
        input: ChangePasswordInput!
    ): Boolean!
    cleanupBlueprintFailover(cleanupJobconfig: CleanupFailoverJobInfo!): CreateOnDemandJobReply!
    "Clear credentials for the user with authorization to perform database backups. Credentials are cleared from the object to which they were assigned directly."
    clearCloudNativeSqlServerBackupCredentials(
        "Input required to clear the credentials used for SQL Server backups."
        input: ClearCloudNativeSqlServerBackupCredentialsInput!
    ): ClearCloudNativeSqlServerBackupCredentialsReply!
    "Check RBA connectivity for the VMs"
    cloudNativeCheckRBAConnectivity(
        "List of snappable IDs"
        snappableIds: [UUID!]!
    ): CheckRBAConnectivityReply!
    "Download files from cloudnative snapshot"
    cloudNativeDownloadFiles(
        "Create the download location"
        createDownloadLoaction: Boolean!,
        "Location where the files would be downloaded"
        downloadLocation: String!,
        "Rubrik ID of the account from which exocompute is launched during recovery. Only applicable when snapshot type is ARCHIVED."
        exocomputeCloudNativeAccountId: UUID,
        "Cloud account region where Rubrik Exocompute is launched during recovery. Only applicable when snapshot type is ARCHIVED."
        exocomputeRegion: String,
        "File/Directory(s) to download"
        filePaths: [String!]!,
        "Snapshot UUID"
        snapshotId: UUID!,
        "Use a snapshot type of SOURCE, REPLICATED or ARCHIVED for recovery."
        snapshotType: SnapshotType,
        "List of key-value pairs for tags."
        tags: [TagType!]
    ): DownloadFilesReply!
    "Complete the Azure OAuth flow and pass the authorization code."
    completeAzureCloudAccountOauth(
        "Input for completing authentication of the Azure Cloud Accounts."
        input: CompleteAzureCloudAccountOauthInput!
    ): CompleteAzureCloudAccountOauthReply!
    "Configure DNS server addresses."
    configureDns(
        "DNS Addresses."
        dnsAddresses: [String!]!
    ): Boolean!
    "Configure NTP server addresses."
    configureNtp(
        "NTP Addresses."
        ntpAddresses: [String!]!
    ): Boolean!
    createAppBlueprint(children: [AppBlueprintChildInput!]!, name: String!, primaryClusterUuid: UUID!): Blueprint!
    createAppBlueprintDownloadSnapshotJobFromCloud(appSnapshotFid: UUID!): Result!
    createAppBlueprintExport(
        exportJobConfig: AppBlueprintExportSnapshotJobConfig!,
        "The Polaris UUID for the object."
        fid: UUID!
    ): Result!
    createAppBlueprintInstantRecovery(
        "The Polaris UUID for the object."
        fid: UUID!,
        instantRecoveryJobConfig: InstantRecoveryJobConfig
    ): Result!
    createAppBlueprintMount(
        "The Polaris UUID for the object."
        fid: UUID!,
        mountJobConfig: AppBlueprintMountSnapshotJobConfig!
    ): Result!
    createAutomaticAwsTargetMapping(automaticAwsTargetMappingCreateRequest: AutomaticAwsTargetMappingCreateRequest!): TargetMapping!
    createAutomaticAzureTargetMapping(automaticAzureTargetMappingCreateRequest: AutomaticAzureTargetMappingCreateRequest!): TargetMapping!
    createAutomaticRcsTargetMapping(
        "Request argument for creating a new Rubrik Cloud location"
        automaticRcsTargetMappingCreateRequest: RcsAzureTargetMappingCreateRequest!
    ): TargetMapping!
    createAwsAccount(
        "Request arg for creating a new AWS account"
        awsAccountCreateRequest: AwsAccountCreateRequest!
    ): CloudAccount!
    "Create a cluster in Aws."
    createAwsCluster(
        "CreateAwsClusterArg params for Aws."
        input: CreateAwsClusterInput!
    ): CcProvisionJobReply!
    createAwsComputeSetting(
        "Request for creating a new Aws Compute Setting"
        awsComputeSettingsCreateRequest: AwsComputeSettingsCreateRequest!
    ): AwsComputeSettings!
    "Create AWS Exocompute configs."
    createAwsExocomputeConfigs(
        "Input to create AWS exocompute configurations."
        input: CreateAwsExocomputeConfigsInput!
    ): CreateAwsExocomputeConfigsReply!
    "Creates a reader type for AWS archival location on a CDM cluster."
    createAwsReaderTarget(
        "Input for creating a new AWS reader target."
        input: CreateAwsReaderTargetInput!
    ): Target!
    createAwsTarget(
        "Request for creating a new AWS target"
        awsTargetCreateRequest: AwsTargetCreateRequest!
    ): Target!
    createAzureAccount(
        "Request arg for creating a new Azure account"
        azureAccountCreateRequest: AzureAccountCreateRequest!
    ): CloudAccount!
    "Create a cluster in Azure."
    createAzureClusterAsync(
        "CreateAzureClusterArg params for Azure."
        input: CreateAzureClusterInput!
    ): CcProvisionJobReply!
    "Creates reader type for Azure archival location on a CDM cluster."
    createAzureReaderTarget(
        "Input for creating a new Azure reader target."
        input: CreateAzureReaderTargetInput!
    ): Target!
    createAzureTarget(
        "Request for creating a new Azure target"
        azureTargetCreateRequest: AzureTargetCreateRequest!
    ): Target!
    "Create set of azure vms."
    createAzureVms(
        "CreateAzureClusterArg params for Azure."
        input: CreateAzureClusterInput!
    ): AzureClusterCreateReply!
    createBlueprint(
        children: [AppBlueprintChildInput!]!,
        "Flag to mark if hydration is enabled for the blueprint."
        enableHydration: Boolean,
        name: String!,
        "The id of the source location."
        sourceLocationId: String!,
        "The type of the source location."
        sourceLocationType: BlueprintLocationTypeEnum! = CDM,
        "The status of the blueprint."
        status: BlueprintStatusEnum! = Uncompleted,
        "The id of the intended remote target location."
        targetLocationId: String,
        "The type of the intended remote target location."
        targetLocationType: BlueprintLocationTypeEnum = CDM
    ): BlueprintNew!
    "create a list of blueprint recovery specs with a list of child snappable/snapshot recovery specs"
    createBlueprintRecoverySpec(
        "the id of the blueprint"
        blueprintId: UUID!,
        "Indicate if its not a default recovery spec request."
        isDefaultRecoverySpec: Boolean,
        "configurations of the recovery specs"
        recoveryConfigs: [AppBlueprintRecoverySpecCreateReqInputType!]!,
        "the type of the recovery specs (AWS_EC2, VMWARE_VM)"
        specType: RecoverySpecTypeEnum!
    ): [BlueprintRecoverySpec!]!
    createBlueprintSnapshot(
        BaseOnDemandSnapshotConfig: BaseOnDemandSnapshotConfig,
        "The Polaris UUID for the object."
        fid: UUID!
    ): Result!
    "Create a cassandra source."
    createCassandraSource(
        "UUID used to identify the cluster the request goes to"
        clusterUuid: String!,
        "Source Object with details of source to be added."
        sourceData: SourceInput!
    ): MosaicAsyncResponse!
    createCloudNativeAwsStorageSetting(input: CreateCloudNativeAwsStorageSettingInput!): CreateCloudNativeAwsStorageSettingReply!
    "Creates Storage Settings for the archival of azure cloud native protected objects"
    createCloudNativeAzureStorageSetting(input: CreateCloudNativeAzureStorageSettingInput!): CreateCloudNativeAzureStorageSettingReply!
    "Create cloud native label rule"
    createCloudNativeLabelRule(
        "Does this tag rule apply to all cloud accounts."
        applyToAllCloudAccounts: Boolean,
        "cloud native accounts on which tag rule will be applied"
        cloudNativeAccountIds: CloudNativeIDs,
        "Corresponds to optional global SLA forever UUID in Polaris tables."
        globalSlaOptionalFid: UUID,
        "Label key-value pair for label rule."
        label: LabelType!,
        "Type of managed object on which label rule will be applied."
        objectType: CloudNativeLabelObjectType!,
        "Name for the rule"
        ruleName: String!,
        "Corresponds to the assignment type for the SLA."
        ruleSlaAssignType: TagRuleSlaAssignTypeEnum!
    ): CreateCloudNativeLabelRuleReply!
    "Create cloud native tag rule"
    createCloudNativeTagRule(
        "Does this tag rule apply to all cloud accounts."
        applyToAllCloudAccounts: Boolean,
        "cloud native accounts on which tag rule will be applied"
        cloudNativeAccountIds: CloudNativeIDs,
        "Corresponds to optional global SLA forever UUID in Polaris tables."
        globalSlaOptionalFid: UUID,
        "Type of managed object on which tag rule will be applied."
        objectType: CloudNativeTagObjectType!,
        "Name for the rule"
        ruleName: String!,
        "Corresponds to the assignment type for the SLA."
        ruleSlaAssignType: TagRuleSlaAssignTypeEnum!,
        "Tag key-value pair for tag rule."
        tag: TagType!
    ): CreateCloudNativeTagRuleReply!
    "Create a new custom analyzer"
    createCustomAnalyzer(analyzer: AnalyzerInput!): Analyzer!
    createCustomReport(config: CustomReportCreate!): CustomReport!
    "Mutation to take an on demand snapshot of Db2 db."
    createDb2DatabaseSnapshot(
        "Configuration for the on demand backup."
        config: BaseOnDemandSnapshotConfigInput!,
        "ID assigned to a Db2 database object."
        id: String!
    ): AsyncRequestStatus!
    """

    On-demand discovery of a Db2 instance

    Supported in v7.0+
    Initiates an on-demand job to discover a Db2 instance.
    """
    createDb2InstanceDiscovery(
        "Input for V1DiscoverDb2Instance"
        input: DiscoverDb2InstanceInput!
    ): AsyncRequestStatus!
    """

    Creates a download from archival request

    Supported in v5.0+
    Download a snapshot from archival.
    """
    createDownloadSnapshotForVolumeGroup(
        "Input for InternalCreateDownloadSnapshotForVolumeGroup"
        input: CreateDownloadSnapshotForVolumeGroupInput!
    ): AsyncRequestStatus!
    """

    Create a request to mount a Microsoft Exchange database snapshot

    Supported in v8.0
    Create a request to mount a Microsoft Exchange database snapshot.
    """
    createExchangeMount(
        "Input for V1CreateExchangeSnapshotMount"
        input: CreateExchangeSnapshotMountInput!
    ): AsyncRequestStatus!
    createFailoverCluster(
        "UUID used to identify the cluster the request goes to"
        clusterUuid: String!,
        "Create configuration parameters for a failover cluster."
        config: FailoverClusterConfigInput!
    ): FailoverClusterDetail!
    "Create a failover cluster app."
    createFailoverClusterApp(
        "Create configuration parameters for a failover cluster app."
        config: FailoverClusterAppConfigInput!
    ): FailoverClusterAppSummary!
    createFilesetSnapshot(
        "Configuration for the on-demand backup."
        config: BaseOnDemandSnapshotConfigInput!,
        "ID of the Fileset."
        id: String!,
        "Optional User note."
        userNote: String
    ): AsyncRequestStatus!
    "Creates reader type for GCP archival location on a CDM cluster."
    createGcpReaderTarget(
        "Request for creating a new Gcp reader target."
        input: CreateGcpReaderTargetInput!
    ): Target!
    createGcpTarget(
        "Request for creating a new Gcp target"
        input: GcpTargetCreateInput!
    ): Target!
    createGlobalSla(input: CreateGlobalSlaInput!): GlobalSla!
    createGuestCredential(
        "Input for InternalCreateGuestCredential"
        input: CreateGuestCredentialInput!
    ): GuestCredentialDetail!
    """

    Create a live mount request

    Supported in v5.0+
    Create a live mount request with given configuration.
    """
    createHypervVirtualMachineSnapshotMount(
        "Input for InternalCreateHypervVirtualMachineSnapshotMount"
        input: CreateHypervVirtualMachineSnapshotMountInput!
    ): AsyncRequestStatus!
    "Create a Rubrik Kubernetes agent manifest."
    createK8sAgentManifest(
        "Request to create a new Rubrik Kubernetes agent manifest."
        input: CreateK8sAgentManifestInput!
    ): CreateK8sAgentManifestReply!
    "Add a Kubernetes cluster."
    createK8sCluster(
        "Request for creating a new K8s cluster."
        k8sClusterCreateRequest: K8sClusterCreateInput!
    ): OnboardingSetupReply!
    "Snapshot Kubernetes Namespace."
    createK8sNamespaceSnapshots(
        "Request for snapshot of K8s Namespaces."
        input: CreateK8sNamespaceSnapshotsInput!
    ): [CreateOnDemandJobReply!]!
    "Place legal hold on snapshots."
    createLegalHold(
        "Create Legal Hold Request."
        input: CreateLegalHoldInput!
    ): CreateLegalHoldReply!
    createManualTargetMapping(manualTargetMappingCreateRequest: ManualTargetMappingCreateRequest!): TargetMapping!
    """

    Register a new MongoDB source to NoSql cluster.
    For MongoDB, the term "source" is usually used for either a replica set or a sharded cluster.
    For more info on MongoDB cluster refer to : https://docs.mongodb.com/manual/introduction/
    """
    createMongodbSource(
        "UUID used to identify the cluster the request goes to"
        clusterUuid: String!,
        "Source Object with details of source to be added."
        sourceData: SourceInput!
    ): MosaicAsyncResponse!
    "Create live mount of a Microsoft SQL Database."
    createMssqlLiveMount(
        "Input for V1CreateMssqlMount"
        input: CreateMssqlMountInput!
    ): AsyncRequestStatus!
    "Create log shipping configuration of a Microsoft SQL Database."
    createMssqlLogShippingConfiguration(
        "Input for V2CreateLogShippingConfigurationV2"
        input: CreateLogShippingConfigurationV2Input!
    ): AsyncRequestStatus!
    "Creates reader type for NFS archival location on a CDM cluster."
    createNfsReaderTarget(
        "Input for creating a new NFS reader target."
        input: CreateNfsReaderTargetInput!
    ): Target!
    createNfsTarget(
        "Request for creating a new NFS target"
        nfsTargetCreateRequest: NfsTargetCreateRequest!
    ): Target!
    """

    Add Nutanix cluster

    Supported in v5.0+
    Create a Nutanix cluster object by providing an address and account credentials for Prism. Initiates an asynchronous job to establish a connection with the cluster and retrieve all metadata. Use GET /nutanix_cluster/{id}/status to check status.
    """
    createNutanixCluster(
        "Input for InternalCreateNutanixCluster"
        input: CreateNutanixClusterInput!
    ): AsyncRequestStatus!
    createO365AppComplete(o365AppClientId: String!, stateToken: String!, tenantId: String!): RequestStatus!
    createO365AppKickoff(o365AppType: String!, o365SubscriptionName: String!): CreateO365AppKickoffResp!
    """

    Take an on-demand backup of a Microsoft Exchange database

    Supported in v8.0
    Takes an on-demand backup of a Microsoft Exchange database. The forceFullSnapshot property can be set to true to force a full snapshot. To check the result of the request, poll /exchange/request/{id}.
    """
    createOnDemandExchangeBackup(
        "Input for V1CreateOnDemandExchangeDatabaseBackup"
        input: CreateOnDemandExchangeDatabaseBackupInput!
    ): AsyncRequestStatus!
    "Take an on-demand backup of a Microsoft SQL Database"
    createOnDemandMssqlBackup(
        "Input for V1CreateOnDemandMssqlBackup"
        input: CreateOnDemandMssqlBackupInput!
    ): AsyncRequestStatus!
    """

    Create on-demand VM snapshot

    Supported in v5.0+
    Create an on-demand snapshot for the given VM ID.
    """
    createOnDemandNutanixBackup(
        "Input for InternalCreateOnDemandNutanixBackup"
        input: CreateOnDemandNutanixBackupInput!
    ): AsyncRequestStatus!
    """

    Create on-demand snapshot for the Volume Group

    Supported in v5.3+
    Create an on-demand snapshot for the given Volume Group ID.
    """
    createOnDemandVolumeGroupBackup(
        "Input for V1CreateOnDemandVolumeGroupBackup"
        input: CreateOnDemandVolumeGroupBackupInput!
    ): AsyncRequestStatus!
    "Create a new organization under global org."
    createOrg(
        "Input required for org creation."
        input: CreateOrgInput!
    ): CreateOrgReply!
    "Create a classification policy"
    createPolicy(policy: ClassificationPolicyInput!): ClassificationPolicyDetail!
    "Creates reader type for RCS Azure archival location on a CDM cluster."
    createRcsReaderTarget(
        "Input for creating a new RCS reader target."
        input: CreateRcsReaderTargetInput!
    ): Target!
    createRcsTarget(
        "Request for creating a new RCS Azure location"
        rcsAzureTargetCreateRequest: RcsTargetCreateRequest!
    ): Target!
    "Create Recovery Plan."
    createRecoveryPlan(
        "Recovery Plan configuration."
        recoveryPlanConfig: CreateRecoveryPlanInput!
    ): CreateRecoveryPlanReply!
    createReport(reportConfig: ReportConfigInput!): Int!
    createRole(
        description: String!,
        "Role type is org admin role."
        isOrgAdmin: Boolean,
        name: String!,
        "Permissions in the role."
        permissions: [PermissionInput!]!
    ): UUID!
    "Creates reader type for S3Compatible archival location on a CDM cluster."
    createS3CompatibleReaderTarget(
        "Input for creating a new S3Compatible reader target."
        input: CreateS3CompatibleReaderTargetInput!
    ): Target!
    createS3CompatibleTarget(
        "Request for creating a new S3Compatible target"
        input: S3CompatibleTargetCreateInput!
    ): Target!
    createSapHanaDatabaseSnapshot(
        "Configuration for the on demand backup."
        config: BaseOnDemandSnapshotConfigInput!,
        "ID of the Fileset."
        id: String!
    ): AsyncRequestStatus!
    createScheduledReport(scheduledReport: ScheduledReportCreate!): ScheduledReport!
    createServiceAccount(
        "Description of the service account"
        description: String,
        "Name of the service account"
        name: String!,
        "IDs of roles to be assigned to the service account"
        roleIds: [String!]!
    ): CreateServiceAccountReply!
    """

    Create a SnapMirror Cloud protected object for a NetApp volume

    Supported in v7.0+
    Create a SnapMirror Cloud protected object for a NetApp volume.
    """
    createSnapMirrorCloud(
        "Input for V1CreateSnapMirrorCloud"
        input: CreateSnapMirrorCloudInput!
    ): SnapMirrorCloudDetail!
    """

    Create a SnapMirrorCloud relationship on NetApp server between the volume and the cloud target

    Supported in v7.0+
    Creates a SnapMirrorCloud relationship on NetApp server between the volume and the cloud target which are configured on the SnapMirrorCloud protected object.
    """
    createSnapMirrorCloudRelationship(
        "Input for V1CreateSnapMirrorCloudRelationship"
        input: CreateSnapMirrorCloudRelationshipInput!
    ): RelationshipSummary!
    """

    Create restore job to restore multiple files/directories or the NetApp volume

    Supported in v7.0+
    Launches a job to restore a source NetApp volume or a subset of the files and directories in that volume to a target volume. The target volume can be the same as the source volume.
    """
    createSnapMirrorCloudRestoreJob(
        "Input for V1CreateSnapMirrorCloudRestoreJob"
        input: CreateSnapMirrorCloudRestoreJobInput!
    ): AsyncRequestStatus!
    """

    Initiate an on-demand backup for SnapMirror Cloud protected object

    Supported in v7.0+
    Create an on-demand backup request for the specified SnapMirror Cloud protected object.
    """
    createSnapMirrorCloudSnapshot(
        "Input for V1CreateSnapMirrorCloudBackupJob"
        input: CreateSnapMirrorCloudBackupJobInput!
    ): AsyncRequestStatus!
    createUser(email: String!, roleIds: [String!]!): String!
    createUserWithPassword(
        "User credentials required to create a new user."
        input: CreateUserWithPasswordInput!
    ): String!
    "Add a vCenter server"
    createVsphereVcenter(
        "Input for V2CreateVcenterV2"
        input: CreateVcenterV2Input!
    ): VcenterCreateResponse!
    "Create a webhook."
    createWebhook(
        "The webhook configuration to create."
        input: CreateWebhookInput!
    ): CreateWebhookReply!
    "Deactivate a custom analyzer"
    deactivateCustomAnalyzer(analyzerId: String!): String!
    "Deactivate a classification policy"
    deactivatePolicy(policyId: String!, runAsync: Boolean!): [String!]!
    deactivateUser(
        "List of IDs."
        ids: [String!]!
    ): [String!]!
    "Delete AD Groups from O365 hierarchy."
    deleteADGroupsFromHierarchy(
        "List of Polaris internal group IDs."
        groupIds: [UUID!]!,
        orgId: UUID!
    ): RequestStatus!
    "Delete account settings value."
    deleteAccountSettingValue(
        "Name of component that uses ASP in account setting table"
        aspComponent: ComponentEnum!,
        "Name of parameter (ASP) in account setting table"
        aspName: String!
    ): Boolean!
    """

    Delete Oracle database snapshots

    Supported in v5.0+
    Delete all snapshots for a specified Oracle database object. For the operation to succeed the referenced database must not be assigned to an SLA Domain.
    """
    deleteAllOracleDatabaseSnapshots(
        "Input for InternalDeleteAllOracleDbSnapshots"
        input: DeleteAllOracleDbSnapshotsInput!
    ): RequestSuccess!
    """

    Delete all snapshots for a SnapMirror Cloud object

    Supported in v7.0+
    Deletes all snapshots for a given SnapMirror Cloud object. For this operation to work as intended, the SnapMirror Cloud object must be unprotected.
    """
    deleteAllSnapMirrorCloudSnapshots(
        "Input for V1DeleteAllSnapMirrorCloudSnapshots"
        input: DeleteAllSnapMirrorCloudSnapshotsInput!
    ): ResponseSuccess!
    deleteAppBlueprint(
        "The Polaris UUID for the object."
        fid: UUID!
    ): Boolean!
    deleteAppBlueprintSnapshot(
        "The Polaris UUID for the object."
        fid: UUID!,
        location: String!
    ): Result!
    deleteAppBlueprintSnapshots(
        "The Polaris UUID for the object."
        fid: UUID!
    ): Result!
    "Delete a cluster in Aws."
    deleteAwsCluster(
        "DeleteAwsClusterInput params for Aws."
        input: DeleteAwsClusterInput!
    ): CcProvisionJobReply!
    deleteAwsComputeSetting(
        "Id of aws compute setting."
        awsComputeSettingId: UUID!
    ): DeleteAwsCloudComputeSettingReply!
    "Deletes AWS Exocompute configs."
    deleteAwsExocomputeConfigs(
        "List of AWS exocompute configuration IDs."
        input: DeleteAwsExocomputeConfigsInput!
    ): DeleteAwsExocomputeConfigsReply!
    "Delete the Azure Subscriptions cloud account for the given feature."
    deleteAzureCloudAccount(
        "Input for deleting an Azure Cloud Account."
        input: DeleteAzureCloudAccountInput!
    ): DeleteAzureCloudAccountReply!
    "Delete Exocompute configurations for an Azure Cloud Account."
    deleteAzureCloudAccountExocomputeConfigurations(
        "Input for adding Exocompute configurations for an Azure Cloud Account."
        input: DeleteAzureCloudAccountExocomputeConfigurationsInput!
    ): DeleteAzureCloudAccountExocomputeConfigurationsReply!
    "Delete the Azure Subscriptions cloud account for the given feature without OAuth."
    deleteAzureCloudAccountWithoutOauth(
        "Input for deleting an Azure Cloud Account without OAuth."
        input: DeleteAzureCloudAccountWithoutOauthInput!
    ): DeleteAzureCloudAccountWithoutOauthReply!
    "Delete a cluster in Azure."
    deleteAzureClusterAsync(
        "DeleteAzureClusterInput params for Azure."
        input: DeleteAzureClusterInput!
    ): CcProvisionJobReply!
    deleteBlueprint(
        "The Polaris UUID for the object."
        fid: UUID!
    ): Boolean!
    "Delete multiple Blueprints."
    deleteBlueprints(
        "List of blueprint ids."
        input: DeleteBlueprintsInput!
    ): Boolean!
    "Delete a cassandra source."
    deleteCassandraSource(
        "UUID used to identify the cluster the request goes to"
        clusterUuid: String!,
        "Name of the Mosaic source to be deleted."
        sourceName: String!
    ): MosaicAsyncResponse!
    "Delete Certificate"
    deleteCertificate(
        "Certificate id"
        certificateId: Long!
    ): Boolean!
    "Delete cloud native label rule"
    deleteCloudNativeLabelRule(
        "UUID for the tag or label rule"
        ruleId: UUID!
    ): Void
    "Delete cloud native tag rule"
    deleteCloudNativeTagRule(
        "UUID for the tag or label rule"
        ruleId: UUID!
    ): Void
    deleteCustomReport(id: Int!): Int!
    "Mutation to delete existing Db2 instance."
    deleteDb2Instance(
        "ID of the Db2 instance."
        id: String!
    ): AsyncRequestStatus!
    deleteEventDigest(recipientUserIDs: [String!]!): Boolean!
    """

    Request to delete a mount for the Microsoft Exchange database snapshot

    Supported in v8.0
    Request to delete a mount for Microsoft Exchange database snapshot.
    """
    deleteExchangeSnapshotMount(
        "Input for V1DeleteExchangeSnapshotMount"
        input: DeleteExchangeSnapshotMountInput!
    ): AsyncRequestStatus!
    deleteFailoverCluster(
        "ID of the failover cluster."
        id: String!,
        """

        v5.2-v5.3: A Boolean that specifies whether to preserve the snapshots of the fileset which belong to a failover cluster application. When this value is 'true,' the snapshots are preserved. The default value is 'true.'
        v6.0+: A Boolean that specifies whether to preserve the snapshots of the fileset which belong to a failover cluster application. When this value is 'true,' the snapshots are preserved. The default value is 'true'.
        """
        preserveSnapshots: Boolean
    ): ResponseSuccess!
    "Delete failover cluster application."
    deleteFailoverClusterApp(
        "ID of the failover cluster app."
        id: String!,
        """

        v5.2-v5.3: A Boolean that specifies whether to preserve the snapshots of the fileset which belong to a failover cluster application. When this value is 'true,' the snapshots are preserved. The default value is 'true.'
        v6.0+: A Boolean that specifies whether to preserve the snapshots of the fileset which belong to a failover cluster application. When this value is 'true,' the snapshots are preserved. The default value is 'true'.
        """
        preserveSnapshots: Boolean
    ): ResponseSuccess!
    "Delete failover cluster applications."
    deleteFailoverClusterApps(
        "The ID of each failover cluster application to delete."
        ids: [String!]!,
        """

        v5.3: Specifies whether to preserve the snapshots of the fileset that belongs to a failover cluster application. When this value is 'true,' the snapshots are preserved. The default value is 'true.'
        v6.0+: Specifies whether to preserve the snapshots of the fileset that belongs to a failover cluster application. When this value is 'true,' the snapshots are preserved. The default value is 'true'.
        """
        preserveSnapshots: Boolean
    ): ResponseSuccess!
    deleteFailoverClusters(
        "The ID of each failover cluster to delete."
        ids: [String!]!,
        """

        v5.3: Specifies whether to preserve the snapshots of the fileset which belong to a failover cluster application. When this value is 'true,' the snapshots are preserved. The default value is 'true.'
        v6.0+: Specifies whether to preserve the snapshots of the fileset which belong to a failover cluster application. When this value is 'true,' the snapshots are preserved. The default value is 'true'.
        """
        preserveSnapshots: Boolean
    ): ResponseSuccess!
    deleteFilesetSnapshots(
        "ID of the fileset."
        id: String!
    ): ResponseSuccess!
    deleteGlobalSla(
        "SLA Domain ID."
        id: UUID!,
        "Optional User note."
        userNote: String
    ): SlaResult!
    deleteGuestCredentialById(
        "Input for InternalDeleteGuestCredentialById"
        input: DeleteGuestCredentialByIdInput!
    ): Boolean!
    """

    Delete VM snapshot

    Supported in v5.0+
    Delete a snapshot by expiring it. Snapshot is expired only if it is a manual snapshot or a snapshot of an unprotected vm.
    """
    deleteHypervVirtualMachineSnapshot(
        "Input for InternalDeleteHypervVirtualMachineSnapshot"
        input: DeleteHypervVirtualMachineSnapshotInput!
    ): RequestSuccess!
    """

    Requst to delete a live mount

    Supported in v5.0+
    Create a request to delete a live mount.
    """
    deleteHypervVirtualMachineSnapshotMount(
        "Input for InternalDeleteHypervVirtualMachineSnapshotMount"
        input: DeleteHypervVirtualMachineSnapshotMountInput!
    ): AsyncRequestStatus!
    deleteIdentityProvider: IdentityProvider!
    deleteLdapPrincipals(principalIds: [String!]!): Boolean!
    "Delete a specified log shipping configuration."
    deleteLogShipping(
        "Input for V1DeleteLogShippingConfiguration"
        input: DeleteLogShippingConfigurationInput!
    ): AsyncRequestStatus!
    "Remove a registered MongoDB source from NoSql cluster."
    deleteMongodbSource(
        "UUID used to identify the cluster the request goes to"
        clusterUuid: String!,
        "Name of the Mosaic source to be deleted."
        sourceName: String!
    ): MosaicAsyncResponse!
    """

    Remove the store by store_name

    Supported in m3.2.0-m4.1.0
    Remove a store from Mosaic cluster.
    """
    deleteMosaicStore(
        "Input for V2DeleteMosaicStore"
        input: DeleteMosaicStoreInput!
    ): MosaicAsyncResponse!
    "Delete snapshots of a Microsoft SQL Database."
    deleteMssqlDbSnapshots(
        "Input for V1DeleteMssqlDbSnapshots"
        input: DeleteMssqlDbSnapshotsInput!
    ): ResponseSuccess!
    """

    Delete a Live Mount of a SQL Server database

    Supported in v5.0+
    Create an async request to delete a Live Mount of a SQL Server database. Poll the task status by using /mssql/request/{id}.
    """
    deleteMssqlLiveMount(
        "Input for V1CreateMssqlUnmount"
        input: CreateMssqlUnmountInput!
    ): AsyncRequestStatus!
    """

    Delete a registered NAS system

    Supported in v7.0+
    Delete a NAS system by specifying the NAS system ID.
    """
    deleteNasSystem(
        "Input for V1DeleteNasSystem"
        input: DeleteNasSystemInput!
    ): AsyncRequestStatus!
    """

    Remove Nutanix cluster

    Supported in v5.0+
    Initiates an asynchronous job to remove a Nutanix cluster object. The Nutanix cluster cannot have VMs mounted through the Rubrik cluster.
    """
    deleteNutanixCluster(
        "Input for InternalDeleteNutanixCluster"
        input: DeleteNutanixClusterInput!
    ): AsyncRequestStatus!
    """

    Remove a Live Mount of a Nutanix virtual machine snapshot

    Supported in v6.0+
    Initiates a request to remove a Live Mount of a Nutanix virtual machine snapshot identified by the ID of the Live Mount.
    """
    deleteNutanixMountV1(
        "Input for V1CreateNutanixUnmount"
        input: CreateNutanixUnmountInput!
    ): AsyncRequestStatus!
    """

    Delete VM snapshot

    Supported in v5.0+
    Delete a snapshot by expiring it. Snapshot is expired only if it is a manual snapshot or a snapshot of an unprotected vm.
    """
    deleteNutanixSnapshot(
        "Input for InternalDeleteNutanixSnapshot"
        input: DeleteNutanixSnapshotInput!
    ): RequestSuccess!
    """

    Delete all snapshots of VM

    Supported in v5.0+
    Delete all snapshots of a virtual machine.
    """
    deleteNutanixSnapshots(
        "Input for InternalDeleteNutanixSnapshots"
        input: DeleteNutanixSnapshotsInput!
    ): RequestSuccess!
    deleteO365AzureApp(o365AppClientId: String!, o365AppType: String!): RequestStatus!
    deleteO365Org(orgId: UUID!): CreateOnDemandJobReply!
    deleteO365ServiceAccount(orgId: UUID!): RequestStatus!
    "Delete an organization."
    deleteOrg(
        "Input required for org delete."
        input: DeleteOrgInput!
    ): Boolean!
    "Deletes the polaris on-demand snapshot by id"
    deletePolarisSnapshot(
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!
    ): Boolean!
    "delete the recovery specs with the given app blueprint"
    deleteRecoverySpec(
        "the id of the blueprint"
        blueprintId: UUID!,
        "List of plan types (PROD, TEST, PROD_LOCAL) that will be excluded from spec deletion."
        excludePlanTypes: [PlanNameEnum!]!
    ): DeleteBlueprintRecoverySpecReply!
    deleteReport(reportID: Int!): Boolean!
    deleteRole(roleId: String!): Boolean!
    "Delete SMTP configuration value."
    deleteSMTPConfiguration: Boolean!
    deleteSapHanaDatabaseSnapshot(
        "ID assigned to a SAP HANA database full snapshot."
        id: String!
    ): ResponseSuccess!
    deleteSapHanaSystem(
        "The ID of the SAP HANA system."
        id: String!
    ): AsyncRequestStatus!
    deleteScheduledReport(id: Int!): Int!
    deleteServiceAccountsFromAccount(
        "List of service account IDs to be deleted"
        ids: [String!]!
    ): Boolean!
    """

    Delete a SnapMirror Cloud protected object

    Supported in v7.0+
    Delete a SnapMirror Cloud protected object specified by the object ID.
    """
    deleteSnapMirrorCloud(
        "Input for V1DeleteSnapMirrorCloud"
        input: DeleteSnapMirrorCloudInput!
    ): ResponseSuccess!
    """

    Delete the SnapMirrorCloud relationship on the NetApp server between the volume and the cloud target

    Supported in v7.0+
    Deletes the SnapMirrorCloud relationship on the NetApp server between the volume and the cloud target. Also deletes objects on the NetApp server used to establish the relationship.
    """
    deleteSnapMirrorCloudRelationship(
        "Input for V1DeleteSnapMirrorCloudRelationship"
        input: DeleteSnapMirrorCloudRelationshipInput!
    ): ResponseSuccess!
    """

    Delete a SnapMirror Cloud snapshot

    Supported in v7.0+
    Deletes a SnapMirror Cloud snapshot. A snapshot can be deleted only if it is an on-demand snapshot or a snapshot of an unprotected SnapMirror Cloud object.
    """
    deleteSnapMirrorCloudSnapshot(
        "Input for V1DeleteSnapMirrorCloudSnapshot"
        input: DeleteSnapMirrorCloudSnapshotInput!
    ): ResponseSuccess!
    deleteSnapshotsOfUnmanagedObjects(
        "List of UUIDs of objects"
        objectIds: [UUID!]!
    ): RequestSuccess!
    deleteSyslogConfiguration(
        "Syslog ids to delete"
        ids: [String!]!
    ): Boolean!
    deleteTarget(
        "Corresponds to ID of target in Polaris"
        targetId: UUID!
    ): TargetDeleteResult!
    deleteTargetMapping(targetMappingDeleteRequest: TargetMappingDeleteRequest!): TargetMappingDeletionResult!
    "Reset TOTP configuration for a user. Return true when the operation succeeds."
    deleteTotpConfig(
        "User ID."
        userId: String!
    ): Boolean!
    "Reset TOTP configuration for users in batch. Return true when the operation succeeds."
    deleteTotpConfigs(
        "Input required for resetting TOTP for users in batch."
        input: DeleteTotpConfigsInput!
    ): Boolean!
    deleteUnmanagedSnapshots(
        "List of UUIDs of snapshots"
        snapshotIds: [UUID!]!
    ): RequestSuccess!
    deleteUsersFromAccount(
        "List of IDs."
        ids: [String!]!
    ): Boolean!
    """

    Requst to delete a mount

    Supported in v5.0+
    Create a request to delete a mount. If there are volumes mounted on a target host, this will use best-effort to unmount those volumes from the host, and proceed to unmount storage on Rubrik.
    """
    deleteVolumeGroupMount(
        "Input for InternalDeleteVolumeGroupSnapshotMount"
        input: DeleteVolumeGroupSnapshotMountInput!
    ): AsyncRequestStatus!
    "Delete a webhook."
    deleteWebhook(
        "The webhook to delete from the account."
        input: DeleteWebhookInput!
    ): Void
    "A single Rubrik cluster can be the replication target for multiple source Rubrik clusters. For each source cluster specified, this resumes replication from that source cluster to the target cluster."
    disableReplicationPause(
        "Input for V1DisablePerLocationPause"
        input: DisablePerLocationPauseInputVariable!
    ): ResponseSuccess!
    "Disables an Archival Location."
    disableTarget(
        "Request for disabling an Archival Location."
        input: DisableTargetInput!
    ): DisableTargetReply!
    "Dissolve legal hold on snapshots."
    dissolveLegalHold(
        "Dissolve Legal Hold Request."
        input: DissolveLegalHoldInput!
    ): DissolveLegalHoldReply!
    downloadFile(fileType: FileTypeEnum!, reportConfig: ReportConfigInput, reportID: Int!): reportGenerateReply!
    """

    Download files from a Nutanix VM backup

    Supported in v5.0+
    Start an asynchronous job to download multiple files and folders from a specified Nutanix VM backup. The response returns an asynchronous request ID. Get the URL for downloading the zip file including the specific files/folders by sending a GET request to 'nutanix/vm/request/{id}'.
    """
    downloadFilesNutanixSnapshot(
        "Input for InternalCreateNutanixDownloadFilesJob"
        input: CreateNutanixDownloadFilesJobInput!
    ): AsyncRequestStatus!
    downloadFilesetSnapshot(
        "ID of snapshot."
        id: String!
    ): AsyncRequestStatus!
    """

    Download files from a Hyper-V VM backup

    Supported in v5.0+
    Start an asynchronous job to download multiple files and folders from a specified Hyper-V VM backup. The response returns an asynchrounous request ID. Get the URL for downloading the ZIP file including the specific files/folders by sending a GET request to 'hyperv/vm/request/{id}'.
    """
    downloadHypervVMSnapshotFiles(
        "Input for InternalDownloadHypervVirtualMachineSnapshotFiles"
        input: DownloadHypervVirtualMachineSnapshotFilesInput!
    ): AsyncRequestStatus!
    """

    Creates a download from archival request

    Supported in v5.0+
    Download a snapshot from archival.
    """
    downloadHypervVirtualMachineSnapshot(
        "Input for InternalDownloadHypervVirtualMachineSnapshot"
        input: DownloadHypervVirtualMachineSnapshotInput!
    ): AsyncRequestStatus!
    """

    Downloads a list of snapshot and log backups from a Microsoft SQL database

    Supported in v5.2+
    Downloads a list of snapshot and log backups from a Microsoft SQL database.
    """
    downloadMssqlDatabaseBackupFiles(
        "Input for V1CreateDownloadMssqlBackupFilesById"
        input: CreateDownloadMssqlBackupFilesByIdInput!
    ): AsyncRequestStatus!
    "Download Microsoft SQL Database backup files from archival location."
    downloadMssqlDatabaseFilesFromArchivalLocation(
        "Input for V1DownloadFromArchive"
        input: DownloadFromArchiveInput!
    ): AsyncRequestStatus!
    """

    Creates a download from archival request

    Supported in v5.0+
    Download a snapshot from archival.
    """
    downloadNutanixSnapshot(
        "Input for InternalCreateDownloadSnapshotForNutanix"
        input: CreateDownloadSnapshotForNutanixInput!
    ): AsyncRequestStatus!
    "Schedule a download CSV job for cross object files."
    downloadObjectFilesCsv(
        "Request for scheduling a download CSV job for cross object files."
        DownloadObjectFilesCsvInput: DownloadObjectFilesCsvInput!
    ): DownloadCsvReply!
    "Schedule a download CSV job for objects list."
    downloadObjectsListCsv(
        "Request for scheduling a download CSV job for objects list."
        DownloadObjectsListCsvInput: DownloadObjectsListCsvInput!
    ): DownloadCsvReply!
    downloadReportCSVAsync(config: CustomReportCreate, id: Int!): AsyncDownloadReply!
    downloadReportPDFAsync(config: CustomReportCreate, id: Int!): AsyncDownloadReply!
    "Download file results csv"
    downloadResultsCsv(crawlId: String!, downloadFilter: DownloadResultsCsvFiltersInput): DownloadResultsCsvReply!
    "Download snapshot policy results csv"
    downloadSnapshotResultsCsv(downloadFilter: DownloadResultsCsvFiltersInput, snappableFid: String!, snapshotFid: String!): DownloadCsvReply!
    "Schedule a download CSV job for a user's activity."
    downloadUserActivityCsv(
        "Request for scheduling a download CSV job for a user's activity."
        DownloadUserActivityCsvInput: DownloadUserActivityCsvInput!
    ): DownloadCsvReply!
    "Schedule a download CSV job for user activity on a specific file."
    downloadUserFileActivityCsv(
        "Request for scheduling a download CSV job for a user activity on a specific file."
        DownloadUserFileActivityCsvInput: DownloadUserFileActivityCsvInput!
    ): DownloadCsvReply!
    """

    Download files from Volume Group snapshot

    Supported in v5.0+
    Create a download files request.
    """
    downloadVolumeGroupSnapshotFiles(
        "Input for InternalCreateVolumeGroupDownloadFilesJob"
        input: CreateVolumeGroupDownloadFilesJobInput!
    ): AsyncRequestStatus!
    editAutomaticAwsTargetMapping(automaticAwsTargetMappingEditRequest: AutomaticAwsTargetMappingEditRequest!): TargetMapping!
    editAutomaticAzureTargetMapping(automaticAzureTargetMappingEditRequest: AutomaticAzureTargetMappingEditRequest!): TargetMapping!
    editAwsAccount(
        "Request for editing an existing AWS account"
        awsAccountEditRequest: AwsAccountEditRequest!
    ): CloudAccount!
    editAwsTarget(
        "Request for updating an existing AWS target"
        awsTargetEditRequest: AwsTargetEditRequest!
    ): Target!
    editAzureAccount(
        "Request for editing an existing Azure account"
        azureAccountEditRequest: AzureAccountEditRequest!
    ): CloudAccount!
    editAzureTarget(
        "Request for updating an existing Azure target"
        azureTargetEditRequest: AzureTargetEditRequest!
    ): Target!
    "Edit Certificate"
    editCertificate(
        "Certificate"
        certificate: String,
        "Certificate id"
        certificateId: Long!,
        "Certificate description"
        description: String,
        "Certificate name"
        name: String
    ): Boolean!
    editClusterDefaultAddress(
        clusterDefaultAddress: String,
        "The ID of the cluster."
        clusterUuid: UUID!
    ): Cluster!
    editClusterLocation(
        clusterLocation: ClusterLocationEdit!,
        "The ID of the cluster."
        clusterUuid: UUID!
    ): Cluster!
    editCustomReport(config: CustomReportCreate!, id: Int!): CustomReport!
    editGcpTarget(
        "Request for updating an existing Gcp target"
        input: GcpTargetEditInput!
    ): Target!
    editGlobalSla(globalSlaEditRequest: GlobalSlaEditRequest!): GlobalSla!
    editManualTargetMapping(manualTargetMappingEditRequest: ManualTargetMappingEditRequest!): TargetMapping!
    editNfsTarget(
        "Request for updating an existing NFS target"
        nfsTargetEditRequest: NfsTargetEditRequest!
    ): Target!
    editRcsTarget(
        "Request for editing a new RCS Azure location"
        rcsAzureTargetEditRequest: RcsTargetEditRequest!
    ): Target!
    editS3CompatibleTarget(
        "Request for updating an existing S3Compatible target"
        input: S3CompatibleTargetEditInput!
    ): Target!
    editSapHanaSystem(
        "The ID of the SAP HANA system."
        id: String!,
        "An object that contains the updated SLA Domain ID for the SAP HANA system."
        updateProperties: SapHanaSystemPatchInput!
    ): SapHanaPatchSystemResponse!
    editScheduledReport(id: Int!, scheduledReport: ScheduledReportCreate!): ScheduledReport!
    "Enable/disable auto fmd upload on given cluster"
    enableAutomaticFmdUpload(
        "The ID of the cluster."
        clusterUuid: UUID!,
        "Enable or disable lambda service."
        enabled: Boolean!
    ): EnableAutomaticFmdUploadReply!
    "Enable/ Disable App consistency for a VM"
    enableDisableAppConsistency(
        "Input required to enable application consistent snapshots."
        input: EnableDisableAppConsistencyInput!
    ): EnableDisableAppConsistencyReply!
    "Enable/disable lambda service for given snappable on given cluster"
    enableLambdaForSnappable(
        "Enable or disable diff fmd upload."
        enableDiffFmd: Boolean!,
        "Enable or disable full fmd upload."
        enableFullFmd: Boolean!,
        "The FID of the snappable."
        snappableId: UUID!
    ): EnableLambdaForSnappableReply!
    enableO365SharePoint(exocomputeClusterId: String!): RequestStatus!
    enableO365Teams(exocomputeClusterId: String!): RequestStatus!
    "A single Rubrik cluster can be the replication target for multiple source Rubrik clusters. For each source cluster specified, this pauses replication from that source cluster to the target cluster."
    enableReplicationPause(
        "Input for V1EnablePerLocationPause"
        input: EnablePerLocationPauseInputVariable!
    ): ResponseSuccess!
    "Enables an Archival Location."
    enableTarget(
        "Request for enabling an Archival Location."
        input: EnableTargetInput!
    ): EnableTargetReply!
    "Mark AWS Native EBS Volumes to be excluded from EC2 Instance snapshot. By default, all EBS Volumes are marked as included."
    excludeAwsNativeEbsVolumesFromSnapshot(
        "Input to mark EBS volumes to be excluded for EC2 snapshot."
        input: ExcludeAwsNativeEbsVolumesFromSnapshotInput!
    ): Void
    "Exclude the Managed Disks from snapshots, for the specified virtual machines."
    excludeAzureNativeManagedDisksFromSnapshot(
        "Input for excluding Azure Native Managed Disks from Snapshot."
        input: ExcludeAzureNativeManagedDisksFromSnapshotInput!
    ): Void
    """

    Export VM snapshot

    Supported in v5.0+
    Export snapshot of a vm.
    """
    exportHypervVirtualMachine(
        "Input for InternalExportHypervVirtualMachineSnapshot"
        input: ExportHypervVirtualMachineSnapshotInput!
    ): AsyncRequestStatus!
    "Export Kubernetes Namespace Snapshot."
    exportK8sNamespace(
        "Request to export K8s Namespace Snapshot."
        k8sNamespaceExportRequest: ExportK8sNamespaceInput!
    ): CreateOnDemandJobReply!
    "Create a request to export a Microsoft SQL database."
    exportMssqlDatabase(
        "Input for V1CreateExportMssqlDb"
        input: CreateExportMssqlDbInput!
    ): AsyncRequestStatus!
    """

    Export VM snapshot

    Supported in v5.0+
    Export snapshot of a vm.
    """
    exportNutanixSnapshot(
        "Input for InternalCreateNutanixExport"
        input: CreateNutanixExportInput!
    ): AsyncRequestStatus!
    exportO365Mailbox(exportConfig: ExportO365MailboxInput!): CreateOnDemandJobReply!
    filesetAddHost(
        "host name"
        hostName: String!,
        snappableFid: UUID!
    ): RequestSuccess!
    filesetDownloadSnapshotFiles(
        "Configuration information for a job to download files and folders from a fileset backup."
        config: FilesetDownloadFilesJobConfigInput!,
        deltaTypeFilter: [DeltaTypeEnum!],
        "ID assigned to a fileset backup object."
        id: String!,
        nextSnapshotFid: UUID,
        "Optional User note."
        userNote: String
    ): AsyncRequestStatus!
    filesetExportSnapshotFiles(
        "The configuration of a job that exports one or more files or folders from a fileset backup."
        config: FilesetExportFilesJobConfigInput!,
        deltaTypeFilter: [DeltaTypeEnum!],
        "ID of snapshot."
        id: String!,
        nextSnapshotFid: UUID,
        "os type"
        osType: GuestOsTypeEnum!,
        "share type"
        shareType: ShareTypeEnum! = NoShareType
    ): AsyncRequestStatus!
    filesetRecoverFiles(
        "Configuration for job to restore one or more files or folders from a fileset backup."
        config: FilesetRestoreFilesJobConfigInput!,
        deltaTypeFilter: [DeltaTypeEnum!],
        nextSnapshotFid: UUID,
        "os type"
        osType: GuestOsTypeEnum!,
        "List of restore path pairs"
        restorePathPairList: [OldRestorePathPairInput!]!,
        "share type"
        shareType: ShareTypeEnum! = NoShareType,
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!
    ): AsyncRequestStatus!
    "Process and finalize deletion of cloud account is the last step in deletion of a feature from cloud account. This endpoint is a MUST for deletion of disconnected features."
    finalizeAwsCloudAccountDeletion(
        "Arguments to process AWS cloud accounts for deletion."
        input: FinalizeAwsCloudAccountDeletionInput!
    ): FinalizeAwsCloudAccountDeletionReply!
    "Process cloud account. This is the second step after validate and create in addition of a feature for cloud account.The CloudFormation stack should be created after this step using the CloudFormation URL provided in the first step."
    finalizeAwsCloudAccountProtection(
        "Arguments for process cloud accounts."
        input: FinalizeAwsCloudAccountProtectionInput!
    ): FinalizeAwsCloudAccountProtectionReply!
    "Adds a new cloud account for the GCP project which is not already added"
    gcpCloudAccountAddManualAuthProject(
        "Cloud Account Features."
        features: [CloudAccountFeature!]!,
        "The native project ID of the GCP project."
        gcpNativeProjectId: String!,
        "The project name of the GCP project."
        gcpProjectName: String!,
        "The project number of the GCP project."
        gcpProjectNumber: Long!,
        "[Optional] The name of the organization containing the project."
        organizationName: String,
        "[Optional] JWT config of the service account."
        serviceAccountJwtConfigOptional: String
    ): Boolean!
    "Add cloud account for Gcp Projects for the given features."
    gcpCloudAccountAddProjects(
        "List of cloud account project native Ids."
        cloudAccountsProjectIds: [String!]!,
        "List of Gcp project native Ids to be added for native protection."
        nativeProtectionProjectIds: [String!]!,
        "Session ID of the current OAuth session."
        sessionId: String!,
        "List of Gcp shared VPC host project native Ids."
        sharedVpcHostProjectIds: [String!]!
    ): GcpCloudAccountAddProjectsReply!
    "Delete cloud account for the given Gcp Project UUIDs and feature."
    gcpCloudAccountDeleteProjects(
        "List of cloud account project native Uuids."
        cloudAccountsProjectUuids: [UUID!]!,
        "List of Gcp project native Uuids to be added for native protection."
        nativeProtectionProjectUuids: [UUID!]!,
        "Optional Session ID of the current OAuth session."
        sessionId: String,
        "List of Gcp shared VPC host project native Uuids."
        sharedVpcHostProjectUuids: [UUID!]!,
        "Flag that denotes if cleanup of GCP resources should be skipped. If this flag is set, then the session ID is ignored."
        skipResourceDeletion: Boolean!
    ): [GcpCloudAccountProjectDeleteStatus!]!
    "Complete the OAuth flow and pass the authorization code."
    gcpCloudAccountOAuthComplete(
        "Authorization code received after the oauth consent flow."
        authorizationCode: String!,
        "Redirect URL used in the oauth flow."
        redirectUrl: String!,
        "Session ID of the current OAuth session."
        sessionId: String!
    ): GcpCloudAccountOAuthCompleteResponse!
    "Initiate a session before doing Gcp OAuth flow."
    gcpCloudAccountOAuthInitiate(
        "Customer Url."
        customerUrl: String!
    ): GcpCloudAccountOAuthInitiateResponse!
    "Upgrade cloud account for the given Gcp Project UUIDs and feature."
    gcpCloudAccountUpgradeProjects(
        "Cloud Account Feature. A feature refers to the Polaris feature that Rubrik provides."
        feature: CloudAccountFeature!,
        "List of Gcp project UUIDs."
        projectUuids: [UUID!]!,
        "Session ID of the current OAuth session."
        sessionId: String!
    ): [GcpCloudAccountProjectUpgradeStatus!]!
    "Triggers GCPNative disable project job for the given project ID"
    gcpNativeDisableProject(
        "ID of the Project."
        projectId: UUID!,
        "Whether to delete the native snapshots while disabling the project"
        shouldDeleteNativeSnapshots: Boolean!
    ): AsyncJobStatus!
    gcpNativeExcludeDisksFromInstanceSnapshot(
        "Mapping from disk ID to excluded flag"
        diskIdToIsExcluded: [DiskIdToIsExcluded!]!,
        "GCP GCE instance ID"
        instanceId: UUID!
    ): Void
    "Trigger GCP native export disk job for the given disk snapshot"
    gcpNativeExportDisk(
        "Encryption type for created disk(s)"
        diskEncryptionType: DiskEncryptionType!,
        "Customer managed Key to encrypt created disk, applicable when encryption type is CustomerManagedKey"
        kmsCryptoKey: kmsCryptoKey,
        "Customer managed Key to encrypt created disk, applicable when encryption type is CustomerManagedKeyResourceId"
        kmsCryptoKeyResourceId: String,
        "Whether the exported disk should replace source disk from attached instance"
        replaceAttached: Boolean!,
        "The zones where the regional exported disk should be replicated"
        replicaZones: [String!],
        "Whether to allow Rubrik labels on Rubrik created/manipulated resources"
        shouldAddRubrikLabels: Boolean!,
        "The labels will be copied to the Rubrik created/manipulated resource from the source resource that were there at the time of taking the snapshot"
        shouldCopyLabels: Boolean!,
        "ID of snapshot."
        snapshotId: UUID!,
        "The disk name of the to-be-created disk."
        targetDiskName: String!,
        "Size of the exported disk in GB"
        targetDiskSizeGb: Int!,
        "The disk type of the to-be-created disk."
        targetDiskType: String!,
        "The region of the to-be-created disk."
        targetRegion: String!,
        "The zone of the to-be-created disk."
        targetZone: String
    ): AsyncJobStatus!
    "Trigger GCP native export instance job for the given instance snapshot"
    gcpNativeExportGceInstance(
        "Encryption type for created disk(s)"
        diskEncryptionType: DiskEncryptionType!,
        "Customer managed Key to encrypt created disk, applicable when encryption type is CustomerManagedKey"
        kmsCryptoKey: kmsCryptoKey,
        "Customer managed Key to encrypt created disk, applicable when encryption type is CustomerManagedKeyResourceId"
        kmsCryptoKeyResourceId: String,
        "Native ID of the shared VPC host project for the current service project"
        sharedVPCHostProjectNativeID: String,
        "Whether to allow Rubrik labels on Rubrik created/manipulated resources"
        shouldAddRubrikLabels: Boolean!,
        "The labels will be copied to the Rubrik created/manipulated resource from the source resource that were there at the time of taking the snapshot"
        shouldCopyLabels: Boolean!,
        "The to-be-created instance will be created in a powered-off state"
        shouldPowerOff: Boolean!,
        "ID of snapshot."
        snapshotId: UUID!,
        "The instance name of the to-be-created instance."
        targetInstanceName: String!,
        "The machine type of the to-be-created instance."
        targetMachineType: String!,
        "The network tags of the to-be-created instance."
        targetNetworkTags: [String!],
        "The subnet name of the to-be-created instance."
        targetSubnetName: String!,
        "The zone of the to-be-created instance."
        targetZone: String!
    ): AsyncJobStatus!
    "Trigger GCP native refresh project job for the given project IDs"
    gcpNativeRefreshProjects(
        "List of Project IDs"
        projectIds: [UUID!]!
    ): BatchAsyncJobStatus!
    "Triggers GCPNative restore instance job for the given snapshot ID"
    gcpNativeRestoreGceInstance(
        "Whether to allow Rubrik labels on Rubrik created/manipulated resources"
        shouldAddRubrikLabels: Boolean!,
        "Whether to restore labels of the instance from snapshot"
        shouldRestoreLabels: Boolean!,
        "Whether the restored instance should be started"
        shouldStartRestoredInstance: Boolean!,
        "ID of snapshot."
        snapshotId: UUID!
    ): AsyncJobStatus!
    "Sets the default service account auth key"
    gcpSetDefaultServiceAccountJwtConfig(
        "The JWT config for a service account in customer project."
        serviceAccountJWTConfig: String!,
        "The name of the service account"
        serviceAccountName: String!
    ): Boolean!
    "Generate CSR"
    generateCSR(
        "City for your CSR"
        city: String,
        "Country for your CSR"
        country: String,
        "Email for your CSR"
        email: String,
        "Hostnames for your CSR"
        hostnames: [String!]!,
        "Name for your CSR"
        name: String!,
        "Organization for your CSR"
        organization: String,
        "Organization unit for your CSR"
        organizationUnit: String,
        "State for your CSR"
        state: String,
        "Surname for your CSR"
        surname: String,
        "User id for your CSR"
        userId: String
    ): Csr!
    "Generate a JWT that can be used to register clusters with Polaris. If ManagedByPolarisArg is not given, the product type is inferred automatically."
    generateClusterRegistrationToken(
        "Input required for cluster token generation based on cluster details."
        input: GenerateClusterRegistrationTokenInput,
        "If true, generate a token for registering a Hybrid cluster. If false, generate a token for registering LifeOfDevice cluster. If it's not passed, the product type is inferred automatically."
        managedByPolaris: Boolean
    ): ClusterRegistrationToken!
    "Generate TOTP secret for a user."
    generateTotpSecret(
        "User ID."
        userId: String!
    ): GenerateTotpSecretReply!
    getDownloadUrl(downloadId: Long!): UserDownloadUrl!
    """

    Get pending SLA Domain assignments on selected managed objects

    Supported in v5.2+
    Retrieve the details of pending SLA Domain assignments on the given managed objects. For objects with pending assignments, return the SLA Domain that is pending. For objects without pending assignments, return the current SLA Domain information. Explicitly list invalid object IDs.
    """
    getPendingSlaAssignments(
        "Input for V2GetPendingSlaAssignments"
        input: GetPendingSlaAssignmentsInput!
    ): PendingSlaOperations!
    """

    Delete all snapshots of VM

    Supported in v5.0+
    Delete all snapshots of a virtual machine.
    """
    hypervDeleteAllSnapshots(
        "Input for InternalDeleteHypervVirtualMachineSnapshots"
        input: DeleteHypervVirtualMachineSnapshotsInput!
    ): RequestSuccess!
    """

    Create on-demand VM snapshot

    Supported in v5.0+
    Create an on-demand snapshot for the given VM ID.
    """
    hypervOnDemandSnapshot(
        "Input for InternalCreateHypervVirtualMachineSnapshot"
        input: CreateHypervVirtualMachineSnapshotInput!
    ): AsyncRequestStatus!
    "Delete a given HyperV SCVMM."
    hypervScvmmDelete(
        "ID of the Hyper-V SCVMM."
        id: String!
    ): ResponseSuccess!
    "Update properties for a given HyperV SCVMM."
    hypervScvmmUpdate(
        "ID of Hyper-V SCVMM."
        id: String!,
        "Properties to update."
        updateProperties: HypervScvmmUpdateInput!
    ): HypervScvmmDetail!
    """

    Initiate a live mount for a given Volume Group snapshot

    Supported in v5.0+
    Create a live mount request for a Volume Group snapshot.
    """
    initiateVolumeGroupMount(
        "Input for InternalCreateVolumeGroupMount"
        input: CreateVolumeGroupMountInput!
    ): AsyncRequestStatus!
    insertCustomerO365App(
        o365AppClientId: String!,
        o365AppClientSecret: String!,
        o365AppType: String!,
        "A certificate attached to the Azure AD App provided as a base64 string."
        o365Base64AppCertificate: String,
        "A private key attached to the Azure AD App provided as a base64 string."
        o365Base64AppPrivateKey: String,
        o365SubscriptionName: String!
    ): RequestStatus!
    """

    Creates an instant recover request that restores a target VM from the given Rubrik-hosted-snapshot

    Supported in v5.0+
    The VM will be started with networking enabled. If the VM does not exist anymore, a new VM will be created.
    """
    instantRecoverHypervVMSnapshot(
        "Input for InternalRecoverHypervVirtualMachineSnapshot"
        input: RecoverHypervVirtualMachineSnapshotInput!
    ): AsyncRequestStatus!
    "List CIDRs for compute setting."
    listCidrsForComputeSetting(
        "Optional List of Cluster UUIDs."
        clusterIdsArg: [UUID!]
    ): ListCidrsForComputeSettingReply!
    "Login to Rubrik support portal using username and password."
    loginToRubrikSupportPortal(
        "Support portal hostname"
        hostname: String! = "rubrik.force.com",
        "Support portal organization ID"
        organizationId: String! = "00D40000000N3x2",
        "Support portal password to login"
        password: String!,
        "Support portal username to login"
        username: String!
    ): SupportPortalLoginReply!
    "Logout from Rubrik support portal using username."
    logoutFromRubrikSupportPortal: SupportPortalLogoutReply!
    "Map Azure cloud accounts to an Exocompute subscription."
    mapAzureCloudAccountExocomputeSubscription(
        "Input for mapping Azure cloud accounts to an Exocompute subscription."
        input: MapAzureCloudAccountExocomputeSubscriptionInput!
    ): MapAzureCloudAccountExocomputeSubscriptionReply!
    "Map Azure cloud accounts to a persistent storage location."
    mapAzureCloudAccountToPersistentStorageLocation(
        "Input for mapping Azure cloud accounts to a persistent storage location."
        input: MapAzureCloudAccountToPersistentStorageLocationInput!
    ): MapAzureCloudAccountToPersistentStorageLocationReply!
    """

    Relocate a Nutanix virtual machine to another storage container

    Supported in v6.0+
    Initiate a request to migrate the virtual disks of a specified Nutanix Live Mount to another storage container. The destination storage container has been specified when the Live Mount was created. The Live Mount will be deleted when the relocation succeeds.
    """
    migrateNutanixMountV1(
        "Input for V1CreateNutanixVmMountMigration"
        input: CreateNutanixVmMountMigrationInput!
    ): AsyncRequestStatus!
    """

    Initiate a Live Mount of a Nutanix virtual machine snapshot

    Supported in v6.0+
    Initiates a request to perform a Live Mount of a Nutanix virtual machine snapshot identified by the snapshot ID.
    """
    mountNutanixSnapshotV1(
        "Input for V1CreateNutanixMount"
        input: CreateNutanixMountInput!
    ): AsyncRequestStatus!
    "Mutate LDAP Integration"
    mutateLdapIntegration(
        "BaseDn for your LDAP integration."
        baseDn: String,
        "BindUserName for your LDAP integration."
        bindUserName: String!,
        "BindUserPassword for your LDAP integration."
        bindUserPassword: String!,
        "Dynamic DNS name for your LDAP integration."
        dynamicDnsName: String,
        "Group member attribute for your LDAP integration."
        groupMemberAttr: String,
        "Group membership attribute for your LDAP integration."
        groupMembershipAttr: String,
        "Group search filter for your LDAP integration."
        groupSearchFilter: String,
        "ID for your LDAP integration."
        id: UUID,
        "LdapServers for your LDAP integration."
        ldapServers: [LdapServerInput!],
        "Name for your LDAP integration."
        name: String!,
        "TrustedCerts for your LDAP integration."
        trustedCerts: String,
        "User name attribute for your LDAP integration."
        userNameAttr: String,
        "User search filter for your LDAP integration."
        userSearchFilter: String
    ): String!
    mutateRole(
        description: String!,
        "Role type is org admin role."
        isOrgAdmin: Boolean,
        name: String!,
        "Permissions in the role."
        permissions: [PermissionInput!]!,
        protectableClusters: [String!]!,
        roleId: String
    ): UUID!
    o365OAuthConsentComplete(code: String!, o365ResourceNaturalID: String!, redirectUrl: String!, stateToken: String!, tenantId: String!): O365OAuthConsentCompleteResp!
    o365OAuthConsentKickoff(o365AppType: String!, orgId: UUID!): O365OAuthConsentKickoffResp!
    o365SaaSSetupComplete(o365AppTypes: [String!]!, regionName: String!, stateToken: String!, tenantId: String!): AddO365OrgResponse!
    o365SaaSSetupKickoff: O365SaaSSetupKickoffResp!
    o365SetupKickoff: O365SetupKickoffResp!
    "Open a support tunnel in cluster."
    openSupportTunnel(
        "Cluster uuid"
        clusterUuid: UUID!,
        "Close existing tunnel if any, before attempting to open the tunnel"
        force: Boolean! = false,
        "Activity timeout of support tunnel"
        timeout: Int! = 0
    ): OpenSupportTunnelReply!
    "Updates authentication server-based AWS cloud account. Use this mutation to update account details related to role name, certificates, features. The mutation can update one or more certificates associated to an account in a single request. All input fields except account identifier are optional so that any combination of account attributes can be updated in a single call. If none of the optional fields are provided in the input then no updates are performed, and the response does not contain any error message."
    patchAwsAuthenticationServerBasedCloudAccount(
        "Input to update authentication server-based AWS cloud account."
        input: PatchAwsAuthenticationServerBasedCloudAccountInput!
    ): Boolean!
    "Updates IAM user-based AWS cloud account. Use this mutation to update account details access/secret keys, role ARN and regions. All input fields except account ID are optional so that any combination of account attributes can be updated in a single call. If none of the optional fields are provided in the input then no updates are performed, and the response does not contain any error message."
    patchAwsIamUserBasedCloudAccount(
        "Input to update IAM user-based AWS cloud account."
        input: PatchAwsIamUserBasedCloudAccountInput!
    ): Boolean!
    """

    Change Nutanix Live Mount power status

    Supported in v6.0+
    Changes the power status of a mounted Nutanix virtual machine.
    """
    patchNutanixMountV1(
        "Input for V1PatchNutanixVmMount"
        input: PatchNutanixVmMountInput!
    ): NutanixVmMountDetail!
    "Pause/Resume Global SLA on the given clusters."
    pauseSla(
        "Pause SLA request."
        input: PauseSlaRequest!
    ): SlaResult!
    pauseTarget(
        "Corresponds to ID of target in Polaris"
        targetId: UUID!
    ): PauseTargetReply!
    "Prepare deletion of cloud account. This is the first step to delete AWS cloud account. It generated template for deletion of cloud account and does not change any state of account."
    prepareAwsCloudAccountDeletion(
        "Args for initiate aws cloud accounts for deletion."
        input: PrepareAwsCloudAccountDeletionInput!
    ): PrepareAwsCloudAccountDeletionReply!
    "Prepare manual update features to latest version."
    prepareFeatureUpdateForAwsCloudAccount(
        "Input to prepare feature update for AWS cloud account."
        input: PrepareFeatureUpdateForAwsCloudAccountInput!
    ): PrepareFeatureUpdateForAwsCloudAccountReply!
    "Promotes a reader Archival Location."
    promoteReaderTarget(
        "Request for promoting a reader Archival Location."
        input: PromoteReaderTargetInput!
    ): Void
    "Recover a cassandra source."
    recoverCassandraSource(
        "Input for V2MosaicRestoreData"
        input: MosaicRestoreDataInput!
    ): MosaicAsyncResponse!
    "Recover a mongodb source."
    recoverMongodbSource(
        "Input for V2MosaicRestoreData"
        input: MosaicRestoreDataInput!
    ): MosaicAsyncResponse!
    refreshGlobalManagerConnectivityStatus(
        "The ID of the cluster."
        clusterUuid: UUID!
    ): GlobalManagerConnectivity!
    refreshHost(
        "ID assigned to a host object."
        id: String!
    ): HostDetail!
    "Refresh a given HyperV SCVMM."
    refreshHypervScvmm(
        "ID of the Hyper-V SCVMM."
        id: String!
    ): AsyncRequestStatus!
    """

    Refresh Hyper-V host metadata

    Supported in v5.0+
    Create a job to refresh the metadata for the specified Hyper-V host.
    """
    refreshHypervServer(
        "Input for InternalRefreshHypervHost"
        input: RefreshHypervHostInput!
    ): AsyncRequestStatus!
    "Refresh resources of a Kubernetes cluster."
    refreshK8sCluster(
        "Request for refreshing resources in a K8s cluster."
        k8sClusterRefreshRequest: K8sClusterRefreshInput!
    ): CreateOnDemandJobReply!
    """

    On-demand discovery of a list of NAS systems

    Supported in v7.0+
    Runs the NAS_DISCOVER job for autodiscovery/refresh of NAS systems.
    """
    refreshNasSystems(
        "Input for V1DiscoverNasSystems"
        input: DiscoverNasSystemsInput!
    ): DiscoverNasSystemResponse!
    """

    Refresh Nutanix cluster metadata

    Supported in v5.0+
    Create a job to refresh the metadata for the specified Nutanix cluster.
    """
    refreshNutanixCluster(
        "Input for InternalCreateNutanixClusterRefresh"
        input: CreateNutanixClusterRefreshInput!
    ): AsyncRequestStatus!
    refreshO365Org(orgId: UUID!): CreateOnDemandJobReply!
    """

    Refresh an Oracle database

    Supported in v6.0+
    Starts an asynchronous job to refresh the Oracle database metadata by querying the database instances on all the underlying hosts.
    """
    refreshOracleDatabase(
        "Input for V1RefreshOracleDb"
        input: RefreshOracleDbInput!
    ): AsyncRequestStatus!
    "Promotes a reader Archival Location."
    refreshReaderTarget(
        "Request for refreshing a reader Archival Location."
        input: RefreshReaderTargetInput!
    ): Void
    refreshSapHanaSystem(
        "The ID of the SAP HANA system."
        id: String!
    ): AsyncRequestStatus!
    """

    Register the agent installed in VM

    Supported in v5.0+
    Register the agent that installed in VM.
    """
    registerAgentHypervVirtualMachine(
        "Input for InternalHypervVmRegisterAgent"
        input: HypervVmRegisterAgentInput!
    ): RequestSuccess!
    """

    Register the agent installed on the Nutanix VM

    Supported in v5.0+
    Register the agent installed on the Nutanix VM.
    """
    registerAgentNutanixVm(
        "Input for InternalNutanixVmRegisterAgent"
        input: NutanixVmRegisterAgentInput!
    ): RequestSuccess!
    "Register HyperV SCVMM to Rubrik Cluster."
    registerHypervScvmm(
        "UUID used to identify the cluster the request goes to"
        clusterUuid: String!,
        "Registration definition for a Hyper-V SCVMM."
        scvmm: HypervScvmmRegisterInput!
    ): AsyncRequestStatus!
    """

    Register a NAS System

    Supported in v7.0+
    Register a NAS system such as a NetApp or an Isilon cluster to be protected.
    """
    registerNasSystem(
        "Input for V1RegisterNasSystem"
        input: RegisterNasSystemInput!
    ): RegisterNasSystemResponse!
    removeCdmCluster(
        "UUID of the Rubrik cluster"
        clusterUUID: UUID!,
        "Number of days after which data from polaris is removed"
        expireInDays: Long,
        isForce: Boolean!
    ): Boolean!
    "Remove account level inventory workloads."
    removeInventoryWorkloads(
        "Inventory workloads to remove from an account."
        input: RemoveInventoryWorkloadsInput!
    ): Boolean!
    "Remove LDAP Integration"
    removeLdapIntegration(
        "ID for your LDAP integration."
        id: UUID!
    ): Boolean!
    "Remove policies from objects."
    removePolicyObjects(objectIds: [String!]!, policyIds: [String!]!, runAsync: Boolean!): [String!]!
    "Reseed a secondary database."
    reseedLogShippingSecondary(
        "Input for V1ReseedSecondary"
        input: ReseedSecondaryInput!
    ): AsyncRequestStatus!
    """

    Restore files

    Supported in v5.0+
    Restore files from a snapshot to the source Nutanix virtual machine.
    """
    restoreFilesNutanixSnapshot(
        "Input for InternalRestoreNutanixVmSnapshotFiles"
        input: RestoreNutanixVmSnapshotFilesInput!
    ): AsyncRequestStatus!
    """

    Restore files from snapshot

    Supported in v5.0+
    Restore files from a snapshot to the original source location.
    """
    restoreHypervVMSnapshotFiles(
        "Input for InternalRestoreHypervVirtualMachineSnapshotFiles"
        input: RestoreHypervVirtualMachineSnapshotFilesInput!
    ): AsyncRequestStatus!
    "Restore Kubernetes Namespace Snapshot."
    restoreK8sNamespace(
        "Request to restore K8s Namespace Snapshot."
        k8sNamespaceRestoreRequest: K8sNamespaceRestore!
    ): CreateOnDemandJobReply!
    "Create a request to restore a Microsoft SQL database."
    restoreMssqlDatabase(
        "Input for V1CreateRestoreMssqlDb"
        input: CreateRestoreMssqlDbInput!
    ): AsyncRequestStatus!
    restoreO365Mailbox(restoreConfig: RestoreO365MailboxInput!): CreateOnDemandJobReply!
    restoreO365Snappable(
        "Restore task type i.e Recover/Export."
        actionType: O365RestoreActionType!,
        destSnappableUUID: UUID!,
        snappableRestoreConfig: SnappableRestoreConfig!,
        snappableType: SnappableType!,
        sourceSnappableUUID: UUID!
    ): CreateOnDemandJobReply!
    restoreO365TeamsConversations(
        channelInfoForFullRestore: O365TeamConvChannelInput,
        destTeamsChannelInfo: TeamsChannelInfo,
        o365AppID: String!,
        refreshTokenEncrypted: String!,
        shouldCreateDestChannel: Boolean!,
        shouldRestoreFileAttachments: Boolean!,
        "List of channel objects (naturalId and name)."
        teamConvChannels: [O365TeamConvChannelInput!]!,
        teamUUID: UUID!,
        teamsConversationsSearchFilter: TeamsConversationsSearchFilter
    ): CreateOnDemandJobReply!
    restoreO365TeamsFiles(
        "Restore task type i.e Recover/Export."
        actionType: O365RestoreActionType!,
        destTeamsChannelInfo: TeamsChannelInfo,
        filesToRestore: [FileInfo!]!,
        foldersToRestore: [FolderInfo!]!,
        shouldCreateDestChannel: Boolean!
    ): CreateOnDemandJobReply!
    """

    Restore files from the Volume Group snapshot

    Supported in v5.0+
    Restore filess to the original Host.
    """
    restoreVolumeGroupSnapshotFiles(
        "Input for InternalRestoreVolumeGroupSnapshotFiles"
        input: RestoreVolumeGroupSnapshotFilesInput!
    ): AsyncRequestStatus!
    resumeTarget(
        "Corresponds to ID of target in Polaris"
        targetId: UUID!
    ): ResumeTargetReply!
    "Resumes previously failed upgrade."
    resumeUpgrade(
        "Cluster uuid"
        clusterUuid: UUID!,
        "Context Tag"
        context_tag: String = "{\"client\": \"polaris\"}"
    ): StartUpgradeReply!
    "Initiates a retry of a failed job."
    retryBackup(backupObjects: [BackupObject!]!, backupRunConfig: BackupRunConfig): RetryBackupResp!
    "Retry the previous failed download package CDM job."
    retryDownloadPackageJob(
        "Cluster uuid"
        clusterUuid: UUID!
    ): DownloadPackageReply!
    "Rolls back the cluster to starting version of previously failed upgrade."
    rollbackUpgrade(
        "Cluster uuid"
        clusterUuid: UUID!,
        "Context Tag"
        context_tag: String = "{\"client\": \"polaris\"}"
    ): StartUpgradeReply!
    rotateServiceAccountSecret(
        "ID of the service account"
        id: String!
    ): RotateServiceAccountSecretReply!
    runCustomAnalyzer(runCustomAnalyzerRequest: RunCustomAnalyzerInput!): RunCustomAnalyzerReply!
    saveEventDigest(eventDigestConfig: EventDigestConfig!, frequency: Int, includeAudits: Boolean, includeEvents: Boolean, isImmediate: Boolean, name: String, recipientUserIDs: [String!]!): [EventDigest!]!
    "Schedule an upgrade job in batch."
    scheduleUpgradeBatchJob(
        "Upgrade action"
        action: ActionEnum!,
        "Context Tag"
        context_tag: String = "{\"client\": \"polaris\"}",
        "List of cluster uuids"
        listClusterUuid: [UUID!]!,
        "Upgrade mode"
        mode: String!,
        "ISO8601 Timestamp string"
        scheduleAt: DateTime!,
        "CDM upgrade tarball version"
        version: String!
    ): [UpgradeJobReplyWithUuid!]!
    "Schedule an upgrade job."
    scheduleUpgradeJob(
        "Upgrade action"
        action: ActionEnum!,
        "Cluster uuid"
        clusterUuid: UUID!,
        "Context Tag"
        context_tag: String = "{\"client\": \"polaris\"}",
        "Upgrade mode"
        mode: String!,
        "ISO8601 Timestamp string"
        scheduleAt: DateTime!,
        "CDM upgrade tarball version"
        version: String!
    ): UpgradeJobReply!
    "Seed account with enabled policies."
    seedEnabledPolicies: SeedEnabledPoliciesReply!
    "DEPRECATED (use seedEnabledPolicies instead) Seed account with initial policies."
    seedInitialPolicies: SeedInitialPoliciesReply!
    sendEmailNow(recipients: [String!]!, reportConfig: ReportConfigInput, reportID: Int!): reportGenerateReply!
    sendScheduledReport(id: Int!, recipients: [String!]!): Boolean!
    sendScheduledReportAsync(id: Int!, recipients: [String!]!): AsyncDownloadReply!
    sendTestSMTPEmail(
        "Email to use as from for your SMTP configuration"
        defaultFromEmail: String,
        "Host name for your SMTP configuration"
        hostName: String,
        "Password for your SMTP configuration"
        password: String,
        "Port number for your SMTP configuration"
        port: Int,
        "Recipient for test email"
        recipient: String!,
        "Security type to use "
        securityType: SMTPSecurityTypeEnum,
        "Trusted certificate to use for your SMTP configuration"
        trustedCerts: String,
        "Whether to use existing config or passed in config"
        useExisting: Boolean!,
        "User name for your SMTP configuration"
        userName: String
    ): Boolean!
    sendTestSyslog(
        "Syslog config to use"
        config: SyslogConfigInputType
    ): Boolean!
    "Set credentials for the customer application, for the tenant domain name."
    setAzureCloudAccountCustomerAppCredentials(
        "Input for setting the app credentials in the Azure Cloud Accounts."
        input: SetAzureCloudAccountCustomerAppCredentialsInput!
    ): Boolean!
    "Set federated login status."
    setFederatedLoginStatus(
        "Federated login status configuration."
        federatedLoginStatusArg: FederatedLoginStatusInput!
    ): Boolean!
    setIdentityProvider(
        "Entity id of your IdP"
        entityId: String!,
        "Sign-in URL id of your IdP"
        signInUrl: String!,
        "Signing certificate of your IdP"
        signingCertificate: String!
    ): IdentityProvider!
    setIpWhitelistEnabled(enabled: Boolean!): Boolean!
    "Update the MFA settings for the given LDAP integration. Return true when the operation succeeds."
    setLdapMfaSetting(
        "Input required for updating LDAP MFA settings."
        input: SetLdapMfaSettingInput!
    ): Boolean!
    "Update the MFA settings for the account. Return true when the operation succeeds."
    setMfaSetting(
        "Input required for updating MFA settings."
        input: SetMfaSettingInput!
    ): Boolean!
    setO365ServiceAccount(appPassword: String!, orgId: UUID!, username: String!): RequestStatus!
    setSMTPConfiguration(
        "Email to use as from for your SMTP configuration"
        defaultFromEmail: String!,
        "Host name for your SMTP configuration"
        hostName: String!,
        "Password for your SMTP configuration"
        password: String!,
        "Port number for your SMTP configuration"
        port: Int!,
        "Security type to use "
        securityType: SMTPSecurityTypeEnum!,
        "Trusted certificate to use for your SMTP configuration"
        trustedCerts: String!,
        "User name for your SMTP configuration"
        userName: String!
    ): Boolean!
    "Enable/disable alerts for given snappable on given cluster"
    setSnappableAlertSetting(
        "The ID of the cluster."
        clusterUuid: UUID!,
        "Enable or disable lambda service."
        enabled: Boolean!,
        "The FID of the snappable."
        snappableId: UUID!
    ): SetSnappableAlertSettingReply!
    "Setup TOTP configuration for a user. Return true when the operation succeeds."
    setTotpConfig(
        "Input required for setting up TOTP configuration."
        input: SetTotpConfigInput!
    ): Boolean!
    "Update the user-level TOTP enforcement for given users. Return true when the operation succeeds."
    setUserLevelTotpEnforcement(
        "Input required for updating user-level TOTP enforcement."
        input: SetUserLevelTotpEnforcementInput!
    ): Boolean!
    "Set user specific setting."
    setUserSetting(
        "User setting to add for specific user"
        userSetting: UserSettingInputType
    ): UserSetting!
    "Set WWW TLS certificate."
    setWwwTlsCert(
        "SetWwwTlsCert Input."
        input: SetWwwTlsCertInputType!
    ): Boolean!
    setupAzureO365Exocompute(exocomputeConfig: AzureO365ExocomputeConfig!, subscriptionId: UUID!, tenantId: String!): SetupAzureO365ExocomputeResp!
    "Setup backups on the SQL Server databases using the admin credentials."
    setupCloudNativeSqlServerBackup(
        "Input required to setup SQL Server backups."
        input: SetupCloudNativeSqlServerBackupInput!
    ): BatchAsyncJobStatus!
    "Starts a job to disable AWS Exocompute feature. When complete, the job will disable exocompute feature for the specified AWS Native account."
    startAwsExocomputeDisableJob(
        "Input required to start the job to disable AWS Exocompute."
        input: StartAwsExocomputeDisableJobInput!
    ): AsyncJobStatus!
    "Starts a job to disable a specific AWS Native account. When complete, the job will disable protection for the specified AWS Native account."
    startAwsNativeAccountDisableJob(
        "Input for AWS native account disable job."
        input: StartAwsNativeAccountDisableJobInput!
    ): AsyncJobStatus!
    "Start an on demand create snapshot job for AWS EC2 Instances.When completed, this will start taking an on-demand snapshot of the selected EC2 Instances  as per the SLA Policy assigned to the respective instances."
    startAwsNativeEc2InstanceSnapshotsJob(
        "Input for create AWS EC2 Instance snapshots job."
        input: StartAwsNativeEc2InstanceSnapshotsJobInput!
    ): BatchAsyncJobStatus!
    "Start job to create snapshots of RDS Instance with given IDs. When completed, this will start taking an on-demand snapshot of the selected RDS Instances  as per the SLA Policy assigned to the respective instances."
    startAwsNativeRdsInstanceSnapshotsJob(
        "Input to trigger job to create AWS RDS Instance snapshots."
        input: StartAwsNativeRdsInstanceSnapshotsJobInput!
    ): BatchAsyncJobStatus!
    "Initiates a session before doing Azure OAuth flow. If a custom app is configured for the tenant, the client ID of the custom app is returned. Otherwise, the client ID of the default app is returned."
    startAzureCloudAccountOauth(
        "Input for initiating authentication of the Azure Cloud Accounts."
        input: StartAzureCloudAccountOauthInput!
    ): StartAzureCloudAccountOauthReply!
    startBlueprintFailover(failoverJobConfig: BlueprintFailoverJobConfig!): CreateOnDemandJobReply!
    "Start failover jobs for multiple blueprints."
    startBlueprintsFailover(failoverJobConfigs: [BlueprintFailoverJobConfig!]!): [CreateOnDemandJobReply!]!
    "Create index of cloudnative snapshots"
    startCloudNativeSnapshotsIndexJob(
        "Input for create snapshots index job."
        input: StartCloudNativeSnapshotsIndexJobInput!
    ): BatchAsyncJobStatus!
    "Start a crawl"
    startCrawl(analyzerGroups: [AnalyzerGroupInput!]!, extWhiteList: [String!], name: String!, resources: [ResourceInput!]!): StartCrawlReply!
    "Start job to create snapshots of EBS Volumes with given IDs. When completed, this will start taking an on-demand snapshot of the selected EBS Volumes  as per the SLA Policy assigned to the respective volumes."
    startCreateAwsNativeEbsVolumeSnapshotsJob(
        "Input for create AWS EBS volume create snapshots job."
        input: StartCreateAwsNativeEbsVolumeSnapshotsJobInput!
    ): BatchAsyncJobStatus!
    "Start a job to create snapshots of the Azure Native Managed Disks identified by the given IDs. When started, this will start taking an on-demand snapshot of the selected disks as per the SLA Policy assigned to the respective disks."
    startCreateAzureNativeManagedDiskSnapshotsJob(
        "Input for the job to create Azure Native Managed Disk Snapshots."
        input: StartCreateAzureNativeManagedDiskSnapshotsJobInput!
    ): BatchAsyncJobStatus!
    "Start a job to create a snapshot for the Azure Native virtual machine identified by the IDs. When started, this will start taking an on-demand snapshot of the selected VMs as per the SLA Policy assigned to the respective VMs."
    startCreateAzureNativeVirtualMachineSnapshotsJob(
        "Input for the job to create Azure Native Virtual Machine snapshots."
        input: StartCreateAzureNativeVirtualMachineSnapshotsJobInput!
    ): BatchAsyncJobStatus!
    "Start on-demand jobs to disable the feature for the given Azure Cloud Accounts. When completed, the status of cloud account feature will change to Disabled and the feature will become eligible to be deleted."
    startDisableAzureCloudAccountJob(
        "Input for starting jobs to disable a cloud account feature for a list of Azure Cloud Accounts."
        input: StartDisableAzureCloudAccountJobInput!
    ): BatchAsyncJobStatus!
    "Start a job to disable protection for a specified Azure subscription."
    startDisableAzureNativeSubscriptionProtectionJob(
        "Input for the job to start disabling protection from the Azure Native Subscription."
        input: StartDisableAzureNativeSubscriptionProtectionJobInput!
    ): AsyncJobStatus!
    "Starts CDM job to download installer package in batch."
    startDownloadPackageBatchJob(
        "CDM download package version"
        downloadVersion: String,
        "List of cluster uuids"
        listClusterUuid: [UUID!]!,
        "MD5CheckSum of CDM installer package"
        md5checksum: String!,
        "CDM upgrade package URL"
        packageUrl: String!,
        "Size, in bytes of CDM package"
        size: Long
    ): [DownloadPackageReplyWithUuid!]!
    "Starts CDM job to download installer package."
    startDownloadPackageJob(
        "Cluster uuid"
        clusterUuid: UUID!,
        "CDM download package version"
        downloadVersion: String,
        "MD5CheckSum of CDM installer package"
        md5checksum: String!,
        "CDM upgrade package URL"
        packageUrl: String!,
        "Size, in bytes of CDM package"
        size: Long
    ): DownloadPackageReply!
    "Starts a job to export an EC2 Instance snapshot. The job creates a new EC2 Instance with the same properties as that of the snapshot that is exported."
    startEc2InstanceSnapshotExportJob(
        "Input to trigger export AWS native EC2 Instance snapshot job."
        input: StartEc2InstanceSnapshotExportJobInput!
    ): AsyncJobStatus!
    "Start a job to export EBS Volume. The job creates a new EBS Volume with the same properties as that of the snapshot that is exported."
    startExportAwsNativeEbsVolumeSnapshotJob(
        "Input to trigger export AWS native EBS volume snapshot job."
        input: StartExportAwsNativeEbsVolumeSnapshotJobInput!
    ): AsyncJobStatus!
    "Start a job to export the specified Azure Native Managed Disks to the desired destination."
    startExportAzureNativeManagedDiskJob(
        "Input for the job to export the specified Azure Native Managed Disks to the specified destination."
        input: StartExportAzureNativeManagedDiskJobInput!
    ): AsyncJobStatus!
    "Start a job to export the Azure native virtual machine for a specified snapshot to a specified destination."
    startExportAzureNativeVirtualMachineJob(
        "Input for the job to export the specified Azure Native Virtual Machine to the specified destination."
        input: StartExportAzureNativeVirtualMachineJobInput!
    ): AsyncJobStatus!
    "Start a job to export Azure SQL Database. The job creates a new Azure SQL Database with the same properties as that of the instance that is exported."
    startExportAzureSqlDatabaseDbJob(
        "Input for the job to export the specified Azure SQL Database."
        input: StartExportAzureSqlDatabaseDbJobInput!
    ): AsyncJobStatus!
    "Start a job to export Azure SQL Managed Instance database. The job creates a new Azure SQL Managed Instance database with the same properties as that of the instance that is exported."
    startExportAzureSqlManagedInstanceDbJob(
        "Input for the job to export the specified Azure SQL Managed Instance database."
        input: StartExportAzureSqlManagedInstanceDbJobInput!
    ): AsyncJobStatus!
    "Start a job to export RDS Instance. The job creates a new RDS Instance with the same properties as that of the instance that is exported."
    startExportRdsInstanceJob(
        "Input to trigger export AWS native RDS Instance job."
        input: StartExportRdsInstanceJobInput!
    ): AsyncJobStatus!
    """

    Detect malware

    Supported in v6.0+
    Initiate an asynchronous malware detection.
    """
    startMalwareDetection(
        "Input for InternalRunDetectMalware"
        input: RunDetectMalwareInput!
    ): AsyncRequestStatus!
    "Starts an on demand periodic upgrade prechecks job in CDM cluster."
    startPeriodicUpgradePrechecksOnDemandJob(
        "Cluster uuid"
        clusterUuid: UUID!
    ): PrechecksJobReply!
    "Start Recovery Plan failover."
    startRecoveryPlan(
        "Start Recovery Plan configuration."
        input: StartRecoveryPlanInput!
    ): StartRecoveryPlanReply!
    "Start an on demand job to refresh AWS accounts. The job updates the Rubrik platform with changes to the AWS Native accounts."
    startRefreshAwsNativeAccountsJob(
        "Input for refresh AWS native accounts job."
        input: StartRefreshAwsNativeAccountsJobInput!
    ): BatchAsyncJobStatus!
    "Start a job to refresh Azure Native subscription for the given subscription IDs. When started, this job will update the Rubrik platform with any changes that have been done on Azure for the respective subscription."
    startRefreshAzureNativeSubscriptionsJob(
        "Input for the job to refresh Azure Native subscriptions."
        input: StartRefreshAzureNativeSubscriptionsJobInput!
    ): BatchAsyncJobStatus!
    "Start an on demand restore snapshot job for AWS EC2 Instance. When completed, this will replace the original EC2 Instance with the selected snapshot."
    startRestoreAwsNativeEc2InstanceSnapshotJob(
        "Input for restore AWS EC2 Instance snapshot job."
        input: StartRestoreAwsNativeEc2InstanceSnapshotJobInput!
    ): AsyncJobStatus!
    "Start a job to restore Azure Native virtual machine with the selected snapshot. When started, this will replace the original VM with the selected snapshot."
    startRestoreAzureNativeVirtualMachineJob(
        "Input for the job to restore Azure Native Virtual Machine."
        input: StartRestoreAzureNativeVirtualMachineJobInput!
    ): AsyncJobStatus!
    "Start a threat hunt on a cluster."
    startThreatHunt(
        "Config to start a threat hunt."
        input: StartThreatHuntInput!
    ): StartThreatHuntReply!
    "Starts the upgrade with given tarball path."
    startUpgrade(
        "Cluster uuid"
        clusterUuid: UUID!,
        "Context Tag"
        context_tag: String = "{\"client\": \"polaris\"}",
        "Upgrade mode"
        mode: String!,
        "CDM upgrade tarball version"
        version: String!
    ): StartUpgradeReply!
    "Starts cdm upgrades instantly, monitors the upgrade until terminal state is reached."
    startUpgradeBatchJob(
        "Upgrade action"
        action: ActionEnum!,
        "Context Tag"
        context_tag: String = "{\"client\": \"polaris\"}",
        "List of cluster uuids"
        listClusterUuid: [UUID!]!,
        "Upgrade mode"
        mode: String!,
        "CDM upgrade tarball version"
        version: String!
    ): [UpgradeJobReplyWithUuid!]!
    "Starts cdm upgrade instantly, monitors the upgrade until terminal state is reached."
    startUpgradeJob(
        "Upgrade action"
        action: ActionEnum!,
        "Cluster uuid"
        clusterUuid: UUID!,
        "Context Tag"
        context_tag: String = "{\"client\": \"polaris\"}",
        "Upgrade mode"
        mode: String!,
        "CDM upgrade tarball version"
        version: String!
    ): UpgradeJobReply!
    "Issue request to stop a job instance. If successful, stop process for job instance is initiated. Job instance is stopped asynchronously in the background."
    stopJobInstance(
        "Args to stop a job instance."
        input: StopJobInstanceInput!
    ): StopJobInstanceReply!
    "Take an on-demand log backup for a Microsoft SQL database."
    takeMssqlLogBackup(
        "Input for V1CreateOnDemandMssqlLogBackup"
        input: CreateOnDemandMssqlLogBackupInput!
    ): AsyncRequestStatus!
    """

    On-demand backup of an Oracle database

    Supported in v5.0+
    Create an asynchronous job for an on-demand snapshot of an Oracle database. The response includes an ID for the asynchronous job request. To see the status of the request, poll /oracle/request/{id}.
    """
    takeOnDemandOracleDatabaseSnapshot(
        "Input for InternalCreateOnDemandOracleBackup"
        input: CreateOnDemandOracleBackupInput!
    ): RequestSuccess!
    """

    On-demand log backup for an Oracle database log

    Supported in v5.0+
    Create an asynchronous job for an on-demand backup of an Oracle database log. The response includes an ID for the asynchronous job request.  To see the status of the request, poll /oracle/request/{id}.
    """
    takeOnDemandOracleLogSnapshot(
        "Input for InternalCreateOnDemandOracleLogBackup"
        input: CreateOnDemandOracleLogBackupInput!
    ): RequestSuccess!
    "Triggers on-demand snapshot for the given Snappables."
    takeOnDemandSnapshot(
        "The SLA ID."
        slaId: String!,
        "List of Snappable IDs"
        snappableIds: [UUID!]!
    ): TakeOnDemandSnapshotReply!
    "Test an existing webhook."
    testExistingWebhook(
        "The existing webhook to test."
        input: TestExistingWebhookInput!
    ): TestExistingWebhookReply!
    "Test a webhook configuration."
    testWebhook(
        "The webhook configuration to test."
        input: TestWebhookInput!
    ): TestWebhookReply!
    toggleClassificationBannerSettings: Boolean!
    toggleClassificationLoginSettings: Boolean!
    toggleFeatureEnabled(enableFeature: Boolean!, featureName: FeatureNameEnum!): Boolean!
    toggleVMwareManagementEnabled(enableVmwareManagement: Boolean!): Boolean!
    "Trigger detect ransomware job for given snapshot"
    triggerRansomwareDetection(
        "The ID of the cluster."
        clusterUuid: UUID!,
        "Snappable managed ID"
        managedId: String!,
        "Corresponds to previous snapshot ID of the target snapshot"
        previousSnapshotId: String!,
        "Corresponds to snapshot ID in CDM tables"
        snapshotId: String!
    ): TriggerRansomwareDetectionReply!
    "Unmap Azure cloud accounts from the mapped Exocompute subscription."
    unmapAzureCloudAccountExocomputeSubscription(
        "Input for unmapping Azure cloud accounts from the mapped Exocompute subscription."
        input: UnmapAzureCloudAccountExocomputeSubscriptionInput!
    ): UnmapAzureCloudAccountExocomputeSubscriptionReply!
    updateAccountOwner(
        "User ID."
        userId: String!
    ): Boolean!
    "This endpoint is deprecated."
    updateAccountSettings(
        "Flag to represent if email notification is enabled"
        isEmailNotificationEnabled: Boolean,
        "Flag to represent if the EULA has been accepted"
        isEulaAccepted: Boolean
    ): AccountSetting!
    updateAppBlueprint(
        children: [AppBlueprintChildInput!]!,
        "The Polaris UUID for the object."
        fid: UUID!,
        name: String!,
        primaryClusterUuid: UUID!
    ): Blueprint!
    "Updates regions, stack ARN, and role ARN for a feature for a given cloud account."
    updateAwsCloudAccount(
        "Arguments to save cloud account's role ARN, stack ARN and regions."
        input: UpdateAwsCloudAccountInput!
    ): UpdateAwsCloudAccountReply!
    updateAwsComputeSetting(
        "Request arguments for updating a Aws Compute Setting"
        awsComputeSettingsUpdateRequest: AwsComputeSettingsEditRequest!
    ): AwsComputeSettings!
    "Update names of the Azure Subscriptions cloud account and regions for the given feature."
    updateAzureCloudAccount(
        "Input for updating an Azure Cloud Account."
        input: UpdateAzureCloudAccountInput!
    ): UpdateAzureCloudAccountReply!
    updateBlueprint(
        children: [AppBlueprintChildInput!]!,
        "Flag to mark if hydration is enabled for the blueprint."
        enableHydration: Boolean,
        "The Polaris UUID for the object."
        fid: UUID!,
        name: String!,
        "The id of the source location."
        sourceLocationId: String!,
        "The type of the source location."
        sourceLocationType: BlueprintLocationTypeEnum! = CDM,
        "The status of the blueprint."
        status: BlueprintStatusEnum! = Uncompleted,
        "The id of the intended remote target location."
        targetLocationId: String,
        "The type of the intended remote target location."
        targetLocationType: BlueprintLocationTypeEnum = CDM,
        "The version of the blueprint."
        version: Int!
    ): BlueprintNew!
    "Update a cassandra source."
    updateCassandraSource(
        "UUID used to identify the cluster the request goes to"
        clusterUuid: String!,
        "Source Object with details of source to be modified."
        sourceData: SourceInput!
    ): MosaicAsyncResponse!
    updateClassificationBannerSettings(
        "The classification banner settings to add or change for account."
        classificationBannerSettingsArg: ClassificationBannerSettingsInputType!
    ): Boolean!
    updateClassificationLoginSettings(
        "The classification login settings to add or change for account."
        classificationLoginSettingsArg: ClassificationLoginSettingsInputType!
    ): Boolean!
    updateCloudNativeAwsStorageSetting(input: UpdateCloudNativeAwsStorageSettingInput!): UpdateCloudNativeAwsStorageSettingReply!
    updateCloudNativeAzureStorageSetting(input: UpdateCloudNativeAzureStorageSettingInput!): UpdateCloudNativeAzureStorageSettingReply!
    "Update indexing status for cloudnative snappables"
    updateCloudNativeIndexingStatus(
        "Is indexing enabled or disabled for snappables"
        isIndexingEnabled: Boolean!,
        "List of snappable IDs"
        snappableIds: [UUID!]!
    ): UpdateCloudNativeIndexingStatusReply!
    "Update cloud native label rule"
    updateCloudNativeLabelRule(
        "Does this tag rule apply to all cloud accounts."
        applyToAllCloudAccounts: Boolean,
        "cloud native accounts on which tag rule will be applied"
        cloudNativeAccountIds: CloudNativeIDs,
        "Corresponds to optional global SLA forever UUID in Polaris tables."
        globalSlaOptionalFid: UUID,
        "UUID for the tag or label rule"
        ruleId: UUID!,
        "Name for the rule"
        ruleName: String!,
        "Corresponds to the assignment type for the SLA."
        ruleSlaAssignType: TagRuleSlaAssignTypeEnum!
    ): Void
    "Update cloud native tag rule"
    updateCloudNativeTagRule(
        "Does this tag rule apply to all cloud accounts."
        applyToAllCloudAccounts: Boolean,
        "cloud native accounts on which tag rule will be applied"
        cloudNativeAccountIds: CloudNativeIDs,
        "Corresponds to optional global SLA forever UUID in Polaris tables."
        globalSlaOptionalFid: UUID,
        "UUID for the tag or label rule"
        ruleId: UUID!,
        "Name for the rule"
        ruleName: String!,
        "Corresponds to the assignment type for the SLA."
        ruleSlaAssignType: TagRuleSlaAssignTypeEnum!
    ): Void
    """

    Assign NTP servers to Rubrik cluster

    Supported in v5.0+
    Assign NTP servers to Rubrik cluster.
    """
    updateClusterNtpServers(
        "ID of the Rubrik cluster or *me* for self."
        id: String!,
        "List of NTP servers."
        ntpServerConfigs: [NtpServerConfigurationInput!]!
    ): ResponseSuccess!
    "Pauses or resumes protection on the Rubrik clusters specified by UUIDs."
    updateClusterPauseStatus(
        "Request to pause or resume protection on Rubrik clusters."
        input: UpdateClusterPauseStatusInput!
    ): UpdateClusterPauseStatusReply!
    "Update a custom analyzer"
    updateCustomAnalyzer(analyzer: AnalyzerInput!): Analyzer!
    "Mutation to update an existing Db2 instance."
    updateDb2Instance(
        "The request object containing parameters like username, password, and list of hosts required to update a Db2 instance on the Rubrik cluster."
        db2InstanceRequestConfig: Db2InstancePatchRequestConfigInput!,
        "ID of the Db2 instance."
        id: String!
    ): PatchDb2InstanceResponse!
    "Update Eula Acceptance details"
    updateEulaAccepted: Boolean!
    updateFailoverCluster(
        "ID of failover cluster."
        id: String!,
        "Properties to update."
        updateProperties: FailoverClusterConfigInput!
    ): FailoverClusterDetail!
    "Update the failover cluster app with specified properties."
    updateFailoverClusterApp(
        "ID of failover cluster app."
        id: String!,
        "Properties to update."
        updateProperties: FailoverClusterAppConfigInput!
    ): FailoverClusterAppSummary!
    updateGlobalSla(input: UpdateGlobalSlaInput!): GlobalSla!
    updateGuestCredential(
        "Input for InternalUpdateGuestCredential"
        input: UpdateGuestCredentialInput!
    ): GuestCredentialDetail!
    updateHostCertificate(
        "ID of the host."
        id: String!
    ): HostDetail!
    """

    Power a Live Mount on and off

    Supported in v5.0+
    Power a specified Live Mount virtual machine on or off. Pass **_true_** to power the virtual machine on and pass **_false_** to power the virtual machine off.
    """
    updateHypervVirtualMachineSnapshotMount(
        "Input for InternalUpdateHypervVirtualMachineSnapshotMount"
        input: UpdateHypervVirtualMachineSnapshotMountInput!
    ): HypervVirtualMachineMountDetail!
    updateIpWhitelist(ipCidrs: [String!]!, whitelistMode: WhitelistModeEnum!): Boolean!
    updateLambdaSettings(
        "Probability threshold for anomaly detector"
        anomalyThreshold: Float,
        "Flag to represent if alert on anomaly snappable is enabled"
        isAnomalyAlertEnabled: Boolean,
        "Probability threshold for ransomware detector"
        ransomwareThreshold: Float
    ): LambdaSettings!
    "Mutation to update an existing Managed Volume."
    updateManagedVolume(
        "Input for InternalUpdateManagedVolume"
        input: UpdateManagedVolumeInput!
    ): ManagedVolumeSummary!
    "Updates configuration for a registered MongoDB source."
    updateMongodbSource(
        "UUID used to identify the cluster the request goes to"
        clusterUuid: String!,
        "Source Object with details of source to be modified."
        sourceData: SourceInput!
    ): MosaicAsyncResponse!
    """

    Modify a store

    Supported in m3.2.0-m4.1.0.
    """
    updateMosaicStore(
        "Input for V2ModifyMosaicStore"
        input: ModifyMosaicStoreInput!
    ): MosaicAsyncResponse!
    "Update the default properties for Microsoft SQL databases."
    updateMssqlDefaultProperties(
        "Input for V1UpdateDefaultDbPropertiesV1"
        input: UpdateDefaultDbPropertiesV1Input!
    ): MssqlDbDefaults!
    "Update log shipping configuration of a Microsoft SQL Database."
    updateMssqlLogShippingConfiguration(
        "Input for V2UpdateLogShippingConfigurationV2"
        input: UpdateLogShippingConfigurationV2Input!
    ): MssqlLogShippingDetailV2!
    """

    Modify the information for a registered NAS system

    Supported in v7.0+
    Change the hostname that is associated with a NAS system. Update the credentials used to access the vendor-specific APIs.
    """
    updateNasSystem(
        "Input for V1UpdateNasSystem"
        input: UpdateNasSystemInput!
    ): NasSystemSummary!
    updateNetworkThrottle(
        "Input for InternalUpdateNetworkThrottle"
        input: UpdateNetworkThrottleInput!
    ): NetworkThrottleSummary!
    """

    Patch Nutanix cluster

    Supported in v5.0+
    Patch the host, credentials, and/or CA certs of the specified Nutanix cluster object.
    """
    updateNutanixCluster(
        "Input for InternalPatchNutanixCluster"
        input: PatchNutanixClusterInput!
    ): NutanixClusterDetail!
    """

    Patch VM

    Supported in v5.0+
    Patch VM with specified properties.
    """
    updateNutanixVm(
        "Input for InternalPatchNutanixVm"
        input: PatchNutanixVmInput!
    ): NutanixVmDetail!
    "Update the custom name for an O365 Organization."
    updateO365OrgCustomName(
        "Config for updating an O365 Org custom name."
        input: UpdateO365OrgCustomNameInput!
    ): UpdateO365OrgCustomNameReply!
    """

    Update an Oracle Data Guard group

    Supported in v6.0+
    Update properties of an Oracle Data Guard group object.
    """
    updateOracleDataGuardGroup(
        "Input for V1UpdateOracleDataGuardGroup"
        input: UpdateOracleDataGuardGroupInput!
    ): OracleDbDetail!
    "Update an organization."
    updateOrg(
        "Input required for org update."
        input: UpdateOrgInput!
    ): UpdateOrgReply!
    "Update a classification policy"
    updatePolicy(policy: ClassificationPolicyInput!): ClassificationPolicyDetail!
    "Update previewer cluster config"
    updatePreviewerClusterConfig(previewerClusterConfig: PreviewerClusterConfigInput!): Cluster!
    "Update RCS automatic target mapping."
    updateRcsAutomaticTargetMapping(
        "Update RCS Automatic target mapping."
        input: UpdateRcsAutomaticTargetMappingInput!
    ): TargetMapping!
    "Update Recovery Plan."
    updateRecoveryPlan(
        "Update Recovery Plan configuration."
        recoveryPlanConfig: UpdateRecoveryPlanInput!
    ): UpdateRecoveryPlanReply!
    updateReport(reportConfig: ReportConfigInput!, reportID: Int!): Boolean!
    updateRole(
        description: String!,
        name: String!,
        "Permissions in the role."
        permissions: [PermissionInput!]!,
        roleId: String!
    ): Boolean!
    updateRoleAssignments(adGroupIds: [String!], roleIds: [String!]!, userIds: [String!]): Boolean!
    updateServiceAccount(
        "Description of the service account"
        description: String,
        "ID of the service account"
        id: String!
    ): Client!
    """

    Update a SnapMirror Cloud

    Supported in v7.0+
    Updates a SnapMirror Cloud with the specified properties.
    """
    updateSnapMirrorCloud(
        "Input for V1UpdateSnapMirrorCloud"
        input: UpdateSnapMirrorCloudInput!
    ): SnapMirrorCloudDetail!
    "API to open or close a support tunnel. nodeId must be the id of the current node, isTunnelEnabled is to open or close the tunnel, and inactivityTimeoutInSeconds is to set the timeout (if not provided, defaults to 4 days)"
    updateSupportTunnel(
        "The ID of the cluster."
        clusterUuid: UUID!,
        inactivityTimeoutInSeconds: Long,
        isTunnelEnabled: Boolean!,
        nodeId: String!
    ): SupportTunnelInfoResp!
    """

    Update Volume Group properties

    Supported in v5.3+
    Patch Volume Group with specified properties.
    """
    updateVolumeGroup(
        "Input for V1PatchVolumeGroup"
        input: PatchVolumeGroupInput!
    ): VolumeGroupDetail!
    "Update a webhook."
    updateWebhook(
        "The webhook configuration to update."
        input: UpdateWebhookInput!
    ): UpdateWebhookReply!
    "Update whitelisted analyzers for a path"
    updateWhitelistedAnalyzers(analyzerIds: [String!]!, runAsync: Boolean!, snappableFid: String!, snapshotFid: String!, stdPath: String!): String!
    "Updates status of AWS cloud account features to connected if they are in missing permissions state. This mutation should be used with caution. It should be invoked only after the latest required permissions are granted to the AWS cloud account user used by Rubrik. This mutation does not verify if the required permissions are actually granted to the user or not. Its usage is restricted to only IAM user-based and authentication server-based AWS cloud accounts."
    upgradeAwsCloudAccountFeaturesWithoutCft(
        "Input to update status of AWS cloud account features to connected from missing permissions state."
        input: UpgradeAwsCloudAccountFeaturesWithoutCftInput!
    ): Boolean!
    "Set IAM user-based AWS account features status to Connected from Missing Permissions state. It should be used by caution from cloud accounts only after latest required permissions are granted to authorized IAM user."
    upgradeAwsIamUserBasedCloudAccountPermissions(
        "Input to set status of IAM user-based AWS cloud account to connected from missing permissions state."
        input: UpgradeAwsIamUserBasedCloudAccountPermissionsInput!
    ): Boolean!
    "Update permissions of the Azure Subscriptions cloud account for given feature."
    upgradeAzureCloudAccount(
        "Input for upgrading an Azure Cloud Account."
        input: UpgradeAzureCloudAccountInput!
    ): UpgradeAzureCloudAccountReply!
    "Set Azure Cloud Account feature status to Connected from Missing Permissions state without any permission validation. It should be used by caution from cloud accounts which have been set up without using OAuth, only after adding missing permissions that are required."
    upgradeAzureCloudAccountPermissionsWithoutOauth(
        "Input to set status of azure cloud account to connected from missing permissions state without OAuth."
        input: UpgradeAzureCloudAccountPermissionsWithoutOauthInput!
    ): UpgradeAzureCloudAccountPermissionsWithoutOauthReply!
    "Set GCP Cloud Account feature status to Connected from Missing Permissions state without any permission validation. It should be used by caution from cloud accounts which have been set up without using OAuth, only after adding missing permissions that are required."
    upgradeGcpCloudAccountPermissionsWithoutOauth(
        "Input to set status of GCP cloud account to connected from missing permissions state without OAuth."
        input: UpgradeGcpCloudAccountPermissionsWithoutOauthInput!
    ): UpgradeGcpCloudAccountPermissionsWithoutOauthReply!
    "Upgrade SLA Domains from the Rubrik clusters."
    upgradeSlas(
        "Upgrade SLA Domain Request."
        input: UpgradeSlasInput!
    ): UpgradeSlasReply!
    "Create (or update if already exists) the account settings value."
    upsertAccountSettingValue(
        "Name of component that uses ASP in account setting table"
        aspComponent: ComponentEnum!,
        "Name of parameter (ASP) in account setting table"
        aspName: String!,
        "Value of ASP in account setting table"
        aspValue: String!
    ): ASPValue!
    "Create a mass export for a group of VMs."
    vSphereVMBatchExport(
        "Input for V2BatchExport"
        input: BatchExportInput!
    ): BatchAsyncRequestStatus!
    vSphereVMBatchLiveMount(
        clusterUuid: UUID!,
        "Configuration object containing an array of virtual machine IDs, a way to indicate the snapshot to be chosen and mount configs."
        config: BatchMountSnapshotJobConfigInput!
    ): BatchAsyncRequestStatus!
    "Create a vSphere Export from a snapshot or a point-in-time"
    vSphereVMExportSnapshotV2(
        "Configuration for the Export request, including timestamp and snapshot ID fields. When the snapshot ID is passed without a timestamp, this endpoint triggers an export using the given snapshot ID. When this endpoint is passed a recovery point or a recovery point and snapshot ID, the endpoint triggers an export using the point in time (PIT) for recovery. Calling this endpoint without a recovery point or a snapshot ID triggers a PIT export that uses the most recent time available."
        config: ExportSnapshotJobConfigV2Input!,
        "ID of a VM."
        id: String!
    ): AsyncRequestStatus!
    vSphereVMExportSnapshotWithDownloadFromCloud(
        "Input for V2CreateExportWithDownloadFromCloudV2"
        input: CreateExportWithDownloadFromCloudV2Input!
    ): AsyncRequestStatus!
    "Initiate a mass instant recovery for a group of VMs."
    vSphereVMInitiateBatchInstantRecovery(
        "Input for V2BatchInstantRecover"
        input: BatchInstantRecoverInput!
    ): BatchAsyncRequestStatus!
    "Initiate a mass live mount for a group of VMs."
    vSphereVMInitiateBatchLiveMountV2(
        "Input for V2BatchMountSnapshotV2"
        input: BatchMountSnapshotV2Input!
    ): BatchAsyncRequestStatus!
    "Instantly recover a vSphere virtual machine from a snapshot or point-in-time"
    vSphereVMInitiateInstantRecoveryV2(
        "Configuration for the Instant Recovery request, including timestamp and snapshot ID fields. When the snapshot ID is passed without a timestamp, this endpoint triggers an instant recovery using the given snapshot ID. When this endpoint is passed a recovery point or a recovery point and snapshot ID, the endpoint triggers an instant recovery using the point in time (PIT) for recovery. Calling this endpoint without a recovery point or a snapshot ID triggers a PIT instant recovery that uses the most recent time or snapshot available."
        config: InstantRecoveryJobConfigV2Input!,
        "ID of a VM."
        id: String!
    ): AsyncRequestStatus!
    "Create a vSphere Live Mount from a snapshot or point-in-time"
    vSphereVMInitiateLiveMountV2(
        "Configuration for the Live Mount request, including timestamp and snapshot ID fields. When the snapshot ID is passed without a timestamp, this endpoint triggers a live mount using the given snapshot ID. When this endpoint is passed a recovery point or a recovery point and snapshot ID, the endpoint triggers a live mount using the point in time (PIT) for recovery. Calling this endpoint without a recovery point or a snapshot ID triggers a PIT live mount that uses the most recent time or snapshot available."
        config: MountSnapshotJobConfigV2Input!,
        "ID of a VM."
        id: String!
    ): AsyncRequestStatus!
    """

    Trigger in-place recovery jobs for a set of virtual machines

    Supported in v6.0+
    Trigger in-place recovery jobs for a set of virtual machines.
    """
    vSphereVmBatchInPlaceRecovery(
        "Input for V2BatchInPlaceRecover"
        input: BatchInPlaceRecoverInput!
    ): BatchAsyncRequestStatus!
    "Trigger an in-place recovery from a snapshot or point-in-time."
    vSphereVmInitiateInPlaceRecovery(
        "Input for V2CreateInPlaceRecoveryV2"
        input: CreateInPlaceRecoveryV2Input!
    ): AsyncRequestStatus!
    """

    Register Rubrik Backup Service

    Supported in v5.0+
    Register the Rubrik Backup Service that is running on a specified host with the specified Rubrik cluster.
    """
    vSphereVmRegisterAgent(
        "Input for V1VmRegisterAgent"
        input: VmRegisterAgentInput!
    ): RequestSuccess!
    "Validate and create AWS cloud account. If validation fails, no error is returned and the cause is present in the \"message\" field of return object or within admin/child accounts of return object. In case validation succeeds, it initiates creation of AWS cloud account. This is the first step to set up native protection."
    validateAndCreateAwsCloudAccount(
        "Input to validate AWS cloud account arguments."
        input: ValidateAndCreateAwsCloudAccountInput!
    ): ValidateAndCreateAwsCloudAccountReply!
    "Validate the resource mapping, RBA status, cluster version of the given blueprint."
    validateBlueprint(
        "Blueprint validation config."
        input: ValidateBlueprintInput!
    ): ValidateBlueprintReply!
    "validate the recovery specs with the given app blueprint snappable or snapshot fid"
    validateBlueprintRecoverySpec(
        "the id of the blueprint"
        blueprintId: UUID!,
        "Flag to represent if it should validate snapshot recovery spec"
        validateSnapshotRecoverySpec: Boolean
    ): RecoverySpecValidityCheckReply!
    "Validate the resource mapping, RBA status, cluster version of all the given blueprints."
    validateBlueprints(
        "Multiple blueprint validation config."
        input: ValidateBlueprintsInput!
    ): ValidateBlueprintsReply!
    vmwareDownloadSnapshotFromLocation(
        "Input for V2VmwareDownloadSnapshotFromLocation"
        input: VmwareDownloadSnapshotFromLocationInput!
    ): AsyncRequestStatus!
    vpshereVMRecoveryPointMount(createDatastoreOnly: Boolean, datastoreName: String, disableNetwork: Boolean, hostID: String, keepMacAddresses: Boolean, powerOn: Boolean, recoveryPoint: String, removeNetworkDevices: Boolean, shouldRecoverTags: Boolean, snappableFid: UUID!, snapshotFid: UUID, unregsiterVm: Boolean, vlan: Int, vmName: String): vSphereAsyncRequestStatus!
    "Trigger a bulk on demand snapshot."
    vsphereBulkOnDemandSnapshot(
        "Input for V1BulkCreateOnDemandBackup"
        input: BulkCreateOnDemandBackupInput!
    ): BatchAsyncRequestStatus!
    vsphereCreateVCenter(caCert: String, clusterUuid: UUID!, conflictResolutionAuthz: ConflictResolutionAuthzEnum!, hostname: String!, password: String!, username: String!): vSphereAsyncRequestStatus!
    vsphereDeleteVCenter(vcenterId: UUID!): vSphereAsyncRequestStatus!
    vsphereEditVCenter(caCert: String, conflictResolutionAuthz: ConflictResolutionAuthzEnum!, hostname: String!, password: String!, username: String!, vcenterId: UUID!): RequestSuccess!
    vsphereExcludeVMDisks(virtualDiskUpdate: [VmDiskUpdateInput!]!): RequestSuccess!
    vsphereExportSnapshotToStandaloneHost(
        datastoreName: String!,
        disableNetwork: Boolean,
        hostIpAddress: String!,
        hostPassword: String!,
        hostUsername: String!,
        keepMacAddresses: Boolean,
        powerOn: Boolean,
        removeNetworkDevices: Boolean,
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!,
        vmName: String
    ): vSphereAsyncRequestStatus!
    vsphereOnDemandSnapshot(
        "The SLA id of the snappable"
        slaID: String,
        snappableFid: UUID!,
        "Optional User note."
        userNote: String
    ): vSphereAsyncRequestStatus!
    vsphereRefreshVCenter(vcenterId: UUID!): vSphereAsyncRequestStatus!
    vsphereVMDeleteLiveMount(force: Boolean, livemountId: UUID!): vSphereAsyncRequestStatus!
    vsphereVMDeleteSnapshot(
        location: String!,
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!
    ): RequestSuccess!
    vsphereVMDownloadSnapshot(
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!
    ): vSphereAsyncRequestStatus!
    vsphereVMDownloadSnapshotFiles(
        deltaTypeFilter: [DeltaTypeEnum!],
        "The additional arguments needed to specify whether snapshot is on legal hold or not."
        isLegalHoldDownload: Boolean,
        nextSnapshotFid: UUID,
        "paths of files"
        paths: [String!]!,
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!,
        "Optional User note."
        userNote: String
    ): AsyncRequestStatus!
    vsphereVMExportSnapshot(
        datastoreId: UUID!,
        disableNetwork: Boolean,
        hostID: String,
        keepMacAddresses: Boolean,
        powerOn: Boolean,
        removeNetworkDevices: Boolean,
        shouldRecoverTags: Boolean,
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!,
        unregsiterVm: Boolean,
        vmName: String
    ): vSphereAsyncRequestStatus!
    vsphereVMInitiateDiskMount(
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!,
        targetVmID: String,
        vlan: Int,
        vmdkIDs: [String!]!
    ): vSphereAsyncRequestStatus!
    vsphereVMInitiateInstantRecovery(
        disableNetwork: Boolean,
        hostID: String,
        keepMacAddresses: Boolean,
        powerOn: Boolean,
        preserveMOID: Boolean,
        removeNetworkDevices: Boolean,
        shouldRecoverTags: Boolean,
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!,
        vlan: Int,
        vmName: String
    ): vSphereAsyncRequestStatus!
    vsphereVMInitiateLiveMount(
        createDatastoreOnly: Boolean,
        datastoreName: String,
        disableNetwork: Boolean,
        hostID: String,
        keepMacAddresses: Boolean,
        powerOn: Boolean,
        removeNetworkDevices: Boolean,
        shouldRecoverTags: Boolean,
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!,
        vlan: Int,
        vmName: String
    ): vSphereAsyncRequestStatus!
    "Retrieve a list of the datastores for a specified ESXi host"
    vsphereVMListESXiDatastores(clusterUuid: UUID!, ipAddress: String!, password: String!, username: String!): DatastoreListResponse!
    vsphereVMMountRelocate(datastoreId: UUID!, livemountId: UUID!): vSphereAsyncRequestStatus!
    vsphereVMPowerOnOffLiveMount(livemountId: UUID!, powerStatus: Boolean!): VmwareVmMountDetailV1!
    vsphereVMRecoverFiles(
        "vm restore parameters"
        restoreConfig: RestoreConfig!,
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!
    ): vSphereAsyncRequestStatus!
    vsphereVMRecoverFilesNew(
        clusterUuid: UUID!,
        "Configuration for the restore request."
        config: RestoreFilesJobConfigInput!,
        "The additional arguments needed for a delta recovery. A delta recovery performs a recovery with an an additional next snapshot delta."
        deltaRequest: DeltaRecoveryInput,
        "ID of a snapshot."
        id: String!
    ): AsyncRequestStatus!
    vsphereVMUpdate(
        isArrayIntegrationEnabled: Boolean,
        postBackupScript: PostBackupScriptInputType,
        postSnapScript: PostSnapScriptInputType,
        preBackupScript: PreBackupScriptInputType,
        snappableFid: UUID!,
        "The snapshot consistency mandate of the snappable."
        snapshotConsistencyMandate: String
    ): RequestSuccess!
    warmSearchCache(snappableFid: UUID!): Boolean!
}

"Supported in v5.0+"
type NasBaseConfig {
    """

    Supported in v5.0+
    TLS certification to validate NAS server.
    """
    apiCertificate: String
    """

    Supported in v5.0+
    API endpoint to access NAS API 'FLASHBLADE'.
    """
    apiEndpoint: String
    """

    Supported in v5.0+
    Hostname or IP used in the NAS API calls.
    """
    apiHostname: String
    """

    Supported in v5.0+
    v5.0-v5.3: username to access NAS API
    v6.0+: Username to access NAS API.
    """
    apiUsername: String
    """

    Supported in v5.2+
    v5.2: A Boolean value that specifies whether Changelist is enabled on Isilon NAS share. When this value is 'true', metadata fetches during backup operations use the Isilon Changelist feature. The Changelist feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.
    v5.3+: Indicates if Changelist is enabled on Isilon NAS share. When this value is 'true', metadata fetches during backup operations use the Isilon Changelist feature. The Changelist feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.
    """
    isIsilonChangelistEnabled: Boolean
    """

    Supported in v5.2+
    v5.2: A Boolean value that specifies whether SnapDiff is enabled on NetApp NAS share. When this value is 'true', metadata fetches during backup operations use the NetApp SnapDiff feature. The SnapDiff feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.
    v5.3+: Indicates if SnapDiff is enabled on NetApp NAS share. When this value is 'true', metadata fetches during backup operations use the NetApp SnapDiff feature. The SnapDiff feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.
    """
    isNetAppSnapDiffEnabled: Boolean
    """

    Supported in v6.0+
    Indicates whether CFT (Change File Tracking) is enabled on the Nutanix NAS share. When this value is 'true', metadata fetches during backup operations use the Nutanix CFT feature. The CFT feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time  during a backup job.
    """
    isNutanixCftEnabled: Boolean
    """

    Supported in v5.3+
    Specifies whether shares on the NAS host are automatically discovered. When this value is 'true', Rubrik periodically (every 30 minutes by default) connects to the NAS host to discover NFS and SMB shares.
    """
    isShareAutoDiscoveryEnabled: Boolean
    """

    Supported in v5.1
    If snapdiff is enabled on NetApp NAS host
    """
    isSnapdiffEnabled: Boolean
    """

    Required. Supported in v5.0+
    v5.0-v5.3: Type of NAS vendor 'ISILON/NETAPP/FLASHBLADE'
    v6.0+: Specifies the NAS vendor, which can be ISILON, NETAPP, FLASHBLADE, or NUTANIX.
    """
    vendorType: String!
    """

    Supported in v5.0+
    Name of the Isilon zone that data IP belongs to.
    """
    zoneName: String
}

type NasNamespace implements CdmHierarchyObject & HierarchyObject & NasSystemDescendantType & NasSystemLogicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): NasNamespaceDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "object id"
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "List of logical children"
    logicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): NasNamespaceLogicalChildTypeConnection!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"Paginated list of NasNamespace objects."
type NasNamespaceConnection {
    "Total number of NasNamespace objects matching the request arguments."
    count: Int!
    "List of NasNamespace objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [NasNamespaceEdge!]!
    "List of NasNamespace objects."
    nodes: [NasNamespace!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Paginated list of NasNamespaceDescendantType objects."
type NasNamespaceDescendantTypeConnection {
    "Total number of NasNamespaceDescendantType objects matching the request arguments."
    count: Int!
    "List of NasNamespaceDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [NasNamespaceDescendantTypeEdge!]!
    "List of NasNamespaceDescendantType objects."
    nodes: [NasNamespaceDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the NasNamespaceDescendantType object. This wrapper is used for pagination."
type NasNamespaceDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual NasNamespaceDescendantType object wrapped by this edge."
    node: NasNamespaceDescendantType!
}

"Wrapper around the NasNamespace object. This wrapper is used for pagination."
type NasNamespaceEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual NasNamespace object wrapped by this edge."
    node: NasNamespace!
}

"Paginated list of NasNamespaceLogicalChildType objects."
type NasNamespaceLogicalChildTypeConnection {
    "Total number of NasNamespaceLogicalChildType objects matching the request arguments."
    count: Int!
    "List of NasNamespaceLogicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [NasNamespaceLogicalChildTypeEdge!]!
    "List of NasNamespaceLogicalChildType objects."
    nodes: [NasNamespaceLogicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the NasNamespaceLogicalChildType object. This wrapper is used for pagination."
type NasNamespaceLogicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual NasNamespaceLogicalChildType object wrapped by this edge."
    node: NasNamespaceLogicalChildType!
}

type NasShare implements CdmHierarchyObject & HierarchyObject & NasNamespaceDescendantType & NasNamespaceLogicalChildType & NasSystemDescendantType & NasSystemLogicalChildType & NasVolumeDescendantType & NasVolumeLogicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    exportPoint: String!
    "object id"
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    shareType: String!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

type NasSystem implements CdmHierarchyObject & HierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): NasSystemDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "object id"
    id: UUID!
    lastRefreshTime: DateTime
    "Latest User note information."
    latestUserNote: LatestUserNote
    "List of logical children"
    logicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): NasSystemLogicalChildTypeConnection!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The total number of namespaces in this NAS system."
    namespaceCount: Int!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    osVersion: String
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The total number of shares in this NAS system."
    shareCount: Int!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    vendorType: String!
    "The total number of volumes in this NAS system."
    volumeCount: Int!
}

"Paginated list of NasSystem objects."
type NasSystemConnection {
    "Total number of NasSystem objects matching the request arguments."
    count: Int!
    "List of NasSystem objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [NasSystemEdge!]!
    "List of NasSystem objects."
    nodes: [NasSystem!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Paginated list of NasSystemDescendantType objects."
type NasSystemDescendantTypeConnection {
    "Total number of NasSystemDescendantType objects matching the request arguments."
    count: Int!
    "List of NasSystemDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [NasSystemDescendantTypeEdge!]!
    "List of NasSystemDescendantType objects."
    nodes: [NasSystemDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the NasSystemDescendantType object. This wrapper is used for pagination."
type NasSystemDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual NasSystemDescendantType object wrapped by this edge."
    node: NasSystemDescendantType!
}

"Wrapper around the NasSystem object. This wrapper is used for pagination."
type NasSystemEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual NasSystem object wrapped by this edge."
    node: NasSystem!
}

"Paginated list of NasSystemLogicalChildType objects."
type NasSystemLogicalChildTypeConnection {
    "Total number of NasSystemLogicalChildType objects matching the request arguments."
    count: Int!
    "List of NasSystemLogicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [NasSystemLogicalChildTypeEdge!]!
    "List of NasSystemLogicalChildType objects."
    nodes: [NasSystemLogicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the NasSystemLogicalChildType object. This wrapper is used for pagination."
type NasSystemLogicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual NasSystemLogicalChildType object wrapped by this edge."
    node: NasSystemLogicalChildType!
}

"Supported in v7.0+"
type NasSystemSummary {
    """

    Required. Supported in v7.0+
    The hostname of the NAS System.
    """
    hostname: String!
    """

    Required. Supported in v7.0+
    ID assigned to the NAS System.
    """
    id: String!
    vendorType: NasVendorTypeEnum!
}

type NasVolume implements CdmHierarchyObject & HierarchyObject & NasNamespaceDescendantType & NasNamespaceLogicalChildType & NasSystemDescendantType & NasSystemLogicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): NasVolumeDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "object id"
    id: UUID!
    "Whether or not the NAS Volume is read-only."
    isReadonly: Boolean!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "List of logical children"
    logicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): NasVolumeLogicalChildTypeConnection!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The NAS Namespace to which this NAS Volume belongs, if any"
    nasNamespace: NasNamespace
    "The NAS System to which this NAS Volume belongs"
    nasSystem: NasSystem!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The size of the volume in bytes."
    sizeInBytes: Long!
    "The size that has been used of the volume in bytes."
    sizeUsedInBytes: Long!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "Labels that can be applied to a newly created SnapMirror Cloud."
    snapMirrorLabels: [String!]!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"Paginated list of NasVolumeDescendantType objects."
type NasVolumeDescendantTypeConnection {
    "Total number of NasVolumeDescendantType objects matching the request arguments."
    count: Int!
    "List of NasVolumeDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [NasVolumeDescendantTypeEdge!]!
    "List of NasVolumeDescendantType objects."
    nodes: [NasVolumeDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the NasVolumeDescendantType object. This wrapper is used for pagination."
type NasVolumeDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual NasVolumeDescendantType object wrapped by this edge."
    node: NasVolumeDescendantType!
}

"Paginated list of NasVolumeLogicalChildType objects."
type NasVolumeLogicalChildTypeConnection {
    "Total number of NasVolumeLogicalChildType objects matching the request arguments."
    count: Int!
    "List of NasVolumeLogicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [NasVolumeLogicalChildTypeEdge!]!
    "List of NasVolumeLogicalChildType objects."
    nodes: [NasVolumeLogicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the NasVolumeLogicalChildType object. This wrapper is used for pagination."
type NasVolumeLogicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual NasVolumeLogicalChildType object wrapped by this edge."
    node: NasVolumeLogicalChildType!
}

"Represents a GCP native network host project"
type NetworkHostProject {
    name: String!
    nativeId: String!
    projectId: String!
}

"Replication network throttle information."
type NetworkThrottle {
    "Active network throttle limit."
    currentThrottleLimit: Float!
    "Default network throttle limit."
    defaultThrottleLimit: Float!
    "Status of network throttle enablement."
    isEnabled: Boolean!
    "Network interface name."
    networkInterface: String!
    "Summary of scheduled throttles."
    scheduledThrottles: [NetworkThrottleSchedule!]!
}

"Summary of scheduled throttle."
type NetworkThrottleSchedule {
    "Days of the week on which to apply a scheduled network throttle."
    daysOfWeek: [DayOfWeek!]!
    "Denotes the end time. The end time should be an hour of the day."
    endHour: Int!
    "Denotes the start time. The start time should be an hour of the day."
    startHour: Int!
    "Network bandwidth throttle limit for a resource, in Mbps."
    throttleLimit: Float!
}

"Supported in v5.0+"
type NetworkThrottleScheduleSummary {
    """

    Required. Supported in v5.0+
    Array of int32 values that represent the days of the week on which to apply a scheduled network throttle. The days of the week are represented from 1-7 with Sunday as 1.
    """
    daysOfWeek: [Int!]!
    """

    Required. Supported in v5.0+
    An int64 value that represents the end time for a scheduled network throttle. The end time should be an hour of the day in minutes. For example, 0, 12*60 and 24*60 are valid values.
    """
    endTime: Long!
    """

    Required. Supported in v5.0+
    An int64 value that represents the start time for a scheduled network throttle. The start time should be an hour of the day in minutes. For example, 0, 12*60 and 24*60 are valid values.
    """
    startTime: Long!
    """

    Required. Supported in v5.0+
    Network bandwidth throttle limit for a resource, in Mbps. The throttle limit is precise to two decimal places.
    """
    throttleLimit: Float!
}

"Supported in v5.0+"
type NetworkThrottleSummary {
    """

    Supported in v5.0+
    Default throttle limit for a resource, in Mbps. The throttle limit is precise to two decimal places.
    """
    defaultThrottleLimit: Float
    """

    Required. Supported in v5.0+
    Boolean value that determines whether a throttle limit is enabled.
    """
    isEnabled: Boolean!
    """

    Supported in v5.2+
    The network interface where outgoing traffic is throttled.
    """
    networkInterface: String
    resourceId: NetworkThrottleResourceIdEnum!
    """

    Required. Supported in v5.0+
    An array containing all of the scheduled throttle limits for the specified resource.
    """
    scheduledThrottles: [NetworkThrottleScheduleSummary!]!
}

"A recurrence range without an end (e.g. repeat the pattern forever starting from 7/29/2019)."
type NoEndRecurrenceRange {
    "The starting date of the recurrence."
    startDate: DateTime!
}

"List of status for each node"
type NodeStatus {
    brikId: String!
    id: String!
    ipAddress: String
    status: String!
    supportTunnel: SupportTunnelInfoResp
}

"Response type for getting information on every node in a cluster"
type NodeStatusListResp {
    data: [NodeStatus!]!
    hasMore: Boolean
    id: String!
    total: Long
}

"A recurrence range with a number of occurrences (e.g. repeat the pattern 10 times starting from 7/29/2019)."
type NumberedRecurrenceRange {
    "The number of occurrences."
    numberOfOccurrences: Int!
    "The starting date of the recurrence."
    startDate: DateTime!
}

type NutanixCluster implements CdmHierarchyObject & HierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    cdmId: String!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "Connection status of the Nutanix Cluster."
    connectionStatus: RefreshableObjectConnectionStatus!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): NutanixClusterDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "object id"
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "List of logical children"
    logicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): NutanixClusterLogicalChildTypeConnection!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"Paginated list of NutanixCluster objects."
type NutanixClusterConnection {
    "Total number of NutanixCluster objects matching the request arguments."
    count: Int!
    "List of NutanixCluster objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [NutanixClusterEdge!]!
    "List of NutanixCluster objects."
    nodes: [NutanixCluster!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Paginated list of NutanixClusterDescendantType objects."
type NutanixClusterDescendantTypeConnection {
    "Total number of NutanixClusterDescendantType objects matching the request arguments."
    count: Int!
    "List of NutanixClusterDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [NutanixClusterDescendantTypeEdge!]!
    "List of NutanixClusterDescendantType objects."
    nodes: [NutanixClusterDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the NutanixClusterDescendantType object. This wrapper is used for pagination."
type NutanixClusterDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual NutanixClusterDescendantType object wrapped by this edge."
    node: NutanixClusterDescendantType!
}

"Supported in v5.0+"
type NutanixClusterDetail {
    """

    Required. Supported in v5.0+
    Concatenated X.509 certificates in Base64 encoded DER format. Each certificate must start with -----BEGIN CERTIFICATE----- and end with -----END CERTIFICATE-----.
    """
    caCerts: String!
    """

    Required. Supported in v5.0+
    Connection status of a Nutanix Cluster.
    """
    connectionStatus: RefreshableObjectConnectionStatus
    nutanixClusterSummary: NutanixClusterSummary
}

"Wrapper around the NutanixCluster object. This wrapper is used for pagination."
type NutanixClusterEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual NutanixCluster object wrapped by this edge."
    node: NutanixCluster!
}

"Paginated list of NutanixClusterLogicalChildType objects."
type NutanixClusterLogicalChildTypeConnection {
    "Total number of NutanixClusterLogicalChildType objects matching the request arguments."
    count: Int!
    "List of NutanixClusterLogicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [NutanixClusterLogicalChildTypeEdge!]!
    "List of NutanixClusterLogicalChildType objects."
    nodes: [NutanixClusterLogicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the NutanixClusterLogicalChildType object. This wrapper is used for pagination."
type NutanixClusterLogicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual NutanixClusterLogicalChildType object wrapped by this edge."
    node: NutanixClusterLogicalChildType!
}

"Supported in v5.0+"
type NutanixClusterSummary {
    """

    Supported in v5.0+
    Connection status of a Nutanix Cluster.
    """
    connectionStatus: RefreshableObjectConnectionStatus
    "Required. Supported in v5.0+"
    hostname: String!
    "Required. Supported in v5.0+"
    naturalId: String!
    """

    Supported in v5.3+
    Describes any pending SLA Domain assignment on this object.
    """
    pendingSlaDomain: ManagedObjectPendingSlaInfo
    slaAssignable: SlaAssignable
    "Required. Supported in v5.0+"
    username: String!
}

"Supported in v5.0+"
type NutanixContainer {
    """

    Required. Supported in v5.0+
    Name of the Nutanix container.
    """
    name: String!
    """

    Required. Supported in v5.0+
    Natural ID of the Nutanix container.
    """
    naturalId: String!
}

"Supported in v5.0+"
type NutanixContainerListResponse {
    """

    Supported in v5.0+
    List of matching objects.
    """
    data: [NutanixContainer!]!
    """

    Supported in v5.0+
    If there is more.
    """
    hasMore: Boolean
    """

    Supported in v5.0+
    Total list responses.
    """
    total: Long
}

"Nutanix VM live mount."
type NutanixLiveMount {
    "Cluster of the live mount."
    cluster: Cluster!
    "Fid of the live mount."
    id: UUID!
    "Describes if the live mount is ready."
    isVmReady: Boolean!
    "Mount job instance ID."
    mountJobInstanceId: String!
    "Specification of the live mount in JSON string."
    mountSpec: String!
    "Name of the live mount."
    name: String!
    "Organization ID of the live mount."
    organizationId: String!
    "Owner ID of the live mount."
    ownerId: String!
    "Source snapshot of the live mount."
    sourceSnapshot: CdmSnapshot!
    "Unmount job instance ID."
    unmountJobInstanceId: String!
}

"Paginated list of NutanixLiveMount objects."
type NutanixLiveMountConnection {
    "Total number of NutanixLiveMount objects matching the request arguments."
    count: Int!
    "List of NutanixLiveMount objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [NutanixLiveMountEdge!]!
    "List of NutanixLiveMount objects."
    nodes: [NutanixLiveMount!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the NutanixLiveMount object. This wrapper is used for pagination."
type NutanixLiveMountEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual NutanixLiveMount object wrapped by this edge."
    node: NutanixLiveMount!
}

"Supported in v5.2+"
type NutanixVirtualDiskSummary {
    """

    Supported in v5.2+
    Type of virtual disk.
    """
    deviceType: String
    """

    Supported in v6.0+
    Specifies whether the Nutanix device can create a snapshot of the disk. Value is true when a snapshot can be created.
    """
    isSnapshottable: Boolean
    """

    Supported in v6.0+
    Label of the disk assigned by Nutanix.
    """
    label: String
    """

    Supported in v5.2+
    Size of the virtual disk in bytes.
    """
    sizeInBytes: Long
    """

    Supported in v5.2-v5.3
    UUID of the disk
    """
    uuid: String
    """

    Supported in v6.0+
    UUID of the virtual machine disk.
    """
    vmDiskUuid: String
}

"Supported in v6.0+"
type NutanixVirtualMachineScriptDetail {
    failureHandling: NutanixVirtualMachineScriptDetailFailureHandlingEnum!
    """

    Required. Supported in v6.0+
    The command to be run in VM guest OS.
    """
    scriptPath: String!
    """

    Required. Supported in v6.0+
    Time (in ms) after which the script will be terminated if it has not completed.
    """
    timeoutMs: Long!
}

type NutanixVm implements CdmHierarchyObject & CdmHierarchySnappableNew & HierarchyObject & HierarchySnappable & NutanixClusterDescendantType & NutanixClusterLogicalChildType {
    "Status of the Rubrik Backup Service agent on this VM."
    agentStatus: AgentStatus
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    cdmId: String!
    "A link to view the snappable on the CDM cluster. For dev use only."
    cdmLink: String!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "object id"
    id: UUID!
    isRelic: Boolean!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The list of missed snapshots for this workload."
    missedSnapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int
    ): MissedSnapshotCommonConnection
    "The list of missed snapshots for this workload."
    missedSnapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: MissedSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): MissedSnapshotGroupByConnection
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot archived to AWS."
    newestArchivedSnapshot: CdmSnapshot
    "The newest snapshot replicated to a cluster."
    newestReplicatedSnapshot: CdmSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: CdmSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "Nutanix VM Live Count Connection."
    nutanixVmMountCount: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: CdmSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "Stats for Nutanix VM (e.g., capacity)."
    reportSnappable: Snappable
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for the snapshots of this workload."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: CdmSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): cdmSnapshotGroupByConnection
}

"Paginated list of NutanixVm objects."
type NutanixVmConnection {
    "Total number of NutanixVm objects matching the request arguments."
    count: Int!
    "List of NutanixVm objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [NutanixVmEdge!]!
    "List of NutanixVm objects."
    nodes: [NutanixVm!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Supported in v5.0+"
type NutanixVmDetail {
    blackoutWindowResponseInfo: BlackoutWindowResponseInfo
    """

    Required. Supported in v5.0+
    A list of virtual disk IDs to exclude from the backup for this virtual machine.
    """
    excludedDiskIds: [String!]!
    """

    Required. Supported in v5.0+
    Returns whether the Rubrik connector is installed and service is registered.
    """
    isAgentRegistered: Boolean!
    """

    Required. Supported in v5.0+
    Whether backup/archival/replication is paused for this System Volume.
    """
    isPaused: Boolean!
    nutanixVmPatch: NutanixVmPatch
    nutanixVmSummary: NutanixVmSummary
    """

    Supported in v5.2+
    Information of all the virtual disks for this virtual machine.
    """
    virtualDisks: [NutanixVirtualDiskSummary!]!
}

"Wrapper around the NutanixVm object. This wrapper is used for pagination."
type NutanixVmEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual NutanixVm object wrapped by this edge."
    node: NutanixVm!
}

"Supported in v6.0+"
type NutanixVmMountDetail {
    nutanixVmMountSummary: NutanixVmMountSummary
}

"Supported in v6.0+"
type NutanixVmMountSummary {
    """

    Required. Supported in v6.0+
    ID of the Live Mount.
    """
    id: String!
    """

    Required. Supported in v6.0+
    Specifies whether the Live Mount is ready.
    """
    isReady: Boolean!
    """

    Supported in v7.0+
    The status of the migration job for the mounted virtual machine. Valid values are 'REQUESTED', 'RUNNING', 'SUCCEEDED', and 'FAILED'. An unspecified value indicates that no migration job has been initiated for the mounted virtual machine.
    """
    migrationStatus: String
    """

    Supported in v6.0+
    ID of the request which initiated the Live Mount.
    """
    mountRequestId: String
    """

    Supported in v6.0+
    Timestamp at which the Live Mount was created.
    """
    mountedDate: DateTime
    """

    Supported in v6.0+
    ID of the mounted virtual machine.
    """
    mountedVmId: String
    """

    Supported in v6.0+
    IP address of the mounted virtual machine.
    """
    mountedVmIpAddress: String
    """

    Supported in v6.0+
    Name of the mounted virtual machine.
    """
    mountedVmName: String
    """

    Supported in v6.0+
    The power status of the mounted virtual machine.
    """
    powerStatus: String
    """

    Required. Supported in v6.0+
    Timestamp of the Nutanix virtual machine snapshot on which the Live Mount is based.
    """
    snapshotDate: DateTime
    """

    Supported in v6.0+
    ID of the Nutanix storage container which contains the mounted virtual disks.
    """
    storageContainerName: String
    """

    Required. Supported in v6.0+
    ID of the Nutanix cluster to which the mounted virtual machine belongs.
    """
    targetNutanixClusterId: String!
    """

    Supported in v6.0+
    Name of the Nutanix cluster to which the mounted virtual machine belongs.
    """
    targetNutanixClusterName: String
    """

    Supported in v6.0+
    ID of the request to delete the Live Mount.
    """
    unmountRequestId: String
    """

    Required. Supported in v6.0+
    ID of the source virtual machine of the Live Mount.
    """
    vmId: String!
    """

    Supported in v6.0+
    Name of the source virtual machine of the Live Mount.
    """
    vmName: String
}

"Supported in v5.0+"
type NutanixVmPatch {
    """

    Supported in v5.0+
    v5.0-v5.1: Assign this VM to the given SLA domain.
    v5.2+: Assign this VM to the given SLA domain. Existing snapshots of the object will be retained with the configuration of specified SLA Domain.
    """
    configuredSlaDomainId: String
    """

    Supported in v5.0+
    A list of virtual disks IDs to exclude from the backup for this virtual machine.
    """
    excludedDiskIds: [String!]!
    """

    Supported in v5.0+
    Whether backup/archival/replication is paused for this VM.
    """
    isPaused: Boolean
    "Supported in v6.0+"
    postBackupScript: NutanixVirtualMachineScriptDetail
    "Supported in v6.0+"
    postSnapScript: NutanixVirtualMachineScriptDetail
    "Supported in v6.0+"
    preBackupScript: NutanixVirtualMachineScriptDetail
    snapshotConsistencyMandate: NutanixSnapshotConsistencyMandateEnum
}

"Supported in v5.0+"
type NutanixVmSummary {
    """

    Supported in v5.0+
    The status of the Rubrik Backup Service agent for Nutanix virtual machines.
    """
    agentStatus: CDMAgentStatus
    "Required. Supported in v5.0+"
    id: String!
    """

    Required. Supported in v5.0+
    Whether this Nutanix VM is currently present on the Nutanix cluster.
    """
    isRelic: Boolean!
    "Required. Supported in v5.0+"
    name: String!
    """

    Supported in v5.0+
    The ID of the Nutanix cluster to which this VM belongs.
    """
    nutanixClusterId: String
    """

    Supported in v5.0+
    The name of the Nutanix cluster to which this VM belongs.
    """
    nutanixClusterName: String
    operatingSystemType: OperatingSystemTypeEnum
    """

    Supported in v5.3+
    Describes any pending SLA Domain assignment on this object.
    """
    pendingSlaDomain: ManagedObjectPendingSlaInfo
    snappable: CDMSnappable
    snapshotConsistencyMandate: NutanixSnapshotConsistencyMandateEnum!
}

type O365App implements O365AppObject {
    "The added time of the O365 app."
    addedAt: DateTime!
    "The id of the O365 app."
    appId: String!
    "The owner of the O365 app (RUBRIK or CUSTOMER)."
    appOwner: String!
    "The type of the O365 app (e.g. ONEDRIVE)."
    appType: String!
    "The authentication status of the app against the subscription."
    isAuthenticated: Boolean!
    "The subscription to which the O365 app is associated."
    subscription: String!
    "The ID of the O365 subscription."
    subscriptionId: String!
}

"Paginated list of O365App objects."
type O365AppConnection {
    "Total number of O365App objects matching the request arguments."
    count: Int!
    "List of O365App objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [O365AppEdge!]!
    "List of O365App objects."
    nodes: [O365App!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the O365App object. This wrapper is used for pagination."
type O365AppEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual O365App object wrapped by this edge."
    node: O365App!
}

type O365Calendar implements HierarchyObject & HierarchySnappable & O365OrgDescendant & O365UserDescendant & PolarisHierarchyObject & PolarisHierarchySnappable {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "object id"
    id: UUID!
    isRelic: Boolean!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: PolarisSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: PolarisSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this workload."
    snapshotsOfSnappableConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Whether to ignore the active protected object check."
        ignoreActiveSnappableCheck: Boolean,
        "Returns the last n elements from the list."
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
}

"An O365 calendar event object."
type O365CalendarEvent implements O365ExchangeObject {
    attendees: [String!]!
    endDateTime: DateTime
    eventType: CalendarEventType!
    id: String!
    name: String
    organizer: String
    parentFolderId: String
    "The recurrence of the event (if part of a series)."
    recurrence: O365CalendarEventRecurrence
    snapshotId: UUID
    "The snapshot time of this version of the event."
    snapshotTime: DateTime
    startDateTime: DateTime
    versionStartSnapshotId: UUID
}

"The recurrence pattern of an O365 calendar event."
type O365CalendarEventRecurrence {
    "The absolute monthly recurrence pattern (e.g. 21st of every 3 months)."
    absoluteMonthlyRecurrence: AbsoluteMonthlyRecurrencePattern
    "The absolute yearly recurrence pattern (e.g. 25th of December)."
    absoluteYearlyRecurrence: AbsoluteYearlyRecurrencePattern
    "The daily recurrence pattern (e.g. Every 3 days)."
    dailyRecurrence: DailyRecurrencePattern
    "A recurrence range with an end date."
    endDateRecurrenceRange: EndDateRecurrenceRange
    "A recurrence range with no end date."
    noEndRecurrenceRange: NoEndRecurrenceRange
    "A recurrence range with a specified number of occurrences."
    numberedRecurrenceRange: NumberedRecurrenceRange
    "The relative monthly recurrence pattern (e.g. Second Thursday or Friday of every other month)."
    relativeMonthlyRecurrence: RelativeMonthlyRecurrencePattern
    "The relative yearly recurrence pattern (e.g. First Tuesday of November)."
    relativeYearlyRecurrence: RelativeYearlyRecurrencePattern
    "The weekly recurrence pattern (e.g. Every other Monday)."
    weeklyRecurrence: WeeklyRecurrencePattern
}

type O365CalendarFolder implements O365ExchangeObject {
    id: String!
    "Indicates if this folder represents a Calendar Group."
    isCalendarGroup: Boolean!
    name: String
    parentFolderId: String
    snapshotId: UUID
    "The snapshot time of this version of the event."
    snapshotTime: DateTime
}

"An O365 contact object."
type O365Contact implements O365ExchangeObject {
    "Addresses associated with this contact."
    addresses: [String!]!
    "The company at which this contact works."
    company: String
    "Email addresses associated with this contact."
    emailAddresses: [String!]!
    "The id of the contact."
    id: String!
    "The name for this contact."
    name: String
    "The parent folder id of the contact."
    parentFolderId: String
    "Phone numbers associated with this contact."
    phoneNumbers: [String!]!
    "The snapshot id of this version of the contact."
    snapshotId: UUID
    "The snapshot number of this version of the contact."
    snapshotNum: Int
    "The snapshot time of this version of the contact."
    snapshotTime: DateTime
}

"An O365 contact folder."
type O365ContactFolder implements O365ExchangeObject {
    "The id of the contact folder."
    id: String!
    "The display name for this contact folder."
    name: String
    "The parent folder id of the contact folder."
    parentFolderId: String
    "The snapshot id of this version of the contact folder."
    snapshotId: UUID
    "The snapshot number of this version of the contact folder."
    snapshotNum: Int
    "The snapshot time of this version of the contact folder."
    snapshotTime: DateTime
}

type O365Email implements O365ExchangeObject {
    from: String
    id: String!
    parentFolderId: String
    receivedDateTime: DateTime
    sentDateTime: DateTime
    snapshotId: UUID
    snapshotNum: Int
    subject: String
    toRecipients: [String!]!
}

"Paginated list of O365ExchangeObject objects."
type O365ExchangeObjectConnection {
    "Total number of O365ExchangeObject objects matching the request arguments."
    count: Int!
    "List of O365ExchangeObject objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [O365ExchangeObjectEdge!]!
    "List of O365ExchangeObject objects."
    nodes: [O365ExchangeObject!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the O365ExchangeObject object. This wrapper is used for pagination."
type O365ExchangeObjectEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual O365ExchangeObject object wrapped by this edge."
    node: O365ExchangeObject!
}

type O365Folder implements O365ExchangeObject {
    id: String!
    name: String
    parentFolderId: String
    snapshotId: UUID
    snapshotNum: Int
}

"O365 Groups from O365 hierarchy."
type O365Group implements HierarchyObject & O365OrgDescendant & PolarisHierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "True, if the group is deleted in AD."
    deletedInAzure: Boolean!
    "DisplayName of AD Group."
    displayName: String!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "Rubrik internal UUID for group."
    groupID: String!
    "Group ID of o365 group object."
    id: UUID!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "Natural ID of AD Group."
    naturalID: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "Number of user that are member of group."
    userCount: Long!
}

"Paginated list of O365Group objects."
type O365GroupConnection {
    "Total number of O365Group objects matching the request arguments."
    count: Int!
    "List of O365Group objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [O365GroupEdge!]!
    "List of O365Group objects."
    nodes: [O365Group!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the O365Group object. This wrapper is used for pagination."
type O365GroupEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual O365Group object wrapped by this edge."
    node: O365Group!
}

"The O365 license."
type O365License {
    "The license detail of O365 account."
    licenseDetails: O365LicenseDetails
}

"The O365 license detail."
type O365LicenseDetails {
    "The host type of the azure subscription."
    allowedHost: AzureHostType!
    "The allowed m365 user license count."
    allowedO365UserCount: Int!
    "The license status."
    disableLicense: Boolean!
    "The M365 cloud type."
    m365Cloud: M365Cloud!
}

type O365Mailbox implements HierarchyObject & HierarchySnappable & O365OrgDescendant & O365UserDescendant & O365UserDescendantMetadata & PolarisHierarchyObject & PolarisHierarchySnappable {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "object id"
    id: UUID!
    isRelic: Boolean!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: PolarisSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: PolarisSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this workload."
    snapshotsOfSnappableConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Whether to ignore the active protected object check."
        ignoreActiveSnappableCheck: Boolean,
        "Returns the last n elements from the list."
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
    userPrincipalName: String!
}

"Paginated list of O365Mailbox objects."
type O365MailboxConnection {
    "Total number of O365Mailbox objects matching the request arguments."
    count: Int!
    "List of O365Mailbox objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [O365MailboxEdge!]!
    "List of O365Mailbox objects."
    nodes: [O365Mailbox!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the O365Mailbox object. This wrapper is used for pagination."
type O365MailboxEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual O365Mailbox object wrapped by this edge."
    node: O365Mailbox!
}

type O365OAuthConsentCompleteResp {
    appId: String!
    encryptedRefreshToken: String!
}

type O365OAuthConsentKickoffResp {
    appClientId: String!
    csrfToken: String!
    tenantId: String!
}

type O365Onedrive implements HierarchyObject & HierarchySnappable & O365OrgDescendant & O365UserDescendant & O365UserDescendantMetadata & PolarisHierarchyObject & PolarisHierarchySnappable {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "object id"
    id: UUID!
    isRelic: Boolean!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: PolarisSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: PolarisSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this workload."
    snapshotsOfSnappableConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Whether to ignore the active protected object check."
        ignoreActiveSnappableCheck: Boolean,
        "Returns the last n elements from the list."
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
    totalStorageInBytes: Long!
    usedStorageInBytes: Long!
    userID: String!
    userName: String!
    userPrincipalName: String!
}

"Paginated list of O365Onedrive objects."
type O365OnedriveConnection {
    "Total number of O365Onedrive objects matching the request arguments."
    count: Int!
    "List of O365Onedrive objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [O365OnedriveEdge!]!
    "List of O365Onedrive objects."
    nodes: [O365Onedrive!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the O365Onedrive object. This wrapper is used for pagination."
type O365OnedriveEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual O365Onedrive object wrapped by this edge."
    node: O365Onedrive!
}

type O365OnedriveFile implements O365OnedriveObject {
    channelFolderName: String
    channelId: String
    channelName: String
    createTime: DateTime
    fileType: String
    id: String!
    modifiedTime: DateTime
    name: String
    parentFolderId: String
    size: Long
    snapshotId: UUID
    snapshotNum: Int
    snapshotTime: DateTime
}

type O365OnedriveFolder implements O365OnedriveObject {
    channelFolderName: String
    channelId: String
    channelName: String
    createTime: DateTime
    id: String!
    itemCount: Int
    modifiedTime: DateTime
    name: String
    parentFolderId: String
    size: Long
    snapshotId: UUID
    snapshotNum: Int
    snapshotTime: DateTime
}

"Paginated list of O365OnedriveObject objects."
type O365OnedriveObjectConnection {
    "Total number of O365OnedriveObject objects matching the request arguments."
    count: Int!
    "List of O365OnedriveObject objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [O365OnedriveObjectEdge!]!
    "List of O365OnedriveObject objects."
    nodes: [O365OnedriveObject!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the O365OnedriveObject object. This wrapper is used for pagination."
type O365OnedriveObjectEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual O365OnedriveObject object wrapped by this edge."
    node: O365OnedriveObject!
}

type O365Org implements HierarchyObject & PolarisHierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "List of direct children of O365Org"
    childConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): O365UserConnection!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    exocomputeId: String!
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    past1DayMailboxComplianceCount: Int!
    past1DayMailboxOutOfComplianceCount: Int!
    past1DayOnedriveComplianceCount: Int!
    past1DayOnedriveOutOfComplianceCount: Int!
    past1DaySharepointComplianceCount: Int!
    past1DaySharepointOutOfComplianceCount: Int!
    past1DaySpListComplianceCount: Int!
    past1DaySpListOutOfComplianceCount: Int!
    past1DayTeamsComplianceCount: Int!
    past1DayTeamsOutOfComplianceCount: Int!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "List of all descendants of O365Org"
    searchDescendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): O365OrgDescendantConnection!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    status: OrgStatus!
    "Number of O365 Users with no SLA assigned"
    unprotectedUsersCount: Int!
}

"Paginated list of O365Org objects."
type O365OrgConnection {
    "Total number of O365Org objects matching the request arguments."
    count: Int!
    "List of O365Org objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [O365OrgEdge!]!
    "List of O365Org objects."
    nodes: [O365Org!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Paginated list of O365OrgDescendant objects."
type O365OrgDescendantConnection {
    "Total number of O365OrgDescendant objects matching the request arguments."
    count: Int!
    "List of O365OrgDescendant objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [O365OrgDescendantEdge!]!
    "List of O365OrgDescendant objects."
    nodes: [O365OrgDescendant!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the O365OrgDescendant object. This wrapper is used for pagination."
type O365OrgDescendantEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual O365OrgDescendant object wrapped by this edge."
    node: O365OrgDescendant!
}

"Wrapper around the O365Org object. This wrapper is used for pagination."
type O365OrgEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual O365Org object wrapped by this edge."
    node: O365Org!
}

"The O365 subscription status and id info."
type O365OrgInfo {
    "Exchange colossus status."
    exchangeOnColossus: Boolean!
    "Polaris ID of O365 subscription."
    orgId: String!
    "Provision status of O365 subscription."
    status: ProvisionStatus!
}

type O365PhysicalDataSizeTimeStamp {
    physicalDataSizeInBytes: Long!
    timestamp: DateTime
}

"O365 SaaS setup kickoff response"
type O365SaaSSetupKickoffResp {
    appClientIdsPerType: [AppIDForType!]!
    csrfToken: String!
}

type O365ServiceAccountStatusResp {
    status: O365ServiceAccountStatus!
    username: String!
}

"O365 setup kickoff response"
type O365SetupKickoffResp {
    appClientId: String!
    appClientIdsPerType: [AppIDForType!]!
    csrfToken: String!
}

type O365SharepointDrive implements HierarchyObject & HierarchySnappable & O365OrgDescendant & O365SharepointObject & PolarisHierarchyObject & PolarisHierarchySnappable {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "object id"
    id: UUID!
    isRelic: Boolean!
    listNaturalId: String!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    naturalId: String!
    "The newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: PolarisSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    objectId: String!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: PolarisSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    parentId: String!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this workload."
    snapshotsOfSnappableConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Whether to ignore the active protected object check."
        ignoreActiveSnappableCheck: Boolean,
        "Returns the last n elements from the list."
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
    title: String!
    totalStorageInBytes: Long!
    url: String!
    usedStorageInBytes: Long!
}

"Paginated list of O365SharepointDrive objects."
type O365SharepointDriveConnection {
    "Total number of O365SharepointDrive objects matching the request arguments."
    count: Int!
    "List of O365SharepointDrive objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [O365SharepointDriveEdge!]!
    "List of O365SharepointDrive objects."
    nodes: [O365SharepointDrive!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the O365SharepointDrive object. This wrapper is used for pagination."
type O365SharepointDriveEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual O365SharepointDrive object wrapped by this edge."
    node: O365SharepointDrive!
}

type O365SharepointList implements HierarchyObject & HierarchySnappable & O365OrgDescendant & O365SharepointObject & PolarisHierarchyObject & PolarisHierarchySnappable {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The id of the O365 SharePoint list object."
    id: UUID!
    isRelic: Boolean!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    naturalId: String!
    "The newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: PolarisSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    objectId: String!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: PolarisSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    parentId: String!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this workload."
    snapshotsOfSnappableConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Whether to ignore the active protected object check."
        ignoreActiveSnappableCheck: Boolean,
        "Returns the last n elements from the list."
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
    title: String!
    url: String!
}

"Paginated list of O365SharepointList objects."
type O365SharepointListConnection {
    "Total number of O365SharepointList objects matching the request arguments."
    count: Int!
    "List of O365SharepointList objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [O365SharepointListEdge!]!
    "List of O365SharepointList objects."
    nodes: [O365SharepointList!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the O365SharepointList object. This wrapper is used for pagination."
type O365SharepointListEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual O365SharepointList object wrapped by this edge."
    node: O365SharepointList!
}

"Paginated list of O365SharepointObject objects."
type O365SharepointObjectConnection {
    "Total number of O365SharepointObject objects matching the request arguments."
    count: Int!
    "List of O365SharepointObject objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [O365SharepointObjectEdge!]!
    "List of O365SharepointObject objects."
    nodes: [O365SharepointObject!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the O365SharepointObject object. This wrapper is used for pagination."
type O365SharepointObjectEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual O365SharepointObject object wrapped by this edge."
    node: O365SharepointObject!
}

type O365Site implements HierarchyObject & HierarchySnappable & O365OrgDescendant & O365SharepointObject & PolarisHierarchyObject & PolarisHierarchySnappable {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    hierarchyLevel: Int!
    "object id"
    id: UUID!
    isRelic: Boolean!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: PolarisSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    objectId: String!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: PolarisSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    parentId: String!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this workload."
    snapshotsOfSnappableConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Whether to ignore the active protected object check."
        ignoreActiveSnappableCheck: Boolean,
        "Returns the last n elements from the list."
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
    title: String!
    url: String!
}

"Paginated list of O365Site objects."
type O365SiteConnection {
    "Total number of O365Site objects matching the request arguments."
    count: Int!
    "List of O365Site objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [O365SiteEdge!]!
    "List of O365Site objects."
    nodes: [O365Site!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the O365Site object. This wrapper is used for pagination."
type O365SiteEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual O365Site object wrapped by this edge."
    node: O365Site!
}

type O365TeamChildSnapshotIDs {
    mailboxSnapshotId: String
    spDriveSnapshotId: String
}

type O365TeamConvChannel {
    folderId: String!
    name: String!
    naturalId: String!
}

"Paginated list of O365TeamConvChannel objects."
type O365TeamConvChannelConnection {
    "Total number of O365TeamConvChannel objects matching the request arguments."
    count: Int!
    "List of O365TeamConvChannel objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [O365TeamConvChannelEdge!]!
    "List of O365TeamConvChannel objects."
    nodes: [O365TeamConvChannel!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the O365TeamConvChannel object. This wrapper is used for pagination."
type O365TeamConvChannelEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual O365TeamConvChannel object wrapped by this edge."
    node: O365TeamConvChannel!
}

type O365TeamConversationsSender {
    displayName: String!
    naturalId: String!
}

"Paginated list of O365TeamConversationsSender objects."
type O365TeamConversationsSenderConnection {
    "Total number of O365TeamConversationsSender objects matching the request arguments."
    count: Int!
    "List of O365TeamConversationsSender objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [O365TeamConversationsSenderEdge!]!
    "List of O365TeamConversationsSender objects."
    nodes: [O365TeamConversationsSender!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the O365TeamConversationsSender object. This wrapper is used for pagination."
type O365TeamConversationsSenderEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual O365TeamConversationsSender object wrapped by this edge."
    node: O365TeamConversationsSender!
}

type O365Teams implements HierarchyObject & HierarchySnappable & O365OrgDescendant & PolarisHierarchyObject & PolarisHierarchySnappable {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "object id"
    id: UUID!
    isRelic: Boolean!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    membersCount: Int!
    "The name of the hierarchy object."
    name: String!
    naturalId: String!
    "The newest snapshot that is indexed and unexpired, and therefore restorable."
    newestIndexedSnapshot: PolarisSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: PolarisSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: PolarisSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    orgID: String!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter polaris snapshot connection"
        filter: PolarisSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByConnection
    "GroupBy connection for this snappable's snapshots."
    snapshotGroupByNewConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "filter polaris snapshot connection"
        snapshotFilter: [PolarisSnapshotFilterNewInput!]!,
        "group polaris snapshots by field"
        snapshotGroupBy: SnapshotGroupByTimeEnum!,
        timezoneOffset: Float = 0.0
    ): PolarisSnapshotGroupByNewConnection
    "The list of snapshots taken for this workload."
    snapshotsOfSnappableConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Whether to ignore the active protected object check."
        ignoreActiveSnappableCheck: Boolean,
        "Returns the last n elements from the list."
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection
    teamName: String!
}

type O365TeamsChannel implements O365TeamsChannelObject {
    folderId: String
    folderName: String
    id: String
    name: String
    naturalId: String
}

"Paginated list of O365TeamsChannel objects."
type O365TeamsChannelConnection {
    "Total number of O365TeamsChannel objects matching the request arguments."
    count: Int!
    "List of O365TeamsChannel objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [O365TeamsChannelEdge!]!
    "List of O365TeamsChannel objects."
    nodes: [O365TeamsChannel!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the O365TeamsChannel object. This wrapper is used for pagination."
type O365TeamsChannelEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual O365TeamsChannel object wrapped by this edge."
    node: O365TeamsChannel!
}

"Paginated list of O365Teams objects."
type O365TeamsConnection {
    "Total number of O365Teams objects matching the request arguments."
    count: Int!
    "List of O365Teams objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [O365TeamsEdge!]!
    "List of O365Teams objects."
    nodes: [O365Teams!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

type O365TeamsConversations {
    channelId: String!
    channelName: String
    channelPostCount: Int!
}

"Paginated list of O365TeamsConversations objects."
type O365TeamsConversationsConnection {
    "Total number of O365TeamsConversations objects matching the request arguments."
    count: Int!
    "List of O365TeamsConversations objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [O365TeamsConversationsEdge!]!
    "List of O365TeamsConversations objects."
    nodes: [O365TeamsConversations!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the O365TeamsConversations object. This wrapper is used for pagination."
type O365TeamsConversationsEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual O365TeamsConversations object wrapped by this edge."
    node: O365TeamsConversations!
}

"Wrapper around the O365Teams object. This wrapper is used for pagination."
type O365TeamsEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual O365Teams object wrapped by this edge."
    node: O365Teams!
}

type O365User implements HierarchyObject & O365OrgDescendant & PolarisHierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "List of direct children of O365User"
    childConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): O365UserDescendantConnection!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    emailAddress: String
    "The fid of the hierarchy object."
    id: UUID!
    isRelic: Boolean!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"Paginated list of O365User objects."
type O365UserConnection {
    "Total number of O365User objects matching the request arguments."
    count: Int!
    "List of O365User objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [O365UserEdge!]!
    "List of O365User objects."
    nodes: [O365User!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Paginated list of O365UserDescendant objects."
type O365UserDescendantConnection {
    "Total number of O365UserDescendant objects matching the request arguments."
    count: Int!
    "List of O365UserDescendant objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [O365UserDescendantEdge!]!
    "List of O365UserDescendant objects."
    nodes: [O365UserDescendant!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the O365UserDescendant object. This wrapper is used for pagination."
type O365UserDescendantEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual O365UserDescendant object wrapped by this edge."
    node: O365UserDescendant!
}

"Paginated list of O365UserDescendantMetadata objects."
type O365UserDescendantMetadataConnection {
    "Total number of O365UserDescendantMetadata objects matching the request arguments."
    count: Int!
    "List of O365UserDescendantMetadata objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [O365UserDescendantMetadataEdge!]!
    "List of O365UserDescendantMetadata objects."
    nodes: [O365UserDescendantMetadata!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the O365UserDescendantMetadata object. This wrapper is used for pagination."
type O365UserDescendantMetadataEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual O365UserDescendantMetadata object wrapped by this edge."
    node: O365UserDescendantMetadata!
}

"Wrapper around the O365User object. This wrapper is used for pagination."
type O365UserEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual O365User object wrapped by this edge."
    node: O365User!
}

"Supported in v6.0+"
type ObjectIdToSnapshotIds {
    """

    Required. Supported in v6.0+
    Object ID.
    """
    id: String!
    """

    Required. Supported in v6.0+
    Snapshot IDs.
    """
    snapshots: [String!]!
}

type ObjectIdsForHierarchyType {
    objectIds: [String!]!
    snappableType: SnappableLevelHierarchyTypeEnum!
}

type ObjectSpecificConfigs {
    awsRdsConfig: AwsRdsConfig
    "SLA Domain configuration for Azure SQL Database DB object."
    azureSqlDatabaseDbConfig: AzureSqlDatabaseDbConfig
    "SLA Domain configuration for Azure SQL Managed Instance DB object."
    azureSqlManagedInstanceDbConfig: AzureSqlManagedInstanceDbConfig
    "SLA Domain configuration for Db2 database object."
    db2Config: Db2Config
    "SLA Domain configuration for SQL Server database object."
    mssqlConfig: MssqlConfig
    "SLA Domain configuration for Oracle database object."
    oracleConfig: OracleConfig
    sapHanaConfig: SapHanaConfig
    vmwareVmConfig: VmwareVmConfig
}

type ObjectStatus {
    id: String!
    latestSnapshotResult: SnapshotResult
    policyStatuses: [PolicyStatus!]!
}

type ObjectSummary {
    id: String!
    isArchived: Boolean!
    mailAddress: String!
    name: String!
    objectType: ManagedObjectType!
}

type ObjectType {
    enumValue: ObjectTypeEnum!
}

"Create Kubernetes Cluster Response."
type OnboardingSetupReply {
    clusterId: String!
    yamlUrl: String!
}

"Open support tunnel response."
type OpenSupportTunnelReply {
    "Support tunnel port."
    currentPort: String!
    "Timeout for tunnel closure."
    inactivityTimeout: String!
    "Support tunnel status flag."
    isTunnelOpen: String!
    "Node id of cluster node."
    nodeId: String!
}

"Represents option group in AWS."
type OptionGroup {
    "Amazon Resource Name (ARN) of the option group."
    arn: String!
    "Option group engine."
    engine: String!
    "Major version of the option group engine."
    majorEngineVersion: String!
    "Name of the option group."
    name: String!
    "Virtual Private Cloud (VPC) corresponding to the option group."
    vpcId: String!
}

"Supported in v6.0+"
type OracleAcoParameterList {
    """

    Required. Supported in v6.0+
    An array that contains the supported Advanced Cloning Options (ACO) parameters.
    """
    parameters: [String!]!
}

"The SLA Domain configuration for Oracle database."
type OracleConfig {
    "Frequency value for log backups of Oracle databases."
    frequency: Duration
    "Specifies the duration for which the archived redo logs will be retained."
    hostLogRetention: Duration
    "Specifies the duration for which the logs will be retained."
    logRetention: Duration
}

type OracleDatabase implements CdmHierarchyObject & CdmHierarchySnappableNew & HierarchyObject & OracleHostDescendantType & OracleHostLogicalChildType & OracleRacDescendantType & OracleRacLogicalChildType & OracleTopLevelDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    cdmId: String!
    "A link to view the snappable on the CDM cluster. For dev use only."
    cdmLink: String!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The DB unique name of the Oracle database."
    dbUniqueName: String!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    isRelic: Boolean!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The list of missed snapshots for this workload."
    missedSnapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int
    ): MissedSnapshotCommonConnection
    "The list of missed snapshots for this workload."
    missedSnapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: MissedSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): MissedSnapshotGroupByConnection
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot archived to AWS."
    newestArchivedSnapshot: CdmSnapshot
    "The newest snapshot replicated to a cluster."
    newestReplicatedSnapshot: CdmSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: CdmSnapshot
    "The number of log snapshots taken of the Oracle database."
    numLogSnapshots: Int!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The number of tablespaces contained in the Oracle database."
    numTablespaces: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: CdmSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for the snapshots of this workload."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: CdmSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): cdmSnapshotGroupByConnection
    "The list of tablespaces in the Oracle database."
    tablespaces: [String!]!
}

"Paginated list of OracleDatabase objects."
type OracleDatabaseConnection {
    "Total number of OracleDatabase objects matching the request arguments."
    count: Int!
    "List of OracleDatabase objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [OracleDatabaseEdge!]!
    "List of OracleDatabase objects."
    nodes: [OracleDatabase!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the OracleDatabase object. This wrapper is used for pagination."
type OracleDatabaseEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual OracleDatabase object wrapped by this edge."
    node: OracleDatabase!
}

"Supported in v5.0+"
type OracleDbDetail {
    """

    Supported in v5.0-v5.3
    Oracle database unique name. (DB_UNIQUE_NAME)
    """
    dbUniqueName: String
    """

    Supported in v5.3+
    An array that contains the host info for each instance.
    """
    hostsInfo: [HostInfo!]!
    """

    Supported in v5.0+
    v5.0-v5.3: Boolean value that indicates whether a Oracle database object is a Live Mount. Value is true when the object is a Live Mount.
    v6.0+: Value that indicates whether an Oracle database object is a Live Mount or not. A true value indicates that the object is a Live Mount.
    """
    isLiveMount: Boolean
    """

    Supported in v5.3+
    General information about last validation job.
    """
    lastValidationResult: OracleLastValidationResult
    "The time stamp of the most recent recovery point for this database."
    latestRecoveryPointV50: String
    "The time stamp of the most recent recovery point for this database."
    latestRecoveryPointV51: String
    "The time stamp of the most recent recovery point for this database."
    latestRecoveryPointV52: String
    "The time stamp of the most recent recovery point for this database."
    latestRecoveryPointV53: String
    "The time stamp of the most recent recovery point for this database."
    latestRecoveryPointV60: DateTime
    "The time stamp of the most recent recovery point for this database."
    latestRecoveryPointV70: DateTime
    "The time stamp of the most recent recovery point for this database."
    latestRecoveryPointV80: DateTime
    "The time stamp of the earliest recovery point for this database."
    oldestRecoveryPointV50: String
    "The time stamp of the earliest recovery point for this database."
    oldestRecoveryPointV51: String
    "The time stamp of the earliest recovery point for this database."
    oldestRecoveryPointV52: String
    "The time stamp of the earliest recovery point for this database."
    oldestRecoveryPointV53: String
    "The time stamp of the earliest recovery point for this database."
    oldestRecoveryPointV60: DateTime
    "The time stamp of the earliest recovery point for this database."
    oldestRecoveryPointV70: DateTime
    "The time stamp of the earliest recovery point for this database."
    oldestRecoveryPointV80: DateTime
    oracleDbSummary: OracleDbSummary
    """

    Supported in v5.0+
    Oracle Home of the Oracle database.
    """
    oracleHome: String
    oracleNonSlaProperties: OracleNonSlaProperties
    """

    Supported in v8.0
    Details about the PDBs that are part of the CDB.
    """
    pdbDetails: OraclePdbDetails
    """

    Supported in v5.3+
    Describes any pending SLA Domain assignment on this object.
    """
    pendingSlaDomain: ManagedObjectPendingSlaInfo
    """

    Supported in v6.0+
    Ordered list of database unique names to use for backup in a Data Guard group.
    """
    preferredDgMemberUniqueNames: [String!]!
    """

    Supported in v6.0+
    Indicates whether to backup only from the PRIMARY Data Guard member or from any available member.
    """
    shouldBackupFromPrimaryDgGroupMemberOnly: Boolean
    "Required. Supported in v5.0+"
    snapshotCount: Int!
    """

    Required. Supported in v5.0+
    An array that contains tablespace names of the specified Oracle database.
    """
    tablespaces: [String!]!
}

"Supported in v5.0+"
type OracleDbSnapshotSummary {
    baseSnapshotSummary: BaseSnapshotSummary
    "Required. Supported in v5.0+"
    databaseName: String!
    """

    Supported in v5.3+
    A Boolean that specifies whether the snapshot is valid.
    """
    isValid: Boolean
    """

    Required. Supported in v5.0+
    Array containing descriptions of the tablespaces that were captured in the specified snapshot.
    """
    tablespaces: [String!]!
}

"Supported in v5.0+"
type OracleDbSummary {
    """

    Supported in v5.2+
    v5.2-v5.3: An array that contains the archive log destinations of the specified Oracle database.
    v6.0+: An array that contains the archive log destinations for the specified Oracle database.
    """
    archiveLogDestinations: [String!]!
    """

    Supported in v5.1+
    Information about the current backup task.
    """
    currentBackupTaskInfo: BackupTaskDiagnosticInfo
    """

    Supported in v6.0+
    Rubrik ID of the Data Guard group to which this database belongs.
    """
    dataGuardGroupId: String
    """

    Supported in v6.0+
    List of Data Guard group members.
    """
    dataGuardGroupMembers: [DataGuardGroupMember!]!
    """

    Supported in v6.0+
    Name of the Data Guard group to which this database belongs.
    """
    dataGuardGroupName: String
    dataGuardType: DataGuardTypeEnum
    """

    Supported in v6.0+
    Current role of the database.
    """
    databaseRole: String
    """

    Supported in v6.0+
    Unique name for the Oracle database (DB_UNIQUE_NAME).
    """
    dbUniqueName: String
    """

    Supported in v7.0+
    Boolean value specifying whether the database obtains the log backup configurations from the SLA Domain.
    """
    hasLogConfigFromSla: Boolean
    """

    Supported in v5.2+
    Specifies an interval in hours. The next log snapshot job deletes archived Oracle redo log files whose 'nextTime' field specifies a time more than the specified number of hours ago. To immediately delete archived redo log files regardless of age, specify an interval of -1. To preserve all archived redo log files, specify an interval of -2.
    """
    hostLogRetentionHours: Int
    """

    Required. Supported in v5.0+
    ID assigned to the Oracle database.
    """
    id: String!
    """

    Supported in v5.1+
    True/false value indicating if backup task information is included in the response.
    """
    includeBackupTaskInfo: Boolean
    """

    Required. Supported in v5.0+
    An array that contains information about the objects in the infrastructure path of a specified Oracle database.
    """
    infraPath: [ManagedHierarchyObjectAncestor!]!
    """

    Supported in v5.0+
    Details of the instances of the Oracle database.
    """
    instances: [OracleInstanceProperties!]!
    """

    Supported in v5.0+
    v5.0-v5.3: Boolean value that indicates whether the ARCHIVELOGMODE is enabled on the Oracle database.
    v6.0+: Boolean value that indicates whether the ARCHIVELOG mode is enabled on the Oracle database or not.
    """
    isArchiveLogModeEnabled: Boolean
    """

    Supported in v5.1+
    A Boolean value that specifies whether the Oracle database is local to the cluster. When this value is 'true', the Oracle database is local to the cluster.
    """
    isDbLocalToTheCluster: Boolean
    """

    Supported in v5.2+
    Indicates whether the current DATABASE_ROLE is PRIMARY which specifies the database is accepting read/write transactions as the primary database in a Data Guard configuration.
    """
    isPrimary: Boolean
    """

    Required. Supported in v5.0+
    Boolean value that indicates whether a Oracle database object is in an archived state and has retained snapshots. Value is true when the object is archived with retained snapshots.
    """
    isRelic: Boolean!
    """

    Supported in v5.1+
    The timestamp of the previous snapshot.
    """
    lastSnapshotTime: DateTime
    """

    Supported in v5.1+
    Specifies an interval in minutes. This interval is the period between successive log backups.
    """
    logBackupFrequencyInMinutes: Int
    """

    Required. Supported in v5.0+
    Service name of the Oracle database.
    """
    name: String!
    """

    Supported in v5.0+
    Count of the number of instances of the Oracle database.
    """
    numInstances: Int
    """

    Supported in v5.1+
    An integer that specifies the number of missed snapshots.
    """
    numMissedSnapshot: Int
    """

    Required. Supported in v5.0+
    Count of the number of table spaces in Oracle database.
    """
    numTablespaces: Int!
    "Required. Supported in v5.0+"
    primaryClusterId: String!
    """

    Supported in v5.0+
    Rubrik ID of the RAC on which this database is hosted. This field will be empty if the database is not hosted on a RAC environment.
    """
    racId: String
    """

    Supported in v5.0+
    v5.0-v5.3: RAC name of cluster database.
    v6.0+: RAC name of the cluster database.
    """
    racName: String
    """

    Supported in v5.0+
    System identifier (SID) of the Oracle database.
    """
    sid: String
    snappable: CDMSnappable
    """

    Supported in v5.0+
    Rubrik ID of the standalone Oracle host on which this database is hosted. This field will be empty if the database is not hosted on a standalone system.
    """
    standaloneHostId: String
    """

    Supported in v5.0+
    Hostname of the standalone Oracle database host.
    """
    standaloneHostName: String
}

"Supported in v5.3+"
type OracleFileDownloadLink {
    """

    Required. Supported in v5.3+
    Link for file download.
    """
    downloadLink: String!
}

type OracleHost implements CdmHierarchyObject & HierarchyObject & OracleTopLevelDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): OracleHostDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "List of logical children"
    logicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): OracleHostLogicalChildTypeConnection!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"Paginated list of OracleHostDescendantType objects."
type OracleHostDescendantTypeConnection {
    "Total number of OracleHostDescendantType objects matching the request arguments."
    count: Int!
    "List of OracleHostDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [OracleHostDescendantTypeEdge!]!
    "List of OracleHostDescendantType objects."
    nodes: [OracleHostDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the OracleHostDescendantType object. This wrapper is used for pagination."
type OracleHostDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual OracleHostDescendantType object wrapped by this edge."
    node: OracleHostDescendantType!
}

"Supported in v5.0+"
type OracleHostDetail {
    oracleHostSummary: OracleHostSummary
    oracleNonSlaProperties: OracleNonSlaProperties
}

"Paginated list of OracleHostLogicalChildType objects."
type OracleHostLogicalChildTypeConnection {
    "Total number of OracleHostLogicalChildType objects matching the request arguments."
    count: Int!
    "List of OracleHostLogicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [OracleHostLogicalChildTypeEdge!]!
    "List of OracleHostLogicalChildType objects."
    nodes: [OracleHostLogicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the OracleHostLogicalChildType object. This wrapper is used for pagination."
type OracleHostLogicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual OracleHostLogicalChildType object wrapped by this edge."
    node: OracleHostLogicalChildType!
}

"Supported in v5.0+"
type OracleHostSummary {
    """

    Supported in v7.0+
    Boolean value specifying whether the database obtains the log backup configurations from the SLA Domain.
    """
    hasLogConfigFromSla: Boolean
    """

    Required. Supported in v5.0+
    ID assigned to the standalone Oracle host.
    """
    id: String!
    """

    Required. Supported in v5.0+
    An array that contains information about the objects in the infrastructure path of a specified Oracle database.
    """
    infraPath: [ManagedHierarchyObjectAncestor!]!
    """

    Required. Supported in v5.0+
    Hostname of the standalone Oracle host.
    """
    name: String!
    """

    Required. Supported in v5.0+
    Count of the number of databases on the Oracle RAC.
    """
    numDbs: Int!
    "Required. Supported in v5.0+"
    primaryClusterId: String!
    slaAssignable: SlaAssignable
    """

    Required. Supported in v5.0+
    Connectivity status of the Oracle RAC.
    """
    status: String!
}

"Supported in v5.0+"
type OracleInstanceProperties {
    """

    Required. Supported in v5.0+
    Name of the Oracle host.
    """
    hostName: String!
    """

    Required. Supported in v5.0+
    System identifier (SID) of the Oracle database instance.
    """
    instanceSid: String!
}

"Supported in v5.3+"
type OracleLastValidationResult {
    """

    Required. Supported in v5.3+
    The eventseries ID for the last validation job.
    """
    eventSeriesId: String!
    """

    Required. Supported in v5.3+
    A Boolean that specifies whether the last validation successfully completed.
    """
    isSuccess: Boolean!
    """

    Required. Supported in v5.3+
    The timestamp of the recovery point to validate.
    """
    validationTime: DateTime
}

"Supported in v5.0+"
type OracleMissedRecoverableRange {
    "Required. Supported in v5.0+"
    beginTime: DateTime
    "Required. Supported in v5.0+"
    description: String!
    "Required. Supported in v5.0+"
    endTime: DateTime
    "Required. Supported in v5.0+"
    errorType: String!
}

"Supported in v5.0+"
type OracleMissedRecoverableRangeListResponse {
    """

    Supported in v5.0+
    List of matching objects.
    """
    data: [OracleMissedRecoverableRange!]!
    """

    Supported in v5.0+
    If there is more.
    """
    hasMore: Boolean
    """

    Supported in v5.0+
    Total list responses.
    """
    total: Long
}

"Supported in v5.0+"
type OracleNonSlaProperties {
    """

    Supported in v5.2+
    Specifies an interval in hours. The next log snapshot job deletes archived Oracle redo log files whose 'nextTime' field specifies a time more than the specified number of hours ago. To immediately delete archived redo log files regardless of age, specify an interval of -1. To preserve all archived redo log files, specify an interval of -2.
    """
    hostLogRetentionHours: Int
    """

    Required. Supported in v5.0+
    Path where the NFS share is mounted on the host.
    """
    hostMount: String!
    """

    Required. Supported in v5.0+
    Specifies an interval in minutes. This interval is the period between successive log backups.
    """
    logBackupFrequencyInMinutes: Int!
    """

    Required. Supported in v5.0+
    Specifies an interval in hours. Log backups are retained for the duration of the interval.
    """
    logRetentionHours: Int!
    """

    Required. Supported in v5.0+
    Number of channels used to backup the Oracle database.
    """
    numChannels: Int!
}

"Supported in v8.0"
type OraclePdbApplicationContainer {
    """

    Required. Supported in v8.0
    Names of the application PDBs that belong to this application container.
    """
    applicationPdbs: [String!]!
    """

    Required. Supported in v8.0
    Name of the application root PDB.
    """
    applicationRoot: String!
}

"Supported in v8.0"
type OraclePdbDetails {
    """

    Required. Supported in v8.0
    List of application containers attached to the CDB.
    """
    applicationContainers: [OraclePdbApplicationContainer!]!
    """

    Required. Supported in v8.0
    Names of the PDBs attached directly to the CDB.
    """
    regularPdbs: [String!]!
}

type OracleRac implements CdmHierarchyObject & HierarchyObject & OracleTopLevelDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): OracleRacDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "List of logical children"
    logicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): OracleRacLogicalChildTypeConnection!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The list of nodes which make up the Oracle RAC."
    nodes: [CdmOracleRacNode!]!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"Paginated list of OracleRacDescendantType objects."
type OracleRacDescendantTypeConnection {
    "Total number of OracleRacDescendantType objects matching the request arguments."
    count: Int!
    "List of OracleRacDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [OracleRacDescendantTypeEdge!]!
    "List of OracleRacDescendantType objects."
    nodes: [OracleRacDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the OracleRacDescendantType object. This wrapper is used for pagination."
type OracleRacDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual OracleRacDescendantType object wrapped by this edge."
    node: OracleRacDescendantType!
}

"Paginated list of OracleRacLogicalChildType objects."
type OracleRacLogicalChildTypeConnection {
    "Total number of OracleRacLogicalChildType objects matching the request arguments."
    count: Int!
    "List of OracleRacLogicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [OracleRacLogicalChildTypeEdge!]!
    "List of OracleRacLogicalChildType objects."
    nodes: [OracleRacLogicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the OracleRacLogicalChildType object. This wrapper is used for pagination."
type OracleRacLogicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual OracleRacLogicalChildType object wrapped by this edge."
    node: OracleRacLogicalChildType!
}

"Supported in v5.0+"
type OracleRecoverableRange {
    "Required. Supported in v5.0+"
    beginTime: DateTime
    """

    Required. Supported in v5.0+
    Database snapshots that fall within the recoverable range.
    """
    dbSnapshotSummaries: [OracleDbSnapshotSummary!]!
    "Required. Supported in v5.0+"
    endTime: DateTime
    "Required. Supported in v5.0+"
    status: String!
}

"Supported in v5.0+"
type OracleRecoverableRangeListResponse {
    """

    Supported in v5.0+
    List of matching objects.
    """
    data: [OracleRecoverableRange!]!
    """

    Supported in v5.0+
    If there is more.
    """
    hasMore: Boolean
    """

    Supported in v5.0+
    Total list responses.
    """
    total: Long
}

"Paginated list of OracleTopLevelDescendantType objects."
type OracleTopLevelDescendantTypeConnection {
    "Total number of OracleTopLevelDescendantType objects matching the request arguments."
    count: Int!
    "List of OracleTopLevelDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [OracleTopLevelDescendantTypeEdge!]!
    "List of OracleTopLevelDescendantType objects."
    nodes: [OracleTopLevelDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the OracleTopLevelDescendantType object. This wrapper is used for pagination."
type OracleTopLevelDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual OracleTopLevelDescendantType object wrapped by this edge."
    node: OracleTopLevelDescendantType!
}

"Details of an org."
type Org {
    "Org description."
    description: String!
    "Org ID."
    id: String!
    "Org name."
    name: String!
    "Role ID of the org admin."
    orgAdminId: String!
    "Org URL."
    url: String!
}

"Paginated list of Org objects."
type OrgConnection {
    "Total number of Org objects matching the request arguments."
    count: Int!
    "List of Org objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [OrgEdge!]!
    "List of Org objects."
    nodes: [Org!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the Org object. This wrapper is used for pagination."
type OrgEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual Org object wrapped by this edge."
    node: Org!
}

"General information about a page of results."
type PageInfo {
    "String used to identify the last edge in the response."
    endCursor: String!
    "Specifies whether edges exist following the current page."
    hasNextPage: Boolean!
    "Specifies whether edges exist prior to the current page."
    hasPreviousPage: Boolean!
    "String used to identify the first edge in the response."
    startCursor: String!
}

"Supported in v7.0+"
type PatchDb2InstanceResponse {
    """

    Required. Supported in v7.0+
    Status of the refresh job triggered on the edited instance.
    """
    asyncRequestStatus: AsyncRequestStatus
    """

    Required. Supported in v7.0+
    Summary of the edited Db2 instance.
    """
    db2InstanceSummary: Db2InstanceSummary
}

"Supported in v6.0+"
type PathInfo {
    """

    Supported in v6.0+
    JSON encoded file access control list (ACL) information.
    """
    aclDetails: String
    """

    Supported in v6.0+
    File creation time.
    """
    creationTime: DateTime
    """

    Supported in v6.0+
    File modification time.
    """
    modificationTime: DateTime
    """

    Required. Supported in v6.0+
    File path that matched the malware Indicator of Compromise.
    """
    path: String!
    """

    Supported in v6.0+
    Hash algorithm and hash values.
    """
    requestedHashDetails: [HashDetail!]!
    """

    Required. Supported in v6.0+
    Details about the matching YARA rule(s).
    """
    yaraMatchDetails: [YARAMatchDetail!]!
}

type PathNode {
    fid: UUID!
    name: String!
    objectType: HierarchyObjectTypeEnum!
}

type PathSecInfo {
    owner: String!
    path: String!
    permissions: [SDDLPermission!]!
}

"Archival location pause result."
type PauseTargetReply {
    "Polaris managed location ID."
    locationId: String!
    "Ownership status of the archival location."
    status: ArchivalLocationStatus!
}

"SLA Domain paused clusters information."
type PausedClustersInfo {
    "Rubrik clusters where the SLA Domain is paused."
    pausedClusters: [Cluster!]
    "Number of Rubrik clusters where the SLA Domain is paused."
    pausedClustersCount: Int!
}

type PendingActionType {
    pendingActionGroupType: PendingActionGroupTypeEnum!
    pendingActionSubGroupType: PendingActionSubGroupTypeEnum!
    pendingActionSyncType: PendingActionSyncTypeEnum!
}

"Detailed information about objects passing through the Radar pipeline."
type PendingEvaluationResults {
    "Unique UUID of the cluster."
    clusterUuid: String!
    "Date that this object was created in Radar."
    createdAt: DateTime
    "Information about this object within the Radar pipeline."
    info: String!
    "Determines whether a result is still pending in the Radar pipeline."
    isCompleted: Boolean!
    "Internally used ID to manage permissions of this object."
    managedId: String!
    "Internally used ID to specify snappable."
    snappableId: String!
    "Snappable name."
    snappableName: String!
    "Type of snappable."
    snappableType: String!
    "Date that this snapshot was performed."
    snapshotDate: DateTime
    "Internally used ID to specify snapshot."
    snapshotId: String!
    "Date that this object was last updated in Radar."
    updatedAt: DateTime
}

"Count and detailed information about items pending in Radar pipeline."
type PendingEvaluationResultsReply {
    count: Long!
    pendingEvaluationResults: [PendingEvaluationResults!]!
}

"Supported in v5.2+"
type PendingSlaOperations {
    """

    Required. Supported in v5.2+
    List of invalid managed IDs from input. They either do not exist or cannot have an SLA assigned to them.
    """
    invalidIds: [String!]!
    """

    Required. Supported in v5.2+
    List of objects with completed SLA operations.
    """
    objectsWithNoOp: [ManagedObjectSlaInfo!]!
    """

    Required. Supported in v5.2+
    List of objects with pending SLA operations.
    """
    objectsWithPendingOp: [ManagedObjectPendingSlaInfo!]!
}

type PendingSnapshotDeletion {
    snapshotFid: UUID!
    status: PendingActionStatusEnum!
}

type PendingSnapshotsOfObjectDeletion {
    objectFid: UUID!
    status: PendingActionStatusEnum!
}

"""

Supported in v8.0
CloudStorageTier information for a snapshot in a particular archival location.
"""
type PerLocationCloudStorageTier {
    cloudStorageTier: SnapshotCloudStorageTierEnum!
    """

    Required. Supported in v8.0
    ID of the archival location.
    """
    locationId: String!
}

type Permission {
    objectsForHierarchyTypes: [ObjectIdsForHierarchyType!]!
    operation: OperationEnum!
}

"Persistent storage configured for storing backups."
type PersistentStorage {
    "ID of the configured storage setting."
    id: String!
    "Name of the configured storage setting."
    name: String!
}

type PhysicalHost implements CdmHierarchyObject & Db2InstanceDescendantType & Db2InstancePhysicalChildType & HierarchyObject & MssqlTopLevelDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The CBT status of this Physical Host."
    cbtStatus: String
    cdmId: String!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    connectionStatus: HostConnectionStatus
    "The default CBT status of this Physical Host."
    defaultCbt: Boolean
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): PhysicalHostDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    hostVolumes: [CdmHostVolume!]!
    "The fid of the hierarchy object."
    id: UUID!
    ipAddresses: [String!]!
    isArchived: Boolean!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    osName: String
    "The OS Type of this Physical Host"
    osType: GuestOsTypeEnum
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "List of physical children"
    physicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): PhysicalHostPhysicalChildTypeConnection!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    vfdState: String!
}

"Paginated list of PhysicalHost objects."
type PhysicalHostConnection {
    "Total number of PhysicalHost objects matching the request arguments."
    count: Int!
    "List of PhysicalHost objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [PhysicalHostEdge!]!
    "List of PhysicalHost objects."
    nodes: [PhysicalHost!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Paginated list of PhysicalHostDescendantType objects."
type PhysicalHostDescendantTypeConnection {
    "Total number of PhysicalHostDescendantType objects matching the request arguments."
    count: Int!
    "List of PhysicalHostDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [PhysicalHostDescendantTypeEdge!]!
    "List of PhysicalHostDescendantType objects."
    nodes: [PhysicalHostDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the PhysicalHostDescendantType object. This wrapper is used for pagination."
type PhysicalHostDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual PhysicalHostDescendantType object wrapped by this edge."
    node: PhysicalHostDescendantType!
}

"Wrapper around the PhysicalHost object. This wrapper is used for pagination."
type PhysicalHostEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual PhysicalHost object wrapped by this edge."
    node: PhysicalHost!
}

"Paginated list of PhysicalHostPhysicalChildType objects."
type PhysicalHostPhysicalChildTypeConnection {
    "Total number of PhysicalHostPhysicalChildType objects matching the request arguments."
    count: Int!
    "List of PhysicalHostPhysicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [PhysicalHostPhysicalChildTypeEdge!]!
    "List of PhysicalHostPhysicalChildType objects."
    nodes: [PhysicalHostPhysicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the PhysicalHostPhysicalChildType object. This wrapper is used for pagination."
type PhysicalHostPhysicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual PhysicalHostPhysicalChildType object wrapped by this edge."
    node: PhysicalHostPhysicalChildType!
}

"Paginated list of PolarisHierarchyObject objects."
type PolarisHierarchyObjectConnection {
    "Total number of PolarisHierarchyObject objects matching the request arguments."
    count: Int!
    "List of PolarisHierarchyObject objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [PolarisHierarchyObjectEdge!]!
    "List of PolarisHierarchyObject objects."
    nodes: [PolarisHierarchyObject!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the PolarisHierarchyObject object. This wrapper is used for pagination."
type PolarisHierarchyObjectEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual PolarisHierarchyObject object wrapped by this edge."
    node: PolarisHierarchyObject!
}

type PolarisHierarchySnappableObject {
    id: String!
    name: String!
}

"Indicator of Compromise."
type PolarisIndicatorOfCompromise {
    "IOC kind that represents this input."
    iocKind: IndicatorOfCompromiseKind!
    """

    Do not use this field.
    TODO(SPARK-106446) - remove before going GA.
    """
    iocType: IndicatorOfCompromiseKind!
    "IOC value as a string."
    iocValue: String!
}

type PolarisInventorySubHierarchyRoot {
    "List of children"
    childConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): PolarisHierarchyObjectConnection!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): PolarisHierarchyObjectConnection!
    rootEnum: InventorySubHierarchyRootEnum!
    "List of top-level descendants (with respect to RBAC)."
    topLevelDescendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): PolarisHierarchyObjectConnection!
}

"Malware scan results for an object."
type PolarisMalwareScanResult {
    "The scanned object."
    object: CdmHierarchySnappableNew
    "Results for each scanned snapshot."
    snapshotResults: [MalwareScanInSnapshotResult!]!
}

"Represents the configuration and results for a malware detection scan."
type PolarisMalwareScanResults {
    "The configuration of the malware scan."
    config: ThreatHuntConfig!
    "Results of the malware detection."
    results: [PolarisMalwareScanResult!]!
    "ID of the malware detection."
    scanId: String!
    "The stats based on results of the malware scan."
    stats: PolarisMalwareScanStats
    "Status of the malware hunt."
    status: MalwareScanStatus!
}

"Represents the stats related to the malware scan."
type PolarisMalwareScanStats {
    "Total objects in which malware was found."
    totalAffectedObjects: Long!
    "Total snapshots in which malware was found."
    totalAffectedSnapshots: Long!
    "Total snapshots scanned."
    totalSnapshotsScanned: Long!
    "Total scans where the malware scan succeeded."
    totalSucceededScans: Long!
    "Total unique paths for which malware was found."
    totalUniqueMatchedPaths: Long!
}

"Specific info for AWS Target created on Polaris"
type PolarisManagedAwsTarget implements Target {
    awsRetrievalTier: AwsRetrievalTier!
    bucket: String!
    cloudAccount: CloudAccount!
    cloudNativeLocTemplateType: CloudNativeLocTemplateType!
    "The cluster to which this target belongs."
    cluster: Cluster!
    "Name of the Rubrik cluster that archives to this archival location."
    clusterName: String
    computeSettings: AwsComputeSettings
    "Connection status of the AWS target."
    connectionStatus: ConnectionStatusType!
    "Number of bytes stored on target."
    consumedBytes: Long
    encryptionType: TargetEncryptionTypeEnum!
    "Number of failed tasks acting on this target."
    failedTasks: Int
    "The id of this Target."
    id: String!
    "Immutability settings of AWS location."
    immutabilitySettings: AwsImmutabilitySettingsType
    "The pause/resume status of this Target."
    isActive: Boolean!
    "Whether this Target is archived."
    isArchived: Boolean!
    isConsolidationEnabled: Boolean!
    kmsMasterKeyId: String!
    "The scope of location, whether Global or Local."
    locationScope: LocationScope!
    "The name of this Target."
    name: String!
    proxySettings: ProxySettings
    "The retrieval method of the reader target."
    readerRetrievalMethod: ReaderRetrievalMethod
    "Region of the AWS location."
    region: AwsRegion!
    "Number of running tasks acting on this target."
    runningTasks: Int
    "Status of the target."
    status: ArchivalLocationStatus!
    storageClass: AwsStorageClassTypeEnum!
    syncFailureReason: String!
    "Sync status of AWS location."
    syncStatus: TargetSyncStatusEnum!
    "Archival location to which the mapping target belongs."
    targetMapping: TargetMappingBasic
    "The type of this Target."
    targetType: TargetTypeEnum!
}

"Specific info for Azure Target created on Polaris"
type PolarisManagedAzureTarget implements Target {
    accessKey: String!
    cloudAccount: CloudAccount!
    cloudNativeCompanion: AzureCloudNativeTargetCompanion
    "The cluster to which this target belongs."
    cluster: Cluster!
    "Name of the Rubrik cluster that archives to this archival location."
    clusterName: String
    computeSettings: AzureComputeSettings
    "Connection status of the Azure target."
    connectionStatus: ConnectionStatusType!
    "Number of bytes stored on target."
    consumedBytes: Long
    containerName: String!
    "Number of failed tasks acting on this target."
    failedTasks: Int
    "The id of this Target."
    id: String!
    "Immutability settings of the Azure target."
    immutabilitySettings: AzureImmutabilitySettingsType
    "Instance type of the Azure location."
    instanceType: InstanceTypeEnum!
    "The pause/resume status of this Target."
    isActive: Boolean!
    "Whether this Target is archived."
    isArchived: Boolean!
    "Specifies whether Azure archival tiering is supported or not."
    isAzureTieringSupported: Boolean
    isConsolidationEnabled: Boolean!
    "The scope of location, whether Global or Local."
    locationScope: LocationScope!
    "The name of this Target."
    name: String!
    proxySettings: ProxySettings
    "The retrieval method of the reader target."
    readerRetrievalMethod: ReaderRetrievalMethod
    "Number of running tasks acting on this target."
    runningTasks: Int
    "Status of the target."
    status: ArchivalLocationStatus!
    storageAccountName: String!
    syncFailureReason: String!
    "Sync status of Azure location."
    syncStatus: TargetSyncStatusEnum!
    "Archival location to which the mapping target belongs."
    targetMapping: TargetMappingBasic
    "The type of this Target."
    targetType: TargetTypeEnum!
}

"Specific info for Gcp Target created on Polaris"
type PolarisManagedGcpTarget implements Target {
    archivalProxySettings: ProxySettings
    bucket: String!
    "The cluster to which this target belongs."
    cluster: Cluster!
    "Name of the Rubrik cluster that archives to this archival location."
    clusterName: String
    "Connection status of the GCP target."
    connectionStatus: ConnectionStatusType!
    "Number of bytes stored on target."
    consumedBytes: Long
    encryptionPassword: String!
    "Number of failed tasks acting on this target."
    failedTasks: Int
    "The id of this Target."
    id: String!
    "The pause/resume status of this Target."
    isActive: Boolean!
    "Whether this Target is archived."
    isArchived: Boolean!
    "The scope of location, whether Global or Local."
    locationScope: LocationScope!
    "The name of this Target."
    name: String!
    "The retrieval method of the reader target."
    readerRetrievalMethod: ReaderRetrievalMethod
    region: GcpRegionEnum!
    "Number of running tasks acting on this target."
    runningTasks: Int
    serviceAccountJsonKey: String!
    "Status of the target."
    status: ArchivalLocationStatus!
    storageClass: GcpStorageClassTypeEnum!
    syncFailureReason: String!
    "Sync status of GCP location."
    syncStatus: TargetSyncStatusEnum!
    "Archival location to which the mapping target belongs."
    targetMapping: TargetMappingBasic
    "The type of this Target."
    targetType: TargetTypeEnum!
}

"Specific info for Nfs Target created on Polaris"
type PolarisManagedNfsTarget implements Target {
    "The cluster to which this target belongs."
    cluster: Cluster!
    "Name of the Rubrik cluster that archives to this archival location."
    clusterName: String
    "Connection status of the NFS target."
    connectionStatus: ConnectionStatusType!
    "Number of bytes stored on target."
    consumedBytes: Long
    destinationFolder: String!
    exportDir: String!
    "Number of failed tasks acting on this target."
    failedTasks: Int
    fileLockPeriodInSeconds: Int!
    "Host of the Nfs location."
    host: String!
    "The id of this Target."
    id: String!
    "The pause/resume status of this Target."
    isActive: Boolean!
    "Whether this Target is archived."
    isArchived: Boolean!
    isConsolidationEnabled: Boolean!
    "The scope of location, whether Global or Local."
    locationScope: LocationScope!
    "The name of this Target."
    name: String!
    nfsAuthType: AuthTypeEnum!
    nfsVersion: Int!
    otherNfsOptions: String!
    "The retrieval method of the reader target."
    readerRetrievalMethod: ReaderRetrievalMethod
    "Number of running tasks acting on this target."
    runningTasks: Int
    "Status of the target."
    status: ArchivalLocationStatus!
    syncFailureReason: String!
    "Sync status of NFS location."
    syncStatus: TargetSyncStatusEnum!
    "Archival location to which the mapping target belongs."
    targetMapping: TargetMappingBasic
    "The type of this Target."
    targetType: TargetTypeEnum!
}

"Specific info for RCS Target created on Polaris"
type PolarisManagedRcsTarget implements Target {
    "The cluster to which this target belongs."
    cluster: Cluster!
    "Name of the Rubrik cluster that archives to this archival location."
    clusterName: String
    "Number of bytes stored on target."
    consumedBytes: Long
    "Number of failed tasks acting on this target."
    failedTasks: Int
    "The id of this Target."
    id: String!
    immutabilityPeriodDays: Long!
    "The pause/resume status of this Target."
    isActive: Boolean!
    "Whether this Target is archived."
    isArchived: Boolean!
    "The scope of location, whether Global or Local."
    locationScope: LocationScope!
    "The name of this Target."
    name: String!
    "The retrieval method of the reader target."
    readerRetrievalMethod: ReaderRetrievalMethod
    region: RcsRegionEnumType!
    rsaKey: String!
    "Number of running tasks acting on this target."
    runningTasks: Int
    spaceUsageAlertThreshold: Int!
    "Status of the target."
    status: ArchivalLocationStatus!
    storageConsumptionValue: Float!
    syncFailureReason: String!
    "Sync status of RCV location."
    syncStatus: TargetSyncStatusEnum!
    "Archival location to which the mapping target belongs."
    targetMapping: TargetMappingBasic
    "The type of this Target."
    targetType: TargetTypeEnum!
    tier: RcsTierEnumType!
}

"Specific info for S3Compatible Target created on Polaris"
type PolarisManagedS3CompatibleTarget implements Target {
    accessKey: String!
    bucketPrefix: String!
    "The cluster to which this target belongs."
    cluster: Cluster!
    "Name of the Rubrik cluster that archives to this archival location."
    clusterName: String
    "Connection status of the S3Compatible target."
    connectionStatus: ConnectionStatusType!
    "Number of bytes stored on target."
    consumedBytes: Long
    encryptionKeyInDer: String!
    "Host of the S3Compatible location."
    endpoint: String!
    "Number of failed tasks acting on this target."
    failedTasks: Int
    "The id of this Target."
    id: String!
    "The pause/resume status of this Target."
    isActive: Boolean!
    "Whether this Target is archived."
    isArchived: Boolean!
    isConsolidationEnabled: Boolean!
    "The scope of location, whether Global or Local."
    locationScope: LocationScope!
    "The name of this Target."
    name: String!
    numberOfBuckets: Int!
    "The retrieval method of the reader target."
    readerRetrievalMethod: ReaderRetrievalMethod
    "Number of running tasks acting on this target."
    runningTasks: Int
    secretKey: String!
    "Status of the target."
    status: ArchivalLocationStatus!
    syncFailureReason: String!
    "Sync status of S3Compatible location."
    syncStatus: TargetSyncStatusEnum!
    "Archival location to which the mapping target belongs."
    targetMapping: TargetMappingBasic
    "The type of this Target."
    targetType: TargetTypeEnum!
    useSystemProxy: Boolean!
}

"Maps an object to targeted snapshots for the scan."
type PolarisObjectIdToSnapshotIds {
    "Object ID."
    objectId: String!
    "Snapshot IDs."
    snapshotIds: [String!]!
    "Timestamps for the snapshots selected for scan."
    snapshotTimestamps: [DateTime!]!
}

"The UI definition of polaris report column."
type PolarisReportColumn {
    "The width of the column showing on the UI."
    columnWidth: Int!
    "If the column should appear in the table in the default view of the report."
    default: Boolean!
    "The column name showing on the UI."
    displayName: String!
    "The other metadata of the column."
    metadata: [Metadata!]!
    "The identifier of the column."
    name: String!
    "Whether this column is sortable."
    sortable: Boolean!
}

"Other configs of the report."
type PolarisReportConfig {
    "The default name of the report."
    defaultName: String!
}

"The schema of a polaris report."
type PolarisReportSchema {
    "All available charts of the report."
    charts: [ChartViewWithName!]!
    "Other misc configs of the report."
    config: PolarisReportConfig!
    "All available tables of the report."
    tables: [TableViewWithName!]!
}

"The schema of a polaris report table."
type PolarisReportTableIntrospection {
    "All available columns of the table."
    columns: [PolarisReportColumn!]!
    "The default sort by column's name."
    defaultSortByColumn: String!
    "The default sort by order."
    defaultSortByOrder: PolarisReportSortOrderType!
    "The page size of the table."
    pageSize: Int!
}

"Global SLA status for cluster."
type PolarisSlaStatus {
    "Cluster where the global SLA is synced."
    cluster: Cluster
    "Pause status of given cluster."
    pauseStatus: PauseStatus!
    "Sync status of given cluster."
    syncStatus: SlaSyncStatus!
}

"Paginated list of PolarisSlaStatus objects."
type PolarisSlaStatusConnection {
    "Total number of PolarisSlaStatus objects matching the request arguments."
    count: Int!
    "List of PolarisSlaStatus objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [PolarisSlaStatusEdge!]!
    "List of PolarisSlaStatus objects."
    nodes: [PolarisSlaStatus!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the PolarisSlaStatus object. This wrapper is used for pagination."
type PolarisSlaStatusEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual PolarisSlaStatus object wrapped by this edge."
    node: PolarisSlaStatus!
}

"SLA Sync status for a given cluster"
type PolarisSlaSyncStatus {
    clusterUuid: String!
    slaSyncStatus: SlaSyncStatus!
}

type PolarisSnapshot implements GenericSnapshot {
    consistencyLevel: SnapshotConsistencyLevelEnum!
    date: DateTime!
    expirationDate: DateTime
    expiryHint: Boolean!
    "Whether or not the snapshot has an unexpired archived copy"
    hasUnexpiredArchivedCopy: Boolean!
    "Whether or not the snapshot has an unexpired replica"
    hasUnexpiredReplica: Boolean!
    id: UUID!
    indexTime: DateTime
    indexingAttempts: Long!
    isArchivalCopy: Boolean
    isArchived: Boolean!
    isCorrupted: Boolean!
    isDeletedFromSource: Boolean!
    isDownloadedSnapshot: Boolean
    "Whether or not the snapshot is expired"
    isExpired: Boolean!
    "Whether or not the snapshot is indexed."
    isIndexed: Boolean!
    isOnDemandSnapshot: Boolean!
    isReplica: Boolean
    isReplicated: Boolean!
    isUnindexable: Boolean!
    "Latest User note information."
    latestUserNote: LatestUserNote
    parentSnapshotId: String
    replicationLocations: [DataLocation!]
    sequenceNumber: Int!
    slaDomain: SlaDomain
    snappableId: String!
    unexpiredArchivedSnapshotCount: Int!
    unexpiredReplicaCount: Int!
}

"Paginated list of PolarisSnapshot objects."
type PolarisSnapshotConnection {
    "Total number of PolarisSnapshot objects matching the request arguments."
    count: Int!
    "List of PolarisSnapshot objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [PolarisSnapshotEdge!]!
    "List of PolarisSnapshot objects."
    nodes: [PolarisSnapshot!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the PolarisSnapshot object. This wrapper is used for pagination."
type PolarisSnapshotEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual PolarisSnapshot object wrapped by this edge."
    node: PolarisSnapshot!
}

"Polaris Snapshot data with groupby info applied to it."
type PolarisSnapshotGroupBy {
    "The data groupby info."
    groupByInfo: PolarisSnapshotGroupByInfo!
    "Paginated snapshot data."
    polarisSnapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort polaris snapshots by field"
        sortBy: PolarisSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): PolarisSnapshotConnection!
    "Further provide groupings for the data."
    polarisSnapshotGroupBy(
        "group polaris snapshots by field"
        groupBy: PolarisSnapshotGroupByEnum!
    ): [PolarisSnapshotGroupBy!]!
}

"Paginated list of PolarisSnapshotGroupBy objects."
type PolarisSnapshotGroupByConnection {
    "Total number of PolarisSnapshotGroupBy objects matching the request arguments."
    count: Int!
    "List of PolarisSnapshotGroupBy objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [PolarisSnapshotGroupByEdge!]!
    "List of PolarisSnapshotGroupBy objects."
    nodes: [PolarisSnapshotGroupBy!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the PolarisSnapshotGroupBy object. This wrapper is used for pagination."
type PolarisSnapshotGroupByEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual PolarisSnapshotGroupBy object wrapped by this edge."
    node: PolarisSnapshotGroupBy!
}

"Polaris Snapshot data with groupby info applied to it."
type PolarisSnapshotGroupByNew {
    "The data groupby info."
    groupByInfo: PolarisSnapshotGroupByInfo!
    "Paginated snapshot data."
    polarisSnapshotConnection: PolarisSnapshotConnection!
}

"Paginated list of PolarisSnapshotGroupByNew objects."
type PolarisSnapshotGroupByNewConnection {
    "Total number of PolarisSnapshotGroupByNew objects matching the request arguments."
    count: Int!
    "List of PolarisSnapshotGroupByNew objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [PolarisSnapshotGroupByNewEdge!]!
    "List of PolarisSnapshotGroupByNew objects."
    nodes: [PolarisSnapshotGroupByNew!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the PolarisSnapshotGroupByNew object. This wrapper is used for pagination."
type PolarisSnapshotGroupByNewEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual PolarisSnapshotGroupByNew object wrapped by this edge."
    node: PolarisSnapshotGroupByNew!
}

"Status of various CDM-to-Polaris data syncing jobs."
type PolarisSyncStatus {
    "Last success time of the cluster syncing job."
    clusterSyncLastSuccessTime: DateTime
    "Last success time of the events syncing job."
    eventsSyncLastSuccessTime: DateTime
    "Last success time of the job-monitoring dashboard syncing job."
    jobMonitoringSyncLastSuccessTime: DateTime
    "Last success time of the object metadata syncing job."
    objectMetadataSyncLastSuccessTime: DateTime
    "Last success time of the reports syncing job."
    reportsSyncLastSuccessTime: DateTime
}

type PolicyObj {
    allAnalyzerMappings(stdPath: String!): [AnalyzerMapping!]!
    fileResultConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ListFileResultFiltersInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        sort: FileResultSortInput,
        timezone: String!
    ): FileResultConnection!
    folderChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: BrowseDirectoryFiltersInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        sort: FileResultSortInput,
        stdPath: String!,
        timezone: String!
    ): FileResultConnection!
    id: String!
    objectStatus: ObjectStatus!
    osType: DataGovOsTypeEnum!
    policySummaries: [ClassificationPolicySummary!]!
    rootFileResult: FileResult!
    shareType: DataGovShareTypeEnum!
    snappable: HierarchyObject!
    snapshotFid: String!
    snapshotTimestamp: Long!
    timeContext: String!
    whitelistedAnalyzerList(stdPath: String!): [WhitelistedAnalyzer!]!
}

"Paginated list of PolicyObj objects."
type PolicyObjConnection {
    "Total number of PolicyObj objects matching the request arguments."
    count: Int!
    "List of PolicyObj objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [PolicyObjEdge!]!
    "List of PolicyObj objects."
    nodes: [PolicyObj!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the PolicyObj object. This wrapper is used for pagination."
type PolicyObjEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual PolicyObj object wrapped by this edge."
    node: PolicyObj!
}

type PolicyObjectUsage {
    hierarchyObject: HierarchyObject!
    policies: [ClassificationPolicySummary!]!
}

"Paginated list of PolicyObjectUsage objects."
type PolicyObjectUsageConnection {
    "Total number of PolicyObjectUsage objects matching the request arguments."
    count: Int!
    "List of PolicyObjectUsage objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [PolicyObjectUsageEdge!]!
    "List of PolicyObjectUsage objects."
    nodes: [PolicyObjectUsage!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the PolicyObjectUsage object. This wrapper is used for pagination."
type PolicyObjectUsageEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual PolicyObjectUsage object wrapped by this edge."
    node: PolicyObjectUsage!
}

type PolicyStatus {
    policyId: String!
    status: ObjectPolicyStatus!
}

"Describes a script that is run before / after snapshot or backup"
type PrePostScript {
    failureHandling: PrePostScriptFailureHandlingEnum!
    scriptPath: String!
    timeoutMs: Int!
}

"Precheck details."
type PrecheckFailure {
    "Cause of precheck failure."
    cause: String!
    "Name of the precheck."
    precheckName: String!
    "Remedy to fix the precheck failure."
    remedy: String!
    "Is upgrade blocker flag."
    upgradeBlocker: Boolean!
}

"Precheck status running information."
type PrecheckStatusNextRunInfo {
    "Upgrade prechecks job instance Id."
    jobInstanceId: String!
    "Upgrade prechecks job start time."
    startTime: Long!
    "Status of Upgrade prechecks job."
    status: String!
}

"Precheck job details."
type PrechecksJobReply {
    "Upgrade Prechecks Job id."
    jobId: String!
}

"Prechecks status response object."
type PrechecksStatusReply {
    "Prechecks job end time."
    endTime: Long!
    "List of prechecks failed."
    failureResults: [PrecheckFailure!]!
    "Next prechecks job Information."
    nextRunInfo: PrecheckStatusNextRunInfo
    "Total number of prechecks run."
    numPrechecks: Int!
    "Prechecks job duration in minutes."
    runPeriodInMinutes: Int!
}

"Prepares AWS cloud account for deletion and initiates deletion of the account."
type PrepareAwsCloudAccountDeletionReply {
    "CloudFormation URL to delete the stack."
    cloudFormationUrl: String!
    "List of feature versions."
    featureRegionMap: [AwsCloudAccountFeatureVersion!]!
    "Template URL of the Cloudformation stack. The template URL is empty when the cloud account has no connected features and is to be deleted."
    templateUrl: String!
}

"Response to prepare updation of AWS cloud account."
type PrepareFeatureUpdateForAwsCloudAccountReply {
    "CloudFormation URL to update cloud account."
    cloudFormationUrl: String!
    "AWS CloudFormation template URL."
    templateUrl: String!
}

type PreviewerClusterConfig {
    clusterId: String!
    enabled: Boolean!
}

"Ldap Principal"
type Principal {
    authDomainId: String!
    description: String
    email: String
    id: String!
    name: String!
    principalType: PrincipalTypeEnum!
}

"Paginated list of Principal objects."
type PrincipalConnection {
    "Total number of Principal objects matching the request arguments."
    count: Int!
    "List of Principal objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [PrincipalEdge!]!
    "List of Principal objects."
    nodes: [Principal!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the Principal object. This wrapper is used for pagination."
type PrincipalEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual Principal object wrapped by this edge."
    node: Principal!
}

"Count of processed Radar snappables"
type ProcessedRadarSnappableCountReply {
    count: Long!
}

"Represents a protected object and its corresponding SLA Domain."
type ProtectedObjectTypeToSla {
    "The type of the protected object."
    protectedObjectType: SnappableLevelHierarchyTypeEnum!
    "SLA Domain assigned to the object."
    slaAssignment: AzureNativeResourceGroupSlaAssignment!
}

"Metadata for rendering protected objects."
type ProtectedObjects implements ProtectedObjectSummary {
    effectiveSlaOpt: String
    id: String!
    isArchived: Boolean!
    isUnprotected: Boolean!
    name: String!
    objectType: ManagedObjectType
    "pause status of the protected object."
    slaPauseStatus: Boolean
}

"Paginated list of ProtectedObjects objects."
type ProtectedObjectsConnection {
    "Total number of ProtectedObjects objects matching the request arguments."
    count: Int!
    "List of ProtectedObjects objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [ProtectedObjectsEdge!]!
    "List of ProtectedObjects objects."
    nodes: [ProtectedObjects!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the ProtectedObjects object. This wrapper is used for pagination."
type ProtectedObjectsEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual ProtectedObjects object wrapped by this edge."
    node: ProtectedObjects!
}

"Count and snappable type representing protected Radar snappables"
type ProtectedRadarSnappable {
    count: Long!
    snappableType: String!
}

"Count of protected Radar snappables"
type ProtectedRadarSnappableCountReply {
    snappableCounts: [ProtectedRadarSnappable!]!
}

type ProtectionStatus {
    enumValue: ProtectionStatusEnum!
}

type ProtectionTaskDetailsTableFilter {
    cluster_location: [FilterOption!]!
    cluster_type: [FilterOption!]!
    object_type: [FilterOption!]!
    replication_source: [FilterOption!]!
    status: [FilterOption!]!
    task_category: [FilterOption!]!
    task_type: [FilterOption!]!
}

"Proxy Settings for Target"
type ProxySettings {
    portNumber: Int!
    protocol: String!
    proxyServer: String!
    username: String!
}

type PvcInformation {
    "Access mode mounted on a host."
    accessMode: String!
    "PVC storage capacity."
    capacity: String!
    "ID to uniquely identify PVC."
    id: String!
    "Json string of PVC Labels."
    labels: String!
    "Name of PVC in snapshot."
    name: String!
    "Phase in which PVC bound to the PV."
    phase: String!
    "Storage class of PVC."
    storageClass: String!
    "PV name on which PVC bound."
    volume: String!
}

"Spec for quarantine."
type QuarantineSpec {
    "Files which need to be quarantined."
    filesDetails: [FileDetails!]!
    "Id of the snapshot."
    snapshotId: String!
}

type QuarterlySnapshotSchedule {
    basicSchedule: BasicSnapshotSchedule
    dayOfQuarter: DayOfQuarter!
    quarterStartMonth: Month!
}

type Query {
    "Account ID."
    accountId: String!
    "Lists the account owners."
    accountOwners: [User!]!
    "This endpoint is deprecated."
    accountSettings: AccountSetting!
    activeCustomAnalyzerConnection: AnalyzerConnection!
    activitySeries(
        "The id of the activity series"
        activitySeriesId: UUID!,
        "The uuid of the cluster"
        clusterUuid: UUID
    ): ActivitySeries!
    activitySeriesConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filters: ActivitySeriesFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Sort activity series by field."
        sortBy: ActivitySeriesSortByEnum = LastUpdated,
        "activity sort order"
        sortOrder: SortOrderEnum = Desc
    ): ActivitySeriesConnection!
    activitySeriesGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filters: ActivitySeriesFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group activity series by a field"
        groupBy: ActivitySeriesGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): ActivitySeriesGroupByConnection!
    allAccountProducts(
        "End date of product (yyyy-mm-dd)."
        endDateArg: DateTime,
        "Name of product (GPS, RADAR, etc.)."
        nameFilter: [ProductName!]!,
        "Start date of product (yyyy-mm-dd)."
        startDateArg: DateTime,
        "State of product (Active, Expired, etc.)."
        stateFilter: [ProductState!]!,
        "Type of product (Revenue, POC, etc.)."
        typeFilter: [ProductType!]!
    ): [AccountProduct!]!
    "List of Availability Zones (AZs) in the specified region on the specified AWS Native account."
    allAvailabilityZonesByRegionFromAws(
        "Rubrik ID for AWS account."
        awsAccountRubrikId: UUID!,
        "Region in AWS."
        region: AwsNativeRegion!
    ): [String!]!
    "Get all CDM versions in Azure marketplace."
    allAwsCdmVersions(
        "CDM version request params for Aws."
        input: AwsCdmVersionRequest!
    ): [AwsCdmVersion!]!
    "List of all AWS cloud account configurations with the given search query."
    allAwsCloudAccountConfigs(
        "Arguments for get cloud accounts configs."
        awsCloudAccountsArg: AwsCloudAccountConfigsInput!
    ): [AwsFeatureConfig!]!
    "List of active AWS cloud accounts and the features for the accounts. A cloud account is an AWS account added to the Rubrik platform."
    allAwsCloudAccountsWithFeatures(
        "Arguments for get cloud accounts."
        awsCloudAccountsArg: AwsCloudAccountsWithFeaturesInput!
    ): [AwsCloudAccountWithFeatures!]!
    "List of all AWS exocompute configurations filtered by a cloud account ID or a cloud account name prefix."
    allAwsExocomputeConfigs(
        "A query that searches for Exocompute configurations with an account name or account native ID that is prefixed by the search query."
        awsNativeAccountIdOrNamePrefix: String!
    ): [AwsExocomputeConfig!]!
    "Get all rubrik Instance Profiles in aws account."
    allAwsInstanceProfileNames(
        "Cloud Account Id"
        cloudAccountId: String!,
        "Region of aws account."
        region: String!
    ): [String!]!
    "All valid aws regions for this cloud account."
    allAwsRegions(
        "Cloud Account Id"
        cloudAccountId: String!
    ): [AwsCloudAccountRegion!]!
    "Get all security groups in aws account."
    allAwsSecurityGroups(
        "Cloud Account Id"
        cloudAccountId: String!,
        "Region of aws account."
        region: String!,
        "ID of the vpc in aws account."
        vpcId: String!
    ): [String!]!
    "Get all subnets in aws account."
    allAwsSubnets(
        "Cloud Account Id"
        cloudAccountId: String!,
        "Region of aws account."
        region: String!,
        "ID of the vpc in aws account."
        vpcId: String!
    ): [String!]!
    "Get all VPCs in aws account."
    allAwsVpcs(
        "Cloud Account Id"
        cloudAccountId: String!,
        "Region of aws account."
        region: String!
    ): [String!]!
    "Get all CDM versions in Azure marketplace."
    allAzureCdmVersions(
        "CDM version request params for Azure."
        cdmVersionRequest: cdmVersionRequest!
    ): [AzureCdmVersion!]!
    "Retrieves a list of all the missing permissions on Azure subscriptions that are a part of the Azure Cloud Account."
    allAzureCloudAccountMissingPermissions(
        "The cloud account action to be performed. Some examples are: isCreate, isUpdateRegions, isDelete."
        cloudAccountAction: CloudAccountAction!,
        "Session ID of the current OAuth session."
        sessionId: String!,
        "List of Azure subscription IDs."
        subscriptionIds: [UUID!]!
    ): [AzureSubscriptionMissingPermissions!]!
    "Retrieves all subnets in the specified region and subscription. Subnets allow you to choose IP address range of your choice. For more information, see https://docs.microsoft.com/en-us/azure/virtual-network/network-overview#virtual-network-and-subnets."
    allAzureCloudAccountSubnetsByRegion(
        "The Rubrik ID of the cloud account."
        cloudAccountId: UUID!,
        "Azure region."
        region: AzureCloudAccountRegion!
    ): [AzureNativeSubnet!]!
    "Retrieves a list of all Azure Subscriptions with feature details such as feature, status, and regions."
    allAzureCloudAccountSubscriptionsByFeature(
        "Cloud Account Feature. A feature refers to the Polaris feature that Rubrik provides."
        feature: CloudAccountFeature!,
        "List of subscription status filters to apply."
        subscriptionStatusFilters: [CloudAccountStatus!]!
    ): [AzureSubscriptionWithFeaturesType!]!
    "Retrieves a list of all the Azure tenants and tenant subscriptions for features. The list can be filtered by feature status, subscription native ID, and subscription name."
    allAzureCloudAccountTenants(
        "Cloud Account Feature. A feature refers to the Polaris feature that Rubrik provides."
        feature: CloudAccountFeature!,
        "Specifies whether the details about the subscriptions in the tenants are included in the response or not."
        includeSubscriptionDetails: Boolean!
    ): [AzureCloudAccountTenant!]!
    "List of all Encryption Keys in an Azure Key Vault."
    allAzureEncryptionKeys(
        "Input for fetching Encryption Keys in an Azure Key Vault."
        azureEncryptionKeysInput: AzureEncryptionKeysInput!
    ): [AzureEncryptionKey!]!
    "Retrieves a list of Azure Exocompute configurations filtered by a cloud account ID or a search query."
    allAzureExocomputeConfigsInAccount(
        "A query that searches for Exocompute configurations with an account name or account native ID that is prefixed by the search query."
        azureExocomputeSearchQuery: String,
        "IDs of cloud accounts."
        cloudAccountIDs: [UUID!]
    ): [AzureExocomputeConfigsInAccount!]!
    "List of all Azure Key Vaults in a region."
    allAzureKeyVaultsByRegion(
        "Input for fetching Key Vaults in an Azure region."
        azureKeyVaultsInput: AzureKeyVaultsInput!
    ): [AzureKeyVault!]!
    "Retrieves all availability sets in the specified region, resource group, and subscription. An availability set is a logical grouping of VMs to facilitate redundancy and availability. For more information, see https://docs.microsoft.com/en-us/azure/virtual-machines/availability-set-overview."
    allAzureNativeAvailabilitySetsByRegionFromAzure(
        "Rubrik ID of the Azure Subscription."
        azureSubscriptionRubrikId: UUID!,
        "The azure region."
        region: AzureNativeRegion!,
        "Resource Group Name"
        resourceGroupName: String!
    ): [AzureNativeAvailabilitySet!]!
    "Retrieves all supported disk types when exporting a specific snapshot. Not all disk types are supported in all the regions. For more information, see https://docs.microsoft.com/en-us/azure/virtual-machines/disks-types."
    allAzureNativeExportCompatibleDiskTypesByRegionFromAzure(
        "Rubrik ID of the Azure Subscription."
        azureSubscriptionRubrikId: UUID!,
        "The azure region."
        region: AzureNativeRegion!
    ): [AzureNativeExportCompatibleDiskTypes!]!
    "Retrieves all supported virtual machine (VM) sizes when exporting a particular snapshot. Not all VM sizes are supported in all the regions. For more information, see https://docs.microsoft.com/en-us/azure/virtual-machines/sizes."
    allAzureNativeExportCompatibleVmSizesByRegionFromAzure(
        "Rubrik ID of the Azure Subscription."
        azureSubscriptionRubrikId: UUID!,
        "The azure region."
        region: AzureNativeRegion!,
        "Snapshot ID"
        vmSnapshotId: UUID!
    ): [AzureNativeExportCompatibleVmSizes!]!
    "Retrieves a list of resource groups with the specified names which exist in the specified account."
    allAzureNativeResourceGroupsInfoIfExist(
        "Input to get Azure Resource Groups if they exist."
        input: AzureGetResourceGroupsInfoIfExistInput!
    ): [AzureResourceGroupInfo!]!
    "Retrieves all security groups in the specified region and subscription. Security groups enable you to configure network security as a natural extension of an application's structure, allowing you to group virtual machines and define network security policies based on those groups. For more information, see https://docs.microsoft.com/en-us/azure/virtual-network/application-security-groups."
    allAzureNativeSecurityGroupsByRegionFromAzure(
        "Rubrik ID of the Azure Subscription."
        azureSubscriptionRubrikId: UUID!,
        "The azure region."
        region: AzureNativeRegion!
    ): [AzureNativeSecurityGroup!]!
    "Retrieves list of all storage Accounts in a subscription."
    allAzureNativeStorageAccountsFromAzure(
        "Rubrik ID of the Azure Subscription."
        azureSubscriptionRubrikId: UUID!
    ): [AzureNativeStorageAccount!]!
    "Retrieves all subnets in the specified region and subscription. Subnets allow you to choose IP address range of your choice. For more information, see https://docs.microsoft.com/en-us/azure/virtual-network/network-overview#virtual-network-and-subnets."
    allAzureNativeSubnetsByRegionFromAzure(
        "Rubrik ID of the Azure Subscription."
        azureSubscriptionRubrikId: UUID!,
        "The azure region."
        region: AzureNativeRegion!
    ): [AzureNativeSubnet!]!
    "Retrieves all virtual machine (VM) sizes in the subscriptions protected by Rubrik that have been configured for protection. For more information, see https://docs.microsoft.com/en-us/azure/virtual-machines/sizes."
    allAzureNativeVirtualMachineSizes(
        "Rubrik ID of the Azure Subscription."
        azureSubscriptionRubrikId: UUID
    ): [String!]!
    "Retrieves all virtual networks (VNets) in the protected subscriptions. VNet enables secure communication with other VNets, the internet, and on-premise networks. For more information, see https://docs.microsoft.com/en-us/azure/virtual-network/virtual-networks-overview."
    allAzureNativeVirtualNetworks(
        "Rubrik ID of the Azure Subscription."
        azureSubscriptionRubrikId: UUID
    ): [AzureNativeVirtualNetwork!]!
    "Get all available network security groups for Azure."
    allAzureNsgs(
        "Nsg request params for Azure."
        nsgRequest: nsgRequest!
    ): [String!]!
    "Get all available locations for Azure."
    allAzureRegions(
        "Cloud Account Id"
        cloudAccountId: String!
    ): [AzureCloudAccountRegion!]!
    "Get resource groups for a service principal in Azure."
    allAzureResourceGroups(
        "Azure region"
        azureRegion: String!,
        "Cloud Account Id"
        cloudAccountId: String!
    ): [String!]!
    "Retrieves the list of elastic pools available for a SQL Database Server.For more information, see https://docs.microsoft.com/en-us/azure/azure-sql/database/elastic-pool-overview."
    allAzureSqlDatabaseServerElasticPools(
        "Name of the Azure SQL Database server."
        azureSqlDatabaseServerName: String!,
        "Rubrik ID of the Azure SQL Database Server."
        azureSqlDatabaseServerRubrikId: UUID!,
        "Resource Group Name"
        resourceGroupName: String!,
        "Subscription ID"
        subscriptionId: UUID!
    ): [AzureSqlDatabaseServerElasticPool!]!
    "List all storage accounts from Azure."
    allAzureStorageAccounts(
        "Storage accounts request params for Azure."
        storageAccountsRequest: AzureStorageAccountsReq!
    ): [String!]!
    "Get subnets for a given account in Azure."
    allAzureSubnets(
        "Subnet request params for Azure."
        subnetRequest: subnetRequest!
    ): [String!]!
    "Retrieves a list of all Azure subscriptions with Exocompute subscription mapping."
    allAzureSubscriptionWithExocomputeMappings(
        "List of mapped Exocompute subscription IDs."
        exocomputeSubscriptionIdsFilter: [UUID!],
        "Cloud account features."
        features: [CloudAccountFeature!]
    ): [AzureSubscriptionWithExocomputeMapping!]!
    "Get vnets for a given account in Azure."
    allAzureVnets(
        "Vnet request params for Azure."
        vnetRequest: vnetRequest!
    ): [String!]!
    "Get all cdm guest credentials."
    allCdmGuestCredentials(clusterUuids: [UUID!]!): [CdmGuestCredential!]!
    "List of the Cloud Direct Sites accessible by the current user."
    allCloudDirectSites: [CloudDirectSite!]!
    "List of snapshots for which file recovery is feasible."
    allCloudNativeFileRecoveryEligibleSnapshots(
        "Snappable ID."
        snappableId: UUID!
    ): [String!]!
    allClusterConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ClusterFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort clusters by field"
        sortBy: ClusterSortByEnum = ClusterType,
        "cluster sort order"
        sortOrder: SortOrderEnum = Desc
    ): ClusterConnection!
    "Global SLAs used by a cluster which are protecting at least one object."
    allClusterGlobalSlas(
        "UUID of the Rubrik cluster"
        cdmClusterUUID: UUID!
    ): [SlaInfo!]!
    "All replication targets for a cluster."
    allClusterReplicationTargets(
        "UUID of the cluster."
        clusterUuid: UUID!
    ): [ClusterReplicationTarget!]!
    "Seven days of compliance status history for the specified lookback period."
    allComplianceTimeSeries(
        "The ID of the cluster."
        clusterUuid: UUID,
        "Period of time to look back when evaluating compliance status."
        lookbackPeriod: LookbackPeriod!,
        "Types of objects to limit the results. If absent, all object types are returned."
        objectTypes: [ObjectTypeEnum!]
    ): [DailyComplianceStats!]!
    "Current permissions are the set of permissions the client has given to Rubrik. This will retrieve permissions for all the features currently active in the account. If these permissions are older than the latest set of permissions we require, the account will go in MISSING PERMISSIONS state"
    allCurrentFeaturePermissionsForCloudAccounts(
        "List of Rubrik IDs of the cloud accounts."
        cloudAccountIds: [UUID!]!,
        "Vendor of the cloud account."
        cloudVendor: CloudVendor!
    ): [CloudAccountFeaturePermission!]!
    "List of all DB parameter groups in a given region. Refers to container for engine configuration that applies to one or more DB Instances. For more information, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithOptionGroups.html."
    allDbParameterGroupsByRegionFromAws(
        "Rubrik ID for AWS account."
        awsAccountRubrikId: UUID!,
        "DB Engine of RDS Instance."
        dbEngine: AwsNativeRdsDbEngine!,
        "Version of DB engine."
        dbEngineVersion: String!,
        "Region in AWS."
        region: AwsNativeRegion!
    ): [DbParameterGroup!]!
    "All DB subnet groups in a given region. Refers to logical isolation of RDS on a network. For more information, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.WorkingWithRDSInstanceinaVPC.html."
    allDbSubnetGroupsByRegionFromAws(
        "Rubrik ID for AWS account."
        awsAccountRubrikId: UUID!,
        "Region in AWS."
        region: AwsNativeRegion!
    ): [SubnetGroup!]!
    "List of all key pairs for a given region. A key pair, consisting of a public key and a private key, is a set of security credentials that you use to prove your identity when connecting to an EC2 instance. For more information, see https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html."
    allEc2KeyPairsByRegionFromAws(
        "Rubrik ID for AWS account."
        awsAccountRubrikId: UUID!,
        "Region in AWS."
        region: AwsNativeRegion!
    ): [String!]!
    "List user activity for a specific file on a specific snapshot."
    allFileActivities(
        "Sorts to apply when listing a file's user activities."
        FileActivitiesSort: FileActivitiesSort!,
        "Request for getting user activity for a specific path on a specific snapshot."
        ListFileActivitiesInput: ListFileActivitiesInput!,
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int
    ): UserActivityResultConnection!
    "List of compatible machine types for instance."
    allGcpNativeCompatibleMachineTypes(
        "ID of snapshot."
        snapshotId: UUID!,
        "The zone of the to-be-created instance."
        targetZone: String!
    ): [String!]!
    "List of networks available in a GCP project along with subnetworks and firewall rules."
    allGcpNativeNetworks(
        "ID of the Project."
        projectId: UUID!
    ): [GcpNativeNetwork!]!
    "List of regions available to a GCP project along with zones."
    allGcpNativeRegions(
        "ID of the Project."
        projectId: UUID!
    ): [GcpNativeRegion!]!
    allHostedAzureRegions: AzureRegionsResp!
    "All account level inventory workloads."
    allInventoryWorkloads: [InventoryCard!]!
    "List of encryption keys in the specified region on the specified AWS Native account. All the encrytion keys listed are managed by AWS Key Management System (KMS). For more information, see https://aws.amazon.com/kms/."
    allKmsEncryptionKeysByRegionFromAws(
        "Rubrik ID for AWS account."
        awsAccountRubrikId: UUID!,
        "Region in AWS."
        region: AwsNativeRegion!
    ): [KmsEncryptionKey!]!
    "Latest Permissions are the most recent set of permissions we require for a feature. This will retrieve the permissions for all the features currently active in the accounts along with the features passed in the call."
    allLatestFeaturePermissionsForCloudAccounts(
        "List of Rubrik IDs of the cloud accounts."
        cloudAccountIds: [UUID!]!,
        "Vendor of the cloud account."
        cloudVendor: CloudVendor!,
        "Cloud Account Features."
        features: [CloudAccountFeature!]!
    ): [CloudAccountFeaturePermission!]!
    "Provides a list of database files to be restored for the specified restore or export operation."
    allMssqlDatabaseRestoreFiles(
        "Input for V1MssqlGetRestoreFilesV1"
        input: MssqlGetRestoreFilesV1Input!
    ): V1MssqlGetRestoreFilesV1Response!
    "List of Mosaic Storage Locations used for NoSQL backups"
    allNosqlStorageLocations(
        "Specification on how to filter a list of Mosaic Storage Locations."
        filter: [MosaicStorageLocationFilterInput!],
        "Specification on how to sort a list of Mosaic Storage Locations."
        sortBy: MosaicStorageLocationQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum
    ): [MosaicStorageLocation!]!
    "All AD Groups belonging to the O365 organization."
    allO365AdGroups(
        "AD group search filter."
        adGroupSearchFilter: String!,
        orgId: UUID!
    ): [ADGroup!]!
    allO365OrgStatuses: [O365OrgInfo!]!
    "Latest audit with usernote for a list of objects."
    allObjectsLatestUserNoteAudit(
        "List of object IDs."
        objectIds: [String!]!
    ): [LatestUserNote!]!
    "List of all RDS option groups in a given region. Refers to settings of how a particular option works for an RDS Instance. For more information, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithOptionGroups.html."
    allOptionGroupsByRegionFromAws(
        "Rubrik ID for AWS account."
        awsAccountRubrikId: UUID!,
        "DB Engine of RDS Instance."
        dbEngine: AwsNativeRdsDbEngine!,
        "Version of DB engine."
        dbEngineVersion: String!,
        "Major version of the option group engine."
        majorEngineVersion: String!,
        "Region in AWS."
        region: AwsNativeRegion!
    ): [OptionGroup!]!
    "Get orgs of given IDs."
    allOrgsByIds(
        "The org ids of the orgs."
        orgIds: [String!]!
    ): [Org!]!
    "Quarantine details of a snappable."
    allQuarantinedDetailsForSnappable(
        "Snappable Id of an object."
        snappableIdNotFid: String!
    ): [QuarantineSpec!]!
    "Quarantine details of all snapshots."
    allQuarantinedDetailsForSnapshots(
        "List of snapshotIds."
        snapshotIds: [String!]!
    ): [QuarantineSpec!]!
    allReportConfigs(
        dataView: DataViewTypeEnum,
        "Search term to test all reports names against."
        searchTerm: String
    ): [ReportConfig!]!
    "Retrieves a list og all resource groups in the specified account."
    allResourceGroupsFromAzure(
        "The Native ID of the subscription."
        azureSubscriptionNativeId: UUID!,
        "The Rubrik ID of the cloud account."
        cloudAccountId: UUID!,
        "Cloud Account Feature. A feature refers to the Polaris feature that Rubrik provides."
        feature: CloudAccountFeature!
    ): [AzureResourceGroup!]!
    "List of all S3 bucket names across regions for the AWS Native account."
    allS3BucketsFromAws(
        "Rubrik ID for AWS account."
        awsAccountRubrikId: UUID!
    ): [String!]!
    "All PVCs in a snapshot."
    allSnapshotPvcs(
        "The FID of the snappable."
        snappableId: UUID!,
        "The snapshot ID."
        snapshotId: String!
    ): [PvcInformation!]!
    "Details of the unexpired snapshot closest to the specified point in time for each provided snappable ID."
    allSnapshotsClosestToPointInTime(
        "The time to search after (inclusive)."
        afterTime: DateTime,
        "The time to search before (inclusive)."
        beforeTime: DateTime,
        "Whether to ignore the active protected object check."
        ignoreActiveSnappableCheck: Boolean,
        "Indicate fetched snapshots should include linked ones. if it is true, the return snapshots should include linked ones. "
        includeLinked: Boolean,
        "Snappable UUIDs."
        snappableIds: [String!]!
    ): [ClosestSnapshotSearchResult!]!
    allStorageArrays(
        "Input for InternalQueryStorageArrays"
        input: QueryStorageArraysInput!
    ): StorageArrayDetailListResponse!
    allUsersOnAccountConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        emailFilter: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        roleIdsFilter: [UUID!],
        "Get local users only."
        shouldGetLocalUsersOnly: Boolean! = false,
        sortBy: UserFieldEnum = Email,
        "sort order"
        sortOrder: SortOrderEnum
    ): UserConnection!
    "List of all Virtual Private Clouds (VPCs) in the AWS Native account, classified by region."
    allVpcsByRegionFromAws(
        "Rubrik ID for AWS account."
        awsAccountRubrikId: UUID!,
        "Region in AWS."
        region: AwsNativeRegion!
    ): [AwsVpc!]!
    "List of all Virtual Private Clouds (VPCs) in the AWS Native account."
    allVpcsFromAws(
        "Rubrik ID for AWS account."
        awsAccountRubrikId: UUID
    ): [AwsVpc!]!
    "All webhooks in the account."
    allWebhooks(
        "The name of the webhooks to retrieve. Leave empty to retrieve all webhooks."
        name: String
    ): [Webhook!]!
    "Amazon Machine Image (AMI) type for export of an archived EC2 Instance snapshot. For more information, see https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instances-and-amis.html."
    amiTypeForAwsNativeArchivedSnapshotExport(
        "Input for AmiTypeForAwsNativeArchivedSnapshotExport."
        input: AmiTypeForAwsNativeArchivedSnapshotExportInput!
    ): AmiTypeForAwsNativeArchivedSnapshotExportReply!
    analyzerGroupConnection: AnalyzerGroupConnection!
    "Returns which policies are using each analyzer"
    analyzerUsageConnection: AnalyzerUsageConnection!
    anomalyResultConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter anomaly results by input"
        filter: AnomalyResultFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort anomaly results by field"
        sortBy: AnomalyResultSortByEnum,
        "sort order"
        sortOrder: SortOrderEnum,
        timezoneOffset: Float = 0.0
    ): AnomalyResultConnection!
    anomalyResultGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter anomaly results by input"
        filter: AnomalyResultFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group anomaly results by field"
        groupBy: AnomalyResultGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): AnomalyResultGroupByConnection!
    anomalyResultOpt(
        "The ID of the cluster."
        clusterUuid: UUID!,
        "Corresponds to snapshot ID in CDM tables"
        snapshotId: String!
    ): AnomalyResult
    appBlueprintOngoingFailoverTaskchainUuids(fids: [UUID!]!): GetAppBlueprintOngoingFailoverTaskchainUuidsRsp!
    appBlueprintSnapshotImageInfos(appSnapshotFids: [UUID!]!): GetAppBlueprintSnapshotCloudImagesRsp!
    appflowsSummary: AppflowsSummary!
    "List of AWS cloud accounts and the features for each account, classified by ID."
    awsCloudAccountWithFeatures(
        "Arguments for get cloud account."
        awsCloudAccountArg: AwsCloudAccountWithFeaturesInput!,
        "The Rubrik ID of the cloud account."
        cloudAccountId: UUID!
    ): AwsCloudAccountWithFeatures!
    awsComputeSettings(
        "Corresponds to Compute Setting Id in Polaris tables"
        computeSettingId: UUID!
    ): AwsComputeSettings!
    awsComputeSettingsList(
        "Specification on what context filter to use."
        contextFilter: ContextFilterTypeEnum,
        "Specification on how to filter a list of compute settings"
        filter: [AwsCloudComputeSettingFilterInput!],
        "Specification on how to sort a list of compute settings"
        sortBy: AwsCloudComputeSettingSortByFieldEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): [AwsComputeSettings!]!
    "Refers to the AWS Native account that serves as a container for all your AWS resources. The AWS Native account contains information about the metadata related to the AWS Native resources."
    awsNativeAccount(
        "The Rubrik ID for the AWS Native account."
        awsNativeAccountRubrikId: UUID!,
        "Cloud native protection feature."
        awsNativeProtectionFeature: AwsNativeProtectionFeature!
    ): AwsNativeAccount!
    "Paginated list of all AWS Native accounts."
    awsNativeAccounts(
        accountFilters: AwsNativeAccountFilters,
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        authorizedOperationFilter: OperationEnum,
        "Cloud native protection feature."
        awsNativeProtectionFeature: AwsNativeProtectionFeature!,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Sort fields for list of AWS accounts."
        sortBy: AwsNativeAccountSortFields,
        sortOrder: HierarchySortOrder
    ): AwsNativeAccountConnection!
    "Refers to the Amazon Elastic Block Store (EBS) Volume represented by a specific ID. For more information, see https://aws.amazon.com/ebs/."
    awsNativeEbsVolume(
        "Rubrik ID for the AWS EBS Volume object."
        ebsVolumeRubrikId: UUID!
    ): AwsNativeEbsVolume!
    "Paginated list of all AWS EBS Volumes."
    awsNativeEbsVolumes(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        ebsVolumeFilters: AwsNativeEbsVolumeFilters,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Sort fields for list of AWS EBS volumes."
        sortBy: AwsNativeEbsVolumeSortFields,
        sortOrder: HierarchySortOrder
    ): AwsNativeEbsVolumeConnection!
    "Paginated list of all AWS EBS Volumes by name or substring of name."
    awsNativeEbsVolumesByName(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "The native name for the AWS EBS Volume object."
        ebsVolumeName: String!,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Sort fields for list of AWS EBS volumes."
        sortBy: AwsNativeEbsVolumeSortFields,
        sortOrder: HierarchySortOrder
    ): AwsNativeEbsVolumeConnection!
    "Refers to Amazon Elastic Compute Cloud (EC2) Instance represented by a specific ID. For more information, see https://aws.amazon.com/ec2/."
    awsNativeEc2Instance(
        "Rubrik ID for the AWS EC2 Instance."
        ec2InstanceRubrikId: UUID!
    ): AwsNativeEc2Instance!
    "Paginated list of all AWS EC2 Instances."
    awsNativeEc2Instances(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Filter the CDM cloud hosts by workload type."
        descendantTypeFilter: [HierarchyObjectTypeEnum!],
        ec2InstanceFilters: AwsNativeEc2InstanceFilters,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Sort fields for list of AWS EC2 instances."
        sortBy: AwsNativeEc2InstanceSortFields,
        sortOrder: HierarchySortOrder
    ): AwsNativeEc2InstanceConnection!
    "Paginated list of all AWS EC2 Instances by name or substring of name."
    awsNativeEc2InstancesByName(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Native name for the AWS EC2 Instance object."
        ec2InstanceName: String!,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Sort fields for list of AWS EC2 instances."
        sortBy: AwsNativeEc2InstanceSortFields,
        sortOrder: HierarchySortOrder
    ): AwsNativeEc2InstanceConnection!
    "Refers to the default values for the export operation of the RDS DB Instance in the AWS Native account."
    awsNativeRdsExportDefaults(
        "Specifies whether the export of the instance is manual or Point-in-Time."
        isPointInTime: Boolean!,
        "The Rubrik ID for the AWS RDS Instance."
        rdsInstanceRubrikId: UUID!,
        "ID of the snapshot if the export is manual."
        snapshotId: String
    ): RdsInstanceExportDefaults!
    "Refers to AWS Relational Database Service (RDS) represented by a specific ID. For more information, see https://aws.amazon.com/rds/."
    awsNativeRdsInstance(
        "The Rubrik ID for the AWS RDS Instance."
        rdsInstanceRubrikId: UUID!
    ): AwsNativeRdsInstance!
    "Paginated list of AWS RDS Instances on AWS Native account."
    awsNativeRdsInstances(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        rdsInstanceFilters: AwsNativeRdsInstanceFilters,
        "Sort fields for list of AWS RDS instances."
        sortBy: AwsNativeRdsInstanceSortFields,
        sortOrder: HierarchySortOrder
    ): AwsNativeRdsInstanceConnection!
    "Point-in-Time (PiT) restore window of the RDS Instance in the AWS Native account. Refers to the range of time within which the database is available to be restored to a particular point in time. For more information,see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_PIT.html."
    awsNativeRdsPointInTimeRestoreWindow(
        "Rubrik ID for AWS account."
        awsAccountRubrikId: UUID!,
        "Name of the RDS DB Instance"
        rdsInstanceName: String!,
        "Region in AWS."
        region: AwsNativeRegion!
    ): AwsNativeRdsPointInTimeRestoreWindow!
    "Retrieves the configuration consisting of role permissions and feature policy version required for Azure subscription setup. Features refer to the Polaris features that the customer wants to be enabled on the cloud account."
    azureCloudAccountPermissionConfig(
        "Cloud Account Feature. A feature refers to the Polaris feature that Rubrik provides."
        feature: CloudAccountFeature!
    ): AzureCloudAccountPermissionConfigResponse!
    "Retrieves the details of the Azure cloud account."
    azureCloudAccountSubscriptionWithFeatures(
        "The Rubrik ID of the cloud account."
        cloudAccountId: UUID!
    ): AzureCloudAccountSubscriptionWithFeatures!
    "Retrieves the details of the Azure tenant and all the subscriptions of the tenant, for a feature."
    azureCloudAccountTenant(
        "Cloud Account Feature. A feature refers to the Polaris feature that Rubrik provides."
        feature: CloudAccountFeature!,
        "Search text for subscription name and native ID."
        subscriptionSearchText: String!,
        "List of subscription status filters to apply."
        subscriptionStatusFilters: [CloudAccountStatus!]!,
        "Tenant ID of the Azure tenant."
        tenantId: UUID!
    ): AzureCloudAccountTenant!
    "Retrieves details about the Azure cloud account tenant including the Exocompute configurations for the tenant subscriptions, for a specified feature."
    azureCloudAccountTenantWithExoConfigs(
        "Cloud Account Feature. A feature refers to the Polaris feature that Rubrik provides."
        feature: CloudAccountFeature!,
        "Search text for subscription name and native ID."
        subscriptionSearchText: String!,
        "List of subscription status filters to apply."
        subscriptionStatusFilters: [CloudAccountStatus!]!,
        "Tenant ID of the Azure tenant."
        tenantId: UUID!
    ): AzureCloudAccountTenantWithExoConfigs!
    "Retrieves an Azure Native Managed Disk that refers to the block storage designed to be used with Azure Virtual Machines. Some examples are: ultra disks, premium solid-state drives (SSD), standard SSDs, and standard hard disk drives (HDD). For more information, see https://docs.microsoft.com/en-us/azure/virtual-machines/managed-disks-overview."
    azureNativeManagedDisk(
        "Rubrik ID of the Azure Managed Disk."
        azureManagedDiskRubrikId: UUID!
    ): AzureNativeManagedDisk!
    "Retrieves a paginated list of all Azure Native Managed Disks."
    azureNativeManagedDisks(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        diskFilters: AzureNativeDiskFilters,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Sort fields for list of Azure disks."
        sortBy: AzureNativeDiskSortFields,
        sortOrder: HierarchySortOrder
    ): AzureNativeManagedDiskConnection!
    "Retrieves an Azure Native Resource Group. Refers to a collection of resources in which multiple Azure services can reside."
    azureNativeResourceGroup(
        "Resource Group ID of Virtual Machine (VM) or Disk."
        resourceGroupId: UUID!
    ): AzureNativeResourceGroup!
    "Retrieves a paginated list of all Azure Native Resource Groups."
    azureNativeResourceGroups(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "The type of Azure Native features that Polaris supports."
        azureNativeProtectionFeatures: [AzureNativeProtectionFeature!],
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Filters for listing Azure resource groups"
        commonResourceGroupFilters: AzureNativeCommonResourceGroupFilters,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "List of protected object types."
        protectedObjectTypes: [SnappableLevelHierarchyTypeEnum!],
        "Sort fields for listing Azure resource groups."
        sortBy: AzureNativeCommonResourceGroupSortFields,
        sortOrder: HierarchySortOrder
    ): AzureNativeResourceGroupConnection!
    "Retrieves an Azure Native Subscription. Refers to the logical entity that provides entitlement to deploy and consume Azure resources."
    azureNativeSubscription(
        "Rubrik ID of the Azure Subscription."
        azureSubscriptionRubrikId: UUID!
    ): AzureNativeSubscription!
    "Retrieves a paginated list of all Azure Native Subscriptions."
    azureNativeSubscriptions(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Filters according to the operation given."
        authorizedOperationFilter: OperationEnum,
        "The type of Azure Native feature that Polaris supports."
        azureNativeProtectionFeature: AzureNativeProtectionFeature,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Snappable hierarchy."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        "Sort fields for list of Azure subscriptions."
        sortBy: AzureNativeSubscriptionSortFields,
        sortOrder: HierarchySortOrder,
        subscriptionFilters: AzureNativeSubscriptionFilters
    ): AzureNativeSubscriptionConnection!
    "Retrieves an Azure Virtual Machine that refers to the Azure infrastructure as a service (IaaS) used to deploy persistent VMs. For more information, see https://docs.microsoft.com/en-us/azure/virtual-machines/."
    azureNativeVirtualMachine(
        "Rubrik ID of the Azure Virtual Machine."
        azureVirtualMachineRubrikId: UUID!
    ): AzureNativeVirtualMachine!
    "Retrieves a paginated list of all Azure Virtual Machines (VMs)."
    azureNativeVirtualMachines(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Filter the CDM cloud hosts by workload type."
        descendantTypeFilter: [HierarchyObjectTypeEnum!],
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Sort fields for list of Azure virtual machines."
        sortBy: AzureNativeVirtualMachineSortFields,
        sortOrder: HierarchySortOrder,
        virtualMachineFilters: AzureNativeVirtualMachineFilters
    ): AzureNativeVirtualMachineConnection!
    azureO365CheckNSGOutboundRules(resourceGroupName: String!, subnet_name: String!, subscriptionId: UUID!, tenantId: String!, vnet_name: String!): AzureNetworkSecurityGroupResp!
    azureO365CheckNetworkSubnet(resourceGroupName: String!, strict_addr_check: Boolean!, subnet_name: String!, subscriptionId: UUID!, tenantId: String!, vnet_name: String!): AzureNetworkSubnetResp!
    azureO365CheckResourceGroupName(groupName: String!, subscriptionId: UUID!, tenantId: String!): AzureResourceAvailabilityResp!
    azureO365CheckStorageAccountAccessibility(groupName: String!, storage_account_name: String!, subscriptionId: UUID!, tenantId: String!): AzureResourceAvailabilityResp!
    azureO365CheckStorageAccountName(storage_account_name: String!, subscriptionId: UUID!, tenantId: String!): AzureResourceAvailabilityResp!
    azureO365CheckSubscriptionQuota(regionName: String!, subscriptionId: UUID!, tenantId: String!): AzureResourceAvailabilityResp!
    azureO365CheckVirtualNetworkName(groupName: String!, subscriptionId: UUID!, tenantId: String!, vnet_name: String!): AzureResourceAvailabilityResp!
    azureO365Exocompute(exocomputeClusterId: String!, orgId: UUID!): GetAzureO365ExocomputeResp!
    azureO365GetAzureHostType: GetAzureHostTypeResp!
    azureO365GetNetworkSubnetUnusedAddr(resourceGroupName: String!, strict_addr_check: Boolean!, subnet_name: String!, subscriptionId: UUID!, tenantId: String!, vnet_name: String!): AzureNetworkSubnetUnusedAddrResp!
    azureO365ValidateUserRoles(subscriptionId: UUID!, tenantId: String!): AzureUserRoleResp!
    azureRegions(subscriptionId: UUID!, tenantId: String!): RegionConnection!
    azureResourceGroups(subscriptionId: UUID!, tenantId: String!): ResourceGroupConnection!
    "Retrieves an Azure SQL Database. Refers to the fully managed SQL database built for the cloud. For more information, see https://azure.microsoft.com/en-us/products/azure-sql/database/."
    azureSqlDatabase(
        "Rubrik ID of the Azure SQL Database."
        azureSqlDatabaseRubrikId: UUID!
    ): AzureSqlDatabaseDb!
    "Point-in-Time (PiT) restore window of the Azure SQL Database instance in the Azure native account. Refers to the range of time within which the database is available to be restored to a particular point in time. For more information, see https://azure.microsoft.com/en-in/blog/azure-sql-database-point-in-time-restore/."
    azureSqlDatabaseDbPointInTimeRestoreWindowFromAzure(
        "Name of the Azure SQL Database."
        azureSqlDatabaseName: String!,
        "Name of the Azure SQL Database server."
        azureSqlDatabaseServerName: String!,
        "Resource Group Name"
        resourceGroupName: String!,
        "Subscription ID"
        subscriptionId: UUID!
    ): AzureNativeSqlDatabasePointInTimeRestoreWindow!
    "Retrieves an Azure SQL Database Server. Refers to the server that contains the Azure SQL Databases. For more information, see https://docs.microsoft.com/en-us/azure/azure-sql/database/logical-servers."
    azureSqlDatabaseServer(
        "Rubrik ID of the Azure SQL Database Server."
        azureSqlDatabaseServerRubrikId: UUID!
    ): AzureSqlDatabaseServer!
    "Retrieves a paginated list of all Azure SQL Database Servers."
    azureSqlDatabaseServers(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Filters for listing Azure SQL Database Servers."
        azureSqlDatabaseServerFilters: AzureSqlDatabaseServerFilters,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Sort fields for list of Azure SQL Database Servers."
        sortBy: AzureSqlDatabaseServerSortFields,
        sortOrder: HierarchySortOrder
    ): AzureSqlDatabaseServerConnection!
    "Retrieves a paginated list of all Azure SQL Databases."
    azureSqlDatabases(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Filters for listing Azure SQL Databases."
        azureSqlDatabaseFilters: AzureSqlDatabaseFilters,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Sort fields for list of Azure SQL Databases."
        sortBy: AzureSqlDatabaseSortFields,
        sortOrder: HierarchySortOrder
    ): AzureSqlDatabaseDbConnection!
    "Retrieves an Azure SQL Managed Instance Database. Refers to the database engine compatible with the latest SQL Server (Enterprise Edition) database engine. For more information, see https://docs.microsoft.com/en-us/azure/azure-sql/managed-instance/sql-managed-instance-paas-overview."
    azureSqlManagedInstanceDatabase(
        "Rubrik ID of the Azure SQL Managed Instance Database."
        azureSqlManagedInstanceDatabaseRubrikId: UUID!
    ): AzureSqlManagedInstanceDatabase!
    "Retrieves a paginated list of all Azure SQL Managed Instance Databases."
    azureSqlManagedInstanceDatabases(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Filters for listing Azure SQL Managed Instance Databases."
        azureSqlManagedInstanceDatabaseFilters: AzureSqlManagedInstanceDatabaseFilters,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Sort fields for list of Azure SQL Managed Instance Databases."
        sortBy: AzureSqlManagedInstanceDatabaseSortFields,
        sortOrder: HierarchySortOrder
    ): AzureSqlManagedInstanceDatabaseConnection!
    "Point-in-Time (PiT) restore window of the Azure SQL Managed Instance database in the Azure native account. Refers to the range of time within which the database is available to be restored to a particular point in time. For more information, see https://docs.microsoft.com/en-us/azure/azure-sql/managed-instance/point-in-time-restore?tabs=azure-portal."
    azureSqlManagedInstanceDbPointInTimeRestoreWindowFromAzure(
        "Name of the Azure SQL Database."
        azureSqlDatabaseName: String!,
        "Name of the Azure SQL Managed Instance."
        azureSqlManagedInstanceName: String!,
        "Resource Group Name"
        resourceGroupName: String!,
        "Subscription ID"
        subscriptionId: UUID!
    ): AzureNativeSqlDatabasePointInTimeRestoreWindow!
    "Retrieves an Azure SQL Managed Instance Server. Refers to the server the Azure SQL Managed Instance Database is a part of."
    azureSqlManagedInstanceServer(
        "Rubrik ID of the Azure SQL Managed Instance Server."
        azureSqlManagedInstanceServerRubrikId: UUID!
    ): AzureSqlManagedInstanceServer!
    "Retrieves a paginated list of all Azure SQL Managed Instance Servers."
    azureSqlManagedInstanceServers(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Filters for listing Azure SQL Managed Instance Servers."
        azureSqlManagedInstanceServerFilters: AzureSqlManagedInstanceServerFilters,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Sort fields for list of Azure SQL Managed Instance Servers."
        sortBy: AzureSqlManagedInstanceServerSortFields,
        sortOrder: HierarchySortOrder
    ): AzureSqlManagedInstanceServerConnection!
    azureStorageAccounts(regionName: String!, subscriptionId: UUID!, tenantId: String!): StorageAccountConnection!
    azureSubnets(subscriptionId: UUID!, tenantId: String!, vNetId: String!): SubnetConnection!
    azureSubscriptions(tenantId: String!): AzureSubscriptionConnection!
    azureVNets(regionName: String!, subscriptionId: UUID!, tenantId: String!): VNetConnection!
    blueprint(
        "The Polaris UUID for the object."
        fid: UUID!
    ): Blueprint!
    blueprintConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): BlueprintConnection!
    blueprintNew(
        "The Polaris UUID for the object."
        fid: UUID!
    ): BlueprintNew!
    blueprintNewConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "The status of the blueprint failover."
        failoverStatusOpt: FailoverStatusEnum,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        "The id of the source location."
        sourceLocationIdOpt: String,
        "The status of the blueprint."
        statusOpt: BlueprintStatusEnum,
        "The id of the intended remote target location."
        targetLocationIdOpt: String
    ): BlueprintNewConnection!
    "list the recovery specs associated with the given blueprint"
    blueprintRecoverySpecs(
        "the id of the blueprint"
        blueprintId: UUID!,
        "Get invalid recovery spec if true."
        getInvalidSpecs: Boolean,
        "Ignore invalid recovery specs or raise an error."
        ignoreErrors: Boolean,
        "The list of snappable recovery point infos."
        snappableInfos: [SnappableInfoType!]!,
        "Validate the recovery specs if true."
        validate: Boolean
    ): BlueprintRecoverySpecs!
    "describes the Blueprint resource specs"
    blueprintResourceSpec(
        "the id of the blueprint"
        blueprintId: UUID!,
        "The list of snappable recovery point infos."
        snappableInfos: [SnappableInfoType!]!
    ): [ResourceSpec!]!
    "Bootstrap status of cluster."
    bootstrapStatus(
        "BootstrapStatusReqInput params."
        BootstrapStatus: BootstrapStatusReq!
    ): BootstrapStatusReply!
    browseCalendar(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Search filter for calendar search."
        calendarSearchFilter: CalendarSearchFilter,
        "Returns the first n elements from the list."
        first: Int,
        folderId: String!,
        orgId: UUID!,
        snappableFid: UUID!,
        snapshotFid: UUID!
    ): O365ExchangeObjectConnection!
    "Browse Exchange contacts."
    browseContacts(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Search filter for contacts search."
        contactsSearchFilter: ContactsSearchFilter,
        "Returns the first n elements from the list."
        first: Int,
        folderId: String!,
        orgId: UUID!,
        snappableFid: UUID!,
        snapshotFid: UUID!
    ): O365ExchangeObjectConnection!
    "Browse diff fmd under given path"
    browseDiffFmd(
        "Root path to browse changes of fmd."
        browseDiffPath: String!,
        "The ID of the cluster."
        clusterUuid: UUID!,
        "Snappable managed ID"
        managedId: String!,
        "Corresponds to snapshot ID in CDM tables"
        snapshotId: String!
    ): DiffFMDReply!
    browseFilesetSnapshot(
        "ID of snapshot."
        id: String!,
        "Maximum number of entries in the response."
        limit: Int,
        "Starting position in the list of path entries contained in the query results, sorted by lexicographical order. The response includes the specified numbered entry and all higher numbered entries."
        offset: Int,
        "The absolute path of the starting point for the directory listing."
        path: String!
    ): BrowseResponseListResponse!
    browseFolder(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the first n elements from the list."
        first: Int,
        folderId: String!,
        orgId: UUID!,
        snappableFid: UUID!,
        snapshotFid: UUID!
    ): O365ExchangeObjectConnection!
    """

    Lists all files in VM snapshot

    Supported in v5.0+
    Lists all files and directories in a given path.
    """
    browseNutanixSnapshot(
        "Input for InternalBrowseNutanixSnapshot"
        input: BrowseNutanixSnapshotInput!
    ): BrowseResponseListResponse!
    browseO365TeamConvChannels(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        excludeArchived: Boolean!,
        "Returns the first n elements from the list."
        first: Int,
        nameFilter: String,
        orgId: UUID!,
        snappableFid: UUID!,
        "snapshotFid arg which is of optional type"
        snapshotFidOpt: UUID
    ): O365TeamConvChannelConnection!
    browseOnedrive(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the first n elements from the list."
        first: Int,
        folderId: String,
        onedriveSearchFilter: OnedriveSearchFilter,
        orgId: UUID!,
        snappableFid: UUID!,
        snapshotFid: UUID!
    ): O365OnedriveObjectConnection!
    browseSharepointDrive(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the first n elements from the list."
        first: Int,
        folderId: String,
        orgId: UUID!,
        sharepointDriveSearchFilter: OnedriveSearchFilter,
        snappableFid: UUID!,
        snapshotFid: UUID!
    ): O365OnedriveObjectConnection!
    "Browse list objects"
    browseSharepointList(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the first n elements from the list."
        first: Int,
        folderId: String,
        orgId: UUID!,
        sharepointDriveSearchFilter: OnedriveSearchFilter,
        snappableFid: UUID!,
        snapshotFid: UUID!
    ): O365OnedriveObjectConnection!
    """

    Lists all files and directories in a given path

    Supported in v7.0+
    Lists all files and directories in a given path.
    """
    browseSnapMirrorCloudSnapshot(
        "Input for V1BrowseSnapMirrorCloudSnapshot"
        input: BrowseSnapMirrorCloudSnapshotInput!
    ): BrowseResponseListResponse!
    "Returns a list files whose name is prefixed by the query in the given snapshot"
    browseSnapshotFileConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the first n elements from the list."
        first: Int,
        "The path under which you want your search to run"
        path: String!,
        "Prefix arg for searching for files within a snapshot"
        searchPrefix: String,
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!
    ): SnapshotFileConnection!
    browseTeamsChannels(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the first n elements from the list."
        first: Int,
        nameFilter: String,
        orgId: UUID!,
        snappableFid: UUID!,
        snapshotFid: UUID!
    ): O365TeamsChannelConnection!
    browseTeamsDrive(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the first n elements from the list."
        first: Int,
        folderId: String,
        orgId: UUID!,
        snappableFid: UUID!,
        snapshotFid: UUID!,
        teamsDriveSearchFilter: OnedriveSearchFilter
    ): O365OnedriveObjectConnection!
    "Paginated list of cassandra column families."
    cassandraColumnFamilies(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): CassandraColumnFamilyConnection!
    "Details of a cassandra column family."
    cassandraColumnFamily(
        "The Polaris UUID for the object."
        fid: UUID!
    ): CassandraColumnFamily!
    "Get Recoverable Range of a Cassandra Column Family."
    cassandraColumnFamilyRecoverableRange(
        "Input for V2GetMosaicRecoverableRange"
        input: GetMosaicRecoverableRangeInput!
    ): GetMosaicRecoverableRangeResponse!
    "Get Schema of a Cassandra Column Family."
    cassandraColumnFamilySchema(
        "Input for V2GetMosaicTableSchema"
        input: GetMosaicTableSchemaInput!
    ): GetSchemaResponse!
    "Details of a cassandra keyspace."
    cassandraKeyspace(
        "The Polaris UUID for the object."
        fid: UUID!
    ): CassandraKeyspace!
    "Paginated list of cassandra keyspaces."
    cassandraKeyspaces(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): CassandraKeyspaceConnection!
    "Details of a cassandra source."
    cassandraSource(
        "The Polaris UUID for the object."
        fid: UUID!
    ): CassandraSource!
    "Paginated list of cassandra sources."
    cassandraSources(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): CassandraSourceConnection!
    cdmHierarchySnappableNew(snappableFid: UUID!): CdmHierarchySnappableNew!
    cdmHierarchySnappablesNew(fids: [UUID!]!): [CdmHierarchySnappableNew!]!
    cdmInventorySubHierarchyRoot(rootEnum: InventorySubHierarchyRootEnum!): CdmInventorySubHierarchyRoot!
    "A single Microsoft SQL log shipping target."
    cdmMssqlLogShippingTarget(
        "The Polaris UUID for the object."
        fid: UUID!
    ): MssqlLogShippingTarget
    "Paginated list of Microsoft SQL log shipping target."
    cdmMssqlLogShippingTargets(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Filters for Mssql log shipping targets. No filters by default."
        filters: [MssqlLogShippingTargetFilterInput!],
        "Returns the first n elements from the list."
        first: Int,
        "Sort by argument for Mssql log shipping targets. Default sort is by id in ascending order."
        sortBy: MssqlLogShippingTargetSortByInput
    ): MssqlLogShippingTargetConnection!
    "Browse Certificates"
    certificateConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Search for a Certificate"
        searchTerm: String,
        "Sort"
        sortBy: CertMgmtSortByEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): CertificateConnection!
    "Certificates having private key."
    certificatesWithKey: CertificateConnection!
    "Check if label rule name is unique or not"
    checkCloudNativeLabelRuleNameUniqueness(
        "Type of managed object on which label rule will be applied."
        objectType: CloudNativeLabelObjectType!,
        "Name for the rule"
        ruleName: String!
    ): IsCloudNativeTagRuleNameUniqueReply!
    "Check if tag rule name is unique or not"
    checkCloudNativeTagRuleNameUniqueness(
        "Type of managed object on which tag rule will be applied."
        objectType: CloudNativeTagObjectType!,
        "Name for the rule"
        ruleName: String!
    ): IsCloudNativeTagRuleNameUniqueReply!
    "check the child vm guestOS for given app blueprint"
    checkGuestOsForAppBlueprint(
        "the id of the blueprint"
        blueprintId: UUID!
    ): CheckGuestOsReply!
    classificationBannerSettings: ClassificationBannerSettings!
    classificationLoginSettings: ClassificationLoginSettings!
    cloudAccount(
        "Corresponds to Cloud Account Id in Polaris tables"
        cloudAccountId: UUID!
    ): CloudAccount!
    cloudAccountList(
        "Filters and shows cloud accounts for a specific use-cases or features. Default value: [ARCHIVAL]"
        features: [CloudAccountFeature!],
        filter: [CloudAccountFilterInput!],
        sortBy: CloudAccountSortByFieldEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): [CloudAccount!]!
    "Archived snapshot locking related details for a snappable. If no snapshots IDs are passed, all the expired source snapshots and the source snapshots that have a unexpired archival copy will be checked."
    cloudNativeCheckArchivedSnapshotsLocked(
        "Snappable ID."
        snappableId: UUID!,
        "List of snapshot IDs."
        snapshotIds: [UUID!]
    ): CheckArchivedSnapshotsLockedReply!
    "Queries whether Polaris has the required permissions for a particular feature."
    cloudNativeCheckRequiredPermissionsForFeature(
        "Cloud native account ID"
        cloudNativeAccountId: String!,
        "Feature for which required permissions have to be checked."
        featurePermissionCheck: CloudNativeFeatureForPermissionsCheck!
    ): Boolean!
    "Fetches the URLs for the windows, linux and debian RBA installers"
    cloudNativeGetRBAInstallers: CreateRBAInstallerReply!
    "Returns a list of cloud native label keys matched by substring"
    cloudNativeLabelKeys(
        "key substring for which you want to search keys"
        keySubStr: String!,
        "number of results to return"
        limit: Int!,
        "Type of managed object on which label rule will be applied."
        objectType: CloudNativeLabelObjectType!
    ): [String!]!
    "Cloud native label rules."
    cloudNativeLabelRules(
        "Fields and values according to which rules will be filtered."
        filters: [CloudNativeFilter!],
        "Type of managed object on which label rule will be applied."
        objectType: CloudNativeLabelObjectType!,
        sortBy: CloudNativeTagRuleSortByFields,
        sortOrder: HierarchySortOrder
    ): GetCloudNativeLabelRulesReply!
    "Returns a list of cloud native label values matched by substring"
    cloudNativeLabelValues(
        "key value used only when searching for values"
        key: String!,
        "number of results to return"
        limit: Int!,
        "Type of managed object on which label rule will be applied."
        objectType: CloudNativeLabelObjectType!,
        "value substring for which you want to search values"
        valueSubStr: String!
    ): [String!]!
    "List all files and directories in a given snappable with the given prefix in name."
    cloudNativeSnappableVersionedFiles(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the first n elements from the list."
        first: Int,
        "Name or Path prefix arg for searching for files within a snappable."
        searchQuery: String!,
        "Snappable ID."
        snappableId: UUID!
    ): CloudNativeVersionedFileConnection!
    "Details of snapshot types available for recovery."
    cloudNativeSnapshotDetailsForRecovery(
        "Snapshot UUID"
        snapshotId: UUID!
    ): CloudNativeSnapshotDetailsForRecoveryReply!
    "List of all files and directories in a given path with the given prefix in name."
    cloudNativeSnapshots(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the first n elements from the list."
        first: Int,
        "The path under which you want your search to run."
        path: String!,
        "Name prefix for searching for files within a snapshot."
        searchPrefix: String,
        "Id of the snapshot to be searched/browsed"
        snapshotFid: UUID!
    ): SnapshotFileConnection!
    "Returns the script to setup backup for a SQL Server database."
    cloudNativeSqlServerSetupScript: CloudNativeSqlServerSetupScript!
    "Returns a list of cloud native tag keys matched by substring"
    cloudNativeTagKeys(
        "key substring for which you want to search keys"
        keySubStr: String!,
        "number of results to return"
        limit: Int!,
        "Type of managed object on which tag rule will be applied."
        objectType: CloudNativeTagObjectType!
    ): [String!]!
    "Cloud native tag rules."
    cloudNativeTagRules(
        "Fields and values according to which rules will be filtered."
        filters: [CloudNativeFilter!],
        "Type of managed object on which tag rule will be applied."
        objectType: CloudNativeTagObjectType!,
        sortBy: CloudNativeTagRuleSortByFields,
        sortOrder: HierarchySortOrder
    ): GetCloudNativeTagRulesReply!
    "Returns a list of cloud native tag values matched by substring"
    cloudNativeTagValues(
        "key value used only when searching for values"
        key: String!,
        "number of results to return"
        limit: Int!,
        "Type of managed object on which tag rule will be applied."
        objectType: CloudNativeTagObjectType!,
        "value substring for which you want to search values"
        valueSubStr: String!
    ): [String!]!
    "A cluster object."
    cluster(
        "The ID of the cluster."
        clusterUuid: UUID!
    ): Cluster!
    "List of the available cluster objects."
    clusterConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ClusterFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort clusters by field"
        sortBy: ClusterSortByEnum = ClusterType,
        "cluster sort order"
        sortOrder: SortOrderEnum = Desc
    ): ClusterConnection!
    clusterGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ClusterFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group by field"
        groupBy: ClusterGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): ClusterGroupByConnection!
    clusterGroupByUpgradeInfo(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "group by field"
        groupBy: UpgradeInfoGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0,
        upgradeFilter: CdmUpgradeInfoFilterInput
    ): UpgradeInfoGroupByConnection!
    "Info about the cluster product types the user is entitled to."
    clusterRegistrationProductInfo: ClusterRegistrationProductInfoType!
    clusterSlaDomainConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int
    ): ClusterSlaDomainConnection!
    clusterSlaDomainFilterConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int
    ): ClusterSlaDomainForFilterConnection!
    clusterTypeList: [GroupCount!]!
    clusterWithUpgradesInfo(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort upgradeInfo by field"
        sortBy: UpgradeInfoSortByEnum = ClusterType,
        "cluster sort order"
        sortOrder: SortOrderEnum = Desc,
        upgradeFilter: CdmUpgradeInfoFilterInput
    ): ClusterConnection!
    connectedClusterList(
        "Specification to filter cluster based on type"
        clusterFilterArg: ClusterTypeEnum
    ): [DataLocationSupportedCluster!]!
    countOfObjectsProtectedBySlas(
        filter: [Filter!],
        "Corresponds to optional object root forever UUID, none value is assumed to be the global hierarchy root"
        rootOptionalFid: UUID,
        "Provide a list of Global SLA Domain IDs"
        slaIds: [UUID!]!,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): CountOfObjectsProtectedBySLAsResult!
    "Return details for one crawl"
    crawl(crawlId: String!): Crawl!
    "Return crawls for an account"
    crawlConnection: CrawlConnection!
    "Browse CSRs"
    csrConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Search for a CSR"
        searchTerm: String,
        "Sort"
        sortBy: CertMgmtSortByEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): CsrConnection!
    currentIpAddress: String!
    currentUser: User!
    customAnalyzer(analyzerId: String!): Analyzer!
    "Return hits grouped by analyzer and policy"
    dashboardSummary(getWhitelistedResults: Boolean!): GetDashboardSummaryReply!
    dataViewMetadata: [dataViewMetadata!]!
    "Return permissions associated with a path"
    datagovSecDesc(
        "Skip converting SIDs in response to friendly names"
        skipResolveSids: Boolean,
        snappableFid: String!,
        snapshotFid: String!,
        stdPath: String!
    ): QuerySDDLReply!
    "Details of a db2 database for a given fid."
    db2Database(
        "The Polaris UUID for the object."
        fid: UUID!
    ): Db2Database!
    "Connection of filtered db2 databases based on specific filters."
    db2Databases(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): Db2DatabaseConnection!
    "Details of a db2 instance for a given fid."
    db2Instance(
        "The Polaris UUID of the Db2 instance."
        id: UUID!
    ): Db2Instance!
    "Connection of filtered db2 instances based on specific filters."
    db2Instances(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): Db2InstanceConnection!
    "Details of a Db2 log snapshot for a given fid."
    db2LogSnapshot(
        "The Polaris UUID of the Db2 Log Snapshot Object."
        db2LogSnapshotFid: UUID!
    ): Db2LogSnapshot!
    "Connection of all log snapshots for Db2."
    db2LogSnapshots(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter Db2 log snapshots by input"
        filter: Db2LogSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort Db2 log snapshots by field"
        sortBy: Db2LogSnapshotSortBy,
        "sort order"
        sortOrder: SortOrderEnum
    ): Db2LogSnapshotConnection!
    "Details of a Db2 recoverable range for a given fid."
    db2RecoverableRange(
        "The Polaris UUID of the Db2 Recoverable Range Object."
        db2RecoverableRangeFid: UUID!
    ): Db2RecoverableRange!
    "Connection of all recoverable ranges for Db2."
    db2RecoverableRanges(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter Db2 recoverable ranges by input"
        filter: Db2RecoverableRangeFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort Db2 recoverable ranges by field"
        sortBy: Db2RecoverableRangeSortBy,
        "sort order"
        sortOrder: SortOrderEnum
    ): Db2RecoverableRangeConnection!
    "Decrypt Export URL."
    decryptExportUrl(
        "Encrypted string of Export URL Specs containing arbitrary characters"
        exportUrlSpecsEnc: String!
    ): ExportUrlSpecs!
    "Polaris deployment version."
    deploymentVersion: String!
    """

    v5.0-v5.1: Discover bootstrappable nodes
    v5.2+: (DEPRECATED) Discover bootstrappable nodes

    Supported in v5.0+
    v5.0-v5.1: Searches for nodes bootstrappable to the specified Rubrik cluster
    v5.2+: Searches for nodes that can bootstrap into the specified Rubrik cluster. This endpoint will be moved to v1 in the next major version.
    """
    discoverNodes(
        "ID of the Rubrik cluster or *me* for self."
        id: String!
    ): BootstrappableNodeInfoListResponse!
    "Return timeline data for all policies of an account"
    discoveryTimeline(endDay: String!, getWhitelistedResults: Boolean!, startDay: String!, timezone: String!): GetPoliciesTimelineReply!
    "Checks if a resource group with the specified name exists in the specified account."
    doesAzureNativeResourceGroupExist(
        "The Native ID of the subscription."
        azureSubscriptionNativeId: UUID!,
        "The Rubrik ID of the cloud account."
        cloudAccountId: UUID!,
        "Cloud Account Feature. A feature refers to the Polaris feature that Rubrik provides."
        feature: CloudAccountFeature!,
        "The name of the resource group."
        resourceGroupName: String!
    ): Boolean!
    "Check if an organization exists."
    doesOrgExist(
        "Input required to check if org exists."
        input: DoesOrgExistInput!
    ): DoesOrgExistReply!
    downloadActiveSlaWithReplicationCsv(
        "UUID of the Rubrik cluster"
        cdmClusterUUID: UUID!,
        "Include Archived SLA"
        includeArchived: Boolean!
    ): DownloadActiveSlaWithReplicationCsvReply!
    "Download cdm upgrades table pdf."
    downloadCdmUpgradesPdf(
        "Filters for cdm upgrades page for pdf generation"
        downloadFilter: DownloadCdmUpgradesPdfFiltersInput
    ): DownloadCdmUpgradesPdfReply!
    "Get Status of download package job."
    downloadPackageStatus(
        "Cluster uuid"
        clusterUuid: UUID!
    ): DownloadPackageStatusReply!
    downloadReportLink(config: CustomReportCreate, id: Int!): DownloadLink!
    downloadReportPDFLink(config: CustomReportCreate, id: Int!): DownloadLink!
    downloadedVersionList: [GroupCount!]!
    dummyFieldWithAdminOnlyTag: Boolean!
    ec2Blueprint(
        "The Polaris UUID for the object."
        fid: UUID!
    ): Ec2Blueprint!
    "Fetch access token for envoy registration script."
    envoyRegistrationToken(
        "ID of the tenant network in which envoy VM is to be registered."
        tenantNetworkId: UUID!
    ): FetchEnvoyRegTokenReply!
    eventDigest(recipientUserIDs: [String!]!): [EventDigest!]!
    "Details of an Exchange DAG for a given fid."
    exchangeDag(
        "The Polaris UUID for the object."
        fid: UUID!
    ): ExchangeDag!
    "Connection of filtered Exchange DAGs based on specific filters."
    exchangeDags(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): ExchangeDagConnection!
    "Details of an Exchange Database for a given fid."
    exchangeDatabase(
        "The Polaris UUID for the object."
        fid: UUID!
    ): ExchangeDatabase!
    "Connection of filtered Exchange Databases based on specific filters."
    exchangeDatabases(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): ExchangeDatabaseConnection!
    "Paginated list of Exchange Database live mounts."
    exchangeLiveMounts(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Filter for exchange live mounts."
        filters: [ExchangeLiveMountFilterInput!],
        "Returns the first n elements from the list."
        first: Int,
        "Sort by argument for exchange live mounts."
        sortBy: ExchangeLiveMountSortByInput
    ): ExchangeLiveMountConnection!
    "Details of an Exchange Server for a given fid."
    exchangeServer(
        "The Polaris UUID for the object."
        fid: UUID!
    ): ExchangeServer!
    "Connection of filtered Exchange Servers based on specific filters."
    exchangeServers(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): ExchangeServerConnection!
    "Customer facing Polaris deployment name."
    externalDeploymentName: String!
    "failover"
    failover(
        "failover ID"
        failoverId: String!
    ): Failover
    failoverAllSourceConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int
    ): FailoverSourceConnection!
    failoverAllTargetSiteConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int
    ): FailoverTargetSiteConnection!
    "Get details of the given failover cluster app."
    failoverClusterApp(
        "The Polaris UUID for the object."
        fid: UUID!
    ): FailoverClusterApp!
    "Get a summary of all failover cluster apps."
    failoverClusterApps(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "host failover cluster root type"
        hostFailoverClusterRoot: HostFailoverClusterRoot!,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): FailoverClusterAppConnection!
    "Get a summary of all failover cluster top level descendants."
    failoverClusterTopLevelDescendants(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "host failover cluster root type"
        hostFailoverClusterRoot: HostFailoverClusterRoot!,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): FailoverClusterTopLevelDescendantTypeConnection!
    failoverConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter appflows failover jobs by input"
        filter: FailoverFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort appflows failover jobs by field"
        sortBy: FailoverSortByEnum = AppBlueprintName,
        "failover jobs sort order"
        sortOrder: SortOrderEnum = Desc,
        timezoneOffset: Float = 0.0
    ): FailoverConnection!
    failoverGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter appflows failover jobs by input"
        filter: FailoverFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group appflows failover jobs by a field"
        groupBy: FailoverGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): FailoverGroupByConnection!
    failoverJobReports(
        "The Polaris UUID for the object."
        fid: UUID!
    ): [FailoverJobReport!]!
    "The report for the failover job."
    failoverReport(
        "failover report ID"
        failoverReportId: String!
    ): FailoverReport
    "Evaluate a single feature flag and get the result"
    featureFlag(
        "List of flag names to evaluate"
        entityContext: [FeatureFlagContextField!],
        "The type of entity context to evaluate against. The value of this arg determines how the entity ID is inferred."
        entityType: FeatureFlagEntityTypeEnum!,
        "Name of flag to evaluate"
        flagName: FeatureFlagNameEnum!
    ): FeatureFlag!
    "Evaluate all known feature flags."
    featureFlagAll(
        "List of flag names to evaluate"
        entityContext: [FeatureFlagContextField!],
        "The type of entity context to evaluate against. The value of this arg determines how the entity ID is inferred."
        entityType: FeatureFlagEntityTypeEnum!
    ): FeatureFlagAll!
    "Get names of feature flags that surfaced in APIs"
    featureFlagNames: [String!]!
    "Status of the federated login."
    federatedLoginStatus: FederatedLoginStatus!
    "Fetch fake data for testing purpose"
    fetchFakeData(
        "Buffer space allocated before making an RPC."
        preProcessingBufferBytes: Long,
        "Time taken by the request to serve the response"
        responsePeriodMs: Long!,
        "Approx size of the response payload."
        responseSizeBytes: Long,
        "Whether the request blocks the processing thread."
        shouldBlock: Boolean!
    ): FakeDataConnection!
    filesetSnapshot(
        "ID of snapshot."
        id: String!,
        "Whether or not to fetch verbose fileset snapshot information. The performance of this endpoint will decrease if set to true."
        verbose: Boolean
    ): FilesetSnapshotDetail!
    filesetTemplate(
        "The Polaris UUID for the object."
        fid: UUID!
    ): FilesetTemplate!
    "Get a summary of all fileset templates."
    filesetTemplates(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "host root type"
        hostRoot: HostRoot!,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): FilesetTemplateConnection!
    "Check Gcp Projects permissions for addition."
    gcpCloudAccountCheckProjectPermissionsForAddition(
        "List of Gcp project native Ids."
        projectIds: [String!]!,
        "Session ID of the current OAuth session."
        sessionId: String!
    ): [GcpCloudAccountMissingPermissionsForAddition!]!
    "List permissions required to enable the given feature"
    gcpCloudAccountListPermissions(
        "Cloud Account Feature. A feature refers to the Polaris feature that Rubrik provides."
        feature: CloudAccountFeature!
    ): [GcpPermission!]!
    "Get the details of the Gcp project configured for a feature"
    gcpCloudAccountListProjects(
        "Cloud Account Feature. A feature refers to the Polaris feature that Rubrik provides."
        feature: CloudAccountFeature!,
        "Search text for project name, native id and number."
        projectSearchText: String!,
        "List of project status filters to apply."
        projectStatusFilters: [CloudAccountStatus!]!
    ): [GcpCloudAccountProjectDetail!]!
    "List Gcp Projects to add after successful authorization."
    gcpCloudAccountListProjectsForOAuth(
        "Whether to check permission of projects required for addition"
        checkPermissions: Boolean!,
        "Cloud Account Features."
        features: [CloudAccountFeature!]!,
        "Session ID of the current OAuth session."
        sessionId: String!
    ): [GcpListProjectsForOAuthResponse!]!
    "Returns the service account corresponding to global credentials. Return empty string if global credentials are absent"
    gcpGetDefaultCredentialsServiceAccount: String!
    "Get details of a GCP Disk"
    gcpNativeDisk(
        "The Polaris UUID for the object."
        fid: UUID!
    ): GcpNativeDisk!
    "List of GCP disks."
    gcpNativeDisks(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        diskFilters: GcpNativeDiskFilters,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Sort fields for list of GCP disks."
        sortBy: GcpNativeDiskSortFields,
        sortOrder: HierarchySortOrder
    ): GcpNativeDiskConnection!
    "Get details of a GCE Instance"
    gcpNativeGceInstance(
        "The Polaris UUID for the object."
        fid: UUID!
    ): GcpNativeGCEInstance!
    "List of GCE instances."
    gcpNativeGceInstances(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        gceInstanceFilters: GcpNativeGceInstanceFilters,
        "Returns the last n elements from the list."
        last: Int,
        "Sort fields for list of GCP GCE instances."
        sortBy: GcpNativeGceInstanceSortFields,
        sortOrder: HierarchySortOrder
    ): GcpNativeGCEInstanceConnection!
    "lists GCP KMS Crypto keys accessible in the provided region"
    gcpNativeListAvailableKMSCryptoKeys(
        "ID of the Project."
        projectId: UUID!,
        "native name of GCP region"
        regionName: String!
    ): [KMSCryptoKey!]!
    "Get details of a GCP Project"
    gcpNativeProject(
        "The Polaris UUID for the object."
        fid: UUID!
    ): GcpNativeProject!
    "List of GCP projects."
    gcpNativeProjects(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        authorizedOperationFilter: OperationEnum,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        projectFilters: GcpNativeProjectFilters,
        "provide optional snappable hierarchy for RBAC and SLA, none value is assumed to be All snappable hierarchy"
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        "Sort fields for list of GCP projects."
        sortBy: GcpNativeProjectSortFields,
        sortOrder: HierarchySortOrder
    ): GcpNativeProjectConnection!
    "lists all the GCP projects with accessible networks in this service project"
    gcpNativeProjectsWithAccessibleNetworks(
        "ID of the Project."
        projectId: UUID!
    ): [NetworkHostProject!]!
    "lists distinct regions and zones of the GCP disks stored with Polaris"
    gcpNativeStoredDiskLocations(
        "UUID of the Project (Optional)"
        projectId: UUID
    ): ListStoredDiskLocationsReply!
    "lists all the distinct machine types of the GCP instances stored with Polaris"
    gcpNativeStoredMachineTypes: [String!]!
    "lists all the distinct machine types of the GCP instances stored with Polaris"
    gcpNativeStoredMachineTypesInProject(
        "ID of the Project."
        projectId: UUID!
    ): [String!]!
    "lists all the distinct network names of the GCP instances stored with Polaris"
    gcpNativeStoredNetworkNames: [String!]!
    "lists all the distinct network names of the GCP instances stored with Polaris"
    gcpNativeStoredNetworkNamesInProject(
        "ID of the Project."
        projectId: UUID!
    ): [String!]!
    "lists all the distinct regions of the GCP instances stored with Polaris"
    gcpNativeStoredRegions: [String!]!
    "lists all the distinct regions of the GCP instances stored with Polaris"
    gcpNativeStoredRegionsInProject(
        "ID of the Project."
        projectId: UUID!
    ): [String!]!
    geoLocationList: [GroupCount!]!
    "Obtain account settings value."
    getAccountSettingValue(
        "Name of component that uses ASP in account setting table"
        aspComponent: ComponentEnum!,
        "Name of parameter (ASP) in account setting table"
        aspName: String!
    ): ASPValue!
    getAllRolesInOrgConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Name to filter the results by."
        nameFilter: String,
        sortBy: RoleFieldEnum = Name,
        "sort order"
        sortOrder: SortOrderEnum
    ): RoleConnection!
    getAllTemplatesInOrgConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Name to filter the results by."
        nameFilter: String
    ): RoleTemplateConnection!
    getAllUsersOnAccount(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int
    ): [User!]!
    getAuthorizationsForGlobalResource: [OperationEnum!]!
    getAuthorizationsForObject(
        "The Polaris UUID for the object."
        fid: UUID!
    ): [OperationEnum!]!
    "Get CDM release details from support portal for a given list of clusters."
    getCdmReleaseDetailsForClusterFromSupportPortal(
        "Should fetch version details"
        fetchLinks: Boolean! = false,
        "Filter to include only those releases released after source version"
        filterAfterSource: Boolean! = false,
        "Should filter upgradeable versions"
        filterUpgradeable: Boolean! = true,
        "Prefix filter for available versions"
        filterVersion: String! = "",
        "List of cluster uuids"
        listClusterUuid: [UUID!]!,
        "Should show all versions"
        shouldShowAll: Boolean! = true,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmUpgradeReleaseDetailsFromSupportPortalReply!
    "Get CDM release details from support portal for a given list of clusters specific to a target version."
    getCdmReleaseDetailsForVersionFromSupportPortal(
        "Should fetch version details"
        fetchLinks: Boolean! = false,
        "Filter to include only those releases released after source version"
        filterAfterSource: Boolean! = false,
        "Should filter upgradeable versions"
        filterUpgradeable: Boolean! = true,
        "Prefix filter for available versions"
        filterVersion: String! = "",
        "List of cluster uuids"
        listClusterUuid: [UUID!]!,
        "Should show all versions"
        shouldShowAll: Boolean! = true,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmUpgradeReleaseDetailsFromSupportPortalReply!
    "Get available versions on support portal for a cluster."
    getCdmReleaseDetailsFromSupportPortal(
        "Should fetch version details"
        fetchLinks: Boolean! = false,
        "Filter to include only those releases released after source version"
        filterAfterSource: Boolean! = false,
        "Should filter upgradeable versions"
        filterUpgradeable: Boolean! = true,
        "Prefix filter for available versions"
        filterVersion: String! = "",
        "Number of nodes in the cluster"
        nodeCount: Long! = 4,
        "Platform type of the cluster"
        platform: String! = "",
        "Should show all versions"
        shouldShowAll: Boolean! = true,
        "sort order"
        sortOrder: SortOrderEnum,
        "Source version of the cluster"
        sourceVersion: String! = ""
    ): CdmUpgradeReleaseDetailsFromSupportPortalReply!
    getClusterNodes(
        "The ID of the cluster."
        clusterUuid: UUID!
    ): NodeStatusListResp!
    "Get DNS server addresses."
    getDns: [String!]!
    getGroupCountByCdmClusterStatus: GroupCountListWithTotal!
    getGroupCountByPrechecksStatus: [GroupCount!]!
    getGroupCountByUpgradeJobStatus: [GroupCount!]!
    getGroupCountByVersionStatus: [GroupCount!]!
    getHostDiagnosis(
        "ID assigned to the host object."
        id: String!
    ): HostDiagnosisSummary!
    getKorgTaskchainStatus(taskchainId: String!): GetTaskchainStatusReply!
    "Get NTP server addresses."
    getNtp: [String!]!
    getO365ServiceStatus(orgID: UUID): GetO365ServiceStatusResp!
    getO365StorageStats(orgID: UUID): GetO365StorageStatsResp!
    getPermissions(roleId: String!): [Permission!]!
    getRolesByIds(roleIds: [String!]!): [Role!]!
    "Get whether alerts for a given snappable are enabled"
    getSnappableAlertSetting(
        "The ID of the cluster."
        clusterUuid: UUID!,
        "The FID of the snappable."
        snappableId: UUID!
    ): GetSnappableAlertSettingReply!
    getSupportTunnelStatus(
        "The ID of the cluster."
        clusterUuid: UUID!,
        nodeId: String!
    ): SupportTunnelInfoResp!
    getTaskchainInfo(
        "Job type"
        jobType: String!,
        "Taskchain uuid"
        taskchainId: String!
    ): GetTaskchainInfoReply!
    getUserDownloads(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int
    ): [UserDownload!]!
    "All files matching input filters."
    globalFileSearch(
        "Input for InternalGlobalSearchApiQuery"
        input: GlobalSearchApiQueryInput!
    ): GlobalSearchApiResponseListResponse!
    globalSearchResults(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): HierarchyObjectConnection!
    globalSlaConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Specification on what context filter to use."
        contextFilter: ContextFilterTypeEnum,
        "Specification on what context filter input to use."
        contextFilterInput: [ContextFilterInputField!],
        filter: [GlobalSlaFilterInput!],
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Specifies whether to show the Rubrik clusters where this Global SLA Domain is paused."
        shouldShowPausedClusters: Boolean = false,
        "Specifies whether to show the number of workloads protected by the SLA Domain."
        shouldShowProtectedObjectCount: Boolean = false,
        "Specifies whether to show the Global SLA Domain sync status on Rubrik CDM."
        shouldShowSyncStatus: Boolean = false,
        "Specifies whether to show the upgrade information for an SLA Domain or not."
        shouldShowUpgradeInfo: Boolean = false,
        "Whether or not to show the remote CDM SLAs, by default we do not fetch remote SLAs."
        showRemoteSlas: Boolean,
        sortBy: SLAQuerySortByFieldEnum,
        sortOrder: SLAQuerySortByOrderEnum
    ): SlaDomainConnection!
    globalSlaFilterConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Specification on what context filter to use."
        contextFilter: ContextFilterTypeEnum,
        "Specification on what context filter input to use."
        contextFilterInput: [ContextFilterInputField!],
        filter: [GlobalSlaFilterInput!],
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Specifies whether to show the Rubrik clusters where this Global SLA Domain is paused."
        shouldShowPausedClusters: Boolean = false,
        "Specifies whether to show the number of workloads protected by the SLA Domain."
        shouldShowProtectedObjectCount: Boolean = false,
        "Specifies whether to show the Global SLA Domain sync status on Rubrik CDM."
        shouldShowSyncStatus: Boolean = false,
        "Specifies whether to show the upgrade information for an SLA Domain or not."
        shouldShowUpgradeInfo: Boolean = false,
        "Whether or not to show the remote CDM SLAs, by default we do not fetch remote SLAs."
        showRemoteSlas: Boolean,
        sortBy: SLAQuerySortByFieldEnum,
        sortOrder: SLAQuerySortByOrderEnum
    ): GlobalSlaForFilterConnection!
    "Status on the clusters where global SLA is synced."
    globalSlaStatuses(
        "SLA ID for global SLAs."
        SlaId: UUID!,
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Filters for SLAStatus."
        filter: [SlaStatusFilterInput!],
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int
    ): PolarisSlaStatusConnection!
    guestCredentials(
        "Input for InternalQueryGuestCredential"
        input: QueryGuestCredentialInput!
    ): GuestCredentialDetailListResponse!
    hierarchyObject(
        "The Polaris UUID for the object."
        fid: UUID!
    ): HierarchyObject!
    hierarchyObjects(fids: [UUID!]!, filter: [Filter!]): [HierarchyObject!]!
    hierarchySnappables(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): HierarchySnappableConnection!
    "Get details of the given host failover cluster."
    hostFailoverCluster(
        "The Polaris UUID for the object."
        fid: UUID!
    ): HostFailoverCluster!
    "Get a summary of all host failover clusters."
    hostFailoverClusters(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "host failover cluster root type"
        hostFailoverClusterRoot: HostFailoverClusterRoot!,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): HostFailoverClusterConnection!
    hostShare(
        "The Polaris UUID for the object."
        fid: UUID!
    ): HostShare!
    hostShareConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): HostShareConnection!
    "Total number of host volumes the account has."
    hostVolumesCount: Int!
    "Details of the given Hyper-V Cluster."
    hypervCluster(
        "The Polaris UUID for the object."
        fid: UUID!
    ): HyperVCluster!
    "HyperV Live Mount Connection."
    hypervMounts(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Filter for hyper-v live mounts."
        filters: [HyperVLiveMountFilterInput!],
        "Returns the first n elements from the list."
        first: Int,
        "Sort by argument for hyper-v live mounts."
        sortBy: HyperVLiveMountSortByInput
    ): HyperVLiveMountConnection!
    "Details of the given Hyper-V SCVMM."
    hypervScvmm(
        "The Polaris UUID for the object."
        fid: UUID!
    ): HyperVSCVMM!
    "Paginated list of HyperV SCVMMs."
    hypervScvmms(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): HyperVSCVMMConnection!
    "Details of the given Hyper-V Server."
    hypervServer(
        "The Polaris UUID for the object."
        fid: UUID!
    ): HyperVServer!
    """

    Get summary of all the Hyper-V hosts

    Supported in v5.0+
    Get summary of all the Hyper-V hosts.
    """
    hypervServers(
        "Input for InternalQueryHypervHost"
        input: QueryHypervHostInput!
    ): HypervHostSummaryListResponse!
    "Paginated list of the highest-level HyperV Objects accessible by the current user."
    hypervTopLevelDescendants(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): HyperVTopLevelDescendantTypeConnection!
    "Details of the given Hyper-V Virtual Machine."
    hypervVirtualMachine(
        "The Polaris UUID for the object."
        fid: UUID!
    ): HyperVVirtualMachine!
    "Paginated list of HyperV Virtual Machines."
    hypervVirtualMachines(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): HyperVVirtualMachineConnection!
    identityProviders: [IdentityProvider!]!
    installedVersionList: [InstalledVersionGroupCount!]!
    "list the available Instance Types"
    instanceTypeConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "the id of the blueprint"
        blueprintId: UUID!,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "NamePrefix is prefix for filtering down suggestions"
        namePrefix: String,
        "the fid of the snappable"
        snappableId: UUID,
        "the fid of the snapshot"
        snapshotId: UUID,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): SnappableInstanceTypeConnection!
    inventoryRoot: InventoryRoot!
    inventorySubHierarchyRoot(rootEnum: InventorySubHierarchyRootEnum!): InventorySubHierarchyRoot!
    "Link to downloadable investigation results in CSV format."
    investigationCsvDownloadLink(
        "The ID of the cluster."
        clusterUuid: UUID!,
        "Snappable Id of an object."
        snappableIdNotFid: String!,
        "Corresponds to snapshot ID in CDM tables"
        snapshotId: String!
    ): InvestigationCsvDownloadLinkReply!
    ipWhitelist: GetWhitelistReply!
    "Specified whether an EBS volume is restorable. For an EBS Volume to be restorable, the volume should be able to replace where attached."
    isAwsNativeEbsVolumeSnapshotRestorable(
        "UUID of the snapshot"
        snapshotId: String!
    ): IsVolumeSnapshotRestorableReply!
    "Specifies whether the given DbInstance class, storage type, multi-az capability, encryption capability, iops value are supported for the given dbEngine, dbEngineVersion in the specified availability zone. When true, the specification is valid for a RDS Instance and can be used to create a new Instance."
    isAwsNativeRdsInstanceLaunchConfigurationValid(
        "Rubrik ID for AWS account."
        awsAccountRubrikId: UUID!,
        "DB class of the exported RDS DB instance."
        dbClass: AwsNativeRdsDbInstanceClass!,
        "DB Engine of RDS Instance."
        dbEngine: AwsNativeRdsDbEngine!,
        "Version of DB engine."
        dbEngineVersion: String!,
        "IOPs of the exported RDS DB instance."
        iops: Int,
        "Whether the exported RDS DB instance is multi-AZ or not."
        isMultiAz: Boolean!,
        "KMS Key ID of the exported RDS DB instance."
        kmsKeyId: String,
        "AZ in which the exported RDS DB instance must be launched."
        primaryAz: String,
        "Region in AWS."
        region: AwsNativeRegion!,
        "Storage type of the exported RDS DB instance."
        storageType: AwsNativeRdsStorageType
    ): Boolean!
    "Specifies whether an S3 bucket name is available for use in AWS or not. When true, the bucket name is available for use."
    isAwsS3BucketNameAvailable(
        "Rubrik ID for AWS account."
        awsAccountRubrikId: UUID!,
        "Name of the S3 bucket."
        bucketName: String!
    ): Boolean!
    "Specifies whether the Managed Disk snapshot is restorable or not. A managed disk is restorable when the restore settings of the Managed Disk are configured on the Azure portal and on the Rubrik platform. When the value is true, the managed disk snapshot is restorable."
    isAzureNativeManagedDiskSnapshotRestorable(
        "Rubrik ID of the Azure Subscription."
        azureSubscriptionRubrikId: UUID!,
        "Snapshot ID"
        diskSnapshotId: UUID!
    ): Boolean!
    "Specifies whether the given storage account name is valid and available in Azure to be assigned to a new storage account. When the value is true, the specified account name is available in Azure."
    isAzureStorageAccountNameAvailable(
        "Rubrik ID of the Azure Subscription."
        azureSubscriptionRubrikId: UUID!,
        "A unique name for the storage account. Storage account names must be between 3 and 24 characters in length and may contain numbers and lowercase letters only."
        storageAccountName: String!
    ): Boolean!
    "List of snapshots with their file recovery feasibility status"
    isCloudNativeFileRecoveryFeasible(
        "List of snapshot IDs."
        snapshotIds: [UUID!]!
    ): ValidateCloudNativeFileRecoveryFeasibilityReply!
    "Is Logged into Rubrik support portal."
    isLoggedIntoRubrikSupportPortal: SupportPortalStatusReply!
    "Is Rubrik Suppport Portal reachable from this deployment."
    isSFDCReachable(
        "Support portal hostname"
        hostname: String! = "rubrik.force.com",
        "Support portal organization ID"
        organizationId: String! = "00D40000000N3x2"
    ): Boolean!
    "Is upgrade available for a particular cluster."
    isUpgradeAvailable(
        "Cluster uuid"
        clusterUuid: UUID!
    ): CdmUpgradeAvailabilityReply!
    "Is upgrade recommended for a particular cluster."
    isUpgradeRecommended(
        "Cluster uuid"
        clusterUuid: UUID!
    ): CdmUpgradeRecommendationReply!
    isVMwareManagementEnabled: Boolean!
    "Return details of one issue"
    issue(issueId: String!): Issue!
    "Return all issues filtered by status"
    issueConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        status: IssueStatusEnum!
    ): IssueConnection!
    k8sCluster(
        "The Polaris UUID for the object."
        fid: UUID!
    ): K8sCluster!
    k8sClusters(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): K8sClusterConnection!
    k8sNamespace(
        "The Polaris UUID for the object."
        fid: UUID!
    ): K8sNamespace!
    k8sNamespaces(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Optional Kubernetes cluster UUID."
        k8sClusterId: UUID,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): K8sNamespaceConnection!
    lambdaSettings: LambdaSettings!
    "Browse LDAP authorized principals"
    ldapAuthorizedPrincipalConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Assigned role IDs for LDAP principal."
        roleIds: [UUID!],
        "Search Text for LDAP principal."
        searchText: String!,
        sortBy: LdapAuthorizedPrincipalFieldEnum = Name,
        "sort order"
        sortOrder: SortOrderEnum
    ): AuthorizedPrincipalConnection!
    "Browse LDAP Integrations"
    ldapIntegrationConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        sortBy: LdapIntegrationFieldEnum = Name,
        "sort order"
        sortOrder: SortOrderEnum
    ): LdapIntegrationConnection!
    "Search LDAP Principals"
    ldapPrincipalConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "ID for your LDAP integration."
        id: UUID!,
        "Returns the last n elements from the list."
        last: Int,
        "Search Text for LDAP principal."
        searchText: String!,
        sortBy: LdapPrincipalFieldEnum = Name,
        "sort order"
        sortOrder: SortOrderEnum
    ): PrincipalConnection!
    "List of legal hold snapshots for snappable."
    legalHoldSnapshotsForSnappable(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Query legal hold snapshots for snappable."
        input: LegalHoldSnapshotsForSnappableInput!,
        "Returns the last n elements from the list."
        last: Int
    ): LegalHoldSnapshotDetailConnection!
    linuxFileset(
        "The Polaris UUID for the object."
        fid: UUID!
    ): LinuxFileset!
    "List ids of running issues jobs"
    listIssuesJobStatus(queryIds: [String!]!): [String!]!
    listO365Apps(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the first n elements from the list."
        first: Int,
        o365AppFilters: [AppFilter!]!,
        o365AppSortByParam: AppSortByParam
    ): O365AppConnection!
    """

    Get the result of a completed detection

    Supported in v6.0+
    Get the details of a completed malware detection.
    """
    malwareDetectionTaskResult(
        "Input for InternalGetLambdaDetectMalwareResult"
        input: GetLambdaDetectMalwareResultInput!
    ): MalwareScanResults!
    """

    Get the result of a completed detection

    Supported in v6.0+
    Get the details of a completed malware detection.
    """
    malwareDetectionTaskStatus(
        "Input for InternalGetLambdaDetectMalwareRequestStatus"
        input: GetLambdaDetectMalwareRequestStatusInput!
    ): AsyncRequestStatus!
    """

    Get asynchronous request details for a malware detection

    Supported in v6.0+
    Get the details of an asynchronous malware detection.
    """
    malwareScanDetail(
        "Input for InternalGetLambdaMalwareScanDetail"
        input: GetLambdaMalwareScanDetailInput!
    ): GetLambdaMalwareScanDetailReply!
    """

    List malware scans

    Supported in v6.0+
    List the malware scans.
    """
    malwareScans(
        "Input for InternalListMalwareScans"
        input: ListMalwareScansInput!
    ): MalwareScanDetailListResponse!
    "Details of a Managed Volume Object."
    managedVolume(
        "The Polaris UUID for the object."
        fid: UUID!
    ): ManagedVolume!
    "Paginated list of Managed Volumes."
    managedVolumes(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): ManagedVolumeConnection!
    "Get MFA settings for for an account."
    mfaSetting: GetMfaSettingReply!
    "Recoverable range for multiple Management Objects."
    mongodbBulkRecoverableRange(
        "Input for V2MosaicBulkRecoveryRange"
        input: MosaicBulkRecoveryRangeInput!
    ): MosaicRecoveryRangeResponse!
    """

    Provides details for a MongoDB collection identified by fid.
    MongoDB stores data records as documents which are gathered together in collections.
    For more info refer to : https://docs.mongodb.com/manual/core/databases-and-collections
    """
    mongodbCollection(
        "The Polaris UUID for the object."
        fid: UUID!
    ): MongodbCollection!
    "Recoverable Range of a Mongodb collection."
    mongodbCollectionRecoverableRange(
        "Input for V2GetMosaicRecoverableRange"
        input: GetMosaicRecoverableRangeInput!
    ): GetMosaicRecoverableRangeResponse!
    "Paginated list of MongoDB collections."
    mongodbCollections(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): MongodbCollectionConnection!
    """

    Provides details for a MongoDB database identified by fid.
    MongoDB stores data records as documents which are gathered together in collections.
    A database stores one or more collections of documents.
    For more info refer to : https://docs.mongodb.com/manual/core/databases-and-collections/
    """
    mongodbDatabase(
        "The Polaris UUID for the object."
        fid: UUID!
    ): MongodbDatabase!
    "Paginated list of MongoDB databases."
    mongodbDatabases(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): MongodbDatabaseConnection!
    """

    Provides details for the MongoDB source cluster identified by the fid.
    For MongoDB, the term "source" is usually used for either a replica set or a sharded cluster.
    For more info on MongoDB cluster refer to : https://docs.mongodb.com/manual/introduction/
    """
    mongodbSource(
        "The Polaris UUID for the object."
        fid: UUID!
    ): MongodbSource!
    "Paginated list of MongoDB sources."
    mongodbSources(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): MongodbSourceConnection!
    "Get recoverable range for multiple Management Objects."
    mosaicBulkRecoveryRange(
        "Input for V2MosaicBulkRecoveryRange"
        input: MosaicBulkRecoveryRangeInput!
    ): MosaicRecoveryRangeResponse!
    "List snapshots of a mosaic object."
    mosaicSnapshots(
        "Input for V2GetMosaicVersion"
        input: GetMosaicVersionInput!
    ): ListVersionResponse!
    "List all stores on mosaic cluster."
    mosaicStores(
        "Input for V2GetMosaicStore"
        input: GetMosaicStoreInput!
    ): ListStoreResponse!
    "List versions of a mosaic object."
    mosaicVersions(
        "Input for V2GetMosaicVersion"
        input: GetMosaicVersionInput!
    ): ListVersionResponse!
    "A Microsoft SQL Availability Group."
    mssqlAvailabilityGroup(
        "The Polaris UUID for the object."
        fid: UUID!
    ): MssqlAvailabilityGroup!
    "Returns all compatible instances for export for the specified recovery time."
    mssqlCompatibleInstances(
        "Input for V1GetCompatibleMssqlInstancesV1"
        input: GetCompatibleMssqlInstancesV1Input!
    ): MssqlInstanceSummaryListResponse!
    "A Microsoft SQL Database."
    mssqlDatabase(
        "The Polaris UUID for the object."
        fid: UUID!
    ): MssqlDatabase!
    "Paginated list of Microsoft SQL Database live mounts."
    mssqlDatabaseLiveMounts(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Filters for Mssql database live mounts."
        filters: [MssqlDatabaseLiveMountFilterInput!],
        "Returns the first n elements from the list."
        first: Int,
        "Sort by argument for Mssql database live mounts."
        sortBy: MssqlDatabaseLiveMountSortByInput
    ): CdmMssqlDatabaseLiveMountConnection!
    "List of missed recoverable ranges for a Microsoft SQL Database."
    mssqlDatabaseMissedRecoverableRanges(
        "Input for V1GetMssqlDbMissedRecoverableRanges"
        input: GetMssqlDbMissedRecoverableRangesInput!
    ): MssqlMissedRecoverableRangeListResponse!
    "List of missed snapshots for a Microsoft SQL Database."
    mssqlDatabaseMissedSnapshots(
        "Input for V1GetMissedMssqlDbSnapshots"
        input: GetMissedMssqlDbSnapshotsInput!
    ): MissedSnapshotListResponse!
    "Returns a size estimate for a restore, export, or mount."
    mssqlDatabaseRestoreEstimate(
        "Input for V1MssqlRestoreEstimateV1"
        input: MssqlRestoreEstimateV1Input!
    ): MssqlRestoreEstimateResult!
    "Paginated list of Microsoft SQL Databases."
    mssqlDatabases(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): MssqlDatabaseConnection!
    "The current default properties for Microsoft SQL databases."
    mssqlDefaultProperties(
        "Input for V1GetDefaultDbPropertiesV1"
        input: GetDefaultDbPropertiesV1Input!
    ): MssqlDbDefaults!
    "A Microsoft SQL Instance."
    mssqlInstance(
        "The Polaris UUID for the object."
        fid: UUID!
    ): MssqlInstance!
    "List of recoverable ranges for a Microsoft SQL Database."
    mssqlRecoverableRanges(
        "Input for V1GetMssqlDbRecoverableRanges"
        input: GetMssqlDbRecoverableRangesInput!
    ): MssqlRecoverableRangeListResponse!
    "Paginated list of the highest-level Microsoft SQL Objects accessible by the current user."
    mssqlTopLevelDescendants(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): MssqlTopLevelDescendantTypeConnection!
    "A NAS Namespace."
    nasNamespace(
        "The Polaris UUID for the object."
        fid: UUID!
    ): NasNamespace!
    "Paginated list of NAS Namespaces."
    nasNamespaces(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): NasNamespaceConnection!
    "A NAS Share."
    nasShare(
        "The Polaris UUID for the object."
        fid: UUID!
    ): NasShare!
    "A NAS System."
    nasSystem(
        "The Polaris UUID for the object."
        fid: UUID!
    ): NasSystem!
    "Paginated list of NAS Systems."
    nasSystems(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): NasSystemConnection!
    "Paginated list of the highest-level NAS Objects accessible by the current user."
    nasTopLevelDescendants(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): CdmHierarchyObjectConnection!
    "A NAS Volume."
    nasVolume(
        "The Polaris UUID for the object."
        fid: UUID!
    ): NasVolume!
    "A Nutanix Cluster."
    nutanixCluster(
        "The Polaris UUID for the object."
        fid: UUID!
    ): NutanixCluster!
    """

    Get Nutanix cluster async request

    Supported in v5.0+
    Get details about a Nutanix cluster-related async request.
    """
    nutanixClusterAsyncRequestStatus(
        "Input for InternalGetNutanixClusterAsyncRequestStatus"
        input: GetNutanixClusterAsyncRequestStatusInput!
    ): AsyncRequestStatus!
    """

    Get list of containers on this cluster

    Supported in v5.0+
    Query the nutanix cluster to get the list of containers, used for export purposes.
    """
    nutanixClusterContainers(
        "Input for InternalGetContainers"
        input: GetContainersInput!
    ): NutanixContainerListResponse!
    "Paginated list of Nutanix Clusters."
    nutanixClusters(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): NutanixClusterConnection!
    "Nutanix Live Mount Connection."
    nutanixMounts(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Filter for Nutanix VM live mounts."
        filters: [NutanixLiveMountFilterInput!],
        "Returns the first n elements from the list."
        first: Int,
        "Sort by argument for Nutanix VM live mounts."
        sortBy: NutanixLiveMountSortByInput
    ): NutanixLiveMountConnection!
    "Paginated list of the highest-level Nutanix Objects accessible by the current user."
    nutanixTopLevelDescendants(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): CdmHierarchyObjectConnection!
    "A Nutanix Virtual Machine."
    nutanixVm(
        "The Polaris UUID for the object."
        fid: UUID!
    ): NutanixVm!
    """

    Get VM async request details

    Supported in v5.0+
    Get details about a Nutanix VM-related async request.
    """
    nutanixVmAsyncRequestStatus(
        "Input for InternalGetNutanixVmAsyncRequestStatus"
        input: GetNutanixVmAsyncRequestStatusInput!
    ): AsyncRequestStatus!
    """

    Get details about missed snapshots for a VM

    Supported in v5.0+
    Retrieve the time of the day when the snapshots were missed specific to a vm.
    """
    nutanixVmMissedSnapshots(
        "Input for InternalNutanixMissedSnapshots"
        input: NutanixMissedSnapshotsInput!
    ): MissedSnapshotListResponse!
    "Paginated list of Nutanix Virtual Machines."
    nutanixVms(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): NutanixVmConnection!
    o365Calendar(snappableFid: UUID!): O365Calendar!
    "List of O365 Groups in the O365Org."
    o365Groups(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        o365OrgId: UUID!,
        snappableType: SnappableType!,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): O365GroupConnection!
    "Retrieve o365 licence details."
    o365License: O365License!
    o365Mailbox(snappableFid: UUID!): O365Mailbox!
    "List of Mailboxes of O365Org"
    o365Mailboxes(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        o365OrgId: UUID!,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): O365MailboxConnection!
    o365ObjectAncestors(snappableFid: UUID!): GetImplicitlyAuthorizedAncestorSummariesResponse!
    o365Onedrive(snappableFid: UUID!): O365Onedrive!
    "List of Onedrives of O365Org"
    o365Onedrives(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        o365OrgId: UUID!,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): O365OnedriveConnection!
    o365Org(
        "The Polaris UUID for the object."
        fid: UUID!
    ): O365Org!
    o365OrgAtSnappableLevel(
        "The Polaris UUID for the object."
        fid: UUID!,
        snappableType: SnappableType!
    ): O365Org!
    o365OrgSummaries: GetImplicitlyAuthorizedObjectSummariesResponse!
    o365Orgs(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): O365OrgConnection!
    o365ServiceAccount(orgId: UUID!): O365ServiceAccountStatusResp!
    o365SharepointDrive(snappableFid: UUID!): O365SharepointDrive!
    "List of sharepoint drives (document libraries) in the O365Org"
    o365SharepointDrives(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        o365OrgId: UUID!,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): O365SharepointDriveConnection!
    o365SharepointList(snappableFid: UUID!): O365SharepointList!
    "Paginated list of sharepoint lists in the O365Org."
    o365SharepointLists(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        o365OrgId: UUID!,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): O365SharepointListConnection!
    "Returns the sharepoint objects after filtering on the object types and includeEntireHierarchy."
    o365SharepointObjectList(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "The Polaris UUID for the object."
        fid: UUID!,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "If true, the entire hierarchy will be searched."
        includeEntireHierarchy: Boolean!,
        objectTypeFilter: [String!],
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): O365SharepointObjectConnection!
    o365SharepointObjects(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "The Polaris UUID for the object."
        fid: UUID!,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): O365SharepointObjectConnection! @deprecated(reason: "This is deprecated as it was tied to the specific object type. Use o365SharepointObjectList instead.")
    o365Site(snappableFid: UUID!): O365Site!
    "List of sites of O365Org"
    o365Sites(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        o365OrgId: UUID!,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): O365SiteConnection!
    o365Team(snappableFid: UUID!): O365Teams!
    "List of Channels for the O365Team"
    o365TeamChannels(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        excludeArchived: Boolean!,
        "Returns the first n elements from the list."
        first: Int,
        nameFilter: String,
        snappableFid: UUID!
    ): O365TeamsChannelConnection!
    "IDs of the child snapshots of the Team snapshot"
    o365TeamChildSnapshotIDs(snapshotFid: UUID!): O365TeamChildSnapshotIDs!
    "ID for the conversations folder in the Team's Group Mailbox"
    o365TeamConversationsFolderID(o365OrgId: UUID!, snappableFid: UUID!, snapshotFid: UUID!): String!
    "users who have posted in a team"
    o365TeamPostedBy(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the first n elements from the list."
        first: Int,
        nameFilter: String,
        o365OrgId: UUID!,
        snappableFid: UUID!
    ): O365TeamConversationsSenderConnection!
    "List of O365 Teams in the O365Org"
    o365Teams(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        o365OrgId: UUID!,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): O365TeamsConnection!
    o365User(
        "The Polaris UUID for the object."
        fid: UUID!
    ): O365User!
    "Name, id, object type, and mail address of user descendant object."
    o365UserObjects(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "The Polaris UUID for the object."
        fid: UUID!,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): O365UserDescendantMetadataConnection!
    objectFiles(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        day: String!,
        filter: ListObjectFilesFiltersInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        sort: FileResultSortInput,
        timezone: String!
    ): FileResultConnection!
    """

    Link to download the Advanced Recovery Options example file

    Supported in v5.3+
    Link to download the Advanced Recovery Options example file which can be used to customize Oracle recoveries.
    """
    oracleAcoExampleDownloadLink(
        "Input for V1GetExampleAcoDownloadLink"
        input: GetExampleAcoDownloadLinkInput!
    ): OracleFileDownloadLink!
    """

    List of supported Advanced Cloning Options

    Supported in v6.0+
    Get the list of supported Advanced Cloning Options (ACO) parameters.
    """
    oracleAcoParameters(
        "Input for V1GetAcoParameterList"
        input: GetAcoParameterListInput!
    ): OracleAcoParameterList!
    "An Oracle Database."
    oracleDatabase(
        "The Polaris UUID for the object."
        fid: UUID!
    ): OracleDatabase!
    "Paginated list of Oracle Databases."
    oracleDatabases(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): OracleDatabaseConnection!
    "An Oracle Host."
    oracleHost(
        "The Polaris UUID for the object."
        fid: UUID!
    ): OracleHost!
    """

    Get missed recoverable ranges of a Oracle database

    Supported in v5.0+
    Retrieve a list of missed recoverable ranges for a Oracle database. For each run of one type of error, the first and last occurrence of the error are given.
    """
    oracleMissedRecoverableRanges(
        "Input for InternalGetOracleDbMissedRecoverableRanges"
        input: GetOracleDbMissedRecoverableRangesInput!
    ): OracleMissedRecoverableRangeListResponse!
    "An Oracle Real Application Cluster."
    oracleRac(
        "The Polaris UUID for the object."
        fid: UUID!
    ): OracleRac!
    """

    Get recoverable ranges of a Oracle database

    Supported in v5.0+
    Retrieve the recoverable ranges for a specified Oracle database. A begin and/or end timestamp can be provided to retrieve only the ranges that fall within the window.
    """
    oracleRecoverableRanges(
        "Input for InternalGetOracleDbRecoverableRanges"
        input: GetOracleDbRecoverableRangesInput!
    ): OracleRecoverableRangeListResponse!
    "Paginated list of the highest-level Oracle Objects accessible by the current user."
    oracleTopLevelDescendants(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): OracleTopLevelDescendantTypeConnection!
    "Get all orgs."
    orgs(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Name to filter the results by."
        nameFilter: String,
        "Field in the org to sort orgs by."
        sortBy: OrgField = NAME,
        "sort order"
        sortOrder: SortOrderEnum
    ): OrgConnection!
    pendingAction(pendingActionId: String!): pendingAction!
    pendingActions(
        clusterFilter: UUID,
        historyOnly: Boolean,
        limit: Long,
        objectIds: [String!],
        pendingActionGroupTypeFilter: [PendingActionGroupTypeEnum!],
        pendingActionSubGroupTypeFilter: [PendingActionSubGroupTypeEnum!],
        "Result ordering."
        sortedOrder: SortOrder,
        statusFilter: [PendingActionStatusEnum!]
    ): [pendingAction!]!
    "Get information about objects passing through the Radar pipeline."
    pendingRadarEvaluationResultsCount: PendingEvaluationResultsReply!
    physicalHost(
        "The Polaris UUID for the object."
        fid: UUID!
    ): PhysicalHost!
    physicalHostConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "host root type"
        hostRoot: HostRoot!,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): PhysicalHostConnection!
    "Get the health metric for the radar pipeline covering the backup, indexing, and analysis jobs"
    pipelineHealthForTimeRange(
        "Filtering beginning from this time."
        beginTime: DateTime!,
        "Filtering for objects/events that stared before EndTime."
        endTime: DateTime
    ): GetPipelineHealthReply!
    polarisInventorySubHierarchyRoot(rootEnum: InventorySubHierarchyRootEnum!): PolarisInventorySubHierarchyRoot!
    "The results of a malware detection scan."
    polarisMalwareDetectionTaskResult(
        "The id of the scan."
        scanId: String!
    ): PolarisMalwareScanResults!
    "The structure of a Polaris Report."
    polarisReportSchema(
        polarisReportViewType: PolarisReportViewType!,
        "The timezone to return results in"
        timezone: String
    ): PolarisReportSchema!
    "The structure of a Polaris Report Table."
    polarisReportTableIntrospection(
        "Type of the table view."
        tableView: TableViewType!
    ): PolarisReportTableIntrospection!
    "Returns the Polaris snapshot by id"
    polarisSnapshot(
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!
    ): PolarisSnapshot!
    "Return detailed policy information"
    policy(policyId: String!): ClassificationPolicyDetail!
    "Return active policies for an account"
    policyConnection(policyObjectFilter: PolicyObjectFilterEnum): ClassificationPolicyDetailConnection!
    "Return details for one policy obj"
    policyObj(snappableFid: String!, snapshotFid: String!): PolicyObj!
    "Return status for all objects at a specified timestamp"
    policyObjConnection(day: String!, timezone: String!): PolicyObjConnection!
    "Returns which policies are applied to each object"
    policyObjectUsageConnection(objectIds: [String!]!): PolicyObjectUsageConnection!
    "Gets status of last prechecks job."
    prechecksStatus(
        "Cluster uuid"
        clusterUuid: UUID!
    ): PrechecksStatusReply!
    "Get status of last completed prechecks Job along with details of currently running/scheduled next prechecks Job."
    prechecksStatusWithNextJobInfo(
        "Cluster uuid"
        clusterUuid: UUID!
    ): PrechecksStatusReply!
    "Get the number of snappables that have passed through the Radar pipeline in the past 24 hours."
    processedRadarSnappableCount: ProcessedRadarSnappableCountReply!
    "List of all objects protected by the sla"
    protectedObjectsConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        objectTypeFilter: [String!],
        "Corresponds to optional object root forever UUID, none value is assumed to be the global hierarchy root"
        rootOptionalFid: UUID,
        "Provide a list of Global SLA Domain IDs"
        slaIds: [UUID!]!,
        sortBy: HierarchySortByField,
        "sort order"
        sortOrder: SortOrderEnum
    ): ProtectedObjectsConnection!
    "Get the total number of snappables protected by Radar"
    protectedRadarSnappableCount: ProtectedRadarSnappableCountReply!
    "Get a per day summary of the radar analysis results from start day to end day."
    radarAnalysisSummary(
        "Optional list of cluster uuids to filter on."
        clusterUuidFilter: [String!],
        "End day, formatted(ISO 8601) as YYYY-MM-DD."
        endDay: String!,
        "Do not include the suspicious byte count or suspicious file count of non anomalous snapshots."
        hideSuspiciousDataIfNonAnomalous: Boolean,
        "Optional list of object types to filter on."
        objectTypeFilter: [String!],
        "Optional list of sla fids to filter on."
        slaFidFilter: [String!],
        "Start day, formatted(ISO 8601) as YYYY-MM-DD."
        startDay: String!,
        "Timezone name(IANA)."
        timezone: String!
    ): RadarAnalysisSummaryReply!
    radarClusterConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ClusterFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort clusters by field"
        sortBy: ClusterSortByEnum = ClusterType,
        "cluster sort order"
        sortOrder: SortOrderEnum = Desc
    ): ClusterConnection!
    "Get the total number of times that Radar has scanned an object"
    radarSnappableScannedCount(
        "Snappable Id of an object."
        snappableIdNotFid: String!
    ): RadarSnappableScannedCountReply!
    ransomwareResult(
        "The ID of the cluster."
        clusterUuid: UUID!,
        "Snappable managed ID"
        managedId: String!,
        "Corresponds to snapshot ID in CDM tables"
        snapshotId: String!
    ): RansomwareResult!
    ransomwareResultConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter ransomware results by input"
        filter: RansomwareResultFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort ransomware results by field"
        sortBy: RansomwareResultSortByEnum,
        timezoneOffset: Float = 0.0
    ): RansomwareResultConnection!
    ransomwareResultGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter ransomware results by input"
        filter: RansomwareResultFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group ransomware results by field"
        groupBy: RansomwareResultGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): RansomwareResultGroupByConnection!
    ransomwareResultOpt(
        "The ID of the cluster."
        clusterUuid: UUID!,
        "Snappable managed ID"
        managedId: String!,
        "Corresponds to snapshot ID in CDM tables"
        snapshotId: String!
    ): RansomwareResult
    "RCS Azure archival location consumption stats."
    rcsArchivalLocationsConsumptionStats(
        "Request for fetching consumption stats for multiple rcs Azure locations."
        rcsAzureTargetConsumptionStatsRequest: RcsConsumptionStatsInput!
    ): RcsAzureArchivalLocationsConsumptionStatsOutput!
    "Rubrik Cloud Vault (RCV) Account entitlement details."
    rcvAccountEntitlement: RcvAccountEntitlement!
    "Details of the RDS Instance in the AWS Native account."
    rdsInstanceDetailsFromAws(
        "Rubrik ID for AWS account."
        awsAccountRubrikId: UUID!,
        "Name of the RDS DB Instance"
        rdsInstanceName: String!,
        "Region in AWS."
        region: AwsNativeRegion!
    ): RdsInstanceDetailsFromAws!
    "Recovery Plan."
    recoveryPlan(
        "The Polaris UUID for the object."
        fid: UUID!
    ): RecoveryPlan!
    "Recovery Plans."
    recoveryPlans(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): RecoveryPlanConnection!
    "List of all replication pair Rubrik clusters."
    replicationPairsConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Filter for replication pairs query"
        filter: ReplicationPairsQueryFilter,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Field to sort by for replication pairs."
        sortBy: ReplicationPairsQuerySortByField,
        sortOrder: ReplicationQuerySortByOrder
    ): ReplicationPairConnection!
    report(id: Int!): CustomReport!
    "Report chart data."
    reportChartData(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Type of the chart view."
        chartView: ChartViewType!,
        "A list of filters to filter result with"
        filters: [ReportFilterInput!],
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "The timezone to return results in"
        timezone: String
    ): ChartDataResult!
    reportConfig(reportID: Int!): ReportConfig!
    reportConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter custom reports by input"
        filter: CustomReportFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort by field"
        sortBy: CustomReportSortByEnum = UpdateTime,
        "sort order"
        sortOrder: SortOrderEnum
    ): CustomReportConnection!
    reportData(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        """

        A list of aggregations to apply to the grouped rows, it must be used
        in conjunction with groupBy arg (except for count(*)). Supported
        aggregations are:
        hour, day, week, month, year for datetime columns
        sum, avg for integer columns
        count(*)
        """
        aggregations: [String!],
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        """

        A list of columns to include in the result. It can be omitted when
        requesting aggregations, and server will derive columns by
        concatenating groupBy and aggregation arguments.
        """
        columns: [String!]!,
        dataView: DataViewTypeEnum!,
        "A list of filters to filter result with"
        filters: [ReportFilterInput!],
        "Returns the first n elements from the list."
        first: Int,
        """

        A list of the names of the columns to group result by, it must be
        used in conjunction of aggregations.
        """
        groupBy: [String!],
        "Returns the last n elements from the list."
        last: Int,
        """

        SecondaryGroupBy used for when groupBy values need to be pivoted.
        """
        secondaryGroupBy: String,
        "Name of the column to sort result by"
        sortBy: String,
        "sort order"
        sortOrder: SortOrderEnum,
        "The timezone to return results in"
        timezone: String
    ): RowConnection!
    reportFromConfig(config: CustomReportCreate!): CustomReport!
    reportGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter custom reports by input"
        filter: CustomReportFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group by field"
        groupBy: CustomReportGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int
    ): CustomReportGroupByConnection!
    reportSchema(
        dataView: DataViewTypeEnum!,
        "The timezone to return results in"
        timezone: String
    ): ReportSchema!
    "Report table data."
    reportTableData(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "A list of filters to filter result with"
        filters: [ReportFilterInput!],
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Name of the column to sort result by"
        sortBy: String,
        "sort order"
        sortOrder: SortOrderEnum,
        "Type of the table view."
        tableView: TableViewType!,
        "The timezone to return results in"
        timezone: String
    ): RowConnection!
    "Status of all running jobs for an account."
    runningJobsStatus: RunningJobsReply!
    sapHanaDatabase(
        "The Polaris UUID for the object."
        fid: UUID!
    ): SapHanaDatabase!
    sapHanaDatabaseConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): SapHanaDatabaseConnection!
    sapHanaLogSnapshot(
        "The Polaris UUID for the object."
        fid: UUID!
    ): SapHanaLogSnapshot!
    sapHanaLogSnapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter sap hana log snapshots by input"
        filter: SapHanaLogSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort sap hana log snapshots by field"
        sortBy: SapHanaLogSnapshotSortByEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): SapHanaLogSnapshotConnection!
    sapHanaRecoverableRange(
        "The Polaris UUID for the object."
        fid: UUID!
    ): SapHanaRecoverableRange!
    sapHanaRecoverableRangeConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter sap hana recoverable ranges by input"
        filter: SapHanaRecoverableRangeFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort sap hana recoverable ranges by field"
        sortBy: SapHanaRecoverableRangeSortByEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): SapHanaRecoverableRangeConnection!
    sapHanaSystem(
        "The Polaris UUID for the object."
        fid: UUID!
    ): SapHanaSystem!
    sapHanaSystemConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): SapHanaSystemConnection!
    scheduledReport(id: Int!): ScheduledReport
    scheduledReportConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ScheduledReportFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int
    ): ScheduledReportConnection!
    screenshotReport(
        "The ID of the report to be screenshotted"
        reportId: String!
    ): TakeScreenshotReply!
    "Search file under given folder and with given prefix"
    searchFileByPrefix(
        "The ID of the cluster."
        clusterUuid: UUID!,
        "Filename prefix that should match."
        filenamePrefix: String!,
        "Snappable managed ID"
        managedId: String!,
        "Root path to search file inside fmd."
        searchFolderPath: String!,
        "Corresponds to snapshot ID in CDM tables"
        snapshotId: String!
    ): DiffFMDReply!
    searchHost(
        "ID of the host to search."
        id: String!,
        "The path query. Either path prefix or filename prefix."
        path: String!
    ): SearchResponseListResponse!
    """

    Search for file in Nutanix VM

    Supported in v5.0+
    Search for a file within the Nutanix Virtual Machine. Search via full path prefix or filename prefix.
    """
    searchNutanixVm(
        "Input for InternalSearchNutanixVm"
        input: SearchNutanixVmInput!
    ): SearchResponseListResponse!
    """

    Search for a file within the SnapMirrorCloud

    Supported in v7.0+
    Search for a file within the SnapMirrorCloud. The search can use the full path prefix or the filename prefix.
    """
    searchSnapMirrorCloud(
        "Input for V1SearchSnapMirrorCloud"
        input: SearchSnapMirrorCloudInput!
    ): SearchResponseListResponse!
    searchSnappableConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snappables by input (with search by name)"
        filter: SnappableFilterInputWithSearch,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort snappables by field"
        sortBy: SnappableSortByEnum = Name,
        "sort order"
        sortOrder: SortOrderEnum
    ): SnappableConnection!
    searchSnappableVersionedFiles(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the first n elements from the list."
        first: Int,
        searchQuery: String!,
        snappableFid: UUID!
    ): VersionedFileConnection!
    "list the available Security Groups"
    securityGroupConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "the id of the blueprint"
        blueprintId: UUID!,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "NamePrefix is prefix for filtering down suggestions"
        namePrefix: String,
        "the fid of the snappable"
        snappableId: UUID,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        "the fid of the vpc"
        vpcId: UUID!
    ): SnappableSecurityGroupConnection!
    "Browse Service Accounts"
    serviceAccountConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Assigned role IDs for service account"
        roleIds: [UUID!],
        "Search for a service account"
        searchText: String,
        "Sort"
        sortBy: ServiceAccountSortByEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): ServiceAccountConnection!
    serviceProviderMetadataFields: GetSPExplicitReply!
    shareFileset(
        "The Polaris UUID for the object."
        fid: UUID!
    ): ShareFileset!
    "List of audit details for a given SLA"
    slaAuditDetail(
        "SLA ID for global SLAs and Internal ID for CDM SLAs"
        SlaId: UUID!,
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: [SLAAuditDetailFilterInput!],
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        timezone: String
    ): [SlaAuditDetail!]!
    slaConflictObjects(fids: [UUID!]!): [HierarchyObject!]!
    slaDomain(
        "SLA Domain ID."
        id: UUID!,
        "Specifies whether to show the Rubrik clusters where this Global SLA Domain is paused."
        shouldShowPausedClusters: Boolean = false,
        "Specifies whether to show the Global SLA Domain sync status on Rubrik CDM."
        shouldShowSyncStatus: Boolean = false,
        "Specifies whether to show the upgrade information for an SLA Domain or not."
        shouldShowUpgradeInfo: Boolean = false
    ): SlaDomain!
    slaDomainWithWarnings(
        "Provide optional snappable types under the object for SLA assignment. This is meant to be used only for objects that support multiple snappable hierarchies. See 'applicableSnappableType' for more details. If more than one is provided, the SLA will be assigned to all."
        applicableSnappableTypes: [SnappableLevelHierarchyTypeEnum!],
        "SLA Domain ID."
        id: UUID!,
        "Provide list of object forever IDS you want to assign Global SLA"
        objectIds: [UUID!]!
    ): SlaDomainWithWarnings!
    "Query sla list with warnings"
    slaDomainWithWarningsList(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Provide optional snappable types under the object for SLA assignment. This is meant to be used only for objects that support multiple snappable hierarchies. See 'applicableSnappableType' for more details. If more than one is provided, the SLA will be assigned to all."
        applicableSnappableTypes: [SnappableLevelHierarchyTypeEnum!],
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Specification on what context filter to use."
        contextFilter: ContextFilterTypeEnum,
        filter: [GlobalSlaFilterInput!],
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Provide list of object forever IDS you want to assign Global SLA"
        objectIds: [UUID!]!,
        sortBy: SLAQuerySortByFieldEnum,
        sortOrder: SLAQuerySortByOrderEnum
    ): [SlaDomainWithWarnings!]!
    "Details of a SLA Managed Volume object."
    slaManagedVolume(
        "The Polaris UUID for the object."
        fid: UUID!
    ): ManagedVolume!
    "Paginated list of SLA Managed Volumes."
    slaManagedVolumes(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): ManagedVolumeConnection!
    "List of SLA summaries for the given ids"
    slaSummariesByIds(
        "Provide a list of Global SLA Domain IDs"
        slaIds: [UUID!]!
    ): [SlaDomain!]!
    smtpConfiguration: GetSMTPConfigurationReply!
    "A SnapMirror Cloud."
    snapMirrorCloud(
        "The Polaris UUID for the object."
        fid: UUID!
    ): SnapMirrorCloud!
    "Snappables which have an anomalous snapshot."
    snappableAnomalies(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Filtering beginning from this time."
        beginTime: DateTime!,
        "Optional list of cluster uuids to filter on."
        clusterUuidFilter: [String!],
        "Optional list of encryption levels to filter on."
        encryptionFilter: [EncryptionLevel!],
        "Filtering for objects/events that stared before EndTime."
        endTime: DateTime,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Optional list of object types to filter on."
        objectTypeFilter: [String!],
        "Order snappables with children ahead of non-parents."
        orderParentsFirst: Boolean,
        "Optional list of severity levels to filter on."
        severityFilter: [ActivitySeverity!],
        "Optional list of sla fids to filter on."
        slaFidFilter: [String!],
        "Optional snappable name search filter to apply."
        snappableNameSearch: String,
        "Sort snappable anomalies by field."
        sortBy: SnappableAnomaliesSortBy,
        "sort order"
        sortOrder: SortOrderEnum
    ): SnappableAnomalyConnection!
    snappableConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snappables by input"
        filter: SnappableFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort snappables by field"
        sortBy: SnappableSortByEnum = Name,
        "sort order"
        sortOrder: SortOrderEnum
    ): SnappableConnection!
    "Search over Exchange contacts."
    snappableContactSearch(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Search filter for contacts search."
        contactsSearchFilter: ContactsSearchFilter,
        "Returns the first n elements from the list."
        first: Int,
        orgId: UUID!,
        snappableFid: UUID!
    ): O365ExchangeObjectConnection!
    snappableEmailSearch(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the first n elements from the list."
        first: Int,
        orgId: UUID!,
        "search filters"
        searchFilter: SearchFilter,
        snappableFid: UUID!
    ): O365ExchangeObjectConnection!
    snappableEventSearch(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Search filter for calendar search."
        calendarSearchFilter: CalendarSearchFilter,
        "Returns the first n elements from the list."
        first: Int,
        orgId: UUID!,
        snappableFid: UUID!
    ): O365ExchangeObjectConnection!
    snappableGroupByAtSpecifiedTimeConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snappables by input for group by"
        filter: SnappableGroupByFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snappables by field"
        groupBy: SnappableGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        "List of Snappable aggregations you want to fetch. Explicitly specifying the subset of aggregations you need will greatly speed up the query."
        requestedAggregations: [SnappableAggregationsEnum!],
        "Time to calculate the group by."
        specifiedTime: DateTime!,
        timezoneOffset: Float = 0.0
    ): SnappableGroupByAtSpecifiedTimeConnection!
    snappableGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snappables by input for group by"
        filter: SnappableGroupByFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snappables by field"
        groupBy: SnappableGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        "List of Snappable aggregations you want to fetch. Explicitly specifying the subset of aggregations you need will greatly speed up the query."
        requestedAggregations: [SnappableAggregationsEnum!],
        timezoneOffset: Float = 0.0
    ): SnappableGroupByConnection!
    snappableOnedriveSearch(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the first n elements from the list."
        first: Int,
        onedriveSearchFilter: OnedriveSearchFilter,
        orgId: UUID!,
        snappableFid: UUID!
    ): O365OnedriveObjectConnection!
    "describes the snappable resource specs"
    snappableResourceSpecs(
        "The snappable identifiers."
        ids: [SnappableIdentifierInput!]!
    ): [ResourceSpec!]!
    snappableSharepointDriveSearch(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the first n elements from the list."
        first: Int,
        orgId: UUID!,
        sharepointDriveSearchFilter: OnedriveSearchFilter,
        snappableFid: UUID!
    ): O365OnedriveObjectConnection!
    "Search list objects"
    snappableSharepointListSearch(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the first n elements from the list."
        first: Int,
        orgId: UUID!,
        sharepointDriveSearchFilter: OnedriveSearchFilter,
        snappableFid: UUID!
    ): O365OnedriveObjectConnection!
    snappableTeamsConversationsSearch(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the first n elements from the list."
        first: Int,
        orgId: UUID!,
        snappableFid: UUID!,
        "snapshotFid arg which is of optional type"
        snapshotFidOpt: UUID,
        "List of channel objects (naturalId and name)."
        teamConvChannels: [O365TeamConvChannelInput!]!,
        teamsConversationsSearchFilter: TeamsConversationsSearchFilter
    ): O365TeamsConversationsConnection!
    snappableTeamsDriveSearch(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        channelFolderName: String,
        channelId: String,
        "Returns the first n elements from the list."
        first: Int,
        orgId: UUID!,
        snappableFid: UUID!,
        teamsDriveSearchFilter: OnedriveSearchFilter
    ): O365OnedriveObjectConnection!
    "List of snappables with legal hold snapshots."
    snappablesWithLegalHoldSnapshotsSummary(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Query Snappables with legal hold snapshots input."
        input: SnappablesWithLegalHoldSnapshotsInput!,
        "Returns the last n elements from the list."
        last: Int
    ): LegalHoldSnappableDetailConnection!
    "Returns a single snapshot by id"
    snapshot(
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!
    ): CdmSnapshot!
    snapshotEmailSearch(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the first n elements from the list."
        first: Int,
        orgId: UUID!,
        "search filters"
        searchFilter: SearchFilter,
        snappableFid: UUID!,
        snapshotFid: UUID!
    ): O365ExchangeObjectConnection!
    snapshotEventSearch(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Search filter for calendar search."
        calendarSearchFilter: CalendarSearchFilter,
        "Returns the first n elements from the list."
        first: Int,
        orgId: UUID!,
        snappableFid: UUID!,
        snapshotFid: UUID!
    ): O365ExchangeObjectConnection!
    "Browse or search the given path for files and directories along with their deltas in a given snapshot"
    snapshotFileDeltaConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "filter snapshot delta based on delta types"
        filter: SnapshotDeltaFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "The path under which you want your search to run"
        path: String!,
        "Prefix arg for searching for files within a snapshot"
        searchPrefix: String,
        "Corresponds to snapshot forever UUID in Polaris tables"
        snapshotFid: UUID!
    ): SnapshotFileDeltaConnection!
    "Returns list of snapshots for a snappable"
    snapshotOfASnappableConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Whether to ignore the active protected object check."
        ignoreActiveSnappableCheck: Boolean,
        "Returns the last n elements from the list."
        last: Int,
        snappableId: String!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection!
    "Returns list of snapshots for a list of snappables"
    snapshotOfSnappablesConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Whether to ignore the active protected object check."
        ignoreActiveSnappableCheck: Boolean,
        "Returns the last n elements from the list."
        last: Int,
        "Snappable UUIDs."
        snappableIds: [String!]!,
        "filter for snapshot connection"
        snapshotFilter: [SnapshotQueryFilterInput!],
        sortBy: SnapshotQuerySortByField,
        "sort order"
        sortOrder: SortOrderEnum,
        timeRange: TimeRangeInput
    ): GenericSnapshotConnection!
    snapshotOnedriveSearch(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the first n elements from the list."
        first: Int,
        onedriveSearchFilter: OnedriveSearchFilter,
        orgId: UUID!,
        snappableFid: UUID!,
        snapshotFid: UUID!
    ): O365OnedriveObjectConnection!
    "Return snapshot results for a snappable"
    snapshotResultConnection(
        "End time of the range (in milliseconds since epoch)"
        endTimeMs: Long!,
        snappableFid: String!,
        "Begin time of the range (in milliseconds since epoch)"
        startTimeMs: Long!
    ): SnapshotResultConnection!
    snapshotSharepointDriveSearch(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the first n elements from the list."
        first: Int,
        orgId: UUID!,
        sharepointDriveSearchFilter: OnedriveSearchFilter,
        snappableFid: UUID!,
        snapshotFid: UUID!
    ): O365OnedriveObjectConnection!
    "List of snapshots for unmanaged objects."
    snapshotsForUnmanagedObject(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Input for V1QueryUnmanagedObjectSnapshotsV1"
        input: QueryUnmanagedObjectSnapshotsV1Input!,
        "Returns the last n elements from the list."
        last: Int
    ): SnapshotSummaryConnection!
    "Return groupBy results for SonarContentReport"
    sonarContentReportGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        day: String!,
        filters: SonarContentReportFilter,
        "Returns the first n elements from the list."
        first: Int,
        groupBy: SonarContentReportGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        sortBy: SonarContentReportSortByEnum,
        "sort order"
        sortOrder: SortOrderEnum,
        timezone: String!
    ): SonarContentReportTableRowConnection!
    "Return groupBy for SonarReport"
    sonarReportGroupByConnection(filter: [String!], sonarReportGroupBy: SonarReportGroupByEnum!, timeFilter: TimeFilterInput): SonarReportGroupByResultConnection!
    "Return rows for SonarReport table"
    sonarReportTableConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        endTime: String,
        filter: [String!],
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        sortBy: SonarReportSortByEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): SonarReportTableRowConnection!
    sonarUserGroups(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ListAccessGroupsFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int
    ): AccessGroupConnection!
    sonarUsers(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ListAccessUsersFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        sort: ListAccessUsersSortInput
    ): AccessUserConnection!
    sourceBlueprintInfo(
        "The Polaris UUID for the object."
        fid: UUID!
    ): SourceBlueprintInfo!
    "list the available Subnets"
    subnetConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "the type for id of availability-zone (eg. us-east-1a)"
        availabilityZone: String,
        "the id of the blueprint"
        blueprintId: UUID!,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "NamePrefix is prefix for filtering down suggestions"
        namePrefix: String,
        "the fid of the snappable"
        snappableId: UUID,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        "the fid of the vpc"
        vpcId: UUID!
    ): SnappableSubnetConnection!
    syslogConfiguration: GetSyslogConfigurationReply!
    tableFilters: TableFilters!
    target(
        "Corresponds to ID of target in Polaris"
        targetId: UUID!
    ): Target!
    targetList(
        "Specification on what context filter to use."
        contextFilter: ContextFilterTypeEnum,
        "Specifies how to filter the list of targets."
        filter: [TargetFilterInput!],
        "Specifies the field by which the list of targets will be sorted."
        sortBy: TargetSortByFieldEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): [Target!]! @deprecated(reason: "Please use the query targets instead.")
    targetMapping(
        "Corresponds to ID of target mapping in Polaris"
        targetMappingId: UUID!
    ): TargetMapping!
    targetMappingList(
        "Specification on what context filter to use."
        contextFilter: ContextFilterTypeEnum,
        "Specification on how to filter a list of target mappings"
        filter: [TargetMappingFilterInput!],
        "Corresponds to rcs stats flag, only true value will add rcs stats in response."
        isRcsStatsRequired: Boolean,
        "Specification on how to sort a list of target mappings"
        sortBy: TargetMappingSortByFieldEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): [TargetMapping!]!
    "All archival locations."
    targets(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Specification on what context filter to use."
        contextFilter: ContextFilterTypeEnum,
        "Specifies how to filter the list of targets."
        filter: [TargetFilterInput!],
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Specifies the field by which the list of targets will be sorted."
        sortBy: TargetSortByFieldEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): TargetConnection!
    taskDetailConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter task summary by input"
        filter: TaskDetailFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort task detail by field"
        sortBy: TaskDetailSortByEnum = EndTime,
        "task detail sort order"
        sortOrder: SortOrderEnum = Desc,
        timezoneOffset: Float = 0.0
    ): TaskDetailConnection!
    taskDetailGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter task summary by input"
        filter: TaskDetailFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group task detail by a field"
        groupBy: TaskDetailGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): TaskDetailGroupByConnection!
    taskSummaryConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter task summary by input"
        filter: TaskSummaryFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort task summary by field"
        sortBy: TaskSummarySortByEnum = ObjectName,
        "sort order"
        sortOrder: SortOrderEnum,
        timezoneOffset: Float = 0.0
    ): TaskSummaryConnection!
    taskSummaryGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter task summary by input"
        filter: TaskSummaryFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group task summary by a field"
        groupBy: TaskSummaryGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): TaskSummaryGroupByConnection!
    teamChannelNameAvailable(channelName: String!, teamUUID: UUID!): Boolean!
    "The details of a malware detection scan."
    threatHuntDetail(
        "The id of the threat hunt."
        huntId: String!
    ): MalwareScan!
    "The status of a malware detection scan."
    threatHuntStatus(
        "The id of the threat hunt."
        huntId: String!
    ): AsyncRequestStatus!
    "List of Threat Hunts."
    threatHunts(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Filtering for objects/events that stared after beginTime."
        beginTime: DateTime,
        "Optional list of cluster uuids to filter on."
        clusterUuidFilter: [String!],
        "Filtering for objects/events that stared before EndTime."
        endTime: DateTime,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "Optionally filter on if the hunt had any matches."
        matchesFoundFilter: [MalwareScanMatchesFound!],
        "Optional status to filter on."
        statusFilter: [MalwareScanStatus!]
    ): MalwareScanConnection!
    toggleableFeaturesEnabled: [FeatureNameEnum!]!
    "Get TOTP configuration status for a user."
    totpConfigStatus(
        "User ID."
        userId: String!
    ): GetTotpStatusReply!
    "Count of unique HyperV Servers."
    uniqueHypervServersCount(filter: [Filter!]): Int!
    uniqueVSphereVCenterCount(filter: [Filter!]): Int!
    "List of unmanaged objects."
    unmanagedObjects(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Query unmanaged objects."
        input: UnmanagedObjectsInput!,
        "Returns the last n elements from the list."
        last: Int
    ): UnmanagedObjectDetailsConnection!
    "Gets the status for completed/running upgrade process."
    upgradeStatus(
        "Cluster uuid"
        clusterUuid: UUID!
    ): UpgradeStatusReply!
    userActivities(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ListObjectFilesFiltersInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        sort: FileResultSortInput,
        "Time range specified in the user's local timezone."
        timeRange: UserTimeRangeInput,
        userId: String!
    ): FileResultConnection!
    userActivityTimeline(startDay: String!, timezone: String!, uniqueActivities: Boolean!, userId: String!): ActivityTimelineResultConnection!
    userAnalyzerAccess(limit: Int!, startDay: String!, timezone: String!, userId: String!): AnalyzerAccessUsageConnection!
    userAuditConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filters: UserAuditFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort user audit by field"
        sortBy: UserAuditSortByEnum = Time,
        "user audit sort order"
        sortOrder: SortOrderEnum = Desc
    ): UserAuditConnection!
    userAuditGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filters: UserAuditFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group audits by a field"
        groupBy: UserAuditGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        "sort user audit by field"
        sortBy: UserAuditSortByEnum = Time,
        "user audit sort order"
        sortOrder: SortOrderEnum = Desc,
        timezoneOffset: Float = 0.0
    ): UserAuditGroupByConnection!
    userDetail(startDay: String!, timezone: String!, userId: String!): GetUserDetailReply!
    userFileActivityTimeline(nativePath: String!, resource: ResourceInput, startDay: String!, timeGranularity: TimeGranularityEnum!, timezone: String!, userId: String!): ActivityTimelineResultConnection!
    userGroups(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        roleIdsFilter: [UUID!]
    ): [Group!]!
    "An object containing production notifications information for the current user."
    userNotifications: UserNotifications!
    userSettings: UserSettings!
    vSphereBlueprint(
        "The Polaris UUID for the object."
        fid: UUID!
    ): VSphereBlueprint!
    vSphereComputeCluster(
        "The Polaris UUID for the object."
        fid: UUID!
    ): VSphereComputeCluster!
    "Query compute clusters"
    vSphereComputeClusters(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): VSphereComputeClusterConnection!
    vSphereDatacenter(
        "The Polaris UUID for the object."
        fid: UUID!
    ): VSphereDatacenter!
    "Vsphere datastore based on id passed in."
    vSphereDatastore(
        "The Polaris UUID for the object."
        fid: UUID!
    ): VSphereDatastore!
    "Vsphere datastore cluster based on id passed in."
    vSphereDatastoreCluster(
        "The Polaris UUID for the object."
        fid: UUID!
    ): VsphereDatastoreCluster!
    "Query vSphere datastore clusters."
    vSphereDatastoreClusters(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): VsphereDatastoreClusterConnection!
    vSphereDatastoreConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): VSphereDatastoreConnection!
    vSphereFolder(
        "The Polaris UUID for the object."
        fid: UUID!
    ): VSphereFolder!
    vSphereHost(
        "The Polaris UUID for the object."
        fid: UUID!
    ): VSphereHost!
    vSphereHostConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): VSphereHostConnection!
    "All of the VSphere hosts based on fids passed in."
    vSphereHostsByFids(fids: [UUID!]!): [VSphereHost!]!
    "Get a vSphere Live Mount by id"
    vSphereMount(
        "The Polaris UUID for the object."
        fid: UUID!
    ): VSphereMount!
    "vSphere Live Mount Connection"
    vSphereMountConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "filter for VM live mounts"
        filter: VSphereMountFilter,
        "Returns the first n elements from the list."
        first: Int,
        sortBy: VSphereMountSortByEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): VSphereMountConnection!
    vSphereNetwork(
        "The Polaris UUID for the object."
        fid: UUID!
    ): VSphereNetwork!
    vSphereResourcePool(
        "The Polaris UUID for the object."
        fid: UUID!
    ): VSphereResourcePool!
    "The root hierarchy for VMware export, which includes VMware compute clusters and standalone hosts."
    vSphereRootRecoveryHierarchy(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): CdmHierarchyObjectConnection!
    vSphereTag(
        "The Polaris UUID for the object."
        fid: UUID!
    ): VSphereTag!
    vSphereTagCategory(
        "The Polaris UUID for the object."
        fid: UUID!
    ): VSphereTagCategory!
    vSphereTopLevelDescendantsConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): CdmHierarchyObjectConnection!
    vSphereVCenter(
        "The Polaris UUID for the object."
        fid: UUID!
    ): VSphereVCenter!
    vSphereVCenterConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): VSphereVCenterConnection!
    vSphereVMAsyncRequestStatus(
        clusterUuid: UUID!,
        "ID of an asynchronous request."
        id: String!
    ): AsyncRequestStatus!
    vSphereVmNew(
        "The Polaris UUID for the object."
        fid: UUID!
    ): VSphereVm!
    vSphereVmNewConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): VSphereVmConnection!
    "Validates the name used for an RDS Instance during an export operation. Returns true if the RDS Instance name is valid. Returns false, with an error message, if the RDS Instance name validation fails. Returns false, without an error message for all other failures."
    validateAwsNativeRdsInstanceNameForExport(
        "Rubrik ID for AWS account."
        awsAccountRubrikId: UUID!,
        "Name of the RDS DB Instance"
        rdsInstanceName: String!,
        "Region in AWS."
        region: AwsNativeRegion!
    ): ValidateAwsNativeRdsInstanceNameForExportReply!
    "Validates if Azure subnets are correctly configured for running Azure Kubernetes Service (AKS) Clusters. When correctly configured, the Azure subnets allow the required region-specific outbound connectivity and do not overlap with Azure restricted IP Address Space."
    validateAzureCloudAccountExocomputeConfigurations(
        "Input for validating Exocompute configurations for an Azure Cloud Account."
        input: ValidateAzureCloudAccountExocomputeConfigurationsInput!
    ): ValidateAzureSubnetsForCloudAccountExocomputeReply!
    "Validates the name used for an Sql Database during an export operation. Returns true if the database name is valid. Returns false, with an error message, if the database name validation fails. Returns false, without an error message for all other failures."
    validateAzureNativeSqlDatabaseDbNameForExport(
        "Name of the Azure SQL Database."
        azureSqlDatabaseName: String!,
        "Rubrik ID of the Azure SQL Database Server."
        azureSqlDatabaseServerRubrikId: UUID!
    ): ValidateAzureNativeSqlDatabaseDbNameForExportReply!
    "Validates the name used for an Managed Instance Database during an export operation. Returns true if the database name is valid. Returns false, with an error message, if the database name validation fails. Returns false, without an error message for all other failures."
    validateAzureNativeSqlManagedInstanceDbNameForExport(
        "Name of the Azure SQL Database."
        azureSqlDatabaseName: String!,
        "Rubrik ID of the Azure SQL Managed Instance Server."
        azureSqlManagedInstanceServerRubrikId: UUID!
    ): ValidateAzureNativeSqlManagedInstanceDbNameForExportReply!
    "A vCloud Director."
    vcd(
        "The Polaris UUID for the object."
        fid: UUID!
    ): Vcd!
    "A vCloud Director Catalog."
    vcdCatalog(
        "The Polaris UUID for the object."
        fid: UUID!
    ): VcdCatalog!
    "A vCloud Director Organization."
    vcdOrg(
        "The Polaris UUID for the object."
        fid: UUID!
    ): VcdOrg!
    "A vCloud Director Organization Virtual Data Center."
    vcdOrgVdc(
        "The Polaris UUID for the object."
        fid: UUID!
    ): VcdOrgVdc!
    "Paginated list of the highest-level vCloud Director Objects accessible by the current user."
    vcdTopLevelDescendants(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VcdTopLevelDescendantTypeConnection!
    "A vCloud Director vApp."
    vcdVapp(
        "The Polaris UUID for the object."
        fid: UUID!
    ): VcdVapp!
    "Paginated list of vCloud Director vApps."
    vcdVapps(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): VcdVappConnection!
    "A vCloud Director VIM Server."
    vcdVimServer(
        "The Polaris UUID for the object."
        fid: UUID!
    ): VcdVimServer!
    verifySLAWithReplicationToCluster(
        "Account name."
        account: String!,
        "UUID of the Rubrik cluster"
        cdmClusterUUID: UUID!,
        "Include Archived SLA"
        includeArchived: Boolean!
    ): VerifySLAWithReplicationToClusterResp!
    volumeGroup(
        "The Polaris UUID for the object."
        fid: UUID!
    ): VolumeGroup!
    volumeGroupConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): VolumeGroupConnection!
    "Volume Group Live Mount Connection."
    volumeGroupMounts(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Filter for volume group live mounts."
        filters: [VolumeGroupLiveMountFilterInput!],
        "Returns the first n elements from the list."
        first: Int,
        "Sort by argument for volume group live mounts."
        sortBy: VolumeGroupLiveMountSortByInput
    ): VolumeGroupLiveMountConnection!
    "list the available Volume Types"
    volumeTypeConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "the id of the blueprint"
        blueprintId: UUID!,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        " the device key"
        key: Int!,
        "NamePrefix is prefix for filtering down suggestions"
        namePrefix: String,
        "the fid of the snappable"
        snappableId: UUID,
        "the fid of the snapshot"
        snapshotId: UUID,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): SnappableStorageVolumeTypeConnection!
    "list the available VPCs"
    vpcConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "the id of the blueprint"
        blueprintId: UUID!,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "MaxSuggestionCount is the number of suggestions expected"
        maxSuggestionCount: Int,
        "NamePrefix is prefix for filtering down suggestions"
        namePrefix: String,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder
    ): VpcConnection!
    vsphereVMMissedRecoverableRange(afterTime: DateTime, beforeTime: DateTime, snappableFid: UUID!): RecoverableRangeResponse!
    vsphereVMRecoverableRange(afterTime: DateTime, beforeTime: DateTime, snappableFid: UUID!): RecoverableRangeResponse!
    vsphereVMRecoverableRangeInBatch(
        "The batch request, which includes the ID of each CDP-enabled virtual machine for which recoverable ranges are being retrieved, and optionally the date ranges as a filter."
        requestInfo: BatchVmwareVmRecoverableRangesRequestInput!
    ): BatchVmwareVmRecoverableRanges!
    vsphereVmwareCdpLiveInfo(
        "The ID of each CDP-enabled virtual machine for which live info is being retrieved."
        ids: [String!]!
    ): BatchVmwareCdpLiveInfo!
    "A Windows Cluster."
    windowsCluster(
        "The Polaris UUID for the object."
        fid: UUID!
    ): WindowsCluster!
    windowsFileset(
        "The Polaris UUID for the object."
        fid: UUID!
    ): WindowsFileset!
    "Configured web TLS cert."
    wwwTlsCert: CertificateInfo!
}

type QuerySDDLReply {
    secInfo: [PathSecInfo!]!
}

type RPOLagInfo {
    actualInSecs: Long!
    expectedInSecs: Long!
    level: String!
}

"Summary of the radar analysis results"
type RadarAnalysisSummaryReply {
    analysisDetails: [DailyAnalysisDetails!]!
}

"Number of times Radar has scanned an object"
type RadarSnappableScannedCountReply {
    snappableScannedCounts: [SnappableScanned!]!
}

"Ransomware analysis report from lambda service"
type RansomwareResult {
    clusterUuid: UUID!
    encryptionProbability: Float!
    id: String!
    isEncrypted: Boolean!
    managedId: String!
    snappableId: String!
    snapshotData: DateTime!
    snapshotFid: String!
    snapshotId: String!
}

"Paginated list of RansomwareResult objects."
type RansomwareResultConnection {
    "Total number of RansomwareResult objects matching the request arguments."
    count: Int!
    "List of RansomwareResult objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [RansomwareResultEdge!]!
    "List of RansomwareResult objects."
    nodes: [RansomwareResult!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the RansomwareResult object. This wrapper is used for pagination."
type RansomwareResultEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual RansomwareResult object wrapped by this edge."
    node: RansomwareResult!
}

"Ransomware analysis data with groupby info applied to it"
type RansomwareResultGroupBy {
    "Groupby info."
    groupByInfo: RansomwareResultGroupByInfo!
    "Paginated ransomware result data"
    ransomwareResultConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort ransomware results by field"
        sortBy: RansomwareResultSortByEnum
    ): RansomwareResultConnection!
    "Further provide groupings for the data."
    ransomwareResultGroupBy(
        "group ransomware results by field"
        groupBy: RansomwareResultGroupByEnum!
    ): [RansomwareResultGroupBy!]!
}

"Paginated list of RansomwareResultGroupBy objects."
type RansomwareResultGroupByConnection {
    "Total number of RansomwareResultGroupBy objects matching the request arguments."
    count: Int!
    "List of RansomwareResultGroupBy objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [RansomwareResultGroupByEdge!]!
    "List of RansomwareResultGroupBy objects."
    nodes: [RansomwareResultGroupBy!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the RansomwareResultGroupBy object. This wrapper is used for pagination."
type RansomwareResultGroupByEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual RansomwareResultGroupBy object wrapped by this edge."
    node: RansomwareResultGroupBy!
}

"RCS Azure archival locations consumption stats."
type RcsArchivalLocationConsumptionStats {
    "List of RCS azure archival location blob capacity stats."
    blobCapacityStats: [RcsArchivalLocationStatsRecord!]!
    "List of RCS azure archival location egress stats."
    egressStats: [RcsArchivalLocationStatsRecord!]!
    "List of RCS azure archival location forecasted blob capacity stats."
    forecastedBlobCapacityStats: [RcsArchivalLocationStatsRecord!]!
    "List of RCS azure archival location ingress stats."
    ingressStats: [RcsArchivalLocationStatsRecord!]!
    "Polaris archival location ID."
    locationId: String!
}

"RCS Azure archival locations consumption stats record."
type RcsArchivalLocationStatsRecord {
    "Consumption stats metric name."
    metricName: RcsConsumptionMetricOutputNameType!
    "Consumption stats metric value."
    metricValue: Float!
    "RCS archival location tier."
    tier: RcsTierEnumType!
    "Polaris archival location ID."
    timestamp: String!
}

"RCS Azure archival locations consumption stats."
type RcsAzureArchivalLocationsConsumptionStatsOutput {
    "List of RCS azure archival location consumption stats."
    rcsAzureConsumptionStats: [RcsArchivalLocationConsumptionStats!]!
}

"Specific info for Rcs Azure Target Template."
type RcsAzureTargetTemplate implements TargetTemplate {
    "Immutability setting of the template, that defines thenumber of days for which stored data will be immutable."
    immutabilitySettings: RcsImmutabilitySettings!
    "Region of RCV location template."
    region: RcsRegionEnumType!
    "The type of this Target."
    targetType: TargetTypeEnum!
    "Access tier for the RCV location."
    tier: RcsTierEnumType!
}

"Immutability settings information for RCS Azure Target."
type RcsImmutabilitySettings {
    "Lock duration days defines the number of days for which stored data will be immutable."
    lockDurationDays: Long!
}

"Rubrik Cloud Vault (RCV) account capacity entitlement."
type RcvAccountEntitlement {
    "Rubrik Cloud Vault (RCV) Archive Tier Entitlement details."
    archiveEntitlement: RcvEntitlement
    "Rubrik Cloud Vault (RCV) Backup Tier Entitlement details."
    backupEntitlement: RcvEntitlement
}

"Rubrik Cloud Vault (RCV) entitlement tier wise details."
type RcvEntitlement {
    "Rubrik Cloud Vault (RCV) Entitlement capacity in TBs."
    capacity: Float!
}

"RDS DB Instance details from AWS."
type RdsInstanceDetailsFromAws {
    "Allocated size of an RDS Instance."
    allocatedStorageInGb: Long!
    "Retention time for RDS backups."
    backupRetentionPeriod: Long!
    "DB Engine of RDS Instance."
    dbEngine: String!
    "DB class for RDS Instance."
    dbInstanceClass: String!
    "Status of an RDS Instance. Refers to the health of the RDS Instance."
    dbInstanceStatus: String!
    "Maintenance window for the RDS Instance."
    dbMaintenanceWindow: String!
    "Name of parameter group of RDS Instance."
    dbParameterGroupName: String!
    "Subnet group name of RDS Instance."
    dbSubnetGroupName: String!
    "RDS DB Instance engine version."
    engineVersion: String!
    "Input/Output (IO) operation limit per second for RDS Instance."
    iops: Long!
    "Specifies whether RDS is available in multi Availability Zones (AZs). If true, it means it is a multi-AZ RDS Instance."
    isMultiAz: Boolean!
    "Key Management System (KMS) key ID associated with RDS Instance."
    kmsKeyId: String!
    "Name of option group of RDS Instance."
    optionGroupName: String!
    "Port used to connect to the RDS Instance."
    port: Long!
    "Primary Availability Zone (AZ) of RDS Instance."
    primaryAz: String!
    "Amazon Resource Name (ARN) of RDS Instance."
    rdsInstanceArn: String!
    "Storage type of RDS Instance. Amazon RDS provides three storage types: General Purpose SSD (also known as gp2), Provisioned IOPS SSD (also known as io1), and magnetic (also known as standard)."
    storageType: String!
    "ID of VPC in AWS."
    vpcId: String!
}

"RDS Export defaults from AWS."
type RdsInstanceExportDefaults {
    "Allocated size of an RDS Instance."
    allocatedStorageInGb: Long!
    "DB Engine of RDS Instance."
    dbEngine: AwsNativeRdsDbEngine!
    "Version of DB engine."
    dbEngineVersion: String!
    "DB class for RDS Instance."
    dbInstanceClass: AwsNativeRdsDbInstanceClass!
    "NParameter group name of the RDS Instance."
    dbParameterGroupName: String!
    "Subnet group name of the RDS Instance."
    dbSubnetGroupName: String!
    "Input/Output (IO) operation limit per second for RDS Instance."
    iops: Int!
    "Specifies whether RDS is available in multi Availability Zones (AZs). If true, it means it is a multi-AZ RDS Instance."
    isMultiAz: Boolean!
    "Key Management System (KMS) key ID associated with RDS Instance."
    kmsKeyId: String!
    "Name of option group of RDS Instance."
    optionGroupName: String!
    "Port used to connect to the RDS Instance."
    port: Long!
    "Primary Availability Zone (AZ) of RDS Instance."
    primaryAz: String!
    "Storage type of RDS Instance. Amazon RDS provides three storage types: General Purpose SSD (also known as gp2), Provisioned IOPS SSD (also known as io1), and magnetic (also known as standard)."
    storageType: AwsNativeRdsStorageType!
    "Virtual Private Cloud (VPC) associated with RDS Instance."
    vpcId: String!
}

"Range to recover a snapshot from for a given VM"
type RecoverableRange {
    beginTime: String
    endTime: String
}

"Recoverable ranges for a given VM"
type RecoverableRangeResponse {
    data: [RecoverableRange!]!
    hasMore: Boolean
    total: Long
}

"A Recovery Plan."
type RecoveryPlan implements HierarchyObject {
    "Recovery Plan config."
    config: RecoveryPlanConfig
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "Recovery Plan description."
    description: String!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "Recovery Plan version."
    version: Int!
}

"Recovery Plan Blueprint information."
type RecoveryPlanBlueprintInfo {
    "IDs of Blueprints."
    blueprintId: String!
    "Boot priority."
    bootPriority: Int!
    "Target location information."
    targetLocationInfo: RecoveryPlanLocationInfo
}

"Recovery Plan configuration."
type RecoveryPlanConfig {
    "The list of Blueprints."
    blueprintsInfo: [RecoveryPlanBlueprintInfo!]!
    "Boot priority delay in seconds."
    bootPriorityDelaySeconds: [Int!]!
}

"Paginated list of RecoveryPlan objects."
type RecoveryPlanConnection {
    "Total number of RecoveryPlan objects matching the request arguments."
    count: Int!
    "List of RecoveryPlan objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [RecoveryPlanEdge!]!
    "List of RecoveryPlan objects."
    nodes: [RecoveryPlan!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the RecoveryPlan object. This wrapper is used for pagination."
type RecoveryPlanEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual RecoveryPlan object wrapped by this edge."
    node: RecoveryPlan!
}

"Recovery Plan location information."
type RecoveryPlanLocationInfo {
    "Location ID."
    locationId: String!
    "Location type."
    locationType: BlueprintLocationTypeEnum!
}

type RecoverySpecId {
    fid: String!
}

type RecoverySpecValidityCheckReply {
    errorMessage: String!
    rmStatus: String!
    success: Boolean!
}

type RecoveryTaskDetailsTableFilter {
    cluster_location: [FilterOption!]!
    cluster_type: [FilterOption!]!
    object_type: [FilterOption!]!
    replication_source: [FilterOption!]!
    status: [FilterOption!]!
    task_category: [FilterOption!]!
    task_type: [FilterOption!]!
}

"Supported in v5.0+"
type RefreshableObjectConnectionStatus {
    """

    Supported in v5.0+
    Details about the object status. Will be populated if the status is "BadlyConfigured".
    """
    message: String
    status: RefreshableObjectConnectionStatusTypeEnum!
}

type Region {
    displayName: String!
    id: String!
    name: String!
}

"Paginated list of Region objects."
type RegionConnection {
    "Total number of Region objects matching the request arguments."
    count: Int!
    "List of Region objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [RegionEdge!]!
    "List of Region objects."
    nodes: [Region!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the Region object. This wrapper is used for pagination."
type RegionEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual Region object wrapped by this edge."
    node: Region!
}

"Supported in v7.0+"
type RegisterNasSystemResponse {
    """

    Required. Supported in v7.0+
    The asynchronous request status of the job that registers the NAS system.
    """
    nasDiscoverJobStatus: AsyncRequestStatus
    """

    Required. Supported in v7.0+
    A summary of the NAS system being registered.
    """
    nasSystemSummary: NasSystemSummary
}

"Supported in v7.0+"
type RelationshipSummary {
    """

    Required. Supported in v7.0+
    ID of the SnapMirrorCloud cloud target on the NetApp server.
    """
    cloudTargetId: String!
    """

    Required. Supported in v7.0+
    ID of the SnapMirrorCloud policy on the NetApp server.
    """
    policyId: String!
    """

    Required. Supported in v7.0+
    ID of the SnapMirrorCloud relationship on the NetApp server.
    """
    relationshipId: String!
}

"An relative monthly recurrence pattern (e.g. Second Thursday or Friday of every other month)."
type RelativeMonthlyRecurrencePattern {
    "E.g. first, second, third."
    dayOfWeekIndex: String!
    "Which days of the week the event occurs."
    daysOfWeek: [String!]!
    "The interval at which the recurrence applies."
    interval: Int!
}

"A relative range of time."
type RelativeTimeRange {
    "Number of units in the time range."
    magnitude: Int!
    "Unit of the time range"
    unit: TimeUnitEnum!
}

"A relative yearly recurrence pattern (e.g. First Tuesday of November)."
type RelativeYearlyRecurrencePattern {
    "E.g. first, second, third."
    dayOfWeekIndex: String!
    "Which days of the week the event occurs."
    daysOfWeek: [String!]!
    "The month to which the recurrence applies."
    month: String!
}

"Rubrik cluster details."
type ReplicationCluster {
    "Rubrik cluster uuid."
    id: String!
    "Rubrik cluster name."
    name: String!
    "Rubrik cluster version."
    version: String!
}

"Replication pair specific information."
type ReplicationPair {
    "Additional information about the connection status of the replication pair Rubrik clusters"
    connectionDetails: ConnectionStatusDetails!
    "Failed replication task count in last 24 hours."
    failedTasks: Long
    "Represents replication pair pause enablement status."
    isPaused: Boolean!
    "Network throttle details for source Rubrik cluster."
    networkThrottle: NetworkThrottle
    "Running replication task count."
    runningTasks: Long
    "Source Rubrik cluster details."
    sourceCluster: ReplicationCluster!
    "Connection status of the replication pair (active, disconnected, or paused)."
    status: ReplicationPairConnectionStatus!
    "Storage (in bytes) consumed on target cluster by replicated snapshots."
    storage: Long!
    "Target Rubrik cluster details."
    targetCluster: ReplicationCluster!
}

"Paginated list of ReplicationPair objects."
type ReplicationPairConnection {
    "Total number of ReplicationPair objects matching the request arguments."
    count: Int!
    "List of ReplicationPair objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [ReplicationPairEdge!]!
    "List of ReplicationPair objects."
    nodes: [ReplicationPair!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the ReplicationPair object. This wrapper is used for pagination."
type ReplicationPairEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual ReplicationPair object wrapped by this edge."
    node: ReplicationPair!
}

type ReplicationSource {
    id: String!
    sourceClusterAddress: String
    sourceClusterName: String!
    sourceClusterUuid: UUID!
    totalStorage: Long
}

type ReplicationSpec {
    replicationType: ReplicationTypeEnum!
    specificReplicationSpec: SpecificReplicationSpec
}

type ReplicationSpecV2 {
    awsRegion: String!
    "AWS location used as the replication target"
    awsTarget: AwsReplicationTarget!
    azureRegion: String!
    "Azure location used as the replication target"
    azureTarget: AzureReplicationTarget!
    "Cascading Archival Specifications."
    cascadingArchivalSpecs: [CascadingArchivalSpec!]!
    "Cluster used as replication target"
    cluster: SlaReplicationCluster
    "Time snapshot is kept on local target cluster."
    replicationLocalRetentionDuration: Duration
    retentionDuration: Duration
    targetMapping: TargetMapping
}

type ReplicationTarget {
    id: String!
    targetClusterAddress: String
    targetClusterName: String!
    targetClusterUuid: UUID!
    totalStorage: Long
}

type ReplicationToCloudLocationSpec {
    retentionDuration: Duration
    targetMapping: TargetMapping
}

type ReplicationToCloudRegionSpec {
    cloudProvider: CloudProvider!
    replicationTargetRegion: String!
    retention: Int!
    retentionUnit: RetentionUnitEnum!
}

type ReportConfig {
    aggregations: [String!]!
    "Column selection for the report"
    columns: [String!]!
    "Type of report"
    dataViewType: DataViewTypeEnum!
    "Filter selection for the report"
    filters: [ConfigFilter!]!
    "GroupBy selection for the report"
    groupBy: configGroupBy!
    id: Long!
    "Report name"
    name: String!
    sortBy: String!
    sortOrder: SortOrderEnum
}

type ReportFilter {
    name: String!
    values: [String!]!
}

type ReportFilterDetail {
    dataType: DataTypeEnum!
    defaultValues: [DisplayableValue!]!
    displayName: String!
    name: String!
    type: FilterTypeEnum!
    values: [DisplayableValue!]!
}

type ReportFocus {
    enumValue: ReportFocusEnum!
}

type ReportGroupByDetail {
    aggregations: [DisplayableValue!]!
    allValues: [DisplayableValue!]!
    displayName: String!
    name: String!
    primaryGroupBy: String!
    secondaryAggregation: String
    secondaryGroupBy: String
}

type ReportSchema {
    aggregateColumns: [Column!]!
    allColumns: [Column!]!
    chartConfigs: [ChartConfig!]!
    filters: [ReportFilterDetail!]!
    groupBys: [ReportGroupByDetail!]!
    sortBy: Column!
    sortOrder: SortOrderEnum!
    tableColumns: [Column!]!
}

"Supported in v5.0+"
type RequestErrorInfo {
    """

    Required. Supported in v5.0+
    v5.0: The error message for failed ids.
    v5.1+: The error message for failed IDs.
    """
    message: String!
}

type RequestStatus {
    success: Boolean!
}

type RequestSuccess {
    success: Boolean!
}

"Supported in v6.0+"
type RequestedMatchDetails {
    requestedHashTypes: [HashTypeEnum!]
}

type ResourceGroup {
    id: String!
    name: String!
}

"Paginated list of ResourceGroup objects."
type ResourceGroupConnection {
    "Total number of ResourceGroup objects matching the request arguments."
    count: Int!
    "List of ResourceGroup objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [ResourceGroupEdge!]!
    "List of ResourceGroup objects."
    nodes: [ResourceGroup!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the ResourceGroup object. This wrapper is used for pagination."
type ResourceGroupEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual ResourceGroup object wrapped by this edge."
    node: ResourceGroup!
}

"Information about the resource being validated."
type ResourceInfo {
    "Id of the resource."
    resourceId: String!
    "Type od the resource"
    resourceType: ResourceType!
}

"Empty response type"
type ResponseSuccess {
    "Whether request returned successfully"
    success: Boolean!
}

type Result {
    appFid: String!
    id: String!
    success: Boolean!
}

"Archival location resume result."
type ResumeTargetReply {
    "Polaris managed location ID."
    locationId: String!
    "Ownership status of the archival location."
    status: ArchivalLocationStatus!
}

type RetryBackupClusterResp {
    clusterUuid: String!
    eventSeriesId: String!
}

type RetryBackupResp {
    clusterResp: [RetryBackupClusterResp!]!
}

type Role {
    description: String!
    id: String!
    isReadOnly: Boolean!
    name: String!
    permissions: [Permission!]!
    protectableClusters: [String!]!
}

"Paginated list of Role objects."
type RoleConnection {
    "Total number of Role objects matching the request arguments."
    count: Int!
    "List of Role objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [RoleEdge!]!
    "List of Role objects."
    nodes: [Role!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the Role object. This wrapper is used for pagination."
type RoleEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual Role object wrapped by this edge."
    node: Role!
}

type RoleStatus {
    hasRole: Boolean!
}

type RoleTemplate {
    description: String!
    id: String!
    name: String!
    permissions: [Permission!]!
}

"Paginated list of RoleTemplate objects."
type RoleTemplateConnection {
    "Total number of RoleTemplate objects matching the request arguments."
    count: Int!
    "List of RoleTemplate objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [RoleTemplateEdge!]!
    "List of RoleTemplate objects."
    nodes: [RoleTemplate!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the RoleTemplate object. This wrapper is used for pagination."
type RoleTemplateEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual RoleTemplate object wrapped by this edge."
    node: RoleTemplate!
}

"Overall RU status."
type RollingUpgradeInfo {
    "List of nodes (names), currently being upgraded."
    ruCurrentNodes: [String!]!
    "List of RuNodeInfoEntry objects, one per node."
    ruNodeInfoList: [RollingUpgradeNodeInfoEntry!]!
}

"Detailed RU status of a node."
type RollingUpgradeNodeInfo {
    "Current state details."
    currentStateInfo: CurrentStateInfo
    "RU end time in seconds since epoch."
    ruEndTs: String!
    "RU start time in seconds since epoch."
    ruStartTs: String!
}

"RU node information entry."
type RollingUpgradeNodeInfoEntry {
    "Node name."
    nodeName: String!
    "Detailed RU status of a node."
    ruNodeInfo: RollingUpgradeNodeInfo
}

"Updated service account details"
type RotateServiceAccountSecretReply {
    accessTokenUri: String!
    clientId: String!
    clientSecret: String!
    name: String!
}

type Row {
    metadata: [Metadata!]!
    values: [CellData!]!
}

"Paginated list of Row objects."
type RowConnection {
    columns: [Column!]!
    "Total number of Row objects matching the request arguments."
    count: Int!
    "List of Row objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [RowEdge!]!
    "List of Row objects."
    nodes: [Row!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the Row object. This wrapper is used for pagination."
type RowEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual Row object wrapped by this edge."
    node: Row!
}

type RunCustomAnalyzerReply {
    matches: [CustomAnalyzerMatch!]!
}

"Metadata for all current running jobs."
type RunningJobsReply {
    "Array of running jobs."
    runningJobs: [ClusterMetadata!]!
}

type SDDLPermission {
    access: String!
    accessType: AceQualifierEnum!
    cn: String!
    dn: String!
    flags: [AceFlagsEnum!]!
    resolutionType: ResolutionTypeEnum!
}

"Summary for the no. of objects protected by sla."
type SLAIdToObjectCount {
    objectCount: Int!
    slaId: String!
}

"Supported in v5.3+"
type SapHanaAddSystemResponse {
    """

    Required. Supported in v5.3+
    Status of the job scheduled to refresh the system.
    """
    asyncRequestStatus: AsyncRequestStatus
    """

    Required. Supported in v5.3+
    The ID of the added SAP HANA system.
    """
    id: String!
}

type SapHanaAppMetadata {
    backupId: Long
    backupPrefix: String
    baseBackupId: Long
    baseFullSnapshotId: String
    files: [SapHanaDataBackupFile!]
    isExternalBackup: Boolean
    isRubrikTriggeredOnDemandBackup: Boolean
    rubrikSnapshotEndTime: DateTime
    rubrikSnapshotStartTime: DateTime
    sapHanaEndTime: DateTime
    sapHanaStartTime: DateTime
    snapshotType: String
}

type SapHanaConfig {
    differentialFrequency: Duration
    incrementalFrequency: Duration
    logRetention: Duration
}

type SapHanaDataBackupFile {
    backupFileSizeInBytes: Long!
    destinationPath: String!
    externalBackupId: String!
    redoLogPositionOpt: Long
    serviceType: String!
    sourceId: Long!
    sourceType: String!
}

"Additional information about backup data path"
type SapHanaDataPathSpecObject {
    name: String!
}

type SapHanaDatabase implements CdmHierarchyObject & CdmHierarchySnappableNew & HierarchyObject & SapHanaSystemDescendantType & SapHanaSystemPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    cdmId: String!
    "A link to view the snappable on the CDM cluster. For dev use only."
    cdmLink: String!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    clusterUuid: UUID!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    dataPathSpec: SapHanaDataPathSpecObject
    dataPathType: String!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    forceFull: Boolean!
    "The fid of the hierarchy object."
    id: UUID!
    info: SapHanaDatabaseInfoObject
    isRelic: Boolean!
    "Latest User note information."
    latestUserNote: LatestUserNote
    logSnapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter sap hana log snapshots by input"
        filter: SapHanaLogSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort sap hana log snapshots by field"
        sortBy: SapHanaLogSnapshotSortByEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): SapHanaLogSnapshotConnection!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The list of missed snapshots for this workload."
    missedSnapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int
    ): MissedSnapshotCommonConnection
    "The list of missed snapshots for this workload."
    missedSnapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: MissedSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): MissedSnapshotGroupByConnection
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot archived to AWS."
    newestArchivedSnapshot: CdmSnapshot
    "The newest snapshot replicated to a cluster."
    newestReplicatedSnapshot: CdmSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: CdmSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: CdmSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    primaryClusterUuid: UUID!
    recoverableRangeConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter sap hana recoverable ranges by input"
        filter: SapHanaRecoverableRangeFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort sap hana recoverable ranges by field"
        sortBy: SapHanaRecoverableRangeSortByEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): SapHanaRecoverableRangeConnection!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    sapHanaSystem: SapHanaSystem!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for the snapshots of this workload."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: CdmSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): cdmSnapshotGroupByConnection
    systemId: String!
}

"Paginated list of SapHanaDatabase objects."
type SapHanaDatabaseConnection {
    "Total number of SapHanaDatabase objects matching the request arguments."
    count: Int!
    "List of SapHanaDatabase objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [SapHanaDatabaseEdge!]!
    "List of SapHanaDatabase objects."
    nodes: [SapHanaDatabase!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the SapHanaDatabase object. This wrapper is used for pagination."
type SapHanaDatabaseEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual SapHanaDatabase object wrapped by this edge."
    node: SapHanaDatabase!
}

"Additional information about backint and database configuration"
type SapHanaDatabaseInfoObject {
    approxDbSizeInMb: Long!
    backintPath: String!
    databaseType: String!
    logBackupIntervalSecs: Int!
    numChannels: Int!
    paramFilePath: String!
    status: String!
}

"Supported in v5.3+"
type SapHanaHost {
    """

    Required. Supported in v5.3+
    The IP address or fully qualified domain name of the SAP HANA host.
    """
    hostName: String!
    hostType: SapHanaHostHostTypeEnum
    """

    Required. Supported in v5.3+
    The ID of the SAP HANA system host.
    """
    hostUuid: String!
    """

    Supported in v5.3+
    The local name of the SAP HANA host.
    """
    sapHanaHostName: String
    """

    Required. Supported in v5.3+
    The status of the SAP HANA system host.
    """
    status: String!
}

"Information about sap hana hosts of the system"
type SapHanaHostObject {
    clusterUuid: UUID!
    host: PhysicalHost!
    hostName: String!
    hostType: String!
    hostUuid: String!
    status: String!
}

type SapHanaLogBackup {
    backupId: Long
    bytesTransferred: Long
    doesContainCatalogFile: Boolean
    endTime: DateTime
    files: [SapHanaLogBackupFiles!]
    startTime: DateTime
}

type SapHanaLogBackupFiles {
    backupId: Long
    backupSizeInBytes: Long
    destinationPath: String
    destinationType: String
    externalBackupId: String
    hostName: String
    logPositionInterval: SapHanaLogPositionInterval
    serviceTypeName: String
    sourceId: Long
    sourceTypeName: String
}

type SapHanaLogPositionInterval {
    newestLogPosition: Long
    oldestLogPosition: Long
}

type SapHanaLogSnapshot {
    "app metadata of log snapshots in SAP HANA"
    appMetadata: SapHanaLogSnapshotAppMetadata
    cdmId: String!
    clusterUuid: UUID!
    date: DateTime
    fid: String!
    internalTimestamp: Long!
    isArchived: Boolean!
    locationMap: String
    snappableId: String!
    snappableType: String!
}

type SapHanaLogSnapshotAppMetadata {
    backups: [SapHanaLogBackup!]
}

"Paginated list of SapHanaLogSnapshot objects."
type SapHanaLogSnapshotConnection {
    "Total number of SapHanaLogSnapshot objects matching the request arguments."
    count: Int!
    "List of SapHanaLogSnapshot objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [SapHanaLogSnapshotEdge!]!
    "List of SapHanaLogSnapshot objects."
    nodes: [SapHanaLogSnapshot!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the SapHanaLogSnapshot object. This wrapper is used for pagination."
type SapHanaLogSnapshotEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual SapHanaLogSnapshot object wrapped by this edge."
    node: SapHanaLogSnapshot!
}

"Supported in v5.3+"
type SapHanaPatchSystemResponse {
    """

    Required. Supported in v5.3+
    Status of the job scheduled to refresh the SAP HANA system.
    """
    asyncRequestStatus: AsyncRequestStatus
    """

    Required. Supported in v5.3+
    Summary of the updated SAP HANA system object.
    """
    systemSummary: SapHanaSystemSummary
}

type SapHanaRecoverableRange {
    baseFullSnapshotId: String
    cdmId: String!
    clusterUuid: UUID!
    dbId: String!
    endTime: DateTime
    fid: String!
    isArchived: Boolean!
    startTime: DateTime
}

"Paginated list of SapHanaRecoverableRange objects."
type SapHanaRecoverableRangeConnection {
    "Total number of SapHanaRecoverableRange objects matching the request arguments."
    count: Int!
    "List of SapHanaRecoverableRange objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [SapHanaRecoverableRangeEdge!]!
    "List of SapHanaRecoverableRange objects."
    nodes: [SapHanaRecoverableRange!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the SapHanaRecoverableRange object. This wrapper is used for pagination."
type SapHanaRecoverableRangeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual SapHanaRecoverableRange object wrapped by this edge."
    node: SapHanaRecoverableRange!
}

"Supported in v5.3+"
type SapHanaSslInfo {
    """

    Supported in v7.0+
    Library path for SAP HANA crypto library (libsapcrypto.so).
    """
    cryptoLibPath: String
    encryptionProvider: SapHanaSslInfoEncryptionProviderEnum!
    """

    Supported in v7.0+
    Override the hostname used to verify the server's identity.
    """
    hostNameInCertificate: String
    """

    Required. Supported in v5.3+
    The path where the encryption key for the SAP HANA system is stored.
    """
    keyStorePath: String!
    """

    Supported in v7.0+
    Specifies whether to encrypt the database connection using SSL/TLS.
    """
    shouldEncrypt: Boolean
    """

    Supported in v7.0+
    Specifies whether to validate the SSL certificate of the SAP HANA DB server.
    """
    shouldValidateCertificate: Boolean
    """

    Supported in v7.0+
    Path to a trust store file that contains the public certificates of the SAP HANA DB server.
    """
    trustStorePath: String
}

"Information required to connect to SAP HANA database over SSL."
type SapHanaSslInformation {
    "Library path for SAP HANA crypto library (libsapcrypto.so)."
    cryptoLibPath: String!
    "The encryption provider for the SAPA HANA system."
    encryptionProvider: SapHanaEncryptionProvider!
    "Override the hostname used to verify the server's identity."
    hostNameInCertificate: String!
    "The path where the encryption key for the SAP HANA system is stored."
    keyStorePath: String!
    "Specifies whether to encrypt the database connection using SSL/TLS."
    shouldEncrypt: Boolean!
    "Specifies whether to validate the SSL certificate of the SAP HANA DB server."
    shouldValidateCertificate: Boolean!
    "Path to a trust store file that contains the public certificates of the SAP HANA DB server."
    trustStorePath: String!
}

type SapHanaSystem implements CdmHierarchyObject & HierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    cdmId: String!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    clusterUuid: UUID!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): SapHanaSystemDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    hosts: [SapHanaHostObject!]!
    "The fid of the hierarchy object."
    id: UUID!
    instanceNumber: String!
    lastRefreshTime: DateTime
    lastStatusUpdateTime: DateTime
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "List of physical children"
    physicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): SapHanaSystemPhysicalChildTypeConnection!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    primaryClusterUuid: UUID!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    sid: String!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "Information required to connect to SAP HANA database over SSL."
    sslInfo: SapHanaSslInformation
    status: SapHanaSystemStatus!
    statusMessage: [String!]!
}

"Paginated list of SapHanaSystem objects."
type SapHanaSystemConnection {
    "Total number of SapHanaSystem objects matching the request arguments."
    count: Int!
    "List of SapHanaSystem objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [SapHanaSystemEdge!]!
    "List of SapHanaSystem objects."
    nodes: [SapHanaSystem!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Paginated list of SapHanaSystemDescendantType objects."
type SapHanaSystemDescendantTypeConnection {
    "Total number of SapHanaSystemDescendantType objects matching the request arguments."
    count: Int!
    "List of SapHanaSystemDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [SapHanaSystemDescendantTypeEdge!]!
    "List of SapHanaSystemDescendantType objects."
    nodes: [SapHanaSystemDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the SapHanaSystemDescendantType object. This wrapper is used for pagination."
type SapHanaSystemDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual SapHanaSystemDescendantType object wrapped by this edge."
    node: SapHanaSystemDescendantType!
}

"Wrapper around the SapHanaSystem object. This wrapper is used for pagination."
type SapHanaSystemEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual SapHanaSystem object wrapped by this edge."
    node: SapHanaSystem!
}

"Supported in v5.3+"
type SapHanaSystemInfo {
    """

    Required. Supported in v5.3+
    The version of the SAP HANA system.
    """
    hanaVersion: String!
    """

    Required. Supported in v5.3+
    Indicates whether the SAP HANA system has replication enabled.
    """
    isSystemReplicationEnabled: Boolean!
}

"Paginated list of SapHanaSystemPhysicalChildType objects."
type SapHanaSystemPhysicalChildTypeConnection {
    "Total number of SapHanaSystemPhysicalChildType objects matching the request arguments."
    count: Int!
    "List of SapHanaSystemPhysicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [SapHanaSystemPhysicalChildTypeEdge!]!
    "List of SapHanaSystemPhysicalChildType objects."
    nodes: [SapHanaSystemPhysicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the SapHanaSystemPhysicalChildType object. This wrapper is used for pagination."
type SapHanaSystemPhysicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual SapHanaSystemPhysicalChildType object wrapped by this edge."
    node: SapHanaSystemPhysicalChildType!
}

"Supported in v5.3+"
type SapHanaSystemSummary {
    containerType: SapHanaSystemSummaryContainerTypeEnum
    "Required. Supported in v5.3+"
    hosts: [SapHanaHost!]!
    """

    Required. Supported in v5.3+
    The ID of the SAP HANA system.
    """
    id: String!
    """

    Required. Supported in v5.3+
    The instance number of the SAP HANA system.
    """
    instanceNumber: String!
    """

    Supported in v7.0+
    Specifies whether a SAP HANA system is archived.
    """
    isArchived: Boolean
    """

    Supported in v5.3+
    The UTC timestamp for when the SAP HANA system was last refreshed.
    """
    lastRefreshTime: DateTime
    """

    Required. Supported in v5.3+
    The number of databases in the SAP HANA system.
    """
    numDbs: Int!
    """

    Required. Supported in v5.3+
    The SAP System Identification (SID) code for the SAP HANA system.
    """
    sid: String!
    slaAssignable: SlaAssignable
    "Supported in v5.3+"
    sslInfo: SapHanaSslInfo
    status: SapHanaSystemSummaryStatusEnum!
    """

    Supported in v5.3+
    The message associated with the current SAP HANA system status.
    """
    statusMessage: String
    "Supported in v5.3+"
    systemInfo: SapHanaSystemInfo
    """

    Required. Supported in v5.3+
    The username of the SAP HANA system.
    """
    username: String!
}

type ScaleRuntime {
    deadline: DateTime
    newCount: Int!
    oldCount: Int!
    taskchainUuid: String!
}

"Metadata for rendering a scheduled report."
type ScheduledReport {
    createdAt: DateTime!
    creator: User!
    dailyTime: LocalTime
    hasCSVAttachment: Boolean!
    hasPDFAttachment: Boolean!
    "ID of the scheduled report."
    id: Int!
    lastEditor: User!
    lastUpdatedAt: DateTime!
    monthlyDate: Int
    monthlyTime: LocalTime
    recipients: [User!]!
    "The custom report id corresponding to this scheduled report."
    reportId: Int!
    title: String!
    weeklyDays: [WeekDayEnum!]
    weeklyTime: LocalTime
}

"Paginated list of ScheduledReport objects."
type ScheduledReportConnection {
    "Total number of ScheduledReport objects matching the request arguments."
    count: Int!
    "List of ScheduledReport objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [ScheduledReportEdge!]!
    "List of ScheduledReport objects."
    nodes: [ScheduledReport!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the ScheduledReport object. This wrapper is used for pagination."
type ScheduledReportEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual ScheduledReport object wrapped by this edge."
    node: ScheduledReport!
}

"Supported in v5.0+"
type SearchResponse {
    "Supported in v5.0+"
    fileVersions: [FileVersion!]!
    """

    Supported in v5.0+
    Just the filename without the whole path.
    """
    filename: String
    "Supported in v5.0+"
    path: String
}

"Supported in v5.0+"
type SearchResponseListResponse {
    """

    Supported in v5.0+
    List of matching objects.
    """
    data: [SearchResponse!]!
    """

    Supported in v5.0+
    If there is more.
    """
    hasMore: Boolean
    """

    Supported in v5.0+
    Total list responses.
    """
    total: Long
}

type SecurityGroup {
    id: String!
    name: String!
}

type SeedEnabledPoliciesReply {
    policies: [ClassificationPolicyDetail!]!
}

type SeedInitialPoliciesReply {
    policies: [ClassificationPolicyDetail!]!
}

"Service Account"
type ServiceAccount {
    clientId: String!
    description: String!
    lastLogin: DateTime
    name: String!
    roles: [Role!]!
}

"Paginated list of ServiceAccount objects."
type ServiceAccountConnection {
    "Total number of ServiceAccount objects matching the request arguments."
    count: Int!
    "List of ServiceAccount objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [ServiceAccountEdge!]!
    "List of ServiceAccount objects."
    nodes: [ServiceAccount!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the ServiceAccount object. This wrapper is used for pagination."
type ServiceAccountEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual ServiceAccount object wrapped by this edge."
    node: ServiceAccount!
}

"Enable or disable radar alerts for a snappable"
type SetSnappableAlertSettingReply {
    enabled: Boolean!
}

type SetupAzureO365ExocomputeResp {
    clusterId: String!
    taskchainId: String!
}

type ShareFileset implements CdmHierarchyObject & CdmHierarchySnappableNew & FilesetTemplateDescendantType & FilesetTemplatePhysicalChildType & HierarchyObject & HierarchySnappable & HostShareDescendantType & HostSharePhysicalChildType & PhysicalHostDescendantType & PhysicalHostPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    cdmId: String!
    "A link to view the snappable on the CDM cluster. For dev use only."
    cdmLink: String!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    hardlinkSupportEnabled: Boolean!
    host: PhysicalHost
    "The fid of the hierarchy object."
    id: UUID!
    isPassThrough: Boolean!
    isRelic: Boolean!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The list of missed snapshots for this workload."
    missedSnapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int
    ): MissedSnapshotCommonConnection
    "The list of missed snapshots for this workload."
    missedSnapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: MissedSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): MissedSnapshotGroupByConnection
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot archived to AWS."
    newestArchivedSnapshot: CdmSnapshot
    "The newest snapshot replicated to a cluster."
    newestReplicatedSnapshot: CdmSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: CdmSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: CdmSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    pathExceptions: [String!]!
    pathExcluded: [String!]!
    pathIncluded: [String!]!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "HostShare of this ShareFileset."
    share: HostShare
    "Share type of this fileset"
    shareType: ShareTypeEnum!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for the snapshots of this workload."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: CdmSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): cdmSnapshotGroupByConnection
    symlinkResolutionEnabled: Boolean!
}

"Response for Assign SLA Result."
type SlaAssignResult {
    "Returns true for successful assignment otherwise false."
    success: Boolean!
}

"Supported in v5.0+"
type SlaAssignable {
    """

    Required. Supported in v5.0+
    v5.0-v5.1: ID of the configured SLA domain
    v5.2+: The ID of the SLA Domain configured directly on the Rubrik object.
    """
    configuredSlaDomainId: String!
    """

    Required. Supported in v5.0+
    v5.0-v5.1: name of the configured SLA domain
    v5.2+: The name of the SLA Domain configured directly on the Rubrik object.
    """
    configuredSlaDomainName: String!
    configuredSlaDomainType: ConfiguredSlaTypeEnum
    """

    Required. Supported in v5.0+
    v5.0-v5.1:
    v5.2+: The ID of the Rubrik object.
    """
    id: String!
    """

    Supported in v5.1+
    v5.1: A Boolean that indicates whether the configured SLA domain is Retention Locked. When this value is 'true', the configured SLA domain is a Retention Lock SLA Domain.
    v5.2+: Indicates whether the configured SLA Domain is Retention Locked. When this value is 'true', the configured SLA Domain is a Retention Lock SLA Domain.
    """
    isConfiguredSlaDomainRetentionLocked: Boolean
    """

    Required. Supported in v5.0+
    v5.0-v5.1:
    v5.2+: The name of the Rubrik object.
    """
    name: String!
    """

    Required. Supported in v5.0+
    v5.0-v5.1:
    v5.2+: The ID of the cluster that manages the Rubrik object.
    """
    primaryClusterId: String!
    """

    Supported in v5.2+
    The UTC time when the SLA Domain was last updated.
    """
    slaLastUpdateTime: DateTime
}

type SlaAuditDetail {
    applyToExistingSnapshots: Boolean!
    cluster: Cluster
    currentSlaSummary: SlaDomain
    previousSlaSummary: SlaDomain
    timestamp: DateTime
    userAction: String!
    userName: String!
}

"Configuration of the SLA of a snapshot."
type SlaConfig {
    "ID of the SLA."
    id: String!
    "Name of the SLA."
    name: String!
}

"Paginated list of SlaDomain objects."
type SlaDomainConnection {
    "Total number of SlaDomain objects matching the request arguments."
    count: Int!
    "List of SlaDomain objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [SlaDomainEdge!]!
    "List of SlaDomain objects."
    nodes: [SlaDomain!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the SlaDomain object. This wrapper is used for pagination."
type SlaDomainEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual SlaDomain object wrapped by this edge."
    node: SlaDomain!
}

"SLA Domain with warnings detail"
type SlaDomainWithWarnings {
    slaDomain: SlaDomain!
    warnings: [SlaWarning!]!
}

"Type that contains SLA name and ID."
type SlaInfo {
    "ID of SLA."
    id: String!
    "Name of SLA."
    name: String!
}

type SlaLogFrequencyConfigResult {
    retention: Duration
}

"Supported in v5.3+"
type SlaManagedVolumeDetail {
    """

    Required. Supported in v5.3+
    Backup script specifications.
    """
    backupScriptDetails: SlaManagedVolumeScriptSummary
    """

    Required. Supported in v5.3+
    v5.3-v7.0: List of paths the host uses to mount individual channels for managed volumes.
    v8.0: List of paths the host uses to mount individual channels for Managed Volumes.
    """
    channelHostMountPaths: [String!]!
    """

    Required. Supported in v5.3+
    Configuration of the host on which the SLA Managed Volume channels are mounted.
    """
    hostDetails: SlaManagedVolumeHostSummary
    """

    Supported in v5.3+
    v5.3-v7.0: Specifications of the script run after unsuccessful backup.
    v8.0: Specifications of the script run after an unsuccessful backup.
    """
    postBackupScriptOnBackupFailureDetails: SlaManagedVolumeScriptSummary
    """

    Supported in v5.3+
    v5.3-v7.0: Specifications of the script run after successful backup.
    v8.0: Specifications of the script run after a successful backup.
    """
    postBackupScriptOnBackupSuccessDetails: SlaManagedVolumeScriptSummary
    """

    Supported in v5.3+
    Specifications of the script run prior to backup.
    """
    preBackupScriptDetails: SlaManagedVolumeScriptSummary
    """

    Supported in v5.3+
    Indicates if a failure of the script run prior to backup halts the backup process.
    """
    shouldCancelBackupOnPreBackupScriptFailure: Boolean
}

"Host of the SLA Managed volume."
type SlaManagedVolumeHost {
    "Identifier of the host cluster."
    clusterUuid: UUID!
    "FID of the host."
    fid: UUID!
    "Type of the host."
    hostType: String!
    "Name of the host."
    name: String!
    "Status of the host."
    status: String!
}

"Supported in v5.3+"
type SlaManagedVolumeHostSummary {
    """

    Required. Supported in v5.3+
    v5.3: ID of the host mounting the managed volume channels and running the scripts
    v6.0-v7.0: ID of the host mounting the managed volume channels and running the scripts.
    v8.0: ID of the host mounting the Managed Volume channels and running the scripts.
    """
    hostId: String!
    """

    Required. Supported in v5.3+
    The name of the host on which the SLA Managed Volume channels are mounted.
    """
    hostName: String!
    """

    Required. Supported in v5.3+
    The type of the operating system running on the host. Possible responses are `Linux`, `Windows` and `UnixLike`.
    """
    operatingSystemType: String!
    """

    Required. Supported in v5.3+
    v5.3-v7.0: The status of the Rubrik Backup Service (RBS) installed on the managed volume host. Possible responses are `Connected`, `Disconnected` and `REPLICATION_TARGET` when the host is being replicated from a separate Rubrik cluster.
    v8.0: Status of the Rubrik Backup Service (RBS) installed on the Managed Volume host. Possible responses are `Connected`, `Disconnected`, and `REPLICATION_TARGET` when the host is being replicated from a separate Rubrik cluster.
    """
    rubrikBackupServiceStatus: String!
}

"Supported in v5.3+"
type SlaManagedVolumeScriptSummary {
    """

    Required. Supported in v5.3+
    Name of the user running the script on the host.
    """
    runAsUser: String!
    """

    Required. Supported in v5.3+
    v5.3-v7.0: The full command with arguments to execute the script.
    v8.0: Full command, with arguments, to execute the script.
    """
    scriptCommand: String!
    """

    Supported in v5.3+
    (Optional) Timeout period, in seconds, for the script. Specifying 0, or not including a value, indicates there is no timeout period.
    """
    timeout: Long
}

"Replication cluster specific information."
type SlaReplicationCluster {
    "Id of replication cluster."
    id: UUID!
    "Name of replication cluster."
    name: String!
}

type SlaResult {
    success: Boolean!
}

"SLA Domain taskchain information for upgrade."
type SlaTaskchainInfo {
    "Error message when taskchain can not be scheduled."
    errMsg: String!
    "SLA Domain ID."
    slaId: String!
    "Taskchain ID."
    taskchainId: String!
}

"Information about the most recently attempted SLA Domain upgrade."
type SlaUpgrade {
    "Failure message."
    msg: String!
    "Status of the upgrade."
    status: SlaMigrationStatus!
    "Taskchain ID for upgrade."
    taskchainId: String!
}

"Information about eligibility of the SLA Domain for upgrade."
type SlaUpgradeEligibility {
    "Reason for the SLA Domain being ineligible for upgrade."
    ineligibilityReason: SlaMigrationIneligibilityReason!
    "Specifies whether the SLA Domain is eligible for upgrade."
    isEligible: Boolean!
}

"SLA Domain upgrade information."
type SlaUpgradeInfo {
    "Information about eligibility of the SLA Domain for upgrade."
    eligibility: SlaUpgradeEligibility
    "Information about the most recently attempted SLA Domain upgrade."
    latestUpgrade: SlaUpgrade
}

"Warning for SLA Assignment for each object"
type SlaWarning {
    code: AssignSLAWarningsEnum!
    objectIds: [String!]!
    severity: WarningSeverityEnum!
}

type SnapMirrorCloud implements CdmHierarchyObject & CdmHierarchySnappableNew & HierarchyObject & HierarchySnappable & NasNamespaceDescendantType & NasSystemDescendantType & NasVolumeDescendantType & NasVolumeLogicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    cdmId: String!
    "A link to view the snappable on the CDM cluster. For dev use only."
    cdmLink: String!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "object id"
    id: UUID!
    isRelic: Boolean!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The list of missed snapshots for this workload."
    missedSnapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int
    ): MissedSnapshotCommonConnection
    "The list of missed snapshots for this workload."
    missedSnapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: MissedSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): MissedSnapshotGroupByConnection
    "The name of the hierarchy object."
    name: String!
    "The NAS volume to which this SnapMirror Cloud belongs."
    nasVolume: NasVolume
    "The newest snapshot archived to AWS."
    newestArchivedSnapshot: CdmSnapshot
    "The newest snapshot replicated to a cluster."
    newestReplicatedSnapshot: CdmSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: CdmSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: CdmSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "Label applied to the SnapMirror Cloud."
    snapMirrorLabel: String
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for the snapshots of this workload."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: CdmSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): cdmSnapshotGroupByConnection
}

"Supported in v7.0+"
type SnapMirrorCloudDetail {
    "Supported in v7.0+"
    archiveStorage: Long
    "Supported in v7.0+"
    localStorage: Long
    "Supported in v7.0+"
    protectionDate: DateTime
    snapMirrorCloudSummary: SnapMirrorCloudSummary
    "Supported in v7.0+"
    snapshotCount: Int
}

"Supported in v7.0+"
type SnapMirrorCloudSummary {
    """

    Supported in v7.0+
    ID of the effective SLA Domain for this SnapMirror Cloud protected object.
    """
    effectiveSlaDomainId: String
    """

    Supported in v7.0+
    Name of the effective SLA Domain for this SnapMirror Cloud protected object.
    """
    effectiveSlaDomainName: String
    """

    Supported in v7.0+
    Optional field containing the Polaris managed ID of the effective SLA domain, if it is managed by Polaris.
    """
    effectiveSlaDomainPolarisManagedId: String
    """

    Supported in v7.0+
    Optional Boolean value that specifies whether the effective SLA Domain of a SnapMirror Cloud protected object is retention locked. When this value is 'true,' the SLA Domain is retention locked. When this value is 'false,' the SLA Domain is not retention locked.
    """
    isEffectiveSlaDomainRetentionLocked: Boolean
    "Required. Supported in v7.0+"
    isRelic: Boolean!
    "Required. Supported in v7.0+"
    nasNamespaceId: String!
    "Required. Supported in v7.0+"
    nasNamespaceName: String!
    "Required. Supported in v7.0+"
    nasSystemId: String!
    "Required. Supported in v7.0+"
    nasSystemName: String!
    "Required. Supported in v7.0+"
    nasVolumeId: String!
    "Required. Supported in v7.0+"
    nasVolumeName: String!
    "Supported in v7.0+"
    relationshipUuid: String
    slaAssignable: SlaAssignable
    "Supported in v7.0+"
    snapMirrorLabel: String
}

"An object that can be snapshotted."
type Snappable {
    archivalComplianceStatus: ComplianceStatusEnum
    archivalSnapshotLag: Int
    "The number of snapshots that have been archived."
    archiveSnapshots: Int
    "The amount of storage taken by archived snapshots."
    archiveStorage: Long
    awaitingFirstFull: Boolean
    "The cluster the snappable belongs to"
    cluster: Cluster
    "The current compliance status of the snappable."
    complianceStatus: ComplianceStatusEnum
    "The change from transferred bytes to physical bytes"
    dataReduction: Float
    fid: UUID
    "The id of the snappable."
    id: String!
    "The timestamp of the last taken snapshot."
    lastSnapshot: DateTime
    latestArchivalSnapshot: DateTime
    latestReplicationSnapshot: DateTime
    "The local effective storage size in bytes."
    localEffectiveStorage: Long
    "The local metered data size in bytes."
    localMeteredData: Long
    localOnDemandSnapshots: Int
    "The local protected data size in bytes."
    localProtectedData: Long
    localSLASnapshots: Int
    "The number of snapshots locally present."
    localSnapshots: Int
    "The local storage size in bytes."
    localStorage: Long
    location: String!
    "Logical bytes taken by snapshots of this snappable."
    logicalBytes: Long
    logicalDataReduction: Float
    "The number of snapshots that were missed."
    missedSnapshots: Int
    "The name of the snappable."
    name: String!
    "The object type of the snappable."
    objectType: ObjectTypeEnum!
    "Physical bytes taken by snapshots of this snappable."
    physicalBytes: Long
    "The date and time when the snappable was last protected."
    protectedOn: DateTime
    "The protection status of the snappable."
    protectionStatus: ProtectionStatusEnum!
    "The provisioned bytes size."
    provisionedBytes: Long
    "The time this snappable data was pulled from cdm."
    pullTime: DateTime!
    "The number of snapshots that have been replicated."
    replicaSnapshots: Int
    "The amount of storage taken by replicated snapshots."
    replicaStorage: Long
    replicationComplianceStatus: ComplianceStatusEnum
    replicationSnapshotLag: Int
    "The sla domain of the snappable."
    slaDomain: SlaDomain
    "The total number of snapshots present for the snapshot."
    totalSnapshots: Int
    "Bytes ingested over the network for this snappable."
    transferredBytes: Long
    "Total bytes used."
    usedBytes: Long
}

type SnappableAggregation {
    archiveStorage: Long!
    logicalBytes: Long!
    missedSnapshots: Int!
    physicalBytes: Long!
    replicaStorage: Long!
    totalSnapshots: Int!
}

"A snappable which has a snapshot or children with anomalous activity."
type SnappableAnomaly {
    """

    A list of children belonging to the snappable which were also determined
    to have snapshots with anomalous activity.
    """
    anomalousChildren: [SnappableAnomaly!]!
    """

    The creation date of the snapshot which was
    determined to have anomalous activity.
    """
    anomalousSnapshotDate: DateTime!
    "The fid of the snapshot which was determined to have anomalous activity."
    anomalousSnapshotFid: String!
    "The cdm id of the snapshot which was determined to have anomalous activity."
    anomalousSnapshotId: String!
    "The Rubrik cluster associated with the object."
    cluster: Cluster!
    "The number of files created within the snapshot."
    createdFileCount: Long!
    "The number of files deleted within the snapshot."
    deletedFileCount: Long!
    "The level of encryption detected within the snapshot."
    encryption: EncryptionLevel!
    "The location of the object."
    location: String!
    "The number of files modified within the snapshot."
    modifiedFileCount: Long!
    "The object type of the snappable."
    objectType: HierarchyObjectTypeEnum!
    "The severity of the anomalous activity detected within the snapshot."
    severity: ActivitySeverity!
    "The fid of the snappable."
    snappableFid: String!
    "The cdm id of the snappable."
    snappableId: String!
    "The name of the snappable."
    snappableName: String!
    "The number of suspicious files within the snapshot."
    suspiciousFileCount: Long!
    """

    The total number of children belong to the snappable, regardless
    of whether they have snapshots containing anomalous activity.
    """
    totalChildren: Long!
}

"Paginated list of SnappableAnomaly objects."
type SnappableAnomalyConnection {
    aggregation: AggregatedValues!
    "Total number of SnappableAnomaly objects matching the request arguments."
    count: Int!
    "List of SnappableAnomaly objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [SnappableAnomalyEdge!]!
    "List of SnappableAnomaly objects."
    nodes: [SnappableAnomaly!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the SnappableAnomaly object. This wrapper is used for pagination."
type SnappableAnomalyEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual SnappableAnomaly object wrapped by this edge."
    node: SnappableAnomaly!
}

type SnappableChart {
    focus: ReportFocusEnum!
    groupBy: [SnappableGroupByEnum!]
    name: String!
}

"Paginated list of Snappable objects."
type SnappableConnection {
    aggregation: SnappableAggregation!
    "Total number of Snappable objects matching the request arguments."
    count: Int!
    "List of Snappable objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [SnappableEdge!]!
    "List of Snappable objects."
    nodes: [Snappable!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the Snappable object. This wrapper is used for pagination."
type SnappableEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual Snappable object wrapped by this edge."
    node: Snappable!
}

"Snappable data with groupby info applied to it."
type SnappableGroupBy {
    "The data groupby info."
    groupByInfo: SnappableGroupByInfo!
    "Paginated snappable data."
    snappableConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort snappables by field"
        sortBy: SnappableSortByEnum = Name,
        "sort order"
        sortOrder: SortOrderEnum
    ): SnappableConnection!
    "Further provide groupings for the data."
    snappableGroupBy(
        "group snappables by field"
        groupBy: SnappableGroupByEnum!
    ): [SnappableGroupBy!]!
}

"Snappable data with groupby info applied to it with data previous to specified time"
type SnappableGroupByAtSpecifiedTime {
    "The data groupby info."
    groupByInfo: SnappableGroupByInfo!
    "Paginated snappable data."
    snappableConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort snappables by field"
        sortBy: SnappableSortByEnum = Name,
        "sort order"
        sortOrder: SortOrderEnum
    ): SnappableConnection!
    "Further provide groupings for the data."
    snappableGroupBy(
        "group snappables by field"
        groupBy: SnappableGroupByEnum!
    ): [SnappableGroupBy!]!
}

"Paginated list of SnappableGroupByAtSpecifiedTime objects."
type SnappableGroupByAtSpecifiedTimeConnection {
    "Total number of SnappableGroupByAtSpecifiedTime objects matching the request arguments."
    count: Int!
    "List of SnappableGroupByAtSpecifiedTime objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [SnappableGroupByAtSpecifiedTimeEdge!]!
    "List of SnappableGroupByAtSpecifiedTime objects."
    nodes: [SnappableGroupByAtSpecifiedTime!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the SnappableGroupByAtSpecifiedTime object. This wrapper is used for pagination."
type SnappableGroupByAtSpecifiedTimeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual SnappableGroupByAtSpecifiedTime object wrapped by this edge."
    node: SnappableGroupByAtSpecifiedTime!
}

"Paginated list of SnappableGroupBy objects."
type SnappableGroupByConnection {
    "Total number of SnappableGroupBy objects matching the request arguments."
    count: Int!
    "List of SnappableGroupBy objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [SnappableGroupByEdge!]!
    "List of SnappableGroupBy objects."
    nodes: [SnappableGroupBy!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the SnappableGroupBy object. This wrapper is used for pagination."
type SnappableGroupByEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual SnappableGroupBy object wrapped by this edge."
    node: SnappableGroupBy!
}

type SnappableInstanceType {
    awsInstanceType: AwsInstanceType!
}

"Paginated list of SnappableInstanceType objects."
type SnappableInstanceTypeConnection {
    "Total number of SnappableInstanceType objects matching the request arguments."
    count: Int!
    "List of SnappableInstanceType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [SnappableInstanceTypeEdge!]!
    "List of SnappableInstanceType objects."
    nodes: [SnappableInstanceType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
    suggestInstanceType: SnappableInstanceType
}

"Wrapper around the SnappableInstanceType object. This wrapper is used for pagination."
type SnappableInstanceTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual SnappableInstanceType object wrapped by this edge."
    node: SnappableInstanceType!
}

"Snappable recovery info."
type SnappableRecoveryInfo {
    "Whether snapshot metadata refresh is in progress."
    isRefreshInProgressOpt: Boolean
    "Recovery infomation update time."
    lastUpdatedTimeOpt: DateTime
    "Reader location ID."
    locationId: String!
    "Newly assigned data source ID."
    newSnappableId: String!
    "Original data source ID."
    oldSnappableId: String!
}

"Count, snappable_id, snappable_type of how many times Radar has scanned an object"
type SnappableScanned {
    count: Long!
    snappableId: String!
    snappableType: String!
}

type SnappableSecurityGroup {
    description: String!
    id: String!
    name: String!
    ownerId: String!
    securityGroupId: String!
    "vpc of the security group"
    vpc: Vpc
}

"Paginated list of SnappableSecurityGroup objects."
type SnappableSecurityGroupConnection {
    "Total number of SnappableSecurityGroup objects matching the request arguments."
    count: Int!
    "List of SnappableSecurityGroup objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [SnappableSecurityGroupEdge!]!
    "List of SnappableSecurityGroup objects."
    nodes: [SnappableSecurityGroup!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the SnappableSecurityGroup object. This wrapper is used for pagination."
type SnappableSecurityGroupEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual SnappableSecurityGroup object wrapped by this edge."
    node: SnappableSecurityGroup!
}

type SnappableStorageVolumeType {
    awsStorageVolumeType: AwsStorageVolumeType!
}

"Paginated list of SnappableStorageVolumeType objects."
type SnappableStorageVolumeTypeConnection {
    "Total number of SnappableStorageVolumeType objects matching the request arguments."
    count: Int!
    "List of SnappableStorageVolumeType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [SnappableStorageVolumeTypeEdge!]!
    "List of SnappableStorageVolumeType objects."
    nodes: [SnappableStorageVolumeType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the SnappableStorageVolumeType object. This wrapper is used for pagination."
type SnappableStorageVolumeTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual SnappableStorageVolumeType object wrapped by this edge."
    node: SnappableStorageVolumeType!
}

type SnappableSubnet {
    availabilityZone: String!
    cidrBlock: AddressBlockV4
    id: String!
    name: String!
    subnetId: String!
    "vpc of the subnet"
    vpc: Vpc
}

"Paginated list of SnappableSubnet objects."
type SnappableSubnetConnection {
    "Total number of SnappableSubnet objects matching the request arguments."
    count: Int!
    "List of SnappableSubnet objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [SnappableSubnetEdge!]!
    "List of SnappableSubnet objects."
    nodes: [SnappableSubnet!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the SnappableSubnet object. This wrapper is used for pagination."
type SnappableSubnetEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual SnappableSubnet object wrapped by this edge."
    node: SnappableSubnet!
}

type SnappableTable {
    focus: ReportFocusEnum!
    groupBy: [SnappableGroupByEnum!]
    name: String!
    selectedColumns: [SnappableTableColumnEnum!]!
    sortBy: SnappableSortByEnum
    sortOrder: SortOrderEnum
}

type SnappableTypeSummary {
    count: Int!
    snappableType: HierarchyObjectTypeEnum!
}

"Details of the setup for performing backups for various object types."
type SnappableTypeToBackupSetupSpecs {
    "The object from where the setup specification is inherited."
    setupSourceObject: PathNode!
    "The object type."
    snappableType: SnappableLevelHierarchyTypeEnum!
}

type SnapshotDelta {
    deltaAmount: Long!
    deltaType: DeltaTypeEnum!
}

"A generic snapshot type"
type SnapshotDistribution {
    "The id of the snappable"
    id: UUID!
    "Number of on demand snapshots"
    onDemandCount: Long!
    "Number of retrieved snapshots"
    retrievedCount: Long!
    "Number of scheduled snapshots"
    scheduledCount: Long!
    "Total number of snapshots"
    totalCount: Long!
}

type SnapshotFile {
    absolutePath: String!
    displayPath: String!
    fileMode: FileModeEnum!
    filename: String!
    lastModified: DateTime!
    path: String!
    size: Long!
    statusMessage: String!
}

"Paginated list of SnapshotFile objects."
type SnapshotFileConnection {
    "Total number of SnapshotFile objects matching the request arguments."
    count: Int!
    "List of SnapshotFile objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [SnapshotFileEdge!]!
    "List of SnapshotFile objects."
    nodes: [SnapshotFile!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

type SnapshotFileDelta {
    childrenDeltas: [SnapshotDelta!]!
    file: SnapshotFile!
    selfDeltas: [SnapshotDelta!]!
}

"Paginated list of SnapshotFileDelta objects."
type SnapshotFileDeltaConnection {
    "Total number of SnapshotFileDelta objects matching the request arguments."
    count: Int!
    currentSnapshot: CdmSnapshot!
    "List of SnapshotFileDelta objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [SnapshotFileDeltaEdge!]!
    "List of SnapshotFileDelta objects."
    nodes: [SnapshotFileDelta!]!
    "General information about this page of results."
    pageInfo: PageInfo!
    previousSnapshot: CdmSnapshot
}

"Wrapper around the SnapshotFileDelta object. This wrapper is used for pagination."
type SnapshotFileDeltaEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual SnapshotFileDelta object wrapped by this edge."
    node: SnapshotFileDelta!
}

"Wrapper around the SnapshotFile object. This wrapper is used for pagination."
type SnapshotFileEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual SnapshotFile object wrapped by this edge."
    node: SnapshotFile!
}

"Supported in v5.2+"
type SnapshotLocationRetentionInfo {
    """

    Supported in v5.2+
    Time when the snapshot expired or is expected to expire at this location. This field will only be set if the snapshot has ever existed at the location. If the snapshot is present at the location, but the expiration time calculation is pending, this field will be absent. If the expiration time calculation is complete and the field is still absent, the snapshot will be retained forever at this location.
    """
    expirationTime: DateTime
    """

    Required. Supported in v5.2+
    ID of the location.
    """
    id: String!
    """

    Supported in v5.2+
    A Boolean that indicates whether expiration date for snapshot has been calculated. This field will be absent if the snapshot has never existed at this location.
    """
    isExpirationDateCalculated: Boolean
    """

    Supported in v5.2+
    Indicates whether expiration information of the snapshot is unavailable at this location. This field is always and only present for replication locations. Its value is true if and only if the replicated snapshots are from pre-5.2 cluster.
    """
    isExpirationInformationUnavailable: Boolean
    """

    Required. Supported in v5.2+
    Boolean that specifies whether the snapshot is present at this location. When this value is 'false,' the snapshot is expired at this location. Because retention information is unreliable for locations where the snapshots are not present, confirming that this value is 'true' is the best practice.
    """
    isSnapshotPresent: Boolean!
    """

    Required. Supported in v5.2+
    Name of the location.
    """
    name: String!
    """

    Supported in v5.2+
    The tag to determine what frequency the snapshot corresponds to at this location. The snapshot tag can be hourly, daily, weekly, monthly, quarterly, or yearly depending on the SLA frequency which is used to determine the retention of the snapshot. A value of "Ready for Deletion" means that the snapshot will be deleted soon. A value of "Forever" means that the snapshot will never be deleted. This field is absent when the tag computation is incomplete.
    """
    snapshotFrequency: String
}

type SnapshotResult {
    snapshotFid: String!
    snapshotTime: Long!
}

"Paginated list of SnapshotResult objects."
type SnapshotResultConnection {
    "Total number of SnapshotResult objects matching the request arguments."
    count: Int!
    "List of SnapshotResult objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [SnapshotResultEdge!]!
    "List of SnapshotResult objects."
    nodes: [SnapshotResult!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the SnapshotResult object. This wrapper is used for pagination."
type SnapshotResultEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual SnapshotResult object wrapped by this edge."
    node: SnapshotResult!
}

"Supported in v5.2+"
type SnapshotRetentionInfo {
    """

    Required. Supported in v5.2+
    List of snapshot retention information on the archival locations.
    """
    archivalInfos: [SnapshotLocationRetentionInfo!]!
    """

    Required. Supported in v5.2+
    Snapshot retention information such as frequency tag and expected expiration time on the cloud native locations.
    """
    cloudNativeLocationInfo: [SnapshotLocationRetentionInfo!]!
    """

    Supported in v5.2+
    Snapshot retention information on the local cluster.
    """
    localInfo: SnapshotLocationRetentionInfo
    """

    Required. Supported in v5.2+
    List of snapshot retention information on the replicated locations.
    """
    replicationInfos: [SnapshotLocationRetentionInfo!]!
}

type SnapshotSchedule {
    daily: DailySnapshotSchedule
    hourly: HourlySnapshotSchedule
    minute: MinuteSnapshotSchedule
    monthly: MonthlySnapshotSchedule
    quarterly: QuarterlySnapshotSchedule
    weekly: WeeklySnapshotSchedule
    yearly: YearlySnapshotSchedule
}

"DataType representing the sub objects captured in a snapshot."
type SnapshotSubObj {
    "A volume captured in a volume group snapshot."
    volumeGroupSubObj: VolumeGroupSubObject
}

"The sub objects captured in a snapshot."
type SnapshotSubObject {
    "The sub object captured in a snapshot"
    subObj: SnapshotSubObj!
}

"Supported in v5.2+"
type SnapshotSummary {
    """

    Required. Supported in v5.2+
    Time at which the snapshot was taken.
    """
    date: DateTime
    """

    Required. Supported in v5.2+
    ID of the snapshot.
    """
    id: String!
    """

    Required. Supported in v5.2+
    A Boolean value that indicates whether custom retention is applied to the specified snapshot. Value is true when custom retention is applied to the snapshot.
    """
    isCustomRetentionApplied: Boolean!
    """

    Required. Supported in v5.2+
    Indicates whether the snapshot is protected by a Retention Locked SLA Domain.
    """
    isRetentionLockApplied: Boolean!
    """

    Required. Supported in v5.2+
    Retention information for snapshots at the local, archival, and replication locations.
    """
    snapshotRetentionInfo: SnapshotRetentionInfo
    snapshotType: UnmanagedSnapshotTypeEnum!
}

"Paginated list of SnapshotSummary objects."
type SnapshotSummaryConnection {
    "Total number of SnapshotSummary objects matching the request arguments."
    count: Int!
    "List of SnapshotSummary objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [SnapshotSummaryEdge!]!
    "List of SnapshotSummary objects."
    nodes: [SnapshotSummary!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the SnapshotSummary object. This wrapper is used for pagination."
type SnapshotSummaryEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual SnapshotSummary object wrapped by this edge."
    node: SnapshotSummary!
}

type SonarContentReportChart {
    focus: ReportFocusEnum!
    groupBy: [SonarContentReportGroupByEnum!]
    name: String!
}

type SonarContentReportTable {
    focus: ReportFocusEnum!
    groupBy: [SonarContentReportGroupByEnum!]
    name: String!
    selectedColumns: [SonarContentReportTableColumnEnum!]!
    sortBy: SonarContentReportSortByEnum
    sortOrder: SortOrderEnum
}

type SonarContentReportTableRow {
    analyzerGroupResults: [AnalyzerGroupResult!]!
    analyzerId: String!
    analyzerResults: [AnalyzerResult!]!
    cluster: String!
    fileName: String!
    filesWithHits: Int!
    hits: Hits
    id: String!
    location: String!
    objectName: String!
    objectType: HierarchyObjectTypeEnum!
    path: String!
    policyId: String!
    size: Long!
    slaDomainId: String!
    snappableFid: String!
    snapshotTimestamp: Long!
}

"Paginated list of SonarContentReportTableRow objects."
type SonarContentReportTableRowConnection {
    "Total number of SonarContentReportTableRow objects matching the request arguments."
    count: Int!
    "List of SonarContentReportTableRow objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [SonarContentReportTableRowEdge!]!
    "List of SonarContentReportTableRow objects."
    nodes: [SonarContentReportTableRow!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the SonarContentReportTableRow object. This wrapper is used for pagination."
type SonarContentReportTableRowEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual SonarContentReportTableRow object wrapped by this edge."
    node: SonarContentReportTableRow!
}

type SonarReportChart {
    focus: ReportFocusEnum!
    groupBy: [SonarReportGroupByEnum!]
    name: String!
}

type SonarReportGroupByResult {
    count: Long!
    groupByValue: String!
    timeSeriesResults: [TimeSeriesResult!]!
}

"Paginated list of SonarReportGroupByResult objects."
type SonarReportGroupByResultConnection {
    "Total number of SonarReportGroupByResult objects matching the request arguments."
    count: Int!
    "List of SonarReportGroupByResult objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [SonarReportGroupByResultEdge!]!
    "List of SonarReportGroupByResult objects."
    nodes: [SonarReportGroupByResult!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the SonarReportGroupByResult object. This wrapper is used for pagination."
type SonarReportGroupByResultEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual SonarReportGroupByResult object wrapped by this edge."
    node: SonarReportGroupByResult!
}

type SonarReportTable {
    focus: ReportFocusEnum!
    groupBy: [SonarReportGroupByEnum!]
    name: String!
    selectedColumns: [SonarReportTableColumnEnum!]!
    sortBy: SonarReportSortByEnum
    sortOrder: SortOrderEnum
}

type SonarReportTableRow {
    numHighRiskLocations: Int!
    numObjects: Int!
    numViolatedFiles: Int!
    policyId: String!
    policyName: String!
    policyStatus: SonarReportTablePolicyStatusEnum!
    violations: Int!
}

"Paginated list of SonarReportTableRow objects."
type SonarReportTableRowConnection {
    "Total number of SonarReportTableRow objects matching the request arguments."
    count: Int!
    "List of SonarReportTableRow objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [SonarReportTableRowEdge!]!
    "List of SonarReportTableRow objects."
    nodes: [SonarReportTableRow!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the SonarReportTableRow object. This wrapper is used for pagination."
type SonarReportTableRowEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual SonarReportTableRow object wrapped by this edge."
    node: SonarReportTableRow!
}

type Source {
    stringValue: String!
}

type SourceBlueprintInfo {
    blueprintId: String!
    sourceChildInfos: [SourceChildInfo!]!
}

type SourceChildInfo {
    childInfo: ChildInfo!
    failoverChildId: String!
}

"Configuration Params for the mosaic source object."
type SourceConfigParams {
    "List of cassandra yaml file paths."
    cassandraYaml: [String!]!
    "List of dse yaml file paths"
    dseYaml: [String!]!
    "Path to https certificate."
    httpsCertificate: String!
    "JMX Username."
    jmxUser: String!
    "Database username."
    sourceDbUser: String!
    "Port number used for https connection."
    sourceHttpsPort: Int!
    sourcePort: Int!
    "Configured RPC port on source."
    sourceRpcPort: Int!
    "Source SSL Configuration."
    sslOptions: CassandraSslOptions
}

type SpecificReplicationSpec {
    bidirectionalSpec: BidirectionalReplicationSpec
    cloudLocationSpec: ReplicationToCloudLocationSpec
    cloudRegionSpec: ReplicationToCloudRegionSpec
    unidirectionalSpec: UnidirectionalReplicationSpec
}

"Response of the operation to initiate Azure Cloud Account OAuth."
type StartAzureCloudAccountOauthReply {
    "Client ID of the application configured for authentication of the Azure tenant."
    clientId: String!
    "Session ID of the current OAuth session."
    sessionId: String!
}

type StartCrawlReply {
    crawlId: String!
}

"A Recovery Plan failover job response."
type StartRecoveryPlanReply {
    "Recovery Plan failover job status."
    failoverJobsStatus: [FailoverJobStatusReply!]!
}

"Reply of the threat hunt request."
type StartThreatHuntReply {
    """

    Forever id of the hunt that can be used
    to query other Polaris threat hunt APIs.
    """
    huntId: String!
    "Status of the threat hunt."
    huntStatus: AsyncRequestStatus
    "Status of the metadata load request."
    isSyncSuccessful: Boolean!
}

type StartTimeAttributes {
    dayOfWeek: DayOfWeekOpt
    hour: Int!
    minute: Int!
}

"Start upgrade response."
type StartUpgradeReply {
    "Upgrade context."
    context: Context
    "Event series id of rolling upgrade."
    eventSeriesId: String!
}

type Status {
    stringValue: String!
}

"Stop job instance output."
type StopJobInstanceReply {
    "True if stop process is initiated for job instance."
    success: Boolean!
}

type StorageAccount {
    accessTier: StorageAccountTier!
    id: String!
    kind: String!
    name: String!
    regionName: String!
    resourceGroup: ResourceGroup
    sku: StorageAccountSku!
}

"Paginated list of StorageAccount objects."
type StorageAccountConnection {
    "Total number of StorageAccount objects matching the request arguments."
    count: Int!
    "List of StorageAccount objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [StorageAccountEdge!]!
    "List of StorageAccount objects."
    nodes: [StorageAccount!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the StorageAccount object. This wrapper is used for pagination."
type StorageAccountEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual StorageAccount object wrapped by this edge."
    node: StorageAccount!
}

"Supported in v5.0+"
type StorageArrayDetail {
    arrayType: StorageArrayTypeEnum!
    """

    Supported in v5.0+
    A digital certificate, or concatenated chain of digital certificates, that permits verification of the public key certificate of the storage array. Each certificate must be an X.509 certificate in Base64 encoded DER format and must start with -----BEGIN CERTIFICATE----- and end with -----END CERTIFICATE-----.
    """
    caCerts: String
    """

    Required. Supported in v5.0+
    Connection status of a Storage Array.
    """
    connectionStatus: RefreshableObjectConnectionStatus
    """

    Required. Supported in v5.0+
    Resolvable hostname or IPv4 address of the storage array.
    """
    hostname: String!
    "Required. Supported in v5.0+"
    id: String!
    "Required. Supported in v5.0+"
    username: String!
}

"Supported in v5.0+"
type StorageArrayDetailListResponse {
    """

    Supported in v5.0+
    List of matching objects.
    """
    data: [StorageArrayDetail!]!
    """

    Supported in v5.0+
    If there is more.
    """
    hasMore: Boolean
    """

    Supported in v5.0+
    Total list responses.
    """
    total: Long
}

"""

Supported in m3.2.0-m4.1.0
Metadata for mosaic store.
"""
type StoreMetadata {
    """

    Supported in m3.2.0-m4.1.0
    S3 bucket name
    """
    s3Bucket: String
    """

    Supported in m3.2.0-m4.1.0
    S3 account region
    """
    s3Region: String
}

type Subnet {
    id: String!
    name: String!
    securityGroup: SecurityGroup
}

"Paginated list of Subnet objects."
type SubnetConnection {
    "Total number of Subnet objects matching the request arguments."
    count: Int!
    "List of Subnet objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [SubnetEdge!]!
    "List of Subnet objects."
    nodes: [Subnet!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the Subnet object. This wrapper is used for pagination."
type SubnetEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual Subnet object wrapped by this edge."
    node: Subnet!
}

"Represents a subnet group on AWS."
type SubnetGroup {
    "Amazon Resource Name (ARN) of the subnet group."
    arn: String!
    "Name of the subnet group."
    name: String!
    "Subnets associated with the subnet group."
    subnets: [AwsNativeSubnet!]!
    "Virtual Private Cloud (VPC) corresponding to the subnet group."
    vpcId: String!
}

"Contains the success details about RBA connectivity taskchains"
type Success {
    snappableId: String!
    taskchainId: String!
}

"Support portal login response."
type SupportPortalLoginReply {
    "Support portal login status object."
    status: UpgradeStatus
}

"Support portal logout response."
type SupportPortalLogoutReply {
    "Support portal logout status object."
    status: UpgradeStatus
}

"Support portal user session status."
type SupportPortalStatusReply {
    "Is user logged in flag."
    isLoggedIn: Boolean!
    "Support portal user session status."
    status: UpgradeStatus
    "Support portal username."
    username: String!
}

"Response type for getting information about a support tunnel"
type SupportTunnelInfoResp {
    enabledTime: DateTime
    inactivityTimeoutInSeconds: Long
    isTunnelEnabled: Boolean!
    lastActivityTime: DateTime
    nodeId: String!
    port: Long
}

type SyslogConfig {
    id: Int!
    notificationConf: CommonNotificationConfig
    syslogConf: SyslogSetting
}

type SyslogSetting {
    facility: SyslogFacilityTypeEnum!
    severity: SyslogSeverityTypeEnum!
}

type TableFilters {
    ProtectionTaskDetailsTable: ProtectionTaskDetailsTableFilter!
    RecoveryTaskDetailsTable: RecoveryTaskDetailsTableFilter!
}

"The table's id and its name."
type TableViewWithName {
    "The name of the table."
    tableName: String!
    "Table View Type ID ID of the chart."
    tableViewType: TableViewType!
}

"Represents a tag key-value pair of an AWS resource."
type Tag {
    "Tag key."
    key: String!
    "Tag value."
    value: String!
}

"Key-value pair of string."
type TagObject {
    "Key of the tag or label."
    key: String!
    "Value of the tag or label."
    value: String!
}

"Represents the sla id and name"
type TagRuleEffectiveSla {
    id: String!
    name: String!
}

"Tag represents a tag key value pair"
type TagRuleTag {
    matchAllValues: Boolean!
    tagKey: String!
    tagValue: String!
}

"Represents the error in response to triggering the on-demand snapshot of the snappable"
type TakeOnDemandSnapshotError {
    error: String!
    snappableId: String!
}

"Represents the response to the take on-demand snapshot operation. For each snappable ID that the on-demand snapshot was triggered, it either ends up being in the taskchainUuids or the errors map depending on if the operation succeeded or failed respectively."
type TakeOnDemandSnapshotReply {
    errors: [TakeOnDemandSnapshotError!]!
    taskchainUuids: [TakeOnDemandSnapshotTaskchainUuid!]!
}

"Represents the taskchain UUID in response to triggering the on-demand snapshot of snappable"
type TakeOnDemandSnapshotTaskchainUuid {
    snappableId: String!
    taskchainUuid: String!
}

type TakeScreenshotReply {
    screenshots: [String!]!
}

"Paginated list of Target objects."
type TargetConnection {
    "Total number of Target objects matching the request arguments."
    count: Int!
    "List of Target objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [TargetEdge!]!
    "List of Target objects."
    nodes: [Target!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Result of the delete target operation"
type TargetDeleteResult {
    success: Boolean!
}

"Wrapper around the Target object. This wrapper is used for pagination."
type TargetEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual Target object wrapped by this edge."
    node: Target!
}

"Target Mapping info"
type TargetMapping {
    "Connection status for archival group."
    connectionStatus: ArchivalGroupConnectionStatus
    groupType: ArchivalGroupTypeEnum!
    id: UUID!
    name: String!
    targetTemplate: TargetTemplate
    targetType: TargetTypeEnum!
    targets: [Target!]
    "Tiering status for archival group."
    tieringStatus: [ArchivalGroupTieringStatus!]
}

"Information about the target mapping identifier."
type TargetMappingBasic {
    "Id of the target mapping."
    id: UUID!
    "Name of the target mapping."
    name: String!
}

type TargetMappingDeletionResult {
    success: Boolean!
}

type TargetSite {
    stringValue: String!
}

"A task details."
type TaskDetail {
    archivalTarget: String
    clusterLocation: String!
    clusterName: String!
    clusterType: String!
    clusterUuid: UUID!
    dataReduction: Float
    dataTransferred: Long
    dedupRatio: Float
    directArchive: String
    duration: Long!
    endTime: DateTime!
    failureReason: String
    id: Long!
    location: String!
    logicalBytes: Long
    logicalDataReduction: Float
    logicalDedupRatio: Float
    objectFid: String!
    objectName: String!
    objectType: String!
    physicalBytes: Long
    protectedVolume: String
    recoveryPoint: String
    recoveryPointType: String
    replicationSource: String
    replicationTarget: String
    reportJobInstanceId: String!
    slaDomainId: String!
    slaDomainName: String!
    snapshotConsistency: String
    startTime: DateTime!
    status: String!
    taskCategory: String!
    taskType: String!
    totalFilesTransferred: Long
    userName: String
}

type TaskDetailChart {
    focus: ReportFocusEnum!
    groupBy: [TaskDetailGroupByEnum!]
    name: String!
}

type TaskDetailClusterType {
    stringValue: String!
}

"Paginated list of TaskDetail objects."
type TaskDetailConnection {
    "Total number of TaskDetail objects matching the request arguments."
    count: Int!
    "List of TaskDetail objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [TaskDetailEdge!]!
    "List of TaskDetail objects."
    nodes: [TaskDetail!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the TaskDetail object. This wrapper is used for pagination."
type TaskDetailEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual TaskDetail object wrapped by this edge."
    node: TaskDetail!
}

"Task detail with groupby info applied to it."
type TaskDetailGroupBy {
    "The data groupby info."
    groupByInfo: TaskDetailGroupByInfo!
    "Paginated task detail data."
    taskDetailConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort task detail by field"
        sortBy: TaskDetailSortByEnum = EndTime,
        "task detail sort order"
        sortOrder: SortOrderEnum = Desc
    ): TaskDetailConnection!
    taskDetailGroupBy(
        "group task detail by a field"
        groupBy: TaskDetailGroupByEnum!
    ): [TaskDetailGroupBy!]!
}

"Paginated list of TaskDetailGroupBy objects."
type TaskDetailGroupByConnection {
    "Total number of TaskDetailGroupBy objects matching the request arguments."
    count: Int!
    "List of TaskDetailGroupBy objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [TaskDetailGroupByEdge!]!
    "List of TaskDetailGroupBy objects."
    nodes: [TaskDetailGroupBy!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the TaskDetailGroupBy object. This wrapper is used for pagination."
type TaskDetailGroupByEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual TaskDetailGroupBy object wrapped by this edge."
    node: TaskDetailGroupBy!
}

type TaskDetailObjectType {
    stringValue: String!
}

type TaskDetailTable {
    focus: ReportFocusEnum!
    groupBy: [TaskDetailGroupByEnum!]
    name: String!
    selectedColumns: [TaskDetailTableColumnEnum!]!
    sortBy: TaskDetailSortByEnum
    sortOrder: SortOrderEnum
}

"A backup task summary."
type TaskSummary {
    clusterUuid: UUID!
    date: DateTime!
    "Location of the associated backup task summary."
    location: String
    "The number of the canceled tasks."
    numCanceled: Int!
    "The number of the expected tasks."
    numExpected: Int!
    "The number of the failed and missed tasks."
    numFailed: Int!
    "The number of the successful tasks."
    numSucceeded: Int!
    "Object name of the associated backup task summary."
    objectName: String!
    "Object type of the associated backup task summary."
    objectType: ObjectTypeEnum!
    slaDomainId: String!
    "slaDomain name of the object."
    slaDomainName: String!
    "Snappable Id of the associated backup task summary"
    snappbleId: UUID!
}

type TaskSummaryAggregation {
    NumOfCanceled: Int!
    NumOfExpected: Int!
    NumOfFailed: Int!
    NumOfSucceeded: Int!
}

type TaskSummaryChart {
    focus: ReportFocusEnum!
    groupBy: [TaskSummaryGroupByEnum!]
    name: String!
}

"Paginated list of TaskSummary objects."
type TaskSummaryConnection {
    aggregation: TaskSummaryAggregation!
    "Total number of TaskSummary objects matching the request arguments."
    count: Int!
    "List of TaskSummary objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [TaskSummaryEdge!]!
    "List of TaskSummary objects."
    nodes: [TaskSummary!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the TaskSummary object. This wrapper is used for pagination."
type TaskSummaryEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual TaskSummary object wrapped by this edge."
    node: TaskSummary!
}

"Task summary with groupby info applied to it."
type TaskSummaryGroupBy {
    "The data groupby info."
    groupByInfo: TaskSummaryGroupByInfo!
    "Paginated task summary data."
    taskSummaryConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort task summary by field"
        sortBy: TaskSummarySortByEnum = ObjectName,
        "sort order"
        sortOrder: SortOrderEnum
    ): TaskSummaryConnection!
    taskSummaryGroupBy(
        "group task summary by a field"
        groupBy: TaskSummaryGroupByEnum!
    ): [TaskSummaryGroupBy!]!
}

"Paginated list of TaskSummaryGroupBy objects."
type TaskSummaryGroupByConnection {
    "Total number of TaskSummaryGroupBy objects matching the request arguments."
    count: Int!
    "List of TaskSummaryGroupBy objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [TaskSummaryGroupByEdge!]!
    "List of TaskSummaryGroupBy objects."
    nodes: [TaskSummaryGroupBy!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the TaskSummaryGroupBy object. This wrapper is used for pagination."
type TaskSummaryGroupByEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual TaskSummaryGroupBy object wrapped by this edge."
    node: TaskSummaryGroupBy!
}

type TaskSummaryTable {
    focus: ReportFocusEnum!
    groupBy: [TaskSummaryGroupByEnum!]
    name: String!
    selectedColumns: [TaskReportTableColumnEnum!]!
    sortBy: TaskSummarySortByEnum
    sortOrder: SortOrderEnum
}

"Taskchain"
type Taskchain {
    account: String!
    component: String!
    config: String!
    currentTaskExecutionAttempts: Int!
    currentTaskIndex: Int!
    endTime: DateTime
    error: String!
    id: Long!
    jobId: Long!
    jobType: String!
    name: String!
    parentTaskchainId: String!
    podName: String!
    priority: Int!
    progress: Long!
    progressedAt: DateTime
    startTime: DateTime
    state: TaskchainState!
    taskchainUuid: String!
    workflowName: String!
}

type TaskchainInfo {
    appId: String!
    taskchainId: String!
}

"The results of the webhook test."
type TestExistingWebhookReply {
    "The information describing the error from the webhook test."
    errorInfo: ErrorInfo
    "Describes whether the test was successful or not."
    isSuccessful: Boolean!
    "Describes the webhook status after the test."
    webhookStatus: WebhookStatus!
}

"The results of the webhook test."
type TestWebhookReply {
    "The information describing the error from the webhook test."
    errorInfo: ErrorInfo
    "Describes whether the test was successful or not."
    isSuccessful: Boolean!
}

"Config as the input to start a threat hunt."
type ThreatHuntConfig {
    "UUID used to identify the cluster the request goes to."
    clusterUuid: String!
    "Criteria to restrict files to scan."
    fileScanCriteria: MalwareScanFileCriteria
    "List of IOCs to scan for."
    indicatorsOfCompromise: [PolarisIndicatorOfCompromise!]!
    "Maximum number of matches per shapshot, per IOC.  Scanning for an Indicator Of Compromise within a snapshot will terminate once this many matches have been detected. Defaults to one."
    maxMatchesPerSnapshot: Int
    "Name of this scan."
    name: String!
    "Notes to describe this scan."
    notes: String!
    "The objects to be scanned for malware."
    objects: [CdmHierarchySnappableNew!]!
    "Additional information required for files with malware matches."
    requestedMatchDetails: RequestedMatchDetails
    "Specifies whether features that rely on the accuracy of filesystem metadata, like creation time and modification time of files, are enabled or not. These features include backend optimizations to skip re-scanning files that have not changed across snapshots, as indicated by the unchanged timestamps of files. This flag also gates access to some filters that can be specified in this API. Note that this flag should be used with caution, as relying on file timestamps may make the system vulnerable to adversarial techniques such as timestamp manipulation."
    shouldTrustFilesystemTimeInfo: Boolean!
    "Limit which snapshots to include in the malware scan."
    snapshotScanLimit: MalwareScanSnapshotLimit
}

"Details for the threat hunt."
type ThreatHuntDetails {
    "The CDM id of the scan."
    cdmId: String!
    "The cluster of the scan."
    cluster: Cluster!
    "The configuration of the malware scan."
    config: ThreatHuntConfig!
    "End time of the hunt."
    endTime: DateTime
    "The object ids and corresponding snapshot ids targeted for scanning."
    snapshots: [PolarisObjectIdToSnapshotIds!]!
    "Start time of the hunt."
    startTime: DateTime
}

"A range of time"
type TimeRange {
    "End of the time range"
    end: DateTime!
    "Start of the time range"
    start: DateTime!
}

"A range of time and the unit of that range"
type TimeRangeWithUnit {
    "End of the time range"
    end: DateTime!
    "Start of the time range"
    start: DateTime!
    "Unit of the time range"
    unit: TimeUnitEnum!
}

type TimeSeriesResult {
    count: Long!
    timestamp: String!
}

type TimelineEntry {
    day: String!
    hits: Hits
    policyId: String!
}

"TOTP status for a user."
type TotpStatus {
    "Whether totp is enabled for the user."
    isEnabled: Boolean!
    "Whether totp is enforced."
    isEnforced: Boolean!
    "Whether totp is enforced at the user level."
    isEnforcedUserLevel: Boolean!
    "Whether TOTP is supported for the user."
    isSupported: Boolean!
    "The timestamp of last TOTP configuration update."
    totpConfigUpdateAt: DateTime
}

"Lambda job information on certain cluster "
type TriggerRansomwareDetectionReply {
    clusterUuid: String!
    jobId: String!
}

type UnidirectionalReplicationSpec {
    replicationTargetId: String!
    replicationTargetName: String!
    retention: Int!
    retentionUnit: RetentionUnitEnum!
    "The cluster to which this SLA will replicate the snapshots."
    targetCluster: Cluster
}

"UnmanagedObjectDetails."
type UnmanagedObjectDetails {
    "Storage on the archival location."
    archiveStorage: Long!
    "Any of the snapshots are retained by a SLA."
    hasSnapshotsWithPolicy: Boolean!
    "Snappable id."
    id: String!
    "Whether the object is remote or local."
    isRemote: Boolean
    "Storage on the local location."
    localStorage: Long!
    "Unmanaged object name."
    name: String!
    "Type of the unmanaged object."
    objectType: ManagedObjectType!
    "Physical path to this object."
    physicalLocation: [LocationPathPoint!]!
    "Recovery information for the reader archival locations."
    recoveryInfo: SnappableRecoveryInfo
    "SLA Domain retention policy ID."
    retentionSlaDomainId: String!
    "SLA Domain retention policy name."
    retentionSlaDomainName: String!
    "Polaris SLA Domain ID."
    retentionSlaDomainPolarisManagedId: String
    "Snapshot count."
    snapshotCount: Long!
    "Unmanaged Status of this object."
    unmanagedStatus: UnmanagedObjectStatus!
}

"Paginated list of UnmanagedObjectDetails objects."
type UnmanagedObjectDetailsConnection {
    "Total number of UnmanagedObjectDetails objects matching the request arguments."
    count: Int!
    "List of UnmanagedObjectDetails objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [UnmanagedObjectDetailsEdge!]!
    "List of UnmanagedObjectDetails objects."
    nodes: [UnmanagedObjectDetails!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the UnmanagedObjectDetails object. This wrapper is used for pagination."
type UnmanagedObjectDetailsEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual UnmanagedObjectDetails object wrapped by this edge."
    node: UnmanagedObjectDetails!
}

"Response of the operation to unmap Azure cloud accounts from the mapped exocompute subscription."
type UnmapAzureCloudAccountExocomputeSubscriptionReply {
    "Specifies whether the unmapping was completed successfully."
    isSuccess: Boolean!
}

"Response of the operation to update an AWS cloud account."
type UpdateAwsCloudAccountReply {
    "Contains success response message."
    message: String
}

"Response of the operation to Update Azure Cloud Account."
type UpdateAzureCloudAccountReply {
    "Status of the operation to update Azure Cloud Account."
    status: [UpdateAzureCloudAccountStatus!]!
}

"Status of the operation to Update Azure Cloud Account."
type UpdateAzureCloudAccountStatus {
    "Native ID of the Azure Subscription."
    azureSubscriptionNativeId: String!
    "Specifies whether the update of Azure Cloud Account was successful. When true, the update was successful."
    isSuccess: Boolean!
}

"Output for updateCloudNativeAwsStorageSetting mutation"
type UpdateCloudNativeAwsStorageSettingReply {
    targetMapping: TargetMapping!
}

"Updated storage settings info for Azure"
type UpdateCloudNativeAzureStorageSettingReply {
    targetMapping: TargetMapping!
}

"The status of update indexing status call. For each snappable ID in the request: an entry in errors if failed."
type UpdateCloudNativeIndexingStatusReply {
    errors: [UpdateIndexingStatusError!]!
}

"Response containing a list of objects with the pause or resume status for the Rubrik clusters."
type UpdateClusterPauseStatusReply {
    "List of objects with the pause or resume status for the Rubrik clusters."
    pauseStatuses: [ClusterPauseStatusResult!]
}

type UpdateIndexingStatusError {
    error: String!
    snappableId: String!
}

"Update O365 Org custom name response."
type UpdateO365OrgCustomNameReply {
    "Custom name to use for the O365 organization."
    customName: String!
    "Polaris ID for an O365 organization."
    orgUuid: UUID!
}

"UUID of updated organization."
type UpdateOrgReply {
    "UUID of updated organization."
    organizationId: String!
}

"A Recovery Plan."
type UpdateRecoveryPlanReply implements HierarchyObject {
    "Recovery Plan configuration."
    config: RecoveryPlanConfig
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "Recovery Plan description."
    description: String!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "Recovery Plan version."
    version: Int!
}

"The webhook that was updated."
type UpdateWebhookReply {
    "A description of the webhook."
    description: String
    "The event severities that the webhook is subscribed to."
    eventSeverities: [EventSeverity!]
    "List of webhook's subscribed events."
    eventTypes: [EventType!]
    "The name of the updated webhook."
    name: String
    "The application that will receive the webhook."
    providerType: ProviderType
    "Describes whether the webhook is enabled or disabled."
    status: WebhookStatus
    "The timestamp that this webhook was updated at."
    updatedAt: String!
    "The URL endpoint to the receiving application."
    url: URL
}

"Response of the operation to set Azure cloud account feature status to connected, when in missing permissions state."
type UpgradeAzureCloudAccountPermissionsWithoutOauthReply {
    "Status of the request."
    status: Boolean!
}

"Response of the operation to upgrade Azure Cloud Account."
type UpgradeAzureCloudAccountReply {
    "Status of the operation to upgrade Azure Cloud Account permission."
    status: [UpgradeAzureCloudAccountStatus!]!
}

"Status of the operation to Azure Cloud Account Upgrade permission."
type UpgradeAzureCloudAccountStatus {
    "Native ID of the Azure Subscription."
    azureSubscriptionNativeId: String!
    "Error received during upgrade of Azure Cloud Account."
    error: String!
    "Specifies whether the upgrade of Azure Cloud Account was successful. When true, the upgrade was successful."
    isSuccess: Boolean!
}

type UpgradeDurationReply {
    "Time taken by the last successful fast upgrade, in seconds."
    fastUpgradeDuration: Long!
    "Time taken by the last successful rolling upgrade, in seconds."
    rollingUpgradeDuration: Long!
}

"Response of the operation to set GCP cloud account feature status to connected, when in missing permissions state."
type UpgradeGcpCloudAccountPermissionsWithoutOauthReply {
    "Status of the operation to upgrade GCP project"
    status: GcpCloudAccountProjectUpgradeStatus
}

"Cluster upgrade data with groupby info applied to it."
type UpgradeInfoGroupBy {
    "Paginated snappable data."
    clusterConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort upgradeInfo by field"
        sortBy: UpgradeInfoSortByEnum = ClusterType,
        "cluster sort order"
        sortOrder: SortOrderEnum = Desc
    ): ClusterConnection!
    "Further provide groupings for the data."
    clusterGroupBy(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "group by field"
        groupBy: UpgradeInfoGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int
    ): [UpgradeGroupByInfo!]!
    "The data groupby info."
    groupByInfo: UpgradeGroupByInfo!
}

"Paginated list of UpgradeInfoGroupBy objects."
type UpgradeInfoGroupByConnection {
    "Total number of UpgradeInfoGroupBy objects matching the request arguments."
    count: Int!
    "List of UpgradeInfoGroupBy objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [UpgradeInfoGroupByEdge!]!
    "List of UpgradeInfoGroupBy objects."
    nodes: [UpgradeInfoGroupBy!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the UpgradeInfoGroupBy object. This wrapper is used for pagination."
type UpgradeInfoGroupByEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual UpgradeInfoGroupBy object wrapped by this edge."
    node: UpgradeInfoGroupBy!
}

"Start upgrade job response."
type UpgradeJobReply {
    "Upgrade start message."
    message: String!
    "Upgrade success/failure boolean flag."
    success: Boolean!
}

"Start upgrade batch job response."
type UpgradeJobReplyWithUuid {
    "Upgrade job reply object."
    UpgradeJobReply: UpgradeJobReply!
    "Cluster uuid."
    uuid: String!
}

"Upgrade recommendation information."
type UpgradeRecommendationInfo {
    "Latest upgradable version from the next release."
    nextReleaseRecommendation: String!
    "Recommended version for upgrade in the same release."
    recommendation: String!
    "List of upgradable versions for the cluster."
    upgradability: [String!]!
}

"Response containing taskchain information for the upgrade of SLA Domains."
type UpgradeSlasReply {
    "List of objects containing SLA Domain taskchain information."
    slasTaskchainInfo: [SlaTaskchainInfo!]!
}

"Upgrade context status."
type UpgradeStatus {
    "Return code."
    code: String!
    "Exception trace."
    excepshuns: String!
    "Status message."
    message: String!
}

"Upgrade status response."
type UpgradeStatusReply {
    "Current state."
    currentState: String!
    "Current state name."
    currentStateName: String!
    "Progress percentage of current state."
    currentStateProgress: String!
    "Upgrade states successfully completed running."
    finishedStates: String!
    "Upgrade mode."
    mode: String!
    "Upgrade driver node name."
    nodeName: String!
    "Upgrade states to be attempted to run."
    pendingStates: String!
    "Progress percentage of current state."
    progress: String!
    "Rolling upgrade information."
    ruInfo: RollingUpgradeInfo
    "Upgrade tarball package name."
    tarballName: String!
    "Overall upgrade progress percentage."
    upgradeProgressPercentage: String!
    "Upgrade status object."
    upgradeStatus: UpgradeStatus
    "Time remaining for upgrade to complete."
    upgradeTimeLeftSecs: String!
    "Upgrade start Timestamp."
    upgradeTimestamp: String!
    "Current upgrade task name."
    userSurfacedTaskName: String!
}

"User account details."
type User {
    "The domain the user belongs to."
    domain: UserDomainEnum!
    "The user email."
    email: String!
    emailConfig: [EventDigest!]!
    "Groups user belongs to."
    groups: [String!]!
    "The user id."
    id: String!
    "Whether user is account owner."
    isAccountOwner: Boolean!
    "Last time the user logged in."
    lastLogin: DateTime
    roles: [Role!]!
    "The status of user's account."
    status: UserStatusEnum!
    "The totp status of user."
    totpStatus: TotpStatus!
    "The amount of unread notifications for the current user."
    unreadCount: Long!
    "The user's username."
    username: String!
}

"Represents the activity for a specific user."
type UserActivityResult {
    "The total number of activities this user had."
    numActivities: Long!
    "The total number of activities, grouped by activity type."
    numActivitiesBreakdown: [ActivityResult!]!
    "ID used for pagination."
    paginationId: String!
    "The user that this result corresponds to."
    user: AccessUser
}

"Paginated list of UserActivityResult objects."
type UserActivityResultConnection {
    "Total number of UserActivityResult objects matching the request arguments."
    count: Int!
    "List of UserActivityResult objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [UserActivityResultEdge!]!
    "List of UserActivityResult objects."
    nodes: [UserActivityResult!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the UserActivityResult object. This wrapper is used for pagination."
type UserActivityResultEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual UserActivityResult object wrapped by this edge."
    node: UserActivityResult!
}

type UserAudit {
    auditType: UserAuditTypeEnum
    cluster: Cluster
    id: ID!
    message: String!
    objectId: String!
    objectName: String
    objectType: UserAuditObjectTypeEnum!
    severity: UserAuditSeverityEnum
    status: UserAuditStatusEnum!
    time: DateTime!
    userName: String
    "Optional user note."
    userNote: String
}

type UserAuditChart {
    focus: ReportFocusEnum!
    groupBy: [UserAuditGroupByEnum!]
    name: String!
}

"Paginated list of UserAudit objects."
type UserAuditConnection {
    "Total number of UserAudit objects matching the request arguments."
    count: Int!
    "List of UserAudit objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [UserAuditEdge!]!
    "List of UserAudit objects."
    nodes: [UserAudit!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the UserAudit object. This wrapper is used for pagination."
type UserAuditEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual UserAudit object wrapped by this edge."
    node: UserAudit!
}

"User audit data with groupby info applied to it"
type UserAuditGroupBy {
    "The data group by info."
    groupByInfo: UserAuditGroupByInfo!
    "Paginated audit data."
    userAuditConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort user audit by field"
        sortBy: UserAuditSortByEnum = Time
    ): UserAuditConnection!
    "Further provide groupings for the data."
    userAuditGroupBy(
        "group audits by a field"
        groupBy: UserAuditGroupByEnum!
    ): [UserAuditGroupBy!]!
}

"Paginated list of UserAuditGroupBy objects."
type UserAuditGroupByConnection {
    "Total number of UserAuditGroupBy objects matching the request arguments."
    count: Int!
    "List of UserAuditGroupBy objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [UserAuditGroupByEdge!]!
    "List of UserAuditGroupBy objects."
    nodes: [UserAuditGroupBy!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the UserAuditGroupBy object. This wrapper is used for pagination."
type UserAuditGroupByEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual UserAuditGroupBy object wrapped by this edge."
    node: UserAuditGroupBy!
}

type UserAuditObjectType {
    enumValue: UserAuditObjectTypeEnum!
}

type UserAuditStatus {
    enumValue: UserAuditStatusEnum!
}

type UserAuditTable {
    focus: ReportFocusEnum!
    groupBy: [UserAuditGroupByEnum!]
    name: String!
    selectedColumns: [UserAuditTableColumnEnum!]!
    sortBy: UserAuditSortByEnum
    sortOrder: SortOrderEnum
}

type UserAuditType {
    enumValue: UserAuditTypeEnum!
}

"Paginated list of User objects."
type UserConnection {
    "Total number of User objects matching the request arguments."
    count: Int!
    "List of User objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [UserEdge!]!
    "List of User objects."
    nodes: [User!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

type UserDownload {
    completeTime: String!
    createTime: String!
    id: Long!
    identifier: DownloadIdentifierEnum!
    name: String!
    progress: Int!
    status: DownloadStatusEnum!
}

type UserDownloadUrl {
    url: String!
}

"Wrapper around the User object. This wrapper is used for pagination."
type UserEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual User object wrapped by this edge."
    node: User!
}

"An object representing product notifications."
type UserNotifications {
    "The id for the current user."
    id: String!
    "The amount of unread notifications for the current user."
    unreadCount: Long!
}

type UserSetting {
    setting: String!
    value: String!
}

type UserSettings {
    settings: [UserSetting!]!
}

type V1BulkUpdateExchangeDagResponse {
    items: [ExchangeDagSummary!]!
}

type V1BulkUpdateMssqlDbV1Response {
    items: [MssqlDbDetail!]!
}

type V1BulkUpdateSnapMirrorCloudResponse {
    items: [SnapMirrorCloudDetail!]!
}

type V1MssqlGetRestoreFilesV1Response {
    items: [MssqlRestoreFile!]!
}

type V2AssignMssqlSlaPropertiesAsyncResponse {
    items: [ManagedObjectPendingSlaInfo!]!
}

type VNet {
    id: String!
    name: String!
    regionName: String!
    resourceGroup: ResourceGroup
}

"Paginated list of VNet objects."
type VNetConnection {
    "Total number of VNet objects matching the request arguments."
    count: Int!
    "List of VNet objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VNetEdge!]!
    "List of VNet objects."
    nodes: [VNet!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VNet object. This wrapper is used for pagination."
type VNetEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VNet object wrapped by this edge."
    node: VNet!
}

type VSphereBlueprint implements Blueprint & CdmHierarchyObject & CdmHierarchySnappableNew & HierarchyObject & HierarchySnappable {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    cdmId: String!
    "A link to view the snappable on the CDM cluster. For dev use only."
    cdmLink: String!
    "The list of children workload."
    childConnection: BlueprintChildConnection!
    children: [VSphereVmChild!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    currentFailoverStatus: AppBlueprintFailoverStatusEnum!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    isAssignedSlaSynced: Boolean!
    isMount: Boolean!
    isRelic: Boolean!
    "last failover"
    lastFailover: Failover
    lastFailoverStatus: AppBlueprintLastFailoverStatusEnum!
    lastFailoverTimeMillisOpt: Long
    "last test failover"
    lastTestFailover: Failover
    lastTestFailoverStatus: AppBlueprintLastFailoverStatusEnum!
    lastTestFailoverTimeMillisOpt: Long
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The list of missed snapshots for this workload."
    missedSnapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int
    ): MissedSnapshotCommonConnection
    "The list of missed snapshots for this workload."
    missedSnapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: MissedSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): MissedSnapshotGroupByConnection
    mountTimeMillisOpt: Long
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot archived to AWS."
    newestArchivedSnapshot: CdmSnapshot
    "The newest snapshot ready for failover"
    newestFailoverReadySnapshot(isTestFailover: Boolean!): CdmSnapshot
    "The newest snapshot replicated to a cluster."
    newestReplicatedSnapshot: CdmSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: CdmSnapshot
    "number of child snappables of the Blueprint"
    numChildren: Int!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: CdmSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The recovery ranges of the blueprint"
    recoveryInfo(
        "The ID of the cluster."
        clusterUuid: UUID
    ): BlueprintRecoveryRanges
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    rmStatus: AppBlueprintRmStatusEnum!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for the snapshots of this workload."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: CdmSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): cdmSnapshotGroupByConnection
    status: AppBlueprintStatusEnum!
}

type VSphereBlueprintChildFailoverInstance implements BlueprintFailoverInstance {
    failoverInstance: AwsEc2Instance!
    snappableId: String!
}

type VSphereBlueprintNew implements BlueprintNew & HierarchyObject {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "The list of children workload."
    childConnection: BlueprintChildConnection!
    children: [VSphereVmChild!]!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "Flag to enable hydration."
    enableHydrationOpt: Boolean
    "The fid of the hierarchy object."
    id: UUID!
    isArchived: Boolean!
    "Status of hydration enablement."
    isHydrationEnabled: Boolean
    "Last failover source location."
    lastFailoverSource: String
    lastFailoverStatus: BlueprintFailoverStatus!
    "Last failover time."
    lastFailoverTime: DateTime
    lastFailoverTimeOpt: DateTime
    "Last local recovery time."
    lastLocalRecoveryTime: DateTime
    "Last local recovery time."
    lastLocalRecoveryTimeOpt: DateTime
    lastTestFailoverStatus: BlueprintFailoverStatus!
    "Last test failover time."
    lastTestFailoverTime: DateTime
    lastTestFailoverTimeOpt: DateTime
    latestFailover: BlueprintFailover
    "Details of the local blueprint RPO lag."
    localRpoLagInfo: RPOLagInfo
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "number of child snappables of the Blueprint"
    numChildren: Int!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    platform: BlueprintPlatformEnum!
    "The recovery ranges of the blueprint"
    recoveryInfo(
        "The ID of the cluster."
        clusterUuid: UUID
    ): BlueprintRecoveryRanges
    "blueprint remote RPO lag info"
    remoteRpoLagInfo: RPOLagInfo
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "The source location from which this object originated."
    sourceLocation: BlueprintLocation
    status: BlueprintStatusEnum!
    "The target location to which the object failed over"
    targetLocation: BlueprintLocation
    version: Int!
}

type VSphereComputeCluster implements CdmHierarchyObject & HierarchyObject & VSphereDatacenterDescendantType & VSphereDatacenterPhysicalChildType & VSphereVCenterDescendantType & VSphereVCenterPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereComputeClusterDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "List of physical children"
    physicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereComputeClusterPhysicalChildTypeConnection!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"Paginated list of VSphereComputeCluster objects."
type VSphereComputeClusterConnection {
    "Total number of VSphereComputeCluster objects matching the request arguments."
    count: Int!
    "List of VSphereComputeCluster objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VSphereComputeClusterEdge!]!
    "List of VSphereComputeCluster objects."
    nodes: [VSphereComputeCluster!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Paginated list of VSphereComputeClusterDescendantType objects."
type VSphereComputeClusterDescendantTypeConnection {
    "Total number of VSphereComputeClusterDescendantType objects matching the request arguments."
    count: Int!
    "List of VSphereComputeClusterDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VSphereComputeClusterDescendantTypeEdge!]!
    "List of VSphereComputeClusterDescendantType objects."
    nodes: [VSphereComputeClusterDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VSphereComputeClusterDescendantType object. This wrapper is used for pagination."
type VSphereComputeClusterDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VSphereComputeClusterDescendantType object wrapped by this edge."
    node: VSphereComputeClusterDescendantType!
}

"Wrapper around the VSphereComputeCluster object. This wrapper is used for pagination."
type VSphereComputeClusterEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VSphereComputeCluster object wrapped by this edge."
    node: VSphereComputeCluster!
}

"Paginated list of VSphereComputeClusterPhysicalChildType objects."
type VSphereComputeClusterPhysicalChildTypeConnection {
    "Total number of VSphereComputeClusterPhysicalChildType objects matching the request arguments."
    count: Int!
    "List of VSphereComputeClusterPhysicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VSphereComputeClusterPhysicalChildTypeEdge!]!
    "List of VSphereComputeClusterPhysicalChildType objects."
    nodes: [VSphereComputeClusterPhysicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VSphereComputeClusterPhysicalChildType object. This wrapper is used for pagination."
type VSphereComputeClusterPhysicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VSphereComputeClusterPhysicalChildType object wrapped by this edge."
    node: VSphereComputeClusterPhysicalChildType!
}

type VSphereDatacenter implements CdmHierarchyObject & HierarchyObject & VSphereVCenterDescendantType & VSphereVCenterLogicalChildType & VSphereVCenterPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereDatacenterDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "List of logical children"
    logicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereDatacenterLogicalChildTypeConnection!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "List of physical children"
    physicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereDatacenterPhysicalChildTypeConnection!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"Paginated list of VSphereDatacenterDescendantType objects."
type VSphereDatacenterDescendantTypeConnection {
    "Total number of VSphereDatacenterDescendantType objects matching the request arguments."
    count: Int!
    "List of VSphereDatacenterDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VSphereDatacenterDescendantTypeEdge!]!
    "List of VSphereDatacenterDescendantType objects."
    nodes: [VSphereDatacenterDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VSphereDatacenterDescendantType object. This wrapper is used for pagination."
type VSphereDatacenterDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VSphereDatacenterDescendantType object wrapped by this edge."
    node: VSphereDatacenterDescendantType!
}

"Paginated list of VSphereDatacenterLogicalChildType objects."
type VSphereDatacenterLogicalChildTypeConnection {
    "Total number of VSphereDatacenterLogicalChildType objects matching the request arguments."
    count: Int!
    "List of VSphereDatacenterLogicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VSphereDatacenterLogicalChildTypeEdge!]!
    "List of VSphereDatacenterLogicalChildType objects."
    nodes: [VSphereDatacenterLogicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VSphereDatacenterLogicalChildType object. This wrapper is used for pagination."
type VSphereDatacenterLogicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VSphereDatacenterLogicalChildType object wrapped by this edge."
    node: VSphereDatacenterLogicalChildType!
}

"Paginated list of VSphereDatacenterPhysicalChildType objects."
type VSphereDatacenterPhysicalChildTypeConnection {
    "Total number of VSphereDatacenterPhysicalChildType objects matching the request arguments."
    count: Int!
    "List of VSphereDatacenterPhysicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VSphereDatacenterPhysicalChildTypeEdge!]!
    "List of VSphereDatacenterPhysicalChildType objects."
    nodes: [VSphereDatacenterPhysicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VSphereDatacenterPhysicalChildType object. This wrapper is used for pagination."
type VSphereDatacenterPhysicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VSphereDatacenterPhysicalChildType object wrapped by this edge."
    node: VSphereDatacenterPhysicalChildType!
}

"Vsphere datastore."
type VSphereDatastore implements CdmHierarchyObject & HierarchyObject & VSphereComputeClusterDescendantType & VSphereDatacenterDescendantType & VSphereHostDescendantType & VSphereResourcePoolDescendantType & VSphereVCenterDescendantType & VsphereDatastoreClusterDescendantType & VsphereDatastoreClusterPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    capacity: Long!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    datastoreType: String!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    freeSpace: Long!
    "object id"
    id: UUID!
    isLocal: Boolean!
    "Indicates whether the datastore is standalone or not."
    isStandaloneDatastore: Boolean!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"Paginated list of VSphereDatastore objects."
type VSphereDatastoreConnection {
    "Total number of VSphereDatastore objects matching the request arguments."
    count: Int!
    "List of VSphereDatastore objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VSphereDatastoreEdge!]!
    "List of VSphereDatastore objects."
    nodes: [VSphereDatastore!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VSphereDatastore object. This wrapper is used for pagination."
type VSphereDatastoreEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VSphereDatastore object wrapped by this edge."
    node: VSphereDatastore!
}

type VSphereFolder implements CdmHierarchyObject & HierarchyObject & VSphereDatacenterDescendantType & VSphereDatacenterLogicalChildType & VSphereFolderDescendantType & VSphereFolderLogicalChildType & VSphereVCenterDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereFolderDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "List of logical children"
    logicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereFolderLogicalChildTypeConnection!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"Paginated list of VSphereFolderDescendantType objects."
type VSphereFolderDescendantTypeConnection {
    "Total number of VSphereFolderDescendantType objects matching the request arguments."
    count: Int!
    "List of VSphereFolderDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VSphereFolderDescendantTypeEdge!]!
    "List of VSphereFolderDescendantType objects."
    nodes: [VSphereFolderDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VSphereFolderDescendantType object. This wrapper is used for pagination."
type VSphereFolderDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VSphereFolderDescendantType object wrapped by this edge."
    node: VSphereFolderDescendantType!
}

"Paginated list of VSphereFolderLogicalChildType objects."
type VSphereFolderLogicalChildTypeConnection {
    "Total number of VSphereFolderLogicalChildType objects matching the request arguments."
    count: Int!
    "List of VSphereFolderLogicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VSphereFolderLogicalChildTypeEdge!]!
    "List of VSphereFolderLogicalChildType objects."
    nodes: [VSphereFolderLogicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VSphereFolderLogicalChildType object. This wrapper is used for pagination."
type VSphereFolderLogicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VSphereFolderLogicalChildType object wrapped by this edge."
    node: VSphereFolderLogicalChildType!
}

type VSphereHost implements CdmHierarchyObject & HierarchyObject & VSphereComputeClusterDescendantType & VSphereComputeClusterPhysicalChildType & VSphereDatacenterDescendantType & VSphereDatacenterPhysicalChildType & VSphereVCenterDescendantType & VSphereVCenterPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereHostDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    isStandaloneHost: Boolean!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "List of physical children"
    physicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereHostPhysicalChildTypeConnection!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"Paginated list of VSphereHost objects."
type VSphereHostConnection {
    "Total number of VSphereHost objects matching the request arguments."
    count: Int!
    "List of VSphereHost objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VSphereHostEdge!]!
    "List of VSphereHost objects."
    nodes: [VSphereHost!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Paginated list of VSphereHostDescendantType objects."
type VSphereHostDescendantTypeConnection {
    "Total number of VSphereHostDescendantType objects matching the request arguments."
    count: Int!
    "List of VSphereHostDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VSphereHostDescendantTypeEdge!]!
    "List of VSphereHostDescendantType objects."
    nodes: [VSphereHostDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VSphereHostDescendantType object. This wrapper is used for pagination."
type VSphereHostDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VSphereHostDescendantType object wrapped by this edge."
    node: VSphereHostDescendantType!
}

"Wrapper around the VSphereHost object. This wrapper is used for pagination."
type VSphereHostEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VSphereHost object wrapped by this edge."
    node: VSphereHost!
}

"Paginated list of VSphereHostPhysicalChildType objects."
type VSphereHostPhysicalChildTypeConnection {
    "Total number of VSphereHostPhysicalChildType objects matching the request arguments."
    count: Int!
    "List of VSphereHostPhysicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VSphereHostPhysicalChildTypeEdge!]!
    "List of VSphereHostPhysicalChildType objects."
    nodes: [VSphereHostPhysicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VSphereHostPhysicalChildType object. This wrapper is used for pagination."
type VSphereHostPhysicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VSphereHostPhysicalChildType object wrapped by this edge."
    node: VSphereHostPhysicalChildType!
}

type VSphereMount {
    attachingDiskCount: Int
    authorizedOperations: AuthorizedOperations!
    cdmId: String!
    cluster: Cluster!
    clusterName: String!
    hasAttachingDisk: Boolean
    host: VSphereHost
    id: UUID!
    isReady: Boolean!
    migrateDatastoreRequestId: String
    mountRequestId: String
    mountTimestamp: DateTime
    newVMName: String
    newVm: VSphereVm
    sourceSnapshot: CdmSnapshot
    sourceVm: VSphereVm
    status: VSphereLiveMountStatusEnum!
    unmountRequestId: String
}

"Paginated list of VSphereMount objects."
type VSphereMountConnection {
    "Total number of VSphereMount objects matching the request arguments."
    count: Int!
    "List of VSphereMount objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VSphereMountEdge!]!
    "List of VSphereMount objects."
    nodes: [VSphereMount!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VSphereMount object. This wrapper is used for pagination."
type VSphereMountEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VSphereMount object wrapped by this edge."
    node: VSphereMount!
}

type VSphereNetwork implements CdmHierarchyObject & HierarchyObject & VSphereComputeClusterDescendantType & VSphereHostDescendantType & VSphereResourcePoolDescendantType & VSphereVCenterDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "object id"
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

type VSphereRecoveryComputeTarget {
    computeClusterId: String!
    computeClusterName: String!
    hostId: String!
    hostName: String!
    resourcePoolId: String!
    resourcePoolName: String!
    vCenterId: String!
    vCenterName: String!
}

type VSphereRecoverySpec implements RecoverySpec {
    enableMacPreserveOnly: Boolean
    enableNetworkPreserve: Boolean
    memoryMbs: Int!
    "Recovery point of the snappable."
    recoveryPointOpt: Long
    target: VSphereRecoveryComputeTarget!
    userData: String
    vCpus: Int!
    vSphereNicSpecs: [VSphereVMNicSpec!]!
    vSphereVolumeSpecs: [VSphereVMVolumeSpec!]!
    version: Long!
}

type VSphereResourcePool implements CdmHierarchyObject & HierarchyObject & VSphereComputeClusterDescendantType & VSphereComputeClusterPhysicalChildType & VSphereDatacenterDescendantType & VSphereHostDescendantType & VSphereHostPhysicalChildType & VSphereResourcePoolDescendantType & VSphereResourcePoolPhysicalChildType & VSphereVCenterDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereResourcePoolDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "List of physical children"
    physicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereResourcePoolPhysicalChildTypeConnection!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"Paginated list of VSphereResourcePoolDescendantType objects."
type VSphereResourcePoolDescendantTypeConnection {
    "Total number of VSphereResourcePoolDescendantType objects matching the request arguments."
    count: Int!
    "List of VSphereResourcePoolDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VSphereResourcePoolDescendantTypeEdge!]!
    "List of VSphereResourcePoolDescendantType objects."
    nodes: [VSphereResourcePoolDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VSphereResourcePoolDescendantType object. This wrapper is used for pagination."
type VSphereResourcePoolDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VSphereResourcePoolDescendantType object wrapped by this edge."
    node: VSphereResourcePoolDescendantType!
}

"Paginated list of VSphereResourcePoolPhysicalChildType objects."
type VSphereResourcePoolPhysicalChildTypeConnection {
    "Total number of VSphereResourcePoolPhysicalChildType objects matching the request arguments."
    count: Int!
    "List of VSphereResourcePoolPhysicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VSphereResourcePoolPhysicalChildTypeEdge!]!
    "List of VSphereResourcePoolPhysicalChildType objects."
    nodes: [VSphereResourcePoolPhysicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VSphereResourcePoolPhysicalChildType object. This wrapper is used for pagination."
type VSphereResourcePoolPhysicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VSphereResourcePoolPhysicalChildType object wrapped by this edge."
    node: VSphereResourcePoolPhysicalChildType!
}

type VSphereTag implements CdmHierarchyObject & HierarchyObject & VSphereTagCategoryDescendantType & VSphereTagCategoryTagChildType & VSphereVCenterDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "object id"
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "List of tag children"
    tagChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereTagTagChildTypeConnection!
    vcenterId: String!
    vsphereTagPath: [PathNode!]!
}

type VSphereTagCategory implements CdmHierarchyObject & HierarchyObject & VSphereVCenterDescendantType & VSphereVCenterTagChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "object id"
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "List of tag children"
    tagChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereTagCategoryTagChildTypeConnection!
    vcenterId: String!
    vsphereTagPath: [PathNode!]!
}

"Paginated list of VSphereTagCategoryTagChildType objects."
type VSphereTagCategoryTagChildTypeConnection {
    "Total number of VSphereTagCategoryTagChildType objects matching the request arguments."
    count: Int!
    "List of VSphereTagCategoryTagChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VSphereTagCategoryTagChildTypeEdge!]!
    "List of VSphereTagCategoryTagChildType objects."
    nodes: [VSphereTagCategoryTagChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VSphereTagCategoryTagChildType object. This wrapper is used for pagination."
type VSphereTagCategoryTagChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VSphereTagCategoryTagChildType object wrapped by this edge."
    node: VSphereTagCategoryTagChildType!
}

"Paginated list of VSphereTagTagChildType objects."
type VSphereTagTagChildTypeConnection {
    "Total number of VSphereTagTagChildType objects matching the request arguments."
    count: Int!
    "List of VSphereTagTagChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VSphereTagTagChildTypeEdge!]!
    "List of VSphereTagTagChildType objects."
    nodes: [VSphereTagTagChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VSphereTagTagChildType object. This wrapper is used for pagination."
type VSphereTagTagChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VSphereTagTagChildType object wrapped by this edge."
    node: VSphereTagTagChildType!
}

type VSphereVCenter implements CdmHierarchyObject & HierarchyObject {
    aboutInfo: AboutInformation
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    caCerts: String!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    conflictResolutionAuthz: VcenterSummaryConflictResolutionAuthz
    connectionStatus: RefreshableObjectConnectionStatus!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereVCenterDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Flag to determine whether this vcenter is from VMC or not."
    isVmc: Boolean!
    lastRefreshTime: DateTime
    "Latest User note information."
    latestUserNote: LatestUserNote
    "List of logical children"
    logicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereVCenterLogicalChildTypeConnection!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "List of physical children"
    physicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereVCenterPhysicalChildTypeConnection!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "List of tag children"
    tagChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VSphereVCenterTagChildTypeConnection!
    username: String!
    vcenterId: String!
    "The provider of VMC."
    vmcProvider: String
    vsphereTagPath: [PathNode!]!
}

"Paginated list of VSphereVCenter objects."
type VSphereVCenterConnection {
    "Total number of VSphereVCenter objects matching the request arguments."
    count: Int!
    "List of VSphereVCenter objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VSphereVCenterEdge!]!
    "List of VSphereVCenter objects."
    nodes: [VSphereVCenter!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Paginated list of VSphereVCenterDescendantType objects."
type VSphereVCenterDescendantTypeConnection {
    "Total number of VSphereVCenterDescendantType objects matching the request arguments."
    count: Int!
    "List of VSphereVCenterDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VSphereVCenterDescendantTypeEdge!]!
    "List of VSphereVCenterDescendantType objects."
    nodes: [VSphereVCenterDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VSphereVCenterDescendantType object. This wrapper is used for pagination."
type VSphereVCenterDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VSphereVCenterDescendantType object wrapped by this edge."
    node: VSphereVCenterDescendantType!
}

"Wrapper around the VSphereVCenter object. This wrapper is used for pagination."
type VSphereVCenterEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VSphereVCenter object wrapped by this edge."
    node: VSphereVCenter!
}

"Paginated list of VSphereVCenterLogicalChildType objects."
type VSphereVCenterLogicalChildTypeConnection {
    "Total number of VSphereVCenterLogicalChildType objects matching the request arguments."
    count: Int!
    "List of VSphereVCenterLogicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VSphereVCenterLogicalChildTypeEdge!]!
    "List of VSphereVCenterLogicalChildType objects."
    nodes: [VSphereVCenterLogicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VSphereVCenterLogicalChildType object. This wrapper is used for pagination."
type VSphereVCenterLogicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VSphereVCenterLogicalChildType object wrapped by this edge."
    node: VSphereVCenterLogicalChildType!
}

"Paginated list of VSphereVCenterPhysicalChildType objects."
type VSphereVCenterPhysicalChildTypeConnection {
    "Total number of VSphereVCenterPhysicalChildType objects matching the request arguments."
    count: Int!
    "List of VSphereVCenterPhysicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VSphereVCenterPhysicalChildTypeEdge!]!
    "List of VSphereVCenterPhysicalChildType objects."
    nodes: [VSphereVCenterPhysicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VSphereVCenterPhysicalChildType object. This wrapper is used for pagination."
type VSphereVCenterPhysicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VSphereVCenterPhysicalChildType object wrapped by this edge."
    node: VSphereVCenterPhysicalChildType!
}

"Paginated list of VSphereVCenterTagChildType objects."
type VSphereVCenterTagChildTypeConnection {
    "Total number of VSphereVCenterTagChildType objects matching the request arguments."
    count: Int!
    "List of VSphereVCenterTagChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VSphereVCenterTagChildTypeEdge!]!
    "List of VSphereVCenterTagChildType objects."
    nodes: [VSphereVCenterTagChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VSphereVCenterTagChildType object. This wrapper is used for pagination."
type VSphereVCenterTagChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VSphereVCenterTagChildType object wrapped by this edge."
    node: VSphereVCenterTagChildType!
}

type VSphereVMNicSpec {
    adapterType: NetworkAdapterTypeEnum!
    dnsInfos: [String!]!
    gateway: String!
    ipv4Address: String!
    ipv6Address: String!
    isPrimaryNic: Boolean!
    key: String!
    netmask: String!
    networkId: String!
    networkMoid: String!
    networkType: NetworkTypeEnum!
}

type VSphereVMVolumeSpec {
    "Cdm Id of vSphere Datastore."
    dataStoreCdmId: String!
    "Id of vSphere Datastore."
    dataStoreId: String!
    "Id of vSphere Datastore Cluster."
    datastoreClusterId: String!
    "Key value defined in Ebs Volume."
    key: String!
    "Size of datastore or datastore cluster in Gbs."
    sizeGbs: Float!
}

type VSphereVirtualDisk {
    cdmId: String!
    cdmVersion: String!
    clusterUuid: UUID!
    deviceKey: Int
    excludeFromSnapshots: Boolean!
    fid: UUID!
    fileName: String!
    size: Long
    virtualMachineId: String!
}

"Paginated list of VSphereVirtualDisk objects."
type VSphereVirtualDiskConnection {
    "Total number of VSphereVirtualDisk objects matching the request arguments."
    count: Int!
    "List of VSphereVirtualDisk objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VSphereVirtualDiskEdge!]!
    "List of VSphereVirtualDisk objects."
    nodes: [VSphereVirtualDisk!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VSphereVirtualDisk object. This wrapper is used for pagination."
type VSphereVirtualDiskEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VSphereVirtualDisk object wrapped by this edge."
    node: VSphereVirtualDisk!
}

type VSphereVm implements CdmHierarchyObject & CdmHierarchySnappableNew & HierarchyObject & HierarchySnappable & VSphereComputeClusterDescendantType & VSphereDatacenterDescendantType & VSphereFolderDescendantType & VSphereFolderLogicalChildType & VSphereHostDescendantType & VSphereHostPhysicalChildType & VSphereTagCategoryDescendantType & VSphereTagDescendantType & VSphereTagTagChildType & VSphereVCenterDescendantType {
    "Status of the Rubrik Backup Service agent on this VM"
    agentStatus: AgentStatus
    "Whether array integration is enabled for this VM"
    arrayIntegrationEnabled: Boolean!
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    cdmId: String!
    "A link to view the snappable on the CDM cluster. For dev use only."
    cdmLink: String!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "Guest credential authorization status"
    guestCredentialAuthorizationStatus: GuestCredentialAuthorizationStatusEnum!
    guestOsName: String!
    "The Guest OS Type of this VM"
    guestOsType: GuestOsTypeEnum!
    "object id"
    id: UUID!
    "If VM is active."
    isActive: Boolean!
    "If VM is a child of a blueprint."
    isBlueprintChild: Boolean!
    isRelic: Boolean!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The list of missed snapshots for this workload."
    missedSnapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int
    ): MissedSnapshotCommonConnection
    "The list of missed snapshots for this workload."
    missedSnapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: MissedSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): MissedSnapshotGroupByConnection
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot archived to AWS."
    newestArchivedSnapshot: CdmSnapshot
    "The newest snapshot replicated to a cluster."
    newestReplicatedSnapshot: CdmSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: CdmSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: CdmSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    parentSnappableIdOpt: UUID
    parentSnappableTypeOpt: String
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "postBackupScript"
    postBackupScript: PrePostScript
    "postSnapScript"
    postSnapScript: PrePostScript
    powerStatus: VmPowerStatusEnum
    "preBackupScript"
    preBackupScript: PrePostScript
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "Date that effective SLA was assigned / inherited."
    protectionDate: DateTime
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "contains stats for this snappable (e.g., capacity)"
    reportSnappable: Snappable
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmSnapshotConnection
    "snapshot consistency mandate"
    snapshotConsistencyMandate: ConsistencyLevelEnum!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for the snapshots of this workload."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: CdmSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): cdmSnapshotGroupByConnection
    "list of liveMounts for this VM"
    vSphereMounts(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "filter for VM live mounts"
        filter: VSphereMountFilter,
        "Returns the first n elements from the list."
        first: Int,
        sortBy: VSphereMountSortByEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): VSphereMountConnection!
    vmwareToolsInstalled: Boolean!
    vsphereTagPath: [PathNode!]!
    "list of virtual disks for this VM"
    vsphereVirtualDisks(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "filter for VM virtual disks"
        filter: VSphereVirtualDiskFilter,
        "Returns the first n elements from the list."
        first: Int,
        sortBy: VSphereVirtualDiskSortByEnum,
        "sort order"
        sortOrder: SortOrderEnum
    ): VSphereVirtualDiskConnection!
}

type VSphereVmChild implements BlueprintChild {
    bootPriority: Int!
    "failover instance of child snappable"
    failoverInstance: VSphereBlueprintChildFailoverInstance
    fid: UUID!
    "local RPO lag information"
    localRpoLagInfo: RPOLagInfo
    "The recovery info of the child virtual machine"
    recoveryInfo(
        "The ID of the cluster."
        clusterUuid: UUID
    ): ChildVmRecoveryInfo
    "recoverySpec of child snappable"
    recoverySpec(
        "The recovery point of the snappable."
        recoveryPoint: Long
    ): RecoverySpec
    "remote RPO lag information"
    remoteRpoLagInfo: RPOLagInfo
    "resourceSpec of child snappable"
    resourceSpec(
        "The recovery point of the snappable."
        recoveryPoint: Long
    ): VmwareResourceSpec
    "the child snappable"
    snappable: VSphereVm
    snappableType: ObjectTypeEnum!
}

"Paginated list of VSphereVm objects."
type VSphereVmConnection {
    "Total number of VSphereVm objects matching the request arguments."
    count: Int!
    "List of VSphereVm objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VSphereVmEdge!]!
    "List of VSphereVm objects."
    nodes: [VSphereVm!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VSphereVm object. This wrapper is used for pagination."
type VSphereVmEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VSphereVm object wrapped by this edge."
    node: VSphereVm!
}

"Aws cloud accounts validate response."
type ValidateAndCreateAwsCloudAccountReply {
    "AWS cloud account initiate response if the request is successful."
    initiateResponse: AwsCloudAccountCreateResponse
    "Error messages related to the failure of the request to create an AWS cloud account."
    validateResponse: AwsCloudAccountValidateResponse
}

"Validate AWS RDS Instance name for export."
type ValidateAwsNativeRdsInstanceNameForExportReply {
    "Refers to the reason for the RDS name being invalid."
    error: String!
    "Specifies whether the RDS name is valid or not."
    isValid: Boolean!
}

"Validate Azure SQL Database name for export."
type ValidateAzureNativeSqlDatabaseDbNameForExportReply {
    "Refers to the reason for the database name being invalid."
    error: String!
    "Specifies whether the database name is valid or not."
    isValid: Boolean!
}

"Validate Azure SQL Mananged Instance Database name for export."
type ValidateAzureNativeSqlManagedInstanceDbNameForExportReply {
    "Refers to the reason for the database name being invalid."
    error: String!
    "Specifies whether the database name is valid or not."
    isValid: Boolean!
}

"Response of the operation to validate Azure Cloud Account Exocompute Configurations."
type ValidateAzureSubnetsForCloudAccountExocomputeReply {
    "List of validation information on Azure Exocompute Configurations provided."
    validationInfo: [AzureExocomputeConfigValidationInfo!]!
}

"Blueprint validation reply."
type ValidateBlueprintReply {
    "Blueprint uuid."
    blueprintId: id
    "Status of the validation."
    isValidationSucceeded: Boolean!
    "Detailed information about each resource validation."
    statusInfos: [ValidationStatusInfo!]!
}

"Multiple blueprint validation reply."
type ValidateBlueprintsReply {
    "Detailed information about each blueprint validation."
    blueprintStatus: [ValidateBlueprintReply!]!
}

"Contains a map representing feasibility to do file recovery on snapshots"
type ValidateCloudNativeFileRecoveryFeasibilityReply {
    snapshotFileRecoveryFeasibility: [CloudNativeFileRecoveryFeasibility!]!
}

type ValidateFailureReason {
    failureReason: String!
    planName: PlanNameEnum!
    snappableId: String!
    snapshotId: String!
}

"Status for resource mapping validation for blueprint."
type ValidationStatusInfo {
    "List of all failure error messages."
    failureReasons: [String!]!
    "Validated resource info."
    resourceInfo: ResourceInfo
    "Resource mapping validation status for the snappable."
    validationStatus: ValidationStatus!
    "List of all warning messages."
    warningReasons: [String!]!
}

type ValueBoolean implements Value {
    serializedValue: String!
    value: Boolean
}

type ValueDateTime implements Value {
    serializedValue: String!
    value: DateTime
}

type ValueFloat implements Value {
    serializedValue: String!
    value: Float
}

type ValueInteger implements Value {
    serializedValue: String!
    value: Int
}

type ValueLong implements Value {
    serializedValue: String!
    value: Long
}

type ValueNull implements Value {
    serializedValue: String!
}

type ValueString implements Value {
    serializedValue: String!
    value: String
}

type Vcd implements CdmHierarchyObject & HierarchyObject & VcdTopLevelDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VcdDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "List of logical children"
    logicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VcdLogicalChildTypeConnection!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

type VcdCatalog implements CdmHierarchyObject & HierarchyObject & VcdDescendantType & VcdLogicalChildType & VcdOrgDescendantType & VcdOrgLogicalChildType & VcdTopLevelDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VcdOrgVdcDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "List of logical children"
    logicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VcdOrgLogicalChildTypeConnection!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"Paginated list of VcdDescendantType objects."
type VcdDescendantTypeConnection {
    "Total number of VcdDescendantType objects matching the request arguments."
    count: Int!
    "List of VcdDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VcdDescendantTypeEdge!]!
    "List of VcdDescendantType objects."
    nodes: [VcdDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VcdDescendantType object. This wrapper is used for pagination."
type VcdDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VcdDescendantType object wrapped by this edge."
    node: VcdDescendantType!
}

"Paginated list of VcdLogicalChildType objects."
type VcdLogicalChildTypeConnection {
    "Total number of VcdLogicalChildType objects matching the request arguments."
    count: Int!
    "List of VcdLogicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VcdLogicalChildTypeEdge!]!
    "List of VcdLogicalChildType objects."
    nodes: [VcdLogicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VcdLogicalChildType object. This wrapper is used for pagination."
type VcdLogicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VcdLogicalChildType object wrapped by this edge."
    node: VcdLogicalChildType!
}

type VcdOrg implements CdmHierarchyObject & HierarchyObject & VcdDescendantType & VcdLogicalChildType & VcdTopLevelDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VcdOrgDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "List of logical children"
    logicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VcdOrgLogicalChildTypeConnection!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"Paginated list of VcdOrgDescendantType objects."
type VcdOrgDescendantTypeConnection {
    "Total number of VcdOrgDescendantType objects matching the request arguments."
    count: Int!
    "List of VcdOrgDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VcdOrgDescendantTypeEdge!]!
    "List of VcdOrgDescendantType objects."
    nodes: [VcdOrgDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VcdOrgDescendantType object. This wrapper is used for pagination."
type VcdOrgDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VcdOrgDescendantType object wrapped by this edge."
    node: VcdOrgDescendantType!
}

"Paginated list of VcdOrgLogicalChildType objects."
type VcdOrgLogicalChildTypeConnection {
    "Total number of VcdOrgLogicalChildType objects matching the request arguments."
    count: Int!
    "List of VcdOrgLogicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VcdOrgLogicalChildTypeEdge!]!
    "List of VcdOrgLogicalChildType objects."
    nodes: [VcdOrgLogicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VcdOrgLogicalChildType object. This wrapper is used for pagination."
type VcdOrgLogicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VcdOrgLogicalChildType object wrapped by this edge."
    node: VcdOrgLogicalChildType!
}

type VcdOrgVdc implements CdmHierarchyObject & HierarchyObject & VcdDescendantType & VcdLogicalChildType & VcdOrgDescendantType & VcdOrgLogicalChildType & VcdTopLevelDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VcdOrgVdcDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "List of logical children"
    logicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VcdOrgVdcLogicalChildTypeConnection!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"Paginated list of VcdOrgVdcDescendantType objects."
type VcdOrgVdcDescendantTypeConnection {
    "Total number of VcdOrgVdcDescendantType objects matching the request arguments."
    count: Int!
    "List of VcdOrgVdcDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VcdOrgVdcDescendantTypeEdge!]!
    "List of VcdOrgVdcDescendantType objects."
    nodes: [VcdOrgVdcDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VcdOrgVdcDescendantType object. This wrapper is used for pagination."
type VcdOrgVdcDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VcdOrgVdcDescendantType object wrapped by this edge."
    node: VcdOrgVdcDescendantType!
}

"Paginated list of VcdOrgVdcLogicalChildType objects."
type VcdOrgVdcLogicalChildTypeConnection {
    "Total number of VcdOrgVdcLogicalChildType objects matching the request arguments."
    count: Int!
    "List of VcdOrgVdcLogicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VcdOrgVdcLogicalChildTypeEdge!]!
    "List of VcdOrgVdcLogicalChildType objects."
    nodes: [VcdOrgVdcLogicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VcdOrgVdcLogicalChildType object. This wrapper is used for pagination."
type VcdOrgVdcLogicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VcdOrgVdcLogicalChildType object wrapped by this edge."
    node: VcdOrgVdcLogicalChildType!
}

"Paginated list of VcdTopLevelDescendantType objects."
type VcdTopLevelDescendantTypeConnection {
    "Total number of VcdTopLevelDescendantType objects matching the request arguments."
    count: Int!
    "List of VcdTopLevelDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VcdTopLevelDescendantTypeEdge!]!
    "List of VcdTopLevelDescendantType objects."
    nodes: [VcdTopLevelDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VcdTopLevelDescendantType object. This wrapper is used for pagination."
type VcdTopLevelDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VcdTopLevelDescendantType object wrapped by this edge."
    node: VcdTopLevelDescendantType!
}

type VcdVapp implements CdmHierarchyObject & CdmHierarchySnappableNew & HierarchyObject & VcdCatalogDescendantType & VcdCatalogLogicalChildType & VcdDescendantType & VcdOrgDescendantType & VcdOrgVdcDescendantType & VcdOrgVdcLogicalChildType & VcdTopLevelDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    cdmId: String!
    "A link to view the snappable on the CDM cluster. For dev use only."
    cdmLink: String!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    isRelic: Boolean!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "List of logical children"
    logicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VcdVappLogicalChildTypeConnection!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The list of missed snapshots for this workload."
    missedSnapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int
    ): MissedSnapshotCommonConnection
    "The list of missed snapshots for this workload."
    missedSnapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: MissedSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): MissedSnapshotGroupByConnection
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot archived to AWS."
    newestArchivedSnapshot: CdmSnapshot
    "The newest snapshot replicated to a cluster."
    newestReplicatedSnapshot: CdmSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: CdmSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: CdmSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for the snapshots of this workload."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: CdmSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): cdmSnapshotGroupByConnection
}

"Paginated list of VcdVapp objects."
type VcdVappConnection {
    "Total number of VcdVapp objects matching the request arguments."
    count: Int!
    "List of VcdVapp objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VcdVappEdge!]!
    "List of VcdVapp objects."
    nodes: [VcdVapp!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VcdVapp object. This wrapper is used for pagination."
type VcdVappEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VcdVapp object wrapped by this edge."
    node: VcdVapp!
}

"Paginated list of VcdVappLogicalChildType objects."
type VcdVappLogicalChildTypeConnection {
    "Total number of VcdVappLogicalChildType objects matching the request arguments."
    count: Int!
    "List of VcdVappLogicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VcdVappLogicalChildTypeEdge!]!
    "List of VcdVappLogicalChildType objects."
    nodes: [VcdVappLogicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VcdVappLogicalChildType object. This wrapper is used for pagination."
type VcdVappLogicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VcdVappLogicalChildType object wrapped by this edge."
    node: VcdVappLogicalChildType!
}

type VcdVimServer implements CdmHierarchyObject & HierarchyObject & VcdDescendantType & VcdLogicalChildType & VcdTopLevelDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    cdmId: String!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"Supported in v5.3+"
type VcenterCreateResponse {
    "Required. Supported in v5.3+"
    asyncRequestStatus: AsyncRequestStatus
    """

    Required. Supported in v5.3+
    The ID of the vCenter server that controls the management of the virtual machine whose metadata will be refreshed.
    """
    id: String!
    """

    Supported in v7.0+
    An optional field that specifies whether HotAdd transport mode is enabled for On-Premise vCenter. When this value is `true`, HotAdd transport mode is enabled for this vCenter. When this value is `false`, HotAdd transport mode is disabled for this vCenter. When this value is not specified, it indicates that this is an VMC vCenter.
    """
    isHotAddProxyEnabledForOnPremVcenter: Boolean
    """

    Required. Supported in v5.3+
    Whether the new vCenter is a VMC Instance.
    """
    isVmc: Boolean!
}

type VerifySLAWithReplicationToClusterResp {
    isActiveSla: Boolean!
}

type VersionedFile {
    absolutePath: String!
    displayPath: String!
    fileVersions: [HierarchySnappableFileVersion!]!
    filename: String!
    path: String!
}

"Paginated list of VersionedFile objects."
type VersionedFileConnection {
    "Total number of VersionedFile objects matching the request arguments."
    count: Int!
    "List of VersionedFile objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VersionedFileEdge!]!
    "List of VersionedFile objects."
    nodes: [VersionedFile!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VersionedFile object. This wrapper is used for pagination."
type VersionedFileEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VersionedFile object wrapped by this edge."
    node: VersionedFile!
}

"Vm Application Consistency Specs Info"
type VmAppConsistentSpecsInternal {
    cancelBackupIfPreScriptFails: Boolean!
    postScriptTimeoutInSeconds: Int!
    postSnapshotScriptPath: String!
    preScriptTimeoutInSeconds: Int!
    preSnapshotScriptPath: String!
    rbaStatus: CloudNativeRbaStatusType!
}

type VmDatastore {
    datastoreId: String!
    datastoreName: String!
}

type VmDiskMapEntry {
    sourceDatastore: VmDatastore
    sourceVmDiskId: String!
    targetDiskId: String!
    targetDiskNativeId: String!
    targetIsOsDisk: Boolean!
    targetLogicalSize: Long!
    targetSnapshotId: String!
}

type VmHost {
    hostId: String!
    hostName: String!
    vcenterId: String!
    vcenterName: String!
}

type VmInfo {
    gateway: String!
    ipAddress: String!
    subnetMask: String!
    vmName: String!
}

type VmNic {
    nicId: String!
    nicMoid: String!
    nicName: String!
}

type VmNicMapEntry {
    sourceNic: VmNic
    sourceNicAdapterType: String!
    sourceNicId: String!
    targetNicId: String!
}

"Vmware app metadata for a snapshot."
type VmwareAppMetadata {
    "The VM configuration."
    vmConfig: VmwareSnapshotVmConfig
}

"Supported in v5.1+"
type VmwareCdpLiveInfo {
    """

    Supported in v5.1+
    The time on this node. Computed after computing the live CDP info for the virtual machine.
    """
    currentTime: DateTime
    """

    Supported in v5.1+
    The latest time to which this virtual machine can be recovered locally.
    """
    localRecoveryPoint: DateTime
    """

    Supported in v5.1+
    The latest time to which this virtual machine can be recovered on a remote cluster.
    """
    remoteRecoveryPoint: DateTime
    """

    Required. Supported in v5.1+
    The ID of the virtual machine that we are getting CDP live fields for.
    """
    vmId: String!
}

"VM Network configuration."
type VmwareNetworkConfig {
    "The list of network adaptors."
    nics: [VmwareNetworkDeviceInfo!]!
}

"Vmware Network Device Info."
type VmwareNetworkDeviceInfo {
    "The key of the device."
    key: Int!
    "The name of the device."
    name: String!
}

"Supported in v5.1+"
type VmwareRecoverableRange {
    "Supported in v5.1+"
    beginTime: DateTime
    "Supported in v5.1+"
    endTime: DateTime
}

type VmwareRecoveryPoints {
    localRecoveryPoint: DateTime
    remoteRecoveryPoint: DateTime
}

type VmwareRecoveryState {
    healthPercentage: Float!
    localStatus: CdpLocalStatusEnum!
    replicationStatus: CdpReplicationStatusEnum!
}

type VmwareResourceSpec implements ResourceSpec {
    isArchived: Boolean!
    memoryMbs: Int!
    osType: String!
    "Recovery point of the snappable."
    recoveryPointOpt: Long
    snappableId: String!
    snappableName: String!
    snapshotId: String!
    vCpus: Int!
    vmWareVolumeSpecs: [VmwareVirtualMachineVolume!]!
    vmwareNics: [VmwareVirtualMachineNic!]!
}

"VM configuration for a snapshot."
type VmwareSnapshotVmConfig {
    "The network configuration."
    networkConfig: VmwareNetworkConfig!
}

type VmwareVirtualMachineNic {
    deviceLabel: String!
    key: Int!
    networkLabel: String!
    v4Addresses: [String!]!
}

type VmwareVirtualMachineVolume {
    capacityKbs: Long!
    key: Int!
    label: String!
}

type VmwareVmConfig {
    logRetentionSeconds: Long!
}

"Supported in v5.0+"
type VmwareVmMountDetailV1 {
    """

    Supported in v7.0+
    The IP address of the NFS share.
    """
    nasIp: String
    """

    Supported in v5.0+
    The power status of the mounted VM(ON,OFF,SLEEP etc.).
    """
    powerStatus: String
    vmwareVmMountSummaryV1: VmwareVmMountSummaryV1
}

"Supported in v5.0+"
type VmwareVmMountSummaryV1 {
    """

    Supported in v5.0+
    An integer value that identifies how many disks are attached.
    """
    attachingDiskCount: Int
    """

    Supported in v5.0+
    This boolean value determines whether or not the mount is created as a datastore only. When 'true,' the mount is created with datastore and not the associated virtual machine. When 'false,' the mount is created with both the datastore and the associated virtual machine.
    """
    createDatastoreOnlyMount: Boolean
    """

    Supported in v5.0+
    The name of the datastore that contains the mounted VMDK.
    """
    datastoreName: String
    """

    Supported in v5.0+
    A boolean value that specifies whether the datastore is ready. When 'true,' the datastore is ready. When 'false,' the datastore is not ready.
    """
    datastoreReady: Boolean
    """

    Supported in v5.0+
    A Boolean value that determines whether this job is an attaching disk mount job. When 'true,' this is an attaching disk mount job. When 'false,' this is not an attaching disk mount job.
    """
    hasAttachingDisk: Boolean
    "Supported in v5.0+"
    hostId: String
    "Required. Supported in v5.0+"
    id: String!
    "Required. Supported in v5.0+"
    isReady: Boolean!
    "Supported in v5.0+"
    mountRequestId: String
    """

    Supported in v5.0+
    Gives the timestamp at which the mount was created.
    """
    mountTimestamp: DateTime
    "Supported in v5.0+"
    mountedVmId: String
    "Required. Supported in v5.0+"
    snapshotDate: DateTime
    "Supported in v5.0+"
    unmountRequestId: String
    "Required. Supported in v5.0+"
    vmId: String!
}

"Supported in v5.3+"
type VmwareVmRecoverableRanges {
    """

    Required. Supported in v5.3+
    The recoverable ranges for the virtual machine.
    """
    recoverableRanges: [VmwareRecoverableRange!]!
    """

    Required. Supported in v5.3+
    The ID of the virtual machine for which to retrieve recoverable ranges.
    """
    vmId: String!
}

"Volume group for a host."
type VolumeGroup implements CdmHierarchyObject & CdmHierarchySnappableNew & HierarchyObject & HierarchySnappable & PhysicalHostDescendantType & PhysicalHostPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "CDM ID of the volume group."
    cdmId: String!
    "A link to view the snappable on the CDM cluster. For dev use only."
    cdmLink: String!
    "List of snapshots taken for a Volume Group."
    cdmSnapshots(
        "Filter CDM snapshots."
        CdmSnapshotFilter: [CdmSnapshotFilter!],
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the first n elements from the list."
        first: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CDMSnapshotConnection!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The fid of the hierarchy object."
    id: UUID!
    "Whether the volume group is a relic."
    isRelic: Boolean!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The list of missed snapshots for this workload."
    missedSnapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int
    ): MissedSnapshotCommonConnection
    "The list of missed snapshots for this workload."
    missedSnapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: MissedSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): MissedSnapshotGroupByConnection
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot archived to AWS."
    newestArchivedSnapshot: CdmSnapshot
    "The newest snapshot replicated to a cluster."
    newestReplicatedSnapshot: CdmSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: CdmSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: CdmSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for the snapshots of this workload."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: CdmSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): cdmSnapshotGroupByConnection
    "Volumes in the volume group."
    volumes: [String!]!
}

"Paginated list of VolumeGroup objects."
type VolumeGroupConnection {
    "Total number of VolumeGroup objects matching the request arguments."
    count: Int!
    "List of VolumeGroup objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VolumeGroupEdge!]!
    "List of VolumeGroup objects."
    nodes: [VolumeGroup!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Supported in v5.0+"
type VolumeGroupDetail {
    blackoutWindowResponseInfo: BlackoutWindowResponseInfo
    """

    Required. Supported in v5.0+
    v5.0-v5.2: Assign this Volume Group to the given SLA domain.
    v5.3+: The ID of the SLA Domain policy to assign to the Volume Group.
    """
    configuredSlaDomainId: String!
    """

    Required. Supported in v5.0+
    v5.0-v5.2: Whether backup/archival/replication is paused for this Volume Group
    v5.3+: Indicates whether backup, archival, and replication are paused for this Volume Group.
    """
    isPaused: Boolean!
    """

    Supported in v5.3+
    Describes any pending SLA Domain assignment on this object.
    """
    pendingSlaDomain: ManagedObjectPendingSlaInfo
    volumeGroupSummary: VolumeGroupSummary
    """

    Required. Supported in v5.0+
    v5.0-v5.2:
    v5.3+: Configuration details for the volumes in the Volume Group.
    """
    volumes: [HostVolumeSummary!]!
}

"Wrapper around the VolumeGroup object. This wrapper is used for pagination."
type VolumeGroupEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VolumeGroup object wrapped by this edge."
    node: VolumeGroup!
}

"Volume group live mount."
type VolumeGroupLiveMount {
    "Cluster of the live mount."
    cluster: Cluster!
    "Fid of the live mount."
    id: String!
    "Describes if the live mount is ready."
    isReady: Boolean!
    "Path where the live mount is mounted."
    mountPath: String
    "Id of the mount request."
    mountRequestId: String
    "Timestamp when the mount was created."
    mountTimestamp: DateTime
    "Mounted volumes in the live mount."
    mountedVolumes: [MountedVolume!]!
    "Name of the live mount."
    name: String!
    "Composite Id of the node in the live mount."
    nodeCompositeId: String
    "IP of the node in the live mount."
    nodeIp: String
    "Path of the bare-metal restore script."
    restoreScriptPath: String
    "Name of SMB share."
    smbShareName: String
    "Source host of the live mount."
    sourceHost: PhysicalHost!
    "Source snapshot of the live mount."
    sourceSnapshot: CdmSnapshot!
    "Id of the source volume group in the live mount."
    sourceVolumeGroupId: String!
    "Id of the target host."
    targetHostId: String
    "Name of the target host."
    targetHostName: String
    "Id of the unmount request."
    unmountRequestId: String
}

"Paginated list of VolumeGroupLiveMount objects."
type VolumeGroupLiveMountConnection {
    "Total number of VolumeGroupLiveMount objects matching the request arguments."
    count: Int!
    "List of VolumeGroupLiveMount objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VolumeGroupLiveMountEdge!]!
    "List of VolumeGroupLiveMount objects."
    nodes: [VolumeGroupLiveMount!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VolumeGroupLiveMount object. This wrapper is used for pagination."
type VolumeGroupLiveMountEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VolumeGroupLiveMount object wrapped by this edge."
    node: VolumeGroupLiveMount!
}

"Supported in v5.0+"
type VolumeGroupSnapshotVolumeSummary {
    fileSystemType: FileSystemTypeEnum!
    """

    Required. Supported in v5.0+
    v5.0-v5.2:
    v5.3+: The unique ID of the snapshot volume summary.
    """
    id: String!
    """

    Required. Supported in v5.0+
    v5.0-v5.2: Mount point locations of this Volume on the Host
    v5.3+: The mount points of the volume on the host.
    """
    mountPoints: [String!]!
    """

    Required. Supported in v5.0+
    v5.0-v5.2: Size of the Volume in bytes
    v5.3+: The size of the volume in bytes.
    """
    size: Long!
}

"A volume captured in a volume group snapshot."
type VolumeGroupSubObject {
    "Capacity of the volume in bytes."
    capacityInBytes: Long!
    "File size of the volume in bytes."
    fileSizeInBytes: Long!
    "File system type of the volume."
    fileSystemType: String!
    "Mount point for the volume."
    mountPointsOpt: [String!]!
    "ID of the volume."
    volumeId: String!
}

"Supported in v5.0+"
type VolumeGroupSummary {
    """

    Supported in v5.3+
    Specifies whether the Volume Group is set to take a full snapshot for the next backup.
    """
    forceFull: Boolean
    """

    Supported in v5.0+
    v5.0-v5.2: Id of the host of the volume group
    v5.3+: The unique ID of the host that contains the Volume Group.
    """
    hostId: String
    """

    Supported in v5.0+
    v5.0-v5.2: IP Address or fully qualified domain name with which the host was added
    v5.3+: The name of the host that contains the Volume Group.
    """
    hostname: String
    """

    Required. Supported in v5.0+
    v5.0-v5.2:
    v5.3+: The unique ID of the Volume Group.
    """
    id: String!
    """

    Required. Supported in v5.0+
    v5.0-v5.2: Whether this Volume Group is currently accessible on the host
    v5.3+: Specifies whether the Volume Group is accessible on the Rubrik cluster.
    """
    isRelic: Boolean!
    """

    Required. Supported in v5.0+
    v5.0-v5.2:
    v5.3+: The name of the Volume Group.
    """
    name: String!
    """

    Supported in v5.3+
    Specifies whether the Volume Group needs to be migrated in order to use the fast VHDX builder. This flag is set only when the Volume Group's last backup job failed due to an error during data fetch, and the backup job did not use the fast VHDX builder.
    """
    needsMigration: Boolean
    snappable: CDMSnappable
}

type Vpc {
    cidrBlock: AddressBlockV4
    id: String!
    name: String!
    vpcId: String!
}

"Paginated list of Vpc objects."
type VpcConnection {
    "Total number of Vpc objects matching the request arguments."
    count: Int!
    "List of Vpc objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VpcEdge!]!
    "List of Vpc objects."
    nodes: [Vpc!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the Vpc object. This wrapper is used for pagination."
type VpcEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual Vpc object wrapped by this edge."
    node: Vpc!
}

type VsphereBlueprintChildSnapshotInfo {
    host: VmHost
    memoryMbs: Int!
    nicMap: [VmNicMapEntry!]!
    osType: String!
    snapshotAppMetadata: String!
    snapshotId: String!
    vcpus: Int!
    volumeMap: [VmDiskMapEntry!]!
}

"Vsphere datastore cluster."
type VsphereDatastoreCluster implements CdmHierarchyObject & HierarchyObject & VSphereComputeClusterDescendantType & VSphereDatacenterDescendantType & VSphereDatacenterPhysicalChildType & VSphereHostDescendantType & VSphereResourcePoolDescendantType & VSphereVCenterDescendantType & VSphereVCenterPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Datastore cluster resources - total capacity, in terrabytes."
    capacity: Long!
    "Cdm ID of the vSphere datastore cluster."
    cdmId: String!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VsphereDatastoreClusterDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "Datastore cluster resources - total available free space, in terrabytes."
    freeSpace: Long!
    "Datastore cluster ID."
    id: UUID!
    "Indicates whether the storage DRS automation is enabled."
    isSdrsEnabled: Boolean!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "List of physical children"
    physicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): VsphereDatastoreClusterPhysicalChildTypeConnection!
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "Vcenter ID."
    vcenterId: UUID!
}

"Paginated list of VsphereDatastoreCluster objects."
type VsphereDatastoreClusterConnection {
    "Total number of VsphereDatastoreCluster objects matching the request arguments."
    count: Int!
    "List of VsphereDatastoreCluster objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VsphereDatastoreClusterEdge!]!
    "List of VsphereDatastoreCluster objects."
    nodes: [VsphereDatastoreCluster!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Paginated list of VsphereDatastoreClusterDescendantType objects."
type VsphereDatastoreClusterDescendantTypeConnection {
    "Total number of VsphereDatastoreClusterDescendantType objects matching the request arguments."
    count: Int!
    "List of VsphereDatastoreClusterDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VsphereDatastoreClusterDescendantTypeEdge!]!
    "List of VsphereDatastoreClusterDescendantType objects."
    nodes: [VsphereDatastoreClusterDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VsphereDatastoreClusterDescendantType object. This wrapper is used for pagination."
type VsphereDatastoreClusterDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VsphereDatastoreClusterDescendantType object wrapped by this edge."
    node: VsphereDatastoreClusterDescendantType!
}

"Wrapper around the VsphereDatastoreCluster object. This wrapper is used for pagination."
type VsphereDatastoreClusterEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VsphereDatastoreCluster object wrapped by this edge."
    node: VsphereDatastoreCluster!
}

"Paginated list of VsphereDatastoreClusterPhysicalChildType objects."
type VsphereDatastoreClusterPhysicalChildTypeConnection {
    "Total number of VsphereDatastoreClusterPhysicalChildType objects matching the request arguments."
    count: Int!
    "List of VsphereDatastoreClusterPhysicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [VsphereDatastoreClusterPhysicalChildTypeEdge!]!
    "List of VsphereDatastoreClusterPhysicalChildType objects."
    nodes: [VsphereDatastoreClusterPhysicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the VsphereDatastoreClusterPhysicalChildType object. This wrapper is used for pagination."
type VsphereDatastoreClusterPhysicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual VsphereDatastoreClusterPhysicalChildType object wrapped by this edge."
    node: VsphereDatastoreClusterPhysicalChildType!
}

"A webhook configuration in the account."
type Webhook {
    "The timestamp that this webhook was created at."
    createdAt: String!
    "The user who created the webhook."
    createdBy: String!
    "A description of this webhook."
    description: String
    "The event severities that the webhook is subscribed to."
    eventSeverities: [EventSeverity!]!
    "The event types that the webhook is subscribed to."
    eventTypes: [EventType!]!
    "The webhook's unique id."
    id: Int!
    "The information describing the webhook's most recent error."
    lastFailedErrorInfo: ErrorInfo
    "The webhook's name."
    name: String!
    "The application that will receive the webhook."
    providerType: ProviderType!
    "Describes whether the webhook is enabled or disabled."
    status: WebhookStatus!
    "The timestamp that this webhook was updated at."
    updatedAt: String!
    "The URL endpoint that will receive the webhook."
    url: String!
}

"A weekly recurrence pattern (e.g. Every other Monday)."
type WeeklyRecurrencePattern {
    "Which days of the week the event occurs."
    daysOfWeek: [String!]!
    "E.g. Monday."
    firstDayOfWeek: String!
    "The interval at which the recurrence applies."
    interval: Int!
}

type WeeklySnapshotSchedule {
    basicSchedule: BasicSnapshotSchedule
    dayOfWeek: DayOfWeek!
}

type WhitelistedAnalyzer {
    isExplicit: Boolean!
    whitelistedAnalyzerId: String!
    whitelistedPath: String!
}

type WindowsCluster implements CdmHierarchyObject & HierarchyObject & MssqlTopLevelDescendantType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "List of descendants."
    descendantConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): WindowsClusterDescendantTypeConnection!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    "The list of hosts associated with a Windows Cluster."
    hosts: [PhysicalHost!]!
    "The fid of the hierarchy object."
    id: UUID!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "List of logical children"
    logicalChildConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        filter: [Filter!],
        "Returns the first n elements from the list."
        first: Int,
        "Each value in the enum represents the hierarchy of a specific type of protected object for RBAC and SLA Domain assignments. The value None represents the hierarchy of all types of objects."
        snappableHierarchy: SnappableLevelHierarchyTypeEnum,
        sortBy: HierarchySortByField,
        sortOrder: HierarchySortOrder,
        typeFilter: [HierarchyObjectTypeEnum!]
    ): WindowsClusterLogicalChildTypeConnection!
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The name of the hierarchy object."
    name: String!
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
}

"Paginated list of WindowsClusterDescendantType objects."
type WindowsClusterDescendantTypeConnection {
    "Total number of WindowsClusterDescendantType objects matching the request arguments."
    count: Int!
    "List of WindowsClusterDescendantType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [WindowsClusterDescendantTypeEdge!]!
    "List of WindowsClusterDescendantType objects."
    nodes: [WindowsClusterDescendantType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the WindowsClusterDescendantType object. This wrapper is used for pagination."
type WindowsClusterDescendantTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual WindowsClusterDescendantType object wrapped by this edge."
    node: WindowsClusterDescendantType!
}

"Paginated list of WindowsClusterLogicalChildType objects."
type WindowsClusterLogicalChildTypeConnection {
    "Total number of WindowsClusterLogicalChildType objects matching the request arguments."
    count: Int!
    "List of WindowsClusterLogicalChildType objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [WindowsClusterLogicalChildTypeEdge!]!
    "List of WindowsClusterLogicalChildType objects."
    nodes: [WindowsClusterLogicalChildType!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the WindowsClusterLogicalChildType object. This wrapper is used for pagination."
type WindowsClusterLogicalChildTypeEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual WindowsClusterLogicalChildType object wrapped by this edge."
    node: WindowsClusterLogicalChildType!
}

type WindowsFileset implements CdmHierarchyObject & CdmHierarchySnappableNew & FailoverClusterAppDescendantType & FailoverClusterAppPhysicalChildType & FailoverClusterTopLevelDescendantType & FilesetTemplateDescendantType & FilesetTemplatePhysicalChildType & HierarchyObject & HierarchySnappable & HostFailoverClusterDescendantType & HostFailoverClusterPhysicalChildType & PhysicalHostDescendantType & PhysicalHostPhysicalChildType {
    "The authorized operations on the object."
    authorizedOperations: [OperationEnum!]!
    cdmId: String!
    "A link to view the snappable on the CDM cluster. For dev use only."
    cdmLink: String!
    "Rubrik cluster where this object originated."
    cluster: Cluster!
    "The configured SLA Domain of the hierarchy object."
    configuredSlaDomain: SlaDomain!
    "The effective Retention SLA Domain of the hierarchy object."
    effectiveRetentionSlaDomain: SlaDomain
    "The effective SLA Domain of the hierarchy object."
    effectiveSlaDomain: SlaDomain!
    "The path node of the effective SLA Domain source."
    effectiveSlaSourceObject: PathNode
    failoverClusterApp: FailoverClusterApp
    hardlinkSupportEnabled: Boolean!
    host: PhysicalHost
    "The fid of the hierarchy object."
    id: UUID!
    isPassThrough: Boolean!
    isRelic: Boolean!
    "Latest User note information."
    latestUserNote: LatestUserNote
    "A sequential list of this object's logical ancestors."
    logicalPath: [PathNode!]!
    "The list of missed snapshots for this workload."
    missedSnapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int
    ): MissedSnapshotCommonConnection
    "The list of missed snapshots for this workload."
    missedSnapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter missed snapshots by date"
        filter: MissedSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: MissedSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): MissedSnapshotGroupByConnection
    "The name of the hierarchy object."
    name: String!
    "The newest snapshot archived to AWS."
    newestArchivedSnapshot: CdmSnapshot
    "The newest snapshot replicated to a cluster."
    newestReplicatedSnapshot: CdmSnapshot
    "The most recent snapshot of this workload."
    newestSnapshot: CdmSnapshot
    "The number of descendant workloads of this object."
    numSnappableDescendants: Int!
    "The type of this object."
    objectType: HierarchyObjectTypeEnum!
    "The oldest snapshot of this workload."
    oldestSnapshot: CdmSnapshot
    "The number of on-demand snapshots."
    onDemandSnapshotCount: Int!
    pathExceptions: [String!]!
    pathExcluded: [String!]!
    pathIncluded: [String!]!
    "Mapping from objectID to pending object deletion status."
    pendingObjectDeletionStatus: PendingSnapshotsOfObjectDeletion
    "SLA Domain assignment of the object during the process of being communicated over to Rubrik CDM."
    pendingSla: SlaDomain
    "A sequential list of this object's physical ancestors."
    physicalPath: [PathNode!]!
    "The source cluster of this object. Returned as a data location because there is no guarantee that Polaris has knowledge about the source cluster."
    primaryClusterLocation: DataLocation!
    "The number of objects either replicated by this object or related to this object by replication."
    replicatedObjectCount: Int!
    "Objects either replicated by this object or related to this object by replication."
    replicatedObjects: [CdmHierarchyObject!]!
    "The SLA Domain assignment type for this object."
    slaAssignment: SlaAssignmentTypeEnum!
    "The pause status of the effective SLA Domain of the hierarchy object."
    slaPauseStatus: Boolean!
    "The list of snapshots taken for this workload."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmSnapshotConnection
    "The distribution of the snapshots of the hierarchy object."
    snapshotDistribution: SnapshotDistribution!
    "GroupBy connection for the snapshots of this workload."
    snapshotGroupByConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "filter snapshot connection"
        filter: CdmSnapshotFilterInput,
        "Returns the first n elements from the list."
        first: Int,
        "group snapshots by field"
        groupBy: CdmSnapshotGroupByEnum!,
        "Returns the last n elements from the list."
        last: Int,
        timezoneOffset: Float = 0.0
    ): cdmSnapshotGroupByConnection
    symlinkResolutionEnabled: Boolean!
}

"Supported in v6.0+"
type YARAMatchDetail {
    """

    Required. Supported in v6.0+
    The name of the matching YARA rule.
    """
    name: String!
    """

    Required. Supported in v6.0+
    Optional YARA tags https://yara.readthedocs.io/en/latest/writingrules.html#rule-tags.
    """
    tags: [String!]!
}

type YearlySnapshotSchedule {
    basicSchedule: BasicSnapshotSchedule
    dayOfYear: DayOfYear!
    yearStartMonth: Month!
}

"Snapshot data with groupby info applied to it."
type cdmSnapshotGroupBy {
    "Further provide groupings for the data."
    cdmSnapshotGroupBy(
        "group snapshots by field"
        groupBy: CdmSnapshotGroupByEnum!
    ): [cdmSnapshotGroupBy!]!
    "The data groupby info."
    groupByInfo: CdmSnapshotGroupByInfo!
    "Paginated snapshot data."
    snapshotConnection(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first n elements from the list."
        first: Int,
        "Returns the last n elements from the list."
        last: Int,
        "sort snapshots by field"
        sortBy: CdmSnapshotSortByEnum = Date,
        "sort order"
        sortOrder: SortOrderEnum
    ): CdmSnapshotConnection!
}

"Paginated list of cdmSnapshotGroupBy objects."
type cdmSnapshotGroupByConnection {
    "Total number of cdmSnapshotGroupBy objects matching the request arguments."
    count: Int!
    "List of cdmSnapshotGroupBy objects with supplemental pagination info. Use `nodes` if per-object cursors are not needed."
    edges: [cdmSnapshotGroupByEdge!]!
    "List of cdmSnapshotGroupBy objects."
    nodes: [cdmSnapshotGroupBy!]!
    "General information about this page of results."
    pageInfo: PageInfo!
}

"Wrapper around the cdmSnapshotGroupBy object. This wrapper is used for pagination."
type cdmSnapshotGroupByEdge {
    "String used to identify this edge."
    cursor: String!
    "The actual cdmSnapshotGroupBy object wrapped by this edge."
    node: cdmSnapshotGroupBy!
}

type clusterState {
    "Cluster removal job creation time."
    clusterRemovalCreatedAt: DateTime
    "Cluster removal status of cdm cluster"
    clusterRemovalState: ClusterRemovalState!
    "Cluster removal job update time."
    clusterRemovalUpdatedAt: DateTime
    "ConnectedStatus of cdm cluster"
    connectedState: ClusterStatus!
}

type configGroupBy {
    "Aggregations for single-level groupBy. This does not affect double-level groupBys."
    aggregations: [String!]!
    "Report-level groupBy selection"
    groupById: String!
}

type dataViewMetadata {
    count: Long!
    dataViewType: DataViewTypeEnum!
}

"ID of the resource."
type id {
    id: String!
}

"Cluster metric data grouped by a time unit."
type metricTimeSeries {
    "cluster metric data for the given time interval."
    metric: ClusterMetric!
    "The time groupby info."
    timeInfo: ClusterMetricGroupByInfo!
}

type pendingAction {
    actionType: PendingActionType
    actionTypeStr: String!
    clusterUuid: String!
    createdAt: DateTime
    description: String!
    info: String!
    pendingActionId: String!
    status: PendingActionStatusEnum!
    updatedAt: DateTime
}

type reportGenerateReply {
    "The Id of the job"
    jobId: Long!
    "The reference Id of the job"
    referenceId: String!
}

"The status of the async cdm request"
type vSphereAsyncRequestStatus {
    endTime: DateTime!
    error: vSphereRequestErrorInfo
    id: String!
    links: [vSphereLink!]!
    nodeId: String!
    progress: Float!
    startTime: DateTime!
    status: String!
}

"a link with href and rel properties."
type vSphereLink {
    href: String!
    rel: String!
}

"contains error info for a cdm response"
type vSphereRequestErrorInfo {
    message: String!
}

enum AccessTypeEnum {
    CREATE_ACCESS
    DELETE_ACCESS
    FULL_CONTROL
    READ_ACCESS
    WRITE_ACCESS
}

enum AceFlagsEnum {
    CONTAINER_INHERIT
    EMPTY_FLAG
    FAILED_ACCESS
    INHERITED
    INHERIT_ONLY
    NO_PROPAGATE_INHERIT
    OBJECT_INHERIT
    SUCCESSFUL_ACCESS
}

enum AceQualifierEnum {
    ACCESS_ALLOWED
    ACCESS_DENIED
    CUSTOM
    SYSTEM_ALARM
    SYSTEM_AUDIT
}

enum AckClusterStatus {
    DownloadFailed
    PrechecksError
}

enum ActionEnum {
    RESUME
    ROLLBACK
    START
}

enum ActivityAccessTypeEnum {
    CREATE_ACTIVITY
    DELETE_ACTIVITY
    READ_ACTIVITY
    WRITE_ACTIVITY
}

enum ActivityObjectTypeEnum {
    AppBlueprint
    AppFlows
    AuthDomain
    AwsAccount
    AwsEventType
    AwsNativeAccount
    AwsNativeEbsVolume
    AwsNativeEc2Instance
    AwsNativeRdsInstance
    AzureNativeDisk
    AzureNativeSubscription
    AzureNativeVm
    AzureSqlDatabase
    AzureSqlDatabaseServer
    AzureSqlManagedInstance
    AzureSqlManagedInstanceDatabase
    CASSANDRA_COLUMN_FAMILY
    CASSANDRA_KEYSPACE
    CASSANDRA_SOURCE
    CapacityBundle
    Certificate
    CloudNativeVirtualMachine
    CloudNativeVm
    Cluster
    ComputeInstance
    DataLocation
    Db2Database
    Db2Instance
    Ec2Instance
    Envoy
    ExchangeDatabase
    Exocompute
    FailoverClusterApp
    GcpNativeDisk
    GcpNativeGceInstance
    GcpNativeProject
    Hdfs
    Host
    HypervScvmm
    HypervServer
    HypervVm
    JobInstance
    KuprCluster
    KuprNamespace
    Ldap
    LinuxFileset
    LinuxHost
    MONGODB_COLLECTION
    MONGODB_DATABASE
    MONGODB_SOURCE
    ManagedVolume
    Mssql
    NasHost
    NasSystem
    NutanixCluster
    NutanixVm
    O365Calendar
    O365Group
    O365Mailbox
    O365Onedrive
    O365Organization
    O365SharePointDrive
    O365SharePointList
    O365Site
    O365Team
    ObjectProtection
    Oracle
    OracleDb
    OracleHost
    OracleRac
    PolarisAccount
    PolarisEbsVolume
    PolarisEc2Instance
    PublicCloudMachineInstance
    SamlSso
    SapHanaDb
    SapHanaSystem
    ShareFileset
    SlaDomain
    SmbDomain
    SnapMirrorCloud
    StorageArray
    StorageArrayVolumeGroup
    StorageLocation
    Storm
    SupportBundle
    UnknownObjectType
    Upgrade
    User
    Vcd
    VcdVapp
    Vcenter
    VmwareComputeCluster
    VmwareVm
    VolumeGroup
    WindowsFileset
    WindowsHost
}

enum ActivitySeriesGroupByEnum {
    Cluster
    ClusterType
    Day
    Hour
    LastActivityStatus
    LastActivityType
    Month
    ObjectType
    Quarter
    Week
    Year
}

enum ActivitySeriesSortByEnum {
    ActivityStatus
    ActivityType
    ClusterName
    LastUpdated
    Location
    ObjectName
    ObjectType
    Severity
    StartTime
}

"""

The severity of the anomalous activity detected in the snapshot.
The snapshot is assumed to be anomalous and hence INFO and UNDEFINED are not
possible values of the severity.
"""
enum ActivitySeverity {
    "\"Critical\" level of anomalous activity."
    CRITICAL
    "\"Warning\" level of anomalous activity."
    WARNING
}

enum ActivitySeverityEnum {
    Critical
    Info
    Warning
}

enum ActivityStatusEnum {
    Canceled
    Canceling
    Failure
    Info
    Queued
    Running
    Success
    TaskFailure
    TaskSuccess
    Warning
}

enum ActivityTableColumnEnum {
    ActivityStatus
    ActivityType
    ClusterName
    ClusterType
    ComplianceStatus
    LastUpdated
    Location
    ObjectName
    ObjectType
    SlaDomain
    StartTime
}

enum ActivityTypeEnum {
    Anomaly
    Archive
    AuthDomain
    AwsEvent
    Backup
    Classification
    CloudNativeSource
    CloudNativeVirtualMachine
    CloudNativeVm
    Configuration
    Connection
    Conversion
    Diagnostic
    Discovery
    Download
    EmbeddedEvent
    Failover
    Fileset
    Hardware
    Hdfs
    HostEvent
    HypervScvmm
    HypervServer
    Index
    Instantiate
    LegalHold
    LocalRecovery
    LockSnapshot
    Maintenance
    NutanixCluster
    RadarAnalysis
    Recovery
    Replication
    ResourceOperations
    Storage
    StorageArray
    StormResource
    Support
    Sync
    System
    TestFailover
    ThreatHunt
    Tpr
    UnknownEventType
    Upgrade
    VCenter
    Vcd
    VolumeGroup
}

"The customer adoption status of the Rubrik CDM release."
enum AdoptionStatus {
    "The adoption of the release is decreasing."
    DECLINING
    "The release has the highest adoption."
    MOST_POPULAR
    "The release has a high adoption."
    POPULAR
    "The adoption of the release is increasing."
    RISING
    "Unknown status."
    UNKNOWN
}

enum AgentConnectStatusEnum {
    Connected
    Disconnected
    SecondaryCluster
    Unregistered
}

"AMIType to be used for exporting an archived EC2 instance snapshot."
enum AmiType {
    "EC2 instance is a linux instance wihtout marketplace code. AMI will be created at runtime."
    CREATED_AT_RUNTIME
    "An AMI already exists which can be used for export."
    EXISTING
    "User needs to provide an AMI id, which will be used for export."
    USER_SPECIFIED
}

enum AnalyzerErrorCodeEnum {
    ANALYZER
    NOERROR
    OTHER
    PARSING
    READING
}

enum AnalyzerGroupTypeEnum {
    CCPA
    CUSTOM
    GLBA
    HIPAA
    PCI_DSS
    UK_PII
    UNDEFINED
    US_FINANCE
    US_PII
}

enum AnalyzerTypeEnum {
    ABA_ROUTING_NUMBER
    AUSTRALIA_ABN
    AUSTRALIA_ACN
    AUSTRALIA_DL
    AUSTRALIA_MEDICAL_ACCOUNT
    AUSTRALIA_PASSPORT
    AUSTRALIA_TFN
    AWS_CONNECTION_STRING
    AZURE_CONNECTION_STRING
    BELGIUM_BNN
    BELGIUM_DL
    BELGIUM_PASSPORT
    CANADA_BANK_ACCT
    CANADA_HEALTH_SERVICE
    CANADA_PASSPORT
    CANADA_PHIN
    CREDIT_CARD
    CUSIP_NUMBER
    DEA_NUMBER
    DIGITAL_CERTIFICATE
    EIN
    EMAIL_ADDRESS
    GERMANY_DL
    GERMANY_ID
    GERMANY_PASSPORT
    IBAN
    IPV4_ADDRESS
    IRELAND_PPS
    KEYWORD
    MAC_ADDRESS
    NETHERLANDS_BSN
    NETHERLANDS_DL
    NETHERLANDS_PASSPORT
    NETHERLANDS_TIN
    NETHERLANDS_VAT
    PASSPORT
    PHONE_NUMBER
    PRIVATE_KEY
    REGEX
    SIMHASH
    SWEDEN_DL
    SWEDEN_NIN
    SWEDEN_PASSPORT
    SWEDEN_TIN
    SWIFT_CODE
    UK_DL
    UK_ELECTORAL
    UK_NHS
    UK_NINO
    UK_UTR
    UNDEFINED
    US_BANK_ACCT
    US_CA_DL
    US_DL
    US_HEALTHCARE_NPI
    US_ITIN
    US_MBI
    US_SSN
    US_VIN
    WORD_FREQUENCY
}

enum AnomalyResultGroupByEnum {
    ClusterUuid
    Day
    Hour
    IsAnomaly
    ManagedId
    Month
    Week
    Year
}

enum AnomalyResultSortByEnum {
    AnomalyProbability
    BytesCreatedCount
    BytesDeletedCount
    BytesModifiedCount
    BytesNetChangedCount
    ClusterUuid
    FilesCreatedCount
    FilesDeletedCount
    FilesModifiedCount
    IsAnomaly
    ManagedId
    ObjectType
    PreviousSnapshotDate
    PreviousSnapshotId
    SnappableName
    SnappableType
    SnapshotDate
    SnapshotId
    SuspiciousFilesCount
}

enum AnomalyTableColumnEnum {
    BytesCreated
    BytesDeleted
    BytesModified
    BytesNetChanged
    FilesCreated
    FilesDeleted
    FilesModified
    IsAnomaly
    PreviousSnapshotDate
    PreviousSnapshotId
    SnappableName
    SnappableType
    SnapshotDate
    SnapshotId
    SuspiciousFilesAdded
}

enum AppBlueprintFailoverStatusEnum {
    CleanupInProgress
    InProgress
    Paused
    Ready
    TestCleanupInProgress
    TestInProgress
    TestPaused
    TestPending
    Tested
}

enum AppBlueprintLastFailoverStatusEnum {
    Failed
    NotExist
    Succeeded
}

enum AppBlueprintRmStatusEnum {
    Configured
    Invalid
    MissingVms
    NotConfigured
}

enum AppBlueprintStatusEnum {
    Creating
    Deleted
    Deleting
    Ready
    Updating
}

"Parameter to filter Azure apps on."
enum AppFilterField {
    "Filter on app ID."
    APP_ID
    "Filter on app type."
    APP_TYPE
    "Filter on subscription name."
    SUBSCRIPTION
    "Filter on tenant ID."
    TENANT_ID
}

"Parameter to sort Azure apps by."
enum AppSortByParamField {
    "Sort by added at time."
    ADDED_AT
    "Sort by app ID."
    APP_ID
    "Sort by app owner type."
    APP_OWNER
    "Sort by app type."
    APP_TYPE
    "Sort by authentication status."
    IS_AUTHENTICATED
    "Sort by subscription name."
    SUBSCRIPTION
}

"Sort order for Azure apps."
enum AppSortOrder {
    "Sort in ascending order."
    ASC
    "Sort in descending order."
    DESC
}

enum AppflowsBlueprintFailoverReportStatusEnum {
    ACTIVE
    CREATING
    EXPIRED
}

"Tiering status options for archival groups."
enum ArchivalGroupTieringStatus {
    "Instant tiering not supported."
    INSTANT_TIERING_NOT_SUPPORTED
    "Smart tiering not supported."
    SMART_TIERING_NOT_SUPPORTED
    "Unknown tiering status."
    UNKNOWN_ARCHIVAL_GROUP_TIERING_STATUS
}

enum ArchivalGroupTypeEnum {
    AUTOMATIC_ARCHIVAL_GROUP
    CLOUD_NATIVE_ARCHIVAL_GROUP
    DATACENTER_ARCHIVAL_GROUP
    MANUAL_ARCHIVAL_GROUP
    UNKNOWN_ARCHIVAL_GROUP
}

"Availability status of the archival location."
enum ArchivalLocationStatus {
    "Location is deleted."
    DELETED
    "Location is disabled."
    DISABLED
    "Location is paused."
    PAUSED
    "Location is read-only."
    READ_ONLY
    "Location is read-write."
    READ_WRITE
    "Location status is unknown."
    UNKNOWN_ARCHIVAL_LOCATION_STATUS
}

enum ArchivalLocationType {
    Azure
    Cleversafe
    Glacier
    Google
    HDS
    Nfs
    Qstar
    Rehydrated
    S3
    S3Compatible
    Scality
}

enum AssignSLAWarningsEnum {
    ARCHIVAL_CONFIGURATION_NOT_RESPECTED
    ARCHIVAL_LOCATION_NOT_SPECIFIED
    AWS_ARCHIVAL_NOT_SUPPORTED_FOR_GOVCLOUD_OBJECTS
    AWS_CROSS_ACCOUNT_REPLICATION_CONFIG_WARNING
    AWS_RDS_LOG_BACKUP_CONFIG_WARNING
    AWS_REPLICATION_REGION_VALIDATION
    AZURE_FULL_SNAPSHOTS
    AZURE_NATIONAL_PUBLIC_REPLICATION_NOT_SUPPORTED
    AZURE_SQL_DATABASE_PITR_WINDOW_WARNING
    BACKUP_WINDOWS_NOT_RESPECTED
    CROSS_REGION_ARCHIVAL
    DIFFERENTIAL_BACKUP_FREQUENCY_NOT_RESPECTED
    INCREMENTAL_BACKUP_FREQUENCY_NOT_RESPECTED
    INSTANT_ARCHIVAL_ACCOUNT_LEVEL_DISK_SIZE_WARNING
    INSTANT_ARCHIVAL_DISK_SIZE_WARNING
    MINUTE_LEVEL_CONFIGURATION_NOT_RESPECTED
    NO_WARNING
    REMOTE_CONFIGURATION_NOT_RESPECTED
    REPLICATION_CONFIGURATION_NOT_RESPECTED
    REPLICATION_TARGET_SAME_AS_SOURCE
    SLA_NOT_SYNCED
    SNAPSHOTS_MAY_EXPIRE
}

enum AuthTypeEnum {
    KERBEROS
    NONE
}

"Options for authenticating the webhook."
enum AuthenticationType {
    "Unused default value."
    AUTH_TYPE_UNSPECIFIED
    "Webhook is authenticated with a username/password pair."
    BASIC
    "Webhook is authenticated with a bearer token."
    BEARER
    "Webhook is authenticated with a custom header."
    CUSTOM_HEADER
    "Webhook is authenticated with a URL token."
    URL
}

"Status of an AWS Account."
enum AwsAccountStatus {
    "The AWS account has been added."
    ADDED
    "The AWS account has been deleted."
    DELETED
    "The AWS account is in the process of being deleted."
    DELETING
    "The deletion of the AWS account has failed."
    DELETION_FAILED
    "The AWS account is disconnected."
    DISCONNECTED
    "The AWS account has been refreshed."
    REFRESHED
    "The AWS account is refreshing."
    REFRESHING
    "The AWS account has failed to refresh."
    REFRESH_FAILED
}

"AWS authentication server based cloud account region names."
enum AwsAuthServerBasedCloudAccountRegion {
    "AWS cloud unknown region."
    UNKNOWN_AWS_AUTH_SERVER_BASED_REGION
    "AWS cloud US ISOB East 1 region."
    US_ISOB_EAST_1
    "AWS cloud US ISO East 1 region."
    US_ISO_EAST_1
    "AWS cloud US ISO West 1 region."
    US_ISO_WEST_1
}

"AWS cloud account regions enum."
enum AwsCloudAccountRegion {
    "AWS cloud Africa (Cape Town) region."
    AF_SOUTH_1
    "AWS cloud Asia Pacific (Hong Kong) region."
    AP_EAST_1
    "AWS cloud Asia Pacific (Tokyo) region."
    AP_NORTHEAST_1
    "AWS cloud Asia Pacific (Seoul) region."
    AP_NORTHEAST_2
    "AWS cloud Asia Pacific (Singapore) region."
    AP_SOUTHEAST_1
    "AWS cloud Asia Pacific (Sydney) region."
    AP_SOUTHEAST_2
    "AWS cloud Asia Pacific (Mumbai) region."
    AP_SOUTH_1
    "AWS cloud Canada (Central) region."
    CA_CENTRAL_1
    "AWS cloud China (Ningxia) region."
    CN_NORTHWEST_1
    "AWS cloud China (Beijing) region."
    CN_NORTH_1
    "AWS cloud EU (Frankfurt) region."
    EU_CENTRAL_1
    "AWS cloud EU (Stockholm) region."
    EU_NORTH_1
    "AWS cloud EU (Milan) region."
    EU_SOUTH_1
    "AWS cloud EU (Ireland) region."
    EU_WEST_1
    "AWS cloud EU (London) region."
    EU_WEST_2
    "AWS cloud EU (Paris) region."
    EU_WEST_3
    "AWS cloud Middle East (Bahrain) region."
    ME_SOUTH_1
    "AWS cloud South America (Sao Paulo) region."
    SA_EAST_1
    "AWS cloud region is unknown."
    UNKNOWN_AWS_REGION
    "AWS cloud US East (N. Virginia) region."
    US_EAST_1
    "AWS cloud US East (Ohio) region."
    US_EAST_2
    "AWS Gov cloud US East 1 (N. Virginia) region."
    US_GOV_EAST_1
    "AWS Gov cloud US West 1 (N. California) region."
    US_GOV_WEST_1
    "AWS cloud US West (N. California) region."
    US_WEST_1
    "AWS cloud US West (Oregon) region."
    US_WEST_2
}

enum AwsCloudComputeSettingFilterFieldEnum {
    CLOUD_ACCOUNT_ID
    CLUSTER_ALL
    CLUSTER_ID
    IS_ARCHIVED
    IS_SG_POLARIS_MANAGED
    NAME
}

enum AwsCloudComputeSettingSortByFieldEnum {
    NAME
}

"AWS Cloud Type Enum."
enum AwsCloudType {
    "Cloud type for AWS C2S cloud account."
    C2S
    "Cloud type for AWS China cloud account."
    CHINA
    "Cloud type for AWS Gov cloud account."
    GOV
    "Cloud type for AWS SC2S cloud account."
    SC2S
    "Cloud type for AWS Commercial cloud account."
    STANDARD
}

"AWS feature for which we require some specific permissions."
enum AwsFeatureForPermissionCheck {
    "AWS feature for exporting vm in powered off state."
    AWS_EXPORT_VM_IN_POWERED_OFF_STATE
    "AWS feature for exporting vm with iam instance profile."
    AWS_EXPORT_VM_WITH_IAM_INSTANCE_PROFILE
    "The feature is unspecified."
    AWS_UNSPECIFIED
}

enum AwsInstanceTenancyEnum {
    DEDICATED
    DEFAULT
    HOST
}

"The field type used to sort AWS accounts."
enum AwsNativeAccountSortFields {
    "Use EBS volume count for sorting."
    EBS_VOLUME_COUNT
    "Use EC2 instance count for sorting."
    EC2_INSTANCE_COUNT
    "Use AWS account SLA Domain for sorting."
    EFFECTIVE_SLA_DOMAIN
    "Use AWS account name for sorting."
    NAME
}

"The field type used to sort the EBS volumes."
enum AwsNativeEbsVolumeSortFields {
    "Use AWS account name for sorting."
    AWS_NATIVE_ACCOUNT_NAME
    "Use EBS volume ID for sorting."
    EBS_VOLUME_ID
    "Use EBS volume name for sorting."
    EBS_VOLUME_NAME
    "Use size of EBS volume for sorting."
    EBS_VOLUME_SIZE
    "Use type of EBS volume for sorting."
    EBS_VOLUME_TYPE
    "Use EBS volume SLA Domain for sorting."
    EFFECTIVE_SLA_DOMAIN
}

"AWS EBS volume types."
enum AwsNativeEbsVolumeType {
    "EBS volume type is gp2."
    GP2
    "EBS volume type is gp3."
    GP3
    "EBS volume type is io1."
    IO1
    "EBS volume type is io2."
    IO2
    "EBS volume type is not specified."
    NOT_SPECIFIED
    "EBS volume type is sc1."
    SC1
    "EBS volume type is st1."
    ST1
    "Storage type is standard."
    STANDARD
    "EBS volume type is unknown."
    UNKNOWN
}

"The field type used to sort the EC2 instances."
enum AwsNativeEc2InstanceSortFields {
    "Use SLA Domain assignment for sorting."
    ASSIGNED_SLA_DOMAIN
    "Use AWS account name for sorting."
    AWS_NATIVE_ACCOUNT_NAME
    "Use VPC ID for sorting."
    AWS_VPC_ID
    "Use EC2 instance ID for sorting."
    EC2_INSTANCE_ID
    "Use EC2 instance name for sorting."
    EC2_INSTANCE_NAME
    "Use type of EC2 instance for sorting."
    EC2_INSTANCE_TYPE
    "Use EC2 instance SLA Domain for sorting."
    EFFECTIVE_SLA_DOMAIN
}

"AWS EC2 instance types."
enum AwsNativeEc2InstanceType {
    "EC2 instance type is a1.2xlarge."
    A1_2XLARGE
    "EC2 instance type is a1.4xlarge."
    A1_4XLARGE
    "EC2 instance type is a1.large."
    A1_LARGE
    "EC2 instance type is a1.medium."
    A1_MEDIUM
    "EC2 instance type is a1.metal."
    A1_METAL
    "EC2 instance type is a1.xlarge."
    A1_XLARGE
    "EC2 instance type is c1.medium."
    C1_MEDIUM
    "EC2 instance type is c1.xlarge."
    C1_XLARGE
    "EC2 instance type is c3.2xlarge."
    C3_2XLARGE
    "EC2 instance type is c3.4xlarge."
    C3_4XLARGE
    "EC2 instance type is c3.8xlarge."
    C3_8XLARGE
    "EC2 instance type is c3.large."
    C3_LARGE
    "EC2 instance type is c3.xlarge."
    C3_XLARGE
    "EC2 instance type is c4.2xlarge."
    C4_2XLARGE
    "EC2 instance type is c4.4xlarge."
    C4_4XLARGE
    "EC2 instance type is c4.8xlarge."
    C4_8XLARGE
    "EC2 instance type is c4.large."
    C4_LARGE
    "EC2 instance type is c4.xlarge."
    C4_XLARGE
    "EC2 instance type is c5d.12xlarge."
    C5D_12XLARGE
    "EC2 instance type is c5d.18xlarge."
    C5D_18XLARGE
    "EC2 instance type is c5d.24xlarge."
    C5D_24XLARGE
    "EC2 instance type is c5d.2xlarge."
    C5D_2XLARGE
    "EC2 instance type is c5d.4xlarge."
    C5D_4XLARGE
    "EC2 instance type is c5d.9xlarge."
    C5D_9XLARGE
    "EC2 instance type is c5d.large."
    C5D_LARGE
    "EC2 instance type is c5d.metal."
    C5D_METAL
    "EC2 instance type is c5d.xlarge."
    C5D_XLARGE
    "EC2 instance type is c5n.18xlarge."
    C5N_18XLARGE
    "EC2 instance type is c5n.2xlarge."
    C5N_2XLARGE
    "EC2 instance type is c5n.4xlarge."
    C5N_4XLARGE
    "EC2 instance type is c5n.9xlarge."
    C5N_9XLARGE
    "EC2 instance type is c5n.large."
    C5N_LARGE
    "EC2 instance type is c5n.xlarge."
    C5N_XLARGE
    "EC2 instance type is c5.12xlarge."
    C5_12XLARGE
    "EC2 instance type is c5.18xlarge."
    C5_18XLARGE
    "EC2 instance type is c5.24xlarge."
    C5_24XLARGE
    "EC2 instance type is c5.2xlarge."
    C5_2XLARGE
    "EC2 instance type is c5.4xlarge."
    C5_4XLARGE
    "EC2 instance type is c5.9xlarge."
    C5_9XLARGE
    "EC2 instance type is c5.large."
    C5_LARGE
    "EC2 instance type is c5.metal."
    C5_METAL
    "EC2 instance type is c5.xlarge."
    C5_XLARGE
    "EC2 instance type is cc1.4xlarge."
    CC1_4XLARGE
    "EC2 instance type is cc2.8xlarge."
    CC2_8XLARGE
    "EC2 instance type is cg1.4xlarge."
    CG1_4XLARGE
    "EC2 instance type is cr1.8xlarge."
    CR1_8XLARGE
    "EC2 instance type is d2.2xlarge."
    D2_2XLARGE
    "EC2 instance type is d2.4xlarge."
    D2_4XLARGE
    "EC2 instance type is d2.8xlarge."
    D2_8XLARGE
    "EC2 instance type is d2.xlarge."
    D2_XLARGE
    "EC2 instance type is f1.16xlarge."
    F1_16XLARGE
    "EC2 instance type is f1.2xlarge."
    F1_2XLARGE
    "EC2 instance type is f1.4xlarge."
    F1_4XLARGE
    "EC2 instance type is g2.2xlarge."
    G2_2XLARGE
    "EC2 instance type is g2.8xlarge."
    G2_8XLARGE
    "EC2 instance type is g3s.xlarge."
    G3S_XLARGE
    "EC2 instance type is g3.16xlarge."
    G3_16XLARGE
    "EC2 instance type is g3.4xlarge."
    G3_4XLARGE
    "EC2 instance type is g3.8xlarge."
    G3_8XLARGE
    "EC2 instance type is g4dn.2xlarge."
    G4DN_12XLARGE
    "EC2 instance type is g4dn.2xlarge."
    G4DN_16XLARGE
    "EC2 instance type is g4dn.2xlarge."
    G4DN_2XLARGE
    "EC2 instance type is g4dn.2xlarge."
    G4DN_4XLARGE
    "EC2 instance type is g4dn.2xlarge."
    G4DN_8XLARGE
    "EC2 instance type is g4dn.2xlarge."
    G4DN_XLARGE
    "EC2 instance type is h1.16xlarge."
    H1_16XLARGE
    "EC2 instance type is h1.2xlarge."
    H1_2XLARGE
    "EC2 instance type is h1.4xlarge."
    H1_4XLARGE
    "EC2 instance type is h1.8xlarge."
    H1_8XLARGE
    "EC2 instance type is hI1.4xlarge."
    HI1_4XLARGE
    "EC2 instance type is hs1.8xlarge."
    HS1_8XLARGE
    "EC2 instance type is i2.2xlarge."
    I2_2XLARGE
    "EC2 instance type is i2.4xlarge."
    I2_4XLARGE
    "EC2 instance type is i2.8xlarge."
    I2_8XLARGE
    "EC2 instance type is i2.xlarge."
    I2_XLARGE
    "EC2 instance type is i3en.12xlarge."
    I3EN_12XLARGE
    "EC2 instance type is i3en.24xlarge."
    I3EN_24XLARGE
    "EC2 instance type is i3en.2xlarge."
    I3EN_2XLARGE
    "EC2 instance type is i3en.3xlarge."
    I3EN_3XLARGE
    "EC2 instance type is i3en.6xlarge."
    I3EN_6XLARGE
    "EC2 instance type is i3en.large."
    I3EN_LARGE
    "EC2 instance type is i3en.metal."
    I3EN_METAL
    "EC2 instance type is i3en.xlarge."
    I3EN_XLARGE
    "EC2 instance type is i3.16xlarge."
    I3_16XLARGE
    "EC2 instance type is i3.2xlarge."
    I3_2XLARGE
    "EC2 instance type is i3.4xlarge."
    I3_4XLARGE
    "EC2 instance type is i3.8xlarge."
    I3_8XLARGE
    "EC2 instance type is i3.large."
    I3_LARGE
    "EC2 instance type is i3.metal."
    I3_METAL
    "EC2 instance type is i3.xlarge."
    I3_XLARGE
    "EC2 instance type is inf1.24xlarge."
    INF1_24XLARGE
    "EC2 instance type is inf1.2xlarge."
    INF1_2XLARGE
    "EC2 instance type is inf1.6xlarge."
    INF1_6XLARGE
    "EC2 instance type is inf1.xlarge."
    INF1_XLARGE
    "EC2 instance type is m1.large."
    M1_LARGE
    "EC2 instance type is m1.medium."
    M1_MEDIUM
    "EC2 instance type is m1.small."
    M1_SMALL
    "EC2 instance type is m1.xlarge."
    M1_XLARGE
    "EC2 instance type is m2.2xlarge."
    M2_2XLARGE
    "EC2 instance type is m2.4xlarge."
    M2_4XLARGE
    "EC2 instance type is m2.xlarge."
    M2_XLARGE
    "EC2 instance type is m3.2xlarge."
    M3_2XLARGE
    "EC2 instance type is m3.large."
    M3_LARGE
    "EC2 instance type is m3.medium."
    M3_MEDIUM
    "EC2 instance type is m3.xlarge."
    M3_XLARGE
    "EC2 instance type is m4.10xlarge."
    M4_10XLARGE
    "EC2 instance type is m4.16xlarge."
    M4_16XLARGE
    "EC2 instance type is m4.2xlarge."
    M4_2XLARGE
    "EC2 instance type is m4.4xlarge."
    M4_4XLARGE
    "EC2 instance type is m4.large."
    M4_LARGE
    "EC2 instance type is m4.xlarge."
    M4_XLARGE
    "EC2 instance type is m5ad.12xlarge."
    M5AD_12XLARGE
    "EC2 instance type is m5ad.16xlarge."
    M5AD_16XLARGE
    "EC2 instance type is m5ad.24xlarge."
    M5AD_24XLARGE
    "EC2 instance type is m5ad.2xlarge."
    M5AD_2XLARGE
    "EC2 instance type is m5ad.4xlarge."
    M5AD_4XLARGE
    "EC2 instance type is m5ad.8xlarge."
    M5AD_8XLARGE
    "EC2 instance type is m5ad.large."
    M5AD_LARGE
    "EC2 instance type is m5ad.xlarge."
    M5AD_XLARGE
    "EC2 instance type is m5a.12xlarge."
    M5A_12XLARGE
    "EC2 instance type is m5a.16xlarge."
    M5A_16XLARGE
    "EC2 instance type is m5a.24xlarge."
    M5A_24XLARGE
    "EC2 instance type is m5a.2xlarge."
    M5A_2XLARGE
    "EC2 instance type is m5a.4xlarge."
    M5A_4XLARGE
    "EC2 instance type is m5a.8xlarge."
    M5A_8XLARGE
    "EC2 instance type is m5a.large."
    M5A_LARGE
    "EC2 instance type is m5a.xlarge."
    M5A_XLARGE
    "EC2 instance type is m5dn.12xlarge."
    M5DN_12XLARGE
    "EC2 instance type is m5dn.16xlarge."
    M5DN_16XLARGE
    "EC2 instance type is m5dn.24xlarge."
    M5DN_24XLARGE
    "EC2 instance type is m5dn.2xlarge."
    M5DN_2XLARGE
    "EC2 instance type is m5dn.4xlarge."
    M5DN_4XLARGE
    "EC2 instance type is m5dn.8xlarge."
    M5DN_8XLARGE
    "EC2 instance type is m5dn.large."
    M5DN_LARGE
    "EC2 instance type is m5dn.xlarge."
    M5DN_XLARGE
    "EC2 instance type is m5d.12xlarge."
    M5D_12XLARGE
    "EC2 instance type is m5d.16xlarge."
    M5D_16XLARGE
    "EC2 instance type is m5d.24xlarge."
    M5D_24XLARGE
    "EC2 instance type is m5d.2xlarge."
    M5D_2XLARGE
    "EC2 instance type is m5d.4xlarge."
    M5D_4XLARGE
    "EC2 instance type is m5d.8xlarge."
    M5D_8XLARGE
    "EC2 instance type is m5d.large."
    M5D_LARGE
    "EC2 instance type is m5d.metal."
    M5D_METAL
    "EC2 instance type is m5d.xlarge."
    M5D_XLARGE
    "EC2 instance type is m5n.12xlarge."
    M5N_12XLARGE
    "EC2 instance type is m5n.16xlarge."
    M5N_16XLARGE
    "EC2 instance type is m5n.24xlarge."
    M5N_24XLARGE
    "EC2 instance type is m5n.2xlarge."
    M5N_2XLARGE
    "EC2 instance type is m5n.4xlarge."
    M5N_4XLARGE
    "EC2 instance type is m5n.8xlarge."
    M5N_8XLARGE
    "EC2 instance type is m5n.large."
    M5N_LARGE
    "EC2 instance type is m5n.xlarge."
    M5N_XLARGE
    "EC2 instance type is m5.12xlarge."
    M5_12XLARGE
    "EC2 instance type is m5.16xlarge."
    M5_16XLARGE
    "EC2 instance type is m5.24xlarge."
    M5_24XLARGE
    "EC2 instance type is m5.2xlarge."
    M5_2XLARGE
    "EC2 instance type is m5.4xlarge."
    M5_4XLARGE
    "EC2 instance type is m5.8xlarge."
    M5_8XLARGE
    "EC2 instance type is m5.large."
    M5_LARGE
    "EC2 instance type is m5.metal."
    M5_METAL
    "EC2 instance type is m5.xlarge."
    M5_XLARGE
    "EC2 instance type is not specified."
    NOT_SPECIFIED
    "EC2 instance type is p2.16xlarge."
    P2_16XLARGE
    "EC2 instance type is p2.8xlarge."
    P2_8XLARGE
    "EC2 instance type is p2.xlarge."
    P2_XLARGE
    "EC2 instance type is p3dn.24xlarge."
    P3DN_24XLARGE
    "EC2 instance type is p3.16xlarge."
    P3_16XLARGE
    "EC2 instance type is p3.2xlarge."
    P3_2XLARGE
    "EC2 instance type is p3.8xlarge."
    P3_8XLARGE
    "EC2 instance type is r3.2xlarge."
    R3_2XLARGE
    "EC2 instance type is r3.4xlarge."
    R3_4XLARGE
    "EC2 instance type is r3.8xlarge."
    R3_8XLARGE
    "EC2 instance type is r3.large."
    R3_LARGE
    "EC2 instance type is r3.xlarge."
    R3_XLARGE
    "EC2 instance type is r4.16xlarge."
    R4_16XLARGE
    "EC2 instance type is r4.2xlarge."
    R4_2XLARGE
    "EC2 instance type is r4.4xlarge."
    R4_4XLARGE
    "EC2 instance type is r4.8xlarge."
    R4_8XLARGE
    "EC2 instance type is r4.large."
    R4_LARGE
    "EC2 instance type is r4.xlarge."
    R4_XLARGE
    "EC2 instance type is r5ad.12xlarge."
    R5AD_12XLARGE
    "EC2 instance type is r5ad.16xlarge."
    R5AD_16XLARGE
    "EC2 instance type is r5ad.24xlarge."
    R5AD_24XLARGE
    "EC2 instance type is r5ad.2xlarge."
    R5AD_2XLARGE
    "EC2 instance type is r5ad.4xlarge."
    R5AD_4XLARGE
    "EC2 instance type is r5ad.8xlarge."
    R5AD_8XLARGE
    "EC2 instance type is r5ad.large."
    R5AD_LARGE
    "EC2 instance type is r5ad.xlarge."
    R5AD_XLARGE
    "EC2 instance type is r5a.12xlarge."
    R5A_12XLARGE
    "EC2 instance type is r5a.16xlarge."
    R5A_16XLARGE
    "EC2 instance type is r5a.24xlarge."
    R5A_24XLARGE
    "EC2 instance type is r5a.2xlarge."
    R5A_2XLARGE
    "EC2 instance type is r5a.4xlarge."
    R5A_4XLARGE
    "EC2 instance type is r5a.8xlarge."
    R5A_8XLARGE
    "EC2 instance type is r5a.large."
    R5A_LARGE
    "EC2 instance type is r5a.xlarge."
    R5A_XLARGE
    "EC2 instance type is r5dn.12xlarge."
    R5DN_12XLARGE
    "EC2 instance type is r5dn.16xlarge."
    R5DN_16XLARGE
    "EC2 instance type is r5dn.24xlarge."
    R5DN_24XLARGE
    "EC2 instance type is r5dn.2xlarge."
    R5DN_2XLARGE
    "EC2 instance type is r5dn.4xlarge."
    R5DN_4XLARGE
    "EC2 instance type is r5dn.8xlarge."
    R5DN_8XLARGE
    "EC2 instance type is r5dn.large."
    R5DN_LARGE
    "EC2 instance type is r5dn.xlarge."
    R5DN_XLARGE
    "EC2 instance type is r5d.12xlarge."
    R5D_12XLARGE
    "EC2 instance type is r5d.16xlarge."
    R5D_16XLARGE
    "EC2 instance type is r5d.24xlarge."
    R5D_24XLARGE
    "EC2 instance type is r5d.2xlarge."
    R5D_2XLARGE
    "EC2 instance type is r5d.4xlarge."
    R5D_4XLARGE
    "EC2 instance type is r5d.8xlarge."
    R5D_8XLARGE
    "EC2 instance type is r5d.large."
    R5D_LARGE
    "EC2 instance type is r5d.metal."
    R5D_METAL
    "EC2 instance type is r5d.xlarge."
    R5D_XLARGE
    "EC2 instance type is r5n.12xlarge."
    R5N_12XLARGE
    "EC2 instance type is r5n.16xlarge."
    R5N_16XLARGE
    "EC2 instance type is r5n.24xlarge."
    R5N_24XLARGE
    "EC2 instance type is r5n.2xlarge."
    R5N_2XLARGE
    "EC2 instance type is r5n.4xlarge."
    R5N_4XLARGE
    "EC2 instance type is r5n.8xlarge."
    R5N_8XLARGE
    "EC2 instance type is r5n.large."
    R5N_LARGE
    "EC2 instance type is r5n.xlarge."
    R5N_XLARGE
    "EC2 instance type is r5.12xlarge."
    R5_12XLARGE
    "EC2 instance type is r5.16xlarge."
    R5_16XLARGE
    "EC2 instance type is r5.24xlarge."
    R5_24XLARGE
    "EC2 instance type is r5.2xlarge."
    R5_2XLARGE
    "EC2 instance type is r5.4xlarge."
    R5_4XLARGE
    "EC2 instance type is r5.8xlarge."
    R5_8XLARGE
    "EC2 instance type is r5.large."
    R5_LARGE
    "EC2 instance type is r5.metal."
    R5_METAL
    "EC2 instance type is r5.xlarge."
    R5_XLARGE
    "EC2 instance type is t1.micro."
    T1_MICRO
    "EC2 instance type is t2.2xlarge."
    T2_2XLARGE
    "EC2 instance type is t2.large."
    T2_LARGE
    "EC2 instance type is t2.medium."
    T2_MEDIUM
    "EC2 instance type is t2.micro."
    T2_MICRO
    "EC2 instance type is t2.nano."
    T2_NANO
    "EC2 instance type is t2.small."
    T2_SMALL
    "EC2 instance type is t2.xlarge."
    T2_XLARGE
    "EC2 instance type is t3a.2xlarge."
    T3A_2XLARGE
    "EC2 instance type is t3a.large."
    T3A_LARGE
    "EC2 instance type is t3a.medium."
    T3A_MEDIUM
    "EC2 instance type is t3a.micro."
    T3A_MICRO
    "EC2 instance type is t3a.nano."
    T3A_NANO
    "EC2 instance type is t3a.small."
    T3A_SMALL
    "EC2 instance type is t3a.xlarge."
    T3A_XLARGE
    "EC2 instance type is t3.2xlarge."
    T3_2XLARGE
    "EC2 instance type is t3.large."
    T3_LARGE
    "EC2 instance type is t3.medium."
    T3_MEDIUM
    "EC2 instance type is t3.micro."
    T3_MICRO
    "EC2 instance type is t3.nano."
    T3_NANO
    "EC2 instance type is t3.small."
    T3_SMALL
    "EC2 instance type is t3.xlarge."
    T3_XLARGE
    "EC2 instance type is unknown."
    UNKNOWN
    "EC2 instance type is u-12tb1.metal."
    U_12TB1_METAL
    "EC2 instance type is u-18tb1.metal."
    U_18TB1_METAL
    "EC2 instance type is u-24tb1.metal."
    U_24TB1_METAL
    "EC2 instance type is u-6tb1.metal."
    U_6TB1_METAL
    "EC2 instance type is u-9tb1.metal."
    U_9TB1_METAL
    "EC2 instance type is x1e.16xlarge."
    X1E_16XLARGE
    "EC2 instance type is x1e.2xlarge."
    X1E_2XLARGE
    "EC2 instance type is x1e.32xlarge."
    X1E_32XLARGE
    "EC2 instance type is x1e.4xlarge."
    X1E_4XLARGE
    "EC2 instance type is x1e.8xlarge."
    X1E_8XLARGE
    "EC2 instance type is x1e.xlarge."
    X1E_XLARGE
    "EC2 instance type is x1.16xlarge."
    X1_16XLARGE
    "EC2 instance type is x1.32xlarge."
    X1_32XLARGE
    "EC2 instance type is z1d.12xlarge."
    Z1D_12XLARGE
    "EC2 instance type is z1d.2xlarge."
    Z1D_2XLARGE
    "EC2 instance type is z1d.3xlarge."
    Z1D_3XLARGE
    "EC2 instance type is z1d.6xlarge."
    Z1D_6XLARGE
    "EC2 instance type is z1d.large."
    Z1D_LARGE
    "EC2 instance type is z1d.metal."
    Z1D_METAL
    "EC2 instance type is z1d.xlarge."
    Z1D_XLARGE
}

"State of AWS native file recovery."
enum AwsNativeFileRecoveryStatus {
    "AWS native file recovery is disabled."
    DISABLED
    "AWS native file recovery is enabled."
    ENABLED
    "State of AWS native file recovery is not specified."
    NOT_SPECIFIED
}

"AWS native protection features."
enum AwsNativeProtectionFeature {
    "AWS native protection feature is EC2."
    EC2
    "AWS native protection feature is RDS."
    RDS
}

"DB engine of an RDS instance."
enum AwsNativeRdsDbEngine {
    "DB engine is MariaDB."
    MARIADB
    "DB engine is MySQL."
    MYSQL
    "DB engine is Oracle EE."
    ORACLE_EE
    "DB engine is Oracle SE."
    ORACLE_SE
    "DB engine is Oracle SE1."
    ORACLE_SE1
    "DB engine is Oracle SE2."
    ORACLE_SE2
    "DB engine is PostgreSQL."
    POSTGRES
    "DB engine is SQL Server EE."
    SQLSERVER_EE
    "DB engine is SQL Server EX."
    SQLSERVER_EX
    "DB engine is SQL Server SE."
    SQLSERVER_SE
    "DB engine is SQL Server Web."
    SQLSERVER_WEB
    "DB engine is unknown."
    UNKNOWN
}

"DB class of an RDS instance."
enum AwsNativeRdsDbInstanceClass {
    "DB class is db.m1.large."
    DB_M1_LARGE
    "DB class is db.m1.medium."
    DB_M1_MEDIUM
    "DB class is db.m1.small."
    DB_M1_SMALL
    "DB class is db.m1.xlarge."
    DB_M1_XLARGE
    "DB class is db.m2.2xlarge."
    DB_M2_2XLARGE
    "DB class is db.m2.4xlarge."
    DB_M2_4XLARGE
    "DB class is db.m2.xlarge."
    DB_M2_XLARGE
    "DB class is db.m3.2xlarge."
    DB_M3_2XLARGE
    "DB class is db.m3.large."
    DB_M3_LARGE
    "DB class is db.m3.medium."
    DB_M3_MEDIUM
    "DB class is db.m3.xlarge."
    DB_M3_XLARGE
    "DB class is db.m4.10xlarge."
    DB_M4_10XLARGE
    "DB class is db.m4.16xlarge."
    DB_M4_16XLARGE
    "DB class is db.m4.2xlarge."
    DB_M4_2XLARGE
    "DB class is db.m4.4xlarge."
    DB_M4_4XLARGE
    "DB class is db.m4.large."
    DB_M4_LARGE
    "DB class is db.m4.xlarge."
    DB_M4_XLARGE
    "DB class is db.m5d.12xlarge."
    DB_M5D_12XLARGE
    "DB class is db.m5d.16xlarge."
    DB_M5D_16XLARGE
    "DB class is db.m5d.24xlarge."
    DB_M5D_24XLARGE
    "DB class is db.m5d.2xlarge."
    DB_M5D_2XLARGE
    "DB class is db.m5d.4xlarge."
    DB_M5D_4XLARGE
    "DB class is db.m5d.8xlarge."
    DB_M5D_8XLARGE
    "DB class is db.m5d.large."
    DB_M5D_LARGE
    "DB class is db.m5d.xlarge."
    DB_M5D_XLARGE
    "DB class is db.m5.12xlarge."
    DB_M5_12XLARGE
    "DB class is db.m5.16xlarge."
    DB_M5_16XLARGE
    "DB class is db.m5.24xlarge."
    DB_M5_24XLARGE
    "DB class is db.m5.2xlarge."
    DB_M5_2XLARGE
    "DB class is db.m5.4xlarge."
    DB_M5_4XLARGE
    "DB class is db.m5.8xlarge."
    DB_M5_8XLARGE
    "DB class is db.m5.large."
    DB_M5_LARGE
    "DB class is db.m5.xlarge."
    DB_M5_XLARGE
    "DB class is db.m6gd.12xlarge."
    DB_M6GD_12XLARGE
    "DB class is db.m6gd.16xlarge."
    DB_M6GD_16XLARGE
    "DB class is db.m6gd.2xlarge."
    DB_M6GD_2XLARGE
    "DB class is db.m6gd.4xlarge."
    DB_M6GD_4XLARGE
    "DB class is db.m6gd.8xlarge."
    DB_M6GD_8XLARGE
    "DB class is db.m6gd.large."
    DB_M6GD_LARGE
    "DB class is db.m6gd.xlarge."
    DB_M6GD_XLARGE
    "DB class is db.m6g.12xlarge."
    DB_M6G_12XLARGE
    "DB class is db.m6g.16xlarge."
    DB_M6G_16XLARGE
    "DB class is db.m6g.2xlarge."
    DB_M6G_2XLARGE
    "DB class is db.m6g.4xlarge."
    DB_M6G_4XLARGE
    "DB class is db.m6g.8xlarge."
    DB_M6G_8XLARGE
    "DB class is db.m6g.large."
    DB_M6G_LARGE
    "DB class is db.m6g.xlarge."
    DB_M6G_XLARGE
    "DB class is db.r3.2xlarge."
    DB_R3_2XLARGE
    "DB class is db.r3.4xlarge."
    DB_R3_4XLARGE
    "DB class is db.r3.8xlarge."
    DB_R3_8XLARGE
    "DB class is db.r3.large."
    DB_R3_LARGE
    "DB class is db.r3.xlarge."
    DB_R3_XLARGE
    "DB class is db.r4.12xlarge."
    DB_R4_12XLARGE
    "DB class is db.r4.16xlarge."
    DB_R4_16XLARGE
    "DB class is db.r4.2xlarge."
    DB_R4_2XLARGE
    "DB class is db.r4.4xlarge."
    DB_R4_4XLARGE
    "DB class is db.r4.8xlarge."
    DB_R4_8XLARGE
    "DB class is db.r4.large."
    DB_R4_LARGE
    "DB class is db.r4.xlarge."
    DB_R4_XLARGE
    "DB class is db.r5b.12xlarge."
    DB_R5B_12XLARGE
    "DB class is db.r5b.16xlarge."
    DB_R5B_16XLARGE
    "DB class is db.r5b.24xlarge."
    DB_R5B_24XLARGE
    "DB class is db.r5b.2xlarge."
    DB_R5B_2XLARGE
    "DB class is db.r5b.4xlarge."
    DB_R5B_4XLARGE
    "DB class is db.r5b.8xlarge."
    DB_R5B_8XLARGE
    "DB class is db.r5b.large."
    DB_R5B_LARGE
    "DB class is db.r5b.xlarge."
    DB_R5B_XLARGE
    "DB class is db.r5d.12xlarge."
    DB_R5D_12XLARGE
    "DB class is db.r5d.16xlarge."
    DB_R5D_16XLARGE
    "DB class is db.r5d.24xlarge."
    DB_R5D_24XLARGE
    "DB class is db.r5d.2xlarge."
    DB_R5D_2XLARGE
    "DB class is db.r5d.4xlarge."
    DB_R5D_4XLARGE
    "DB class is db.r5d.8xlarge."
    DB_R5D_8XLARGE
    "DB class is db.r5d.large."
    DB_R5D_LARGE
    "DB class is db.r5d.xlarge."
    DB_R5D_XLARGE
    "DB class is db.r5.12xlarge."
    DB_R5_12XLARGE
    "DB class is db.r5.16xlarge."
    DB_R5_16XLARGE
    "DB class is db.r5.24xlarge."
    DB_R5_24XLARGE
    "DB class is db.r5.2xlarge."
    DB_R5_2XLARGE
    "DB class is db.r5.4xlarge."
    DB_R5_4XLARGE
    "DB class is db.r5.8xlarge."
    DB_R5_8XLARGE
    "DB class is db.r5.large."
    DB_R5_LARGE
    "DB class is db.r5.xlarge."
    DB_R5_XLARGE
    "DB class is db.r6g.12xlarge."
    DB_R6G_12XLARGE
    "DB class is db.r6g.16xlarge."
    DB_R6G_16XLARGE
    "DB class is db.r6g.2xlarge."
    DB_R6G_2XLARGE
    "DB class is db.r6g.4xlarge."
    DB_R6G_4XLARGE
    "DB class is db.r6g.8xlarge."
    DB_R6G_8XLARGE
    "DB class is db.r6g.large."
    DB_R6G_LARGE
    "DB class is db.r6g.xlarge."
    DB_R6G_XLARGE
    "DB class is db.t2.2xlarge."
    DB_T2_2XLARGE
    "DB class is db.t2.large."
    DB_T2_LARGE
    "DB class is db.t2.medium."
    DB_T2_MEDIUM
    "DB class is db.t2.micro."
    DB_T2_MICRO
    "DB class is db.t2.small."
    DB_T2_SMALL
    "DB class is db.t2.xlarge."
    DB_T2_XLARGE
    "DB class is db.t3.2xlarge."
    DB_T3_2XLARGE
    "DB class is db.t3.large."
    DB_T3_LARGE
    "DB class is db.t3.medium."
    DB_T3_MEDIUM
    "DB class is db.t3.micro."
    DB_T3_MICRO
    "DB class is db.t3.small."
    DB_T3_SMALL
    "DB class is db.t3.xlarge."
    DB_T3_XLARGE
    "DB class is db.t4g.2xlarge."
    DB_T4G_2XLARGE
    "DB class is db.t4g.large."
    DB_T4G_LARGE
    "DB class is db.t4g.medium."
    DB_T4G_MEDIUM
    "DB class is db.t4g.micro."
    DB_T4G_MICRO
    "DB class is db.t4g.small."
    DB_T4G_SMALL
    "DB class is db.t4g.xlarge."
    DB_T4G_XLARGE
    "DB class is db.x1e.16xlarge."
    DB_X1E_16XLARGE
    "DB class is db.x1e.2xlarge."
    DB_X1E_2XLARGE
    "DB class is db.x1e.32xlarge."
    DB_X1E_32XLARGE
    "DB class is db.x1e.4xlarge."
    DB_X1E_4XLARGE
    "DB class is db.x1e.8xlarge."
    DB_X1E_8XLARGE
    "DB class is db.x1e.xlarge."
    DB_X1E_XLARGE
    "DB class is db.x1.16xlarge."
    DB_X1_16XLARGE
    "DB class is db.x1.32xlarge."
    DB_X1_32XLARGE
    "DB class is db.x2g.12xlarge."
    DB_X2G_12XLARGE
    "DB class is db.x2g.16xlarge."
    DB_X2G_16XLARGE
    "DB class is db.x2g.2xlarge."
    DB_X2G_2XLARGE
    "DB class is db.x2g.4xlarge."
    DB_X2G_4XLARGE
    "DB class is db.x2g.8xlarge."
    DB_X2G_8XLARGE
    "DB class is db.x2g.large."
    DB_X2G_LARGE
    "DB class is db.x2g.medium."
    DB_X2G_MEDIUM
    "DB class is db.x2g.xlarge."
    DB_X2G_XLARGE
    "DB class is db.z1d.12xlarge."
    DB_Z1D_12XLARGE
    "DB class is db.z1d.2xlarge."
    DB_Z1D_2XLARGE
    "DB class is db.z1d.4xlarge."
    DB_Z1D_4XLARGE
    "DB class is db.z1d.6xlarge."
    DB_Z1D_6XLARGE
    "DB class is db.z1d.large."
    DB_Z1D_LARGE
    "DB class is db.z1d.xlarge."
    DB_Z1D_XLARGE
    "DB class is unknown."
    UNKNOWN
}

"The field type used to sort the RDS instances."
enum AwsNativeRdsInstanceSortFields {
    "Use SLA Domain assignment for sorting."
    ASSIGNED_SLA_DOMAIN
    "Use AWS account name for sorting."
    AWS_NATIVE_ACCOUNT_NAME
    "Use DB engine of RDS instance for sorting."
    AWS_NATIVE_RDS_DB_ENGINE
    "Use DB class of RDS instance for sorting."
    AWS_NATIVE_RDS_DB_INSTANCE_CLASS
    "Use VPC ID for sorting."
    AWS_VPC_ID
    "Use RDS instance SLA Domain for sorting."
    EFFECTIVE_SLA_DOMAIN
    "Use RDS instance name for sorting."
    NAME
}

"The storage type of an RDS instance."
enum AwsNativeRdsStorageType {
    "Storage type is gp2."
    GP2
    "Storage type is io1."
    IO1
    "Storage type is not specified."
    NOT_SPECIFIED
    "Storage type is standard."
    STANDARD
    "Storage type is unknown."
    UNKNOWN
}

"AWS native regions."
enum AwsNativeRegion {
    "AWS native Africa (Cape Town) region."
    AF_SOUTH_1
    "AWS native Asia Pacific (Hong Kong) region."
    AP_EAST_1
    "AWS native Asia Pacific (Tokyo) region."
    AP_NORTHEAST_1
    "AWS native Asia Pacific (Seoul) region."
    AP_NORTHEAST_2
    "AWS native Asia Pacific (Singapore) region."
    AP_SOUTHEAST_1
    "AWS native Asia Pacific (Sydney) region."
    AP_SOUTHEAST_2
    "AWS native Asia Pacific (Mumbai) region."
    AP_SOUTH_1
    "AWS native Canada (Central) region."
    CA_CENTRAL_1
    "AWS native China (Ningxia) region."
    CN_NORTHWEST_1
    "AWS native China (Beijing) region."
    CN_NORTH_1
    "AWS native EU (Frankfurt) region."
    EU_CENTRAL_1
    "AWS native EU (Stockholm) region."
    EU_NORTH_1
    "AWS native EU (Milan) region."
    EU_SOUTH_1
    "AWS native EU (Ireland) region."
    EU_WEST_1
    "AWS native EU (London) region."
    EU_WEST_2
    "AWS native EU (Paris) region."
    EU_WEST_3
    "AWS native Middle East (Bahrain) region."
    ME_SOUTH_1
    "AWS native region is not specified."
    NOT_SPECIFIED
    "AWS native South America (Sao Paulo) region."
    SA_EAST_1
    "AWS native US East (N. Virginia) region."
    US_EAST_1
    "AWS native US East (Ohio) region."
    US_EAST_2
    "AWS Gov native US East 1 (N. Virginia) region."
    US_GOV_EAST_1
    "AWS Gov native US West 1 (N. California) region."
    US_GOV_WEST_1
    "AWS LCK native US East region."
    US_ISOB_EAST_1
    "AWS DCA native US East region."
    US_ISO_EAST_1
    "AWS DCA native US West region."
    US_ISO_WEST_1
    "AWS native US West (N. California) region."
    US_WEST_1
    "AWS native US West (Oregon) region."
    US_WEST_2
}

"AWS native regions for replication."
enum AwsNativeRegionForReplication {
    "AWS native for replication Africa (Cape Town) region."
    AF_SOUTH_1
    "AWS native for replication Asia Pacific (Hong Kong) region."
    AP_EAST_1
    "AWS native for replication Asia Pacific (Tokyo) region."
    AP_NORTHEAST_1
    "AWS native for replication Asia Pacific (Seoul) region."
    AP_NORTHEAST_2
    "AWS native for replication Asia Pacific (Singapore) region."
    AP_SOUTHEAST_1
    "AWS native for replication Asia Pacific (Sydney) region."
    AP_SOUTHEAST_2
    "AWS native for replication Asia Pacific (Mumbai) region."
    AP_SOUTH_1
    "AWS native for replication Canada (Central) region."
    CA_CENTRAL_1
    "AWS native for replication China (Ningxia) region."
    CN_NORTHWEST_1
    "AWS native for replication China (Beijing) region."
    CN_NORTH_1
    "AWS native for replication EU (Frankfurt) region."
    EU_CENTRAL_1
    "AWS native for replication EU (Stockholm) region."
    EU_NORTH_1
    "AWS native for replication EU (Milan) region."
    EU_SOUTH_1
    "AWS native for replication EU (Ireland) region."
    EU_WEST_1
    "AWS native for replication EU (London) region."
    EU_WEST_2
    "AWS native for replication EU (Paris) region."
    EU_WEST_3
    "AWS native for replication Middle East (Bahrain) region."
    ME_SOUTH_1
    "AWS native for replication region is not defined."
    NOT_DEFINED
    "AWS native for replication South America (Sao Paulo) region."
    SA_EAST_1
    "AWS native for replication region is the source region."
    SOURCE_REGION
    "AWS native for replication US East (N. Virginia) region."
    US_EAST_1
    "AWS native for replication US East (Ohio) region."
    US_EAST_2
    "AWS Gov native for replication US East 1 (N. Virginia) region."
    US_GOV_EAST_1
    "AWS Gov native for replication US West 1 (N. California) region."
    US_GOV_WEST_1
    "AWS LCK native for replication US East region."
    US_ISOB_EAST_1
    "AWS DCA native for replication US East region."
    US_ISO_EAST_1
    "AWS DCA native for replication US West region."
    US_ISO_WEST_1
    "AWS native for replication US West (N. California) region."
    US_WEST_1
    "AWS native for replication US West (Oregon) region."
    US_WEST_2
}

"Regions for AWS."
enum AwsRegion {
    "AWS Africa (Cape Town) region."
    AF_SOUTH_1
    "AWS Asia Pacific (Hong Kong) region."
    AP_EAST_1
    "AWS Asia Pacific (Tokyo) region."
    AP_NORTHEAST_1
    "AWS Asia Pacific (Seoul) region."
    AP_NORTHEAST_2
    "AWS Asia Pacific (Seoul) region."
    AP_NORTHEAST_3
    "AWS Asia Pacific (Singapore) region."
    AP_SOUTHEAST_1
    "AWS Asia Pacific (Sydney) region."
    AP_SOUTHEAST_2
    "AWS Asia Pacific (Mumbai) region."
    AP_SOUTH_1
    "AWS Canada (Central) region."
    CA_CENTRAL_1
    "AWS China (Ningxia) region."
    CN_NORTHWEST_1
    "AWS China (Beijing) region."
    CN_NORTH_1
    "AWS EU (Frankfurt) region."
    EU_CENTRAL_1
    "AWS EU (Milan) region."
    EU_SOUTH_1
    "AWS EU (Ireland) region."
    EU_WEST_1
    "AWS EU (London) region."
    EU_WEST_2
    "AWS EU (Paris) region."
    EU_WEST_3
    "AWS Middle East (Bahrain) region."
    ME_SOUTH_1
    "AWS South America (Sao Paulo) region."
    SA_EAST_1
    "AWS region is unknown."
    UNKNOWN_AWS_REGION
    "AWS US East (N. Virginia) region."
    US_EAST_1
    "AWS US East (Ohio) region."
    US_EAST_2
    "AWS Gov US West 1 (N. California) region."
    US_GOV_WEST_1
    "AWS US West (N. California) region."
    US_WEST_1
    "AWS US West (Oregon) region."
    US_WEST_2
}

enum AwsRetrievalTier {
    BULK_TIER
    EXPEDITED_TIER
    STANDARD_TIER
}

enum AwsStorageClassTypeEnum {
    ONEZONE_IA
    STANDARD
    STANDARD_IA
    UNKNOWN_STORAGE_CLASS
}

"Azure cloud account region Enum."
enum AzureCloudAccountRegion {
    "Azure Cloud account region is Australia Central."
    AUSTRALIACENTRAL
    "Azure Cloud account region is Australia Central 2."
    AUSTRALIACENTRAL2
    "Azure Cloud account region is Australia East."
    AUSTRALIAEAST
    "Azure Cloud account region is Australia Southeast."
    AUSTRALIASOUTHEAST
    "Azure Cloud account region is Brazil South."
    BRAZILSOUTH
    "Azure Cloud account region is Canada Central."
    CANADACENTRAL
    "Azure Cloud account region is Canada East."
    CANADAEAST
    "Azure Cloud account region is Central India."
    CENTRALINDIA
    "Azure Cloud account region is Central US."
    CENTRALUS
    "Azure Cloud account region is China East."
    CHINAEAST
    "Azure Cloud account region is China East 2."
    CHINAEAST2
    "Azure Cloud account region is China North."
    CHINANORTH
    "Azure Cloud account region is China North 2."
    CHINANORTH2
    "Azure Cloud account region is East Asia."
    EASTASIA
    "Azure Cloud account region is East US."
    EASTUS
    "Azure Cloud account region is East US 2."
    EASTUS2
    "Azure Cloud account region is France Central."
    FRANCECENTRAL
    "Azure Cloud account region is France South."
    FRANCESOUTH
    "Azure Cloud account region is Germany North."
    GERMANYNORTH
    "Azure Cloud account region is Germany West Central."
    GERMANYWESTCENTRAL
    "Azure Cloud account region is Japan East."
    JAPANEAST
    "Azure Cloud account region is Japan West."
    JAPANWEST
    "Azure Cloud account region is Korea Central."
    KOREACENTRAL
    "Azure Cloud account region is Korea South."
    KOREASOUTH
    "Azure Cloud account region is North Central US."
    NORTHCENTRALUS
    "Azure Cloud account region is North Europe."
    NORTHEUROPE
    "Azure Cloud account region is Norway East."
    NORWAYEAST
    "Azure Cloud account region is Norway West."
    NORWAYWEST
    "Azure Cloud account region is South Africa North."
    SOUTHAFRICANORTH
    "Azure Cloud account region is South Africa West."
    SOUTHAFRICAWEST
    "Azure Cloud account region is South Central US."
    SOUTHCENTRALUS
    "Azure Cloud account region is South East Asia."
    SOUTHEASTASIA
    "Azure Cloud account region is South India."
    SOUTHINDIA
    "Azure Cloud account region is Switzerland North."
    SWITZERLANDNORTH
    "Azure Cloud account region is Switzerland West."
    SWITZERLANDWEST
    "Azure Cloud account region is UAE Central."
    UAECENTRAL
    "Azure Cloud account region is UAE North."
    UAENORTH
    "Azure Cloud account region is UK South."
    UKSOUTH
    "Azure Cloud account region is UK West."
    UKWEST
    "Azure Cloud account region is Unknown."
    UNKNOWN_AZURE_REGION
    "Azure Cloud account region is West Central US."
    WESTCENTRALUS
    "Azure Cloud account region is West Europe."
    WESTEUROPE
    "Azure Cloud account region is West India."
    WESTINDIA
    "Azure Cloud account region is West US."
    WESTUS
    "Azure Cloud account region is West US 2."
    WESTUS2
    "Azure Cloud account region is West US 3."
    WESTUS3
}

"Azure cloud type."
enum AzureCloudType {
    "Azure China cloud."
    AZURECHINACLOUD
    "Azure public cloud."
    AZUREPUBLICCLOUD
}

enum AzureFeatureForPermissionCheck {
    AZURE_CROSS_REGION_REPLICATION
    AZURE_EXPORT_VM_IN_POWERED_OFF_STATE
    AZURE_LIST_AVAILABILITY_SET
    AZURE_UNSPECIFIED
}

"Host type for Azure resources."
enum AzureHostType {
    "Switched from Customer- to Rubrik- hosted."
    BOTH_HOSTS
    "Customer-hosted."
    CUSTOMER_HOST
    "Rubrik-hosted."
    RUBRIK_HOST
    "Undefined host type."
    UNDEFINED
}

"The field type used to sort the resource groups."
enum AzureNativeCommonResourceGroupSortFields {
    "Use region name for sorting."
    AZURE_REGION
    "Use managed disk SLA Domain for sorting."
    AZURE_RG_DISK_EFFECTIVE_SLA
    "Use SQL Database SLA for sorting."
    AZURE_RG_SQL_DATABASE_DB_EFFECTIVE_SLA
    "Use Managed Instance Database SLA Domain for sorting."
    AZURE_RG_SQL_MANAGED_INSTANCE_DB_EFFECTIVE_SLA
    "Use subscription name for sorting."
    AZURE_RG_SUBSCRIPTION_NAME
    "Use virtual machine SLA Domain for sorting."
    AZURE_RG_VM_EFFECTIVE_SLA
    "Use resource group name for sorting."
    NAME
}

"The field type used to sort the managed disks."
enum AzureNativeDiskSortFields {
    "Use SLA Domain assignment for sorting."
    ASSIGNED_SLA_DOMAIN
    "Use common resource group name for sorting."
    AZURE_DISK_CRG_NAME
    "Use subscription name from common resource group for sorting."
    AZURE_DISK_CRG_SUBSCRIPTION_NAME
    "Use disk size for sorting."
    AZURE_DISK_SIZE
    "Use disk type for sorting."
    AZURE_DISK_TYPE
    "Use region name for sorting."
    AZURE_REGION
    "Use managed disk SLA Domain for sorting."
    EFFECTIVE_SLA_DOMAIN
    "Use managed disk name for sorting."
    NAME
}

enum AzureNativeFileIndexingStatus {
    DISABLED
    ENABLED
    NOT_SPECIFIED
}

"Azure Managed Disk types."
enum AzureNativeManagedDiskType {
    "Azure Managed Disk type is not specified."
    NOT_SPECIFIED
    "Azure Managed Disk type is Premium LRS."
    PREMIUM_LRS
    "Azure Managed Disk type is Standard SSD LRS."
    STANDARDSSD_LRS
    "Azure Managed Disk type is Standard LRS."
    STANDARD_LRS
    "Azure Managed Disk type is Ultra SSD LRS."
    ULTRASSD_LRS
    "Azure Managed Disk type is unknown."
    UNKNOWN
}

"The type of Azure Native feature Polaris supports."
enum AzureNativeProtectionFeature {
    "Protection on Azure SQL Databases."
    SQL_DB
    "Protection on Azure Native Managed Instances."
    SQL_MI
    "Protection on Azure Native Virtual Machines."
    VM
}

"Azure native regions."
enum AzureNativeRegion {
    "Azure native region is Australia Central."
    AUSTRALIA_CENTRAL
    "Azure native region is Australia Central 2."
    AUSTRALIA_CENTRAL2
    "Azure native region is Australia East."
    AUSTRALIA_EAST
    "Azure native region is Australia Southeast."
    AUSTRALIA_SOUTHEAST
    "Azure native region is Brazil South."
    BRAZIL_SOUTH
    "Azure native region is Canada Central."
    CANADA_CENTRAL
    "Azure native region is Canada East."
    CANADA_EAST
    "Azure native region is Central India."
    CENTRAL_INDIA
    "Azure native region is Central US."
    CENTRAL_US
    "Azure native region is China East."
    CHINA_EAST
    "Azure native region is China East 2."
    CHINA_EAST2
    "Azure native region is China North."
    CHINA_NORTH
    "Azure native region is China North 2."
    CHINA_NORTH2
    "Azure native region is East Asia."
    EAST_ASIA
    "Azure native region is East US."
    EAST_US
    "Azure native region is East US 2."
    EAST_US2
    "Azure native region is France Central."
    FRANCE_CENTRAL
    "Azure native region is France South."
    FRANCE_SOUTH
    "Azure native region is Germany North."
    GERMANY_NORTH
    "Azure native region is Germany West Central."
    GERMANY_WEST_CENTRAL
    "Azure native region is Japan East."
    JAPAN_EAST
    "Azure native region is Japan West."
    JAPAN_WEST
    "Azure native region is Korea Central."
    KOREA_CENTRAL
    "Azure native region is Korea South."
    KOREA_SOUTH
    "Azure native region is North Central US."
    NORTH_CENTRAL_US
    "Azure native region is North Europe."
    NORTH_EUROPE
    "Azure native region is Norway East."
    NORWAY_EAST
    "Azure native region is Norway West."
    NORWAY_WEST
    "Azure native region is not specified."
    NOT_SPECIFIED
    "Azure native region is Southeast Asia."
    SOUTHEAST_ASIA
    "Azure native region is South Africa North."
    SOUTH_AFRICA_NORTH
    "Azure native region is South Africa West."
    SOUTH_AFRICA_WEST
    "Azure native region is South Central US."
    SOUTH_CENTRAL_US
    "Azure native region is South India."
    SOUTH_INDIA
    "Azure native region is Switzerland North."
    SWITZERLAND_NORTH
    "Azure native region is Switzerland West."
    SWITZERLAND_WEST
    "Azure native region is UAE Central."
    UAE_CENTRAL
    "Azure native region is UAE North."
    UAE_NORTH
    "Azure native region is UK South."
    UK_SOUTH
    "Azure native region is UK West."
    UK_WEST
    "Azure native region is West Central US."
    WEST_CENTRAL_US
    "Azure native region is West Europe."
    WEST_EUROPE
    "Azure native region is West India."
    WEST_INDIA
    "Azure native region is West US."
    WEST_US
    "Azure native region is West US 2."
    WEST_US2
    "Azure native region is West US 3."
    WEST_US3
}

"Azure native regions for replication."
enum AzureNativeRegionForReplication {
    "Azure native region for replication is Australia Central."
    AUSTRALIA_CENTRAL
    "Azure native region for replication is Australia Central 2."
    AUSTRALIA_CENTRAL2
    "Azure native region for replication is Australia East."
    AUSTRALIA_EAST
    "Azure native region for replication is Australia Southeast."
    AUSTRALIA_SOUTHEAST
    "Azure native region for replication is Brazil South."
    BRAZIL_SOUTH
    "Azure native region for replication is Canada Central."
    CANADA_CENTRAL
    "Azure native region for replication is Canada East."
    CANADA_EAST
    "Azure native region for replication is Central India."
    CENTRAL_INDIA
    "Azure native region for replication is Central US."
    CENTRAL_US
    "Azure native region for replication is China East."
    CHINA_EAST
    "Azure native region for replication is China East 2."
    CHINA_EAST2
    "Azure native region for replication is China North."
    CHINA_NORTH
    "Azure native region for replication is China North 2."
    CHINA_NORTH2
    "Azure native region for replication is East Asia."
    EAST_ASIA
    "Azure native region for replication is East US."
    EAST_US
    "Azure native region for replication is East US 2."
    EAST_US2
    "Azure native region for replication is France Central."
    FRANCE_CENTRAL
    "Azure native region for replication is France South."
    FRANCE_SOUTH
    "Azure native region for replication is Germany North."
    GERMANY_NORTH
    "Azure native region for replication is Germany West Central."
    GERMANY_WEST_CENTRAL
    "Azure native region for replication is Japan East."
    JAPAN_EAST
    "Azure native region for replication is Japan West."
    JAPAN_WEST
    "Azure native region for replication is Korea Central."
    KOREA_CENTRAL
    "Azure native region for replication is Korea South."
    KOREA_SOUTH
    "Azure native region for replication is North Central US."
    NORTH_CENTRAL_US
    "Azure native region for replication is North Europe."
    NORTH_EUROPE
    "Azure native region for replication is Norway East."
    NORWAY_EAST
    "Azure native region for replication is Norway West."
    NORWAY_WEST
    "Azure native region for replication is not defined."
    NOT_DEFINED
    "Azure native region for replication is the source region."
    SOURCE_REGION
    "Azure native region for replication is Southeast Asia."
    SOUTHEAST_ASIA
    "Azure native region for replication is South Africa North."
    SOUTH_AFRICA_NORTH
    "Azure native region for replication is South Africa West."
    SOUTH_AFRICA_WEST
    "Azure native region for replication is South Central US."
    SOUTH_CENTRAL_US
    "Azure native region for replication is South India."
    SOUTH_INDIA
    "Azure native region for replication is Switzerland North."
    SWITZERLAND_NORTH
    "Azure native region for replication is Switzerland West."
    SWITZERLAND_WEST
    "Azure native region for replication is UAE Central."
    UAE_CENTRAL
    "Azure native region for replication is UAE North."
    UAE_NORTH
    "Azure native region for replication is UK South."
    UK_SOUTH
    "Azure native region for replication is UK West."
    UK_WEST
    "Azure native region for replication is West Central US."
    WEST_CENTRAL_US
    "Azure native region for replication is West Europe."
    WEST_EUROPE
    "Azure native region for replication is West India."
    WEST_INDIA
    "Azure native region for replication is West US."
    WEST_US
    "Azure native region for replication is West US 2."
    WEST_US2
    "Azure native region for replication is West US 3."
    WEST_US3
}

"The field type used to sort the subscriptions."
enum AzureNativeSubscriptionSortFields {
    "Use SLA Domain assignment for sorting."
    ASSIGNED_SLA_DOMAIN
    "Use disk count for sorting."
    AZURE_SUBSCRIPTION_DISKCOUNT
    "Use virtual machine count for sorting."
    AZURE_SUBSCRIPTION_VMCOUNT
    "Use tenant ID for sorting."
    AZURE_TENANT_ID
    "Use subscription SLA Domain for sorting."
    EFFECTIVE_SLA_DOMAIN
    "Use subscription name for sorting."
    NAME
}

"The field type used to sort the virtual machines."
enum AzureNativeVirtualMachineSortFields {
    "Use SLA Domain assignment for sorting."
    ASSIGNED_SLA_DOMAIN
    "Use region name for sorting."
    AZURE_REGION
    "Use subnet name for sorting."
    AZURE_SUBNET_NAME
    "Use common resource group name for sorting."
    AZURE_VM_CRG_NAME
    "Use subscription name from common resource group for sorting."
    AZURE_VM_CRG_SUBSCRIPTION_NAME
    "Use virtual machine size for sorting."
    AZURE_VM_SIZE
    "Use VNet name for sorting."
    AZURE_VNET_NAME
    "Use virtual machine SLA Domain for sorting."
    EFFECTIVE_SLA_DOMAIN
    "Use virtual machine name for sorting."
    NAME
}

"OS type of an Azure virtual machine."
enum AzureNativeVmOsType {
    "The OS type is Linux."
    LINUX
    "The OS type is unknown."
    UNKNOWN
    "The OS type is Windows."
    WINDOWS
}

"Status of Azure network security rules."
enum AzureNetworkSecurityRulesStatus {
    "NSG denies egress required for successful deployment."
    BLOCKING
    "NSG in good status."
    GOOD
    "NSG denies egress that might be required for successful deployment."
    MAYBE_BLOCKING
}

"Redundancy value for the azure resource. For more information, see https://docs.microsoft.com/en-us/azure/storage/common/storage-redundancy."
enum AzureRedundancy {
    "Geo-redundant storage."
    GRS
    "Geo-zone-redundant storage."
    GZRS
    "Locally redundant storage."
    LRS
    "Read access Geo-redundant storage."
    RA_GRS
    "Read Access Geo-zone-redundant storage."
    RA_GZRS
    UNKNOWN_AZURE_REDUNDANCY
    "Zone-redundant storage."
    ZRS
}

"Regions for Azure."
enum AzureRegion {
    "Azure region is East Asia."
    ASIA_EAST
    "Azure region is Southeast Asia."
    ASIA_SOUTHEAST
    "Azure region is Australia Central."
    AUSTRALIA_CENTRAL
    "Azure region is Australia Central 2."
    AUSTRALIA_CENTRAL2
    "Azure region is Australia East."
    AUSTRALIA_EAST
    "Azure region is Australia Southeast."
    AUSTRALIA_SOUTHEAST
    "Azure region is Brazil South."
    BRAZIL_SOUTH
    "Azure region is Canada Central."
    CANADA_CENTRAL
    "Azure region is Canada East."
    CANADA_EAST
    "Azure region is China East."
    CHINA_EAST
    "Azure region is China East 2."
    CHINA_EAST2
    "Azure region is China North."
    CHINA_NORTH
    "Azure region is North Europe."
    EUROPE_NORTH
    "Azure region is West Europe."
    EUROPE_WEST
    "Azure region is France Central."
    FRANCE_CENTRAL
    "Azure region is France South."
    FRANCE_SOUTH
    "Azure region is Germany Central."
    GERMANY_CENTRAL
    "Azure region is Germany Northeast."
    GERMANY_NORTHEAST
    "Azure region is Germany West Central."
    GERMANY_WEST_CENTRAL
    "Azure region is US Gov Arizona."
    GOV_US_ARIZONA
    "Azure region is US DoD Central."
    GOV_US_DOD_CENTRAL
    "Azure region is US DoD East."
    GOV_US_DOD_EAST
    "Azure region is US Gov Iowa."
    GOV_US_IOWA
    "Azure region is US Gov Texas."
    GOV_US_TEXAS
    "Azure region is US Gov Virginia."
    GOV_US_VIRGINIA
    "Azure region is Central India."
    INDIA_CENTRAL
    "Azure region is South India."
    INDIA_SOUTH
    "Azure region is West India."
    INDIA_WEST
    "Azure region is Japan East."
    JAPAN_EAST
    "Azure region is Japan West."
    JAPAN_WEST
    "Azure region is Korea Central."
    KOREA_CENTRAL
    "Azure region is Korea South."
    KOREA_SOUTH
    "Azure region is Norway East."
    NORWAY_EAST
    "Azure region is Norway West."
    NORWAY_WEST
    "Azure region is South Africa North."
    SOUTH_AFRICA_NORTH
    "Azure region is South Africa West."
    SOUTH_AFRICA_WEST
    "Azure region is Switzerland North."
    SWITZERLAND_NORTH
    "Azure region is Switzerland West."
    SWITZERLAND_WEST
    "Azure region is UAE Central."
    UAE_CENTRAL
    "Azure region is UAE North."
    UAE_NORTH
    "Azure region is UK South."
    UK_SOUTH
    "Azure region is UK West."
    UK_WEST
    "Azure region is unknown."
    UNKNOWN_AZURE_REGION
    "Azure region is Central US."
    US_CENTRAL
    "Azure region is East US."
    US_EAST
    "Azure region is East US 2."
    US_EAST2
    "Azure region is North Central US."
    US_NORTH_CENTRAL
    "Azure region is South Central US."
    US_SOUTH_CENTRAL
    "Azure region is West US."
    US_WEST
    "Azure region is West US 2."
    US_WEST2
    "Azure region is West Central US."
    US_WEST_CENTRAL
    "Azure region is West US 3."
    WEST_US3
}

"The type of snapshot to be used in export or restore jobs."
enum AzureSnapshotType {
    "Use the archived snapshot."
    ARCHIVED
    "Use the replicated snapshot."
    REPLICATED
    "Use the source snapshot."
    SOURCE
}

"The type of backup storage redundancy for Azure SQL."
enum AzureSqlBackupStorageRedundancyType {
    "Geo-Redundant Storage."
    GRS
    "Locally-Redundant Storage."
    LRS
    "Zone-Redundant Storage."
    ZRS
}

"Fields on which the list of Azure SQL Database Servers can be sorted."
enum AzureSqlDatabaseServerSortFields {
    AZURE_SQL_DATABASE_SERVER_REGION
    AZURE_SQL_SERVER_RESOURCE_GROUP
    EFFECTIVE_SLA_DOMAIN
    NAME
}

"Fields on which the list of Azure SQL Databases can be sorted."
enum AzureSqlDatabaseSortFields {
    AZURE_SQL_DATABASE_DB_REGION
    AZURE_SQL_DB_RESOURCE_GROUP
    EFFECTIVE_SLA_DOMAIN
    NAME
}

"Status of the setup for taking Azure SQL database backup."
enum AzureSqlDbBackupSetupStatus {
    "The Azure database backup setup failed because cdc is disabled."
    CDC_DISABLED
    "The Azure database backup setup failed due to invalid credentials."
    INVALID_CREDENTIALS
    "The Azure backup setup status is not specified."
    NOT_SPECIFIED
    "The Azure database backup setup is successful."
    SUCCESS
}

"Fields on which the list of Azure SQL Managed Instance Databases can be sorted."
enum AzureSqlManagedInstanceDatabaseSortFields {
    AZURE_SQL_DB_RESOURCE_GROUP
    AZURE_SQL_MANAGED_INSTANCE_DB_REGION
    EFFECTIVE_SLA_DOMAIN
    NAME
}

"Fields on which the list of Azure SQL Managed Instance Servers can be sorted."
enum AzureSqlManagedInstanceServerSortFields {
    AZURE_SQL_MANAGED_INSTANCE_SERVER_REGION
    AZURE_SQL_SERVER_RESOURCE_GROUP
    EFFECTIVE_SLA_DOMAIN
    NAME
}

"Storage Tier for the storage accounts/containers. For more information, see https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-storage-tiers."
enum AzureStorageTier {
    "Optimized for storing data that is rarely accessed."
    ARCHIVE
    "Optimized for storing data that is accessed frequently."
    COOL
    "Optimized for storing data that is infrequently accessed."
    HOT
    UNKNOWN_STORAGE_TIER
}

"Status of an Azure subscription."
enum AzureSubscriptionStatus {
    "The Azure subscription has been added."
    ADDED
    "The Azure subscription has been deleted."
    DELETED
    "The Azure subscription is in the process of getting deleted."
    DELETING
    "The deletion of the Azure subscription has failed."
    DELETION_FAILED
    "The Azure subscription has been refreshed."
    REFRESHED
    "The Azure subscription is refreshing."
    REFRESHING
    "The Azure subscription has failed to refresh."
    REFRESH_FAILED
}

"Color of the banner displayed on UI for accounts with classified snappables"
enum BannerColor {
    "Blue"
    BLUE
    "Green"
    GREEN
    "None"
    NONE
    "Orange"
    ORANGE
    "Red"
    RED
    "Yellow"
    YELLOW
}

enum BlueprintFailoverIgnorableError {
    NETWORK_RECONFIGURE_ERROR
    POSTSCRIPT_EXECUTION_ERROR
}

"Failover error type."
enum BlueprintFailoverIgnorableErrorType {
    "Network_reconfigure_error."
    NETWORK_RECONFIGURE_ERROR
    "Postscript_execution_error."
    POSTSCRIPT_EXECUTION_ERROR
    "Unknown_error."
    UNKNOWN_ERROR
}

"Blueprint failover status enum."
enum BlueprintFailoverStatus {
    "Blueprint failover failed."
    FAILED
    "Blueprint failover does not exist."
    NOT_EXIST
    "Blueprint failover succeeded."
    SUCCEEDED
}

"Failover type."
enum BlueprintFailoverType {
    "Failover."
    FAILOVER
    "Inplace_recovery."
    INPLACE_RECOVERY
    "Local_export."
    LOCAL_EXPORT
    "Remote_export."
    REMOTE_EXPORT
    "Test_failover."
    TEST_FAILOVER
    "Unknown_type."
    UNKNOWN_TYPE
}

enum BlueprintLocationTypeEnum {
    Aws
    Azure
    CDM
    Unknown
}

enum BlueprintPlatformEnum {
    Aws
    UnknownPlatform
    vSphere
}

enum BlueprintStatusEnum {
    Configured
    Invalid
    MissingChildren
    NotConfigured
    Uncompleted
}

"Email address filter."
enum CalendarEmailAddressFilterType {
    "Search organizer or attendees by email."
    ALL
    "Search attendee by email."
    ATTENDEE
    "Search organizer by email."
    ORGANIZER
}

"Type of the calendar event."
enum CalendarEventType {
    "Series exception event type."
    SERIES_EXCEPTION
    "Series master event type."
    SERIES_MASTER
    "Series occurrence event type."
    SERIES_OCCURRENCE
    "Single instance event type."
    SINGLE_INSTANCE
}

"Recurrence type for calendar event."
enum CalendarRecurrenceType {
    "Event can be either recurring or non-recurring."
    ALL
    "Event is recurring."
    RECURRING
    "Event is a single instance (not recurring)."
    SINGLE
}

"Search keyword type for Calendar."
enum CalendarSearchKeywordType {
    "Search by event or calendar name."
    NAME
}

"Enum for cassandra source status."
enum CassandraSourceStatus {
    "Source is getting added."
    ADDING
    "Source is connected."
    CONNECTED
    "Source is deleted."
    DELETED
    "Source is getting deleted."
    DELETING
    "Source is disconnected."
    DISCONNECTED
    "Source data is getting refreshed."
    REFRESHING
    "Unknown source status."
    UNKNOWN_SYSTEM_STATUS
}

"Status of Job."
enum CcpJobStatus {
    "Bootstrapping cluster."
    BOOTSTRAPPING
    "Completed successfully."
    COMPLETED
    "Failed."
    FAILED
    "Initializing."
    INITIALIZING
    "Invalid status."
    INVALID
    "Node connection verify."
    NODE_CONNECTION_VERIFICATION
    "Node creation."
    NODE_CREATE
    "Node information retrieval."
    NODE_INFO_EXTRACTION
    "Rotate token."
    ROTATE_TOKEN
}

"Type of cluster job."
enum CcpJobType {
    "Add a node to cluster."
    ADD_NODE
    "Create cluster job."
    CLUSTER_CREATE
    "Delete cluster job."
    CLUSTER_DELETE
    "Remove node from cluster."
    REMOVE_NODE
}

"Cloud vendor provider."
enum CcpVendorType {
    "AWS."
    AWS
    "Azure."
    AZURE
    "GCP."
    GCP
}

enum CdmClusterStatusTypeEnum {
    Disconnected
    DownloadPackageFailed
    DownloadingPackage
    FailedToInitiateUpgrade
    OnOldRelease
    PrechecksFailureError
    PrechecksFailureWarning
    PrechecksRunning
    ReadyForDownload
    ReadyForUpgrade
    ResumingUpgrade
    RollbackFailed
    RollingBackUpgrade
    Stable
    StableWithUpgradeInfo
    Unknown
    UpgradeFailed
    UpgradeRecommended
    UpgradeScheduled
    UpgradeScheduledWithWarning
    Upgrading
}

"Ways that CDM snapshots can be filtered."
enum CdmSnapshotFilterField {
    "Filter on the snapshot's cluster id."
    CLUSTER_UUID
    "No filter value."
    EMPTY
    "Filter on whether the snapshot is expired."
    IS_EXPIRED
    "Filter on whether the snapshot was taken as an on demand snapshot."
    IS_ON_DEMAND_SNAPSHOT
    "Filter by snappable id."
    SNAPPABLE_ID
    "Filter by snapshot id."
    SNAPSHOT_ID
    "Filter on the time the snapshot was taken."
    TIME_RANGE
}

enum CdmSnapshotGroupByEnum {
    Day
    Hour
    Month
    Quarter
    Week
    Year
}

enum CdmSnapshotSortByEnum {
    Date
    SnappableId
    SnapshotId
}

enum CdpLocalStatusEnum {
    CDP_LOCAL_STATUS_ACTIVE
    CDP_LOCAL_STATUS_FAILED
    CDP_LOCAL_STATUS_NOT_ENABLED
    CDP_LOCAL_STATUS_PENDING
    CDP_LOCAL_STATUS_RESYNCING
    CDP_LOCAL_STATUS_TAKING_SNAPSHOT
}

enum CdpReplicationStatusEnum {
    CDP_REPLICATION_STATUS_FAILED
    CDP_REPLICATION_STATUS_HEALTHY
    CDP_REPLICATION_STATUS_INITIALIZING
    CDP_REPLICATION_STATUS_NOT_ENABLED
}

enum CertMgmtSortByEnum {
    NAME
}

"All reporting chart types."
enum ChartType {
    "The area chart."
    AREA_CHART
    "The column chart."
    COLUMN_CHART
    "The donut chart."
    DONUT_CHART
}

"All valid chart views."
enum ChartViewType {
    "Object capacity over time report's group by cluster chart."
    OBJECT_CAPACITY_OVERTIME_LOCAL_DATA_STORE_CLUSTER_CHART
    "Protection task detail report's group by cluster chart."
    PROTECTION_TASKS_CLUSTER_CHART
}

enum ClassificationPolicyColor {
    COLOR_001
    COLOR_002
    COLOR_003
    COLOR_004
    COLOR_005
    COLOR_006
    COLOR_007
    COLOR_008
    COLOR_009
    COLOR_010
    COLOR_011
    COLOR_012
    UNKNOWN
}

enum ClassificationPolicyMode {
    COMPLIANCE
    DISCOVERY
}

"Actions that can be performed on a cloud account."
enum CloudAccountAction {
    "Create a cloud account."
    CREATE
    "Delete a cloud account."
    DELETE
    "Update child accounts of a cloud account."
    UPDATE_CHILD_ACCOUNTS
    "Update permissions of a cloud account."
    UPDATE_PERMISSIONS
    "Update regions in a cloud account."
    UPDATE_REGIONS
}

"Cloud account features."
enum CloudAccountFeature {
    "All cloud account features."
    ALL
    "Cloud account feature is App Flows."
    APP_FLOWS
    "Cloud account feature is Archival."
    ARCHIVAL
    "Cloud account feature is Azure SQL DB Protection."
    AZURE_SQL_DB_PROTECTION
    "Cloud account feature is Azure SQL MI Protection."
    AZURE_SQL_MI_PROTECTION
    "Cloud account feature is Cloud Accounts."
    CLOUDACCOUNTS
    "Cloud account feature is Cloud Native Archival."
    CLOUD_NATIVE_ARCHIVAL
    "Cloud account feature is Cloud Native Archival Encryption."
    CLOUD_NATIVE_ARCHIVAL_ENCRYPTION
    "Cloud account feature is Cloud Native Protection."
    CLOUD_NATIVE_PROTECTION
    "Cloud account feature is Exocompute."
    EXOCOMPUTE
    "Cloud account feature is GCP Shared VPC Host."
    GCP_SHARED_VPC_HOST
    "Cloud account feature is RDS Protection."
    RDS_PROTECTION
    "Cloud account feature is Servers and Apps."
    SERVERS_AND_APPS
}

enum CloudAccountFilterFieldEnum {
    ACCOUNT_PROVIDER_TYPE
    IS_KEY_BASED
    NAME
}

enum CloudAccountSortByFieldEnum {
    NAME
}

"Cloud account statuses."
enum CloudAccountStatus {
    "Cloud account is connected."
    CONNECTED
    "Cloud account is connecting."
    CONNECTING
    "Cloud account is disabled."
    DISABLED
    "Cloud account is disconnected."
    DISCONNECTED
    "Cloud account is missing permissions."
    MISSING_PERMISSIONS
}

"Cloud account type."
enum CloudAccountType {
    "Cloud account type is AWS."
    CLOUD_ACCOUNT_AWS
    "Cloud account type is role-based AWS."
    CLOUD_ACCOUNT_AWS_ROLE_BASED
    "Cloud account type is Azure."
    CLOUD_ACCOUNT_AZURE
    "Cloud account type is role-based Azure."
    CLOUD_ACCOUNT_AZURE_ROLE_BASED
    "Cloud account type is GCP."
    CLOUD_ACCOUNT_GCP
    "Cloud account type is unknown."
    UNKNOWN_CLOUD_ACCOUNT
}

enum CloudNativeLabelObjectType {
    GCP_DISK
    GCP_GCE_INSTANCE
}

"The archival location template types."
enum CloudNativeLocTemplateType {
    "Cloud native location type is invalid."
    INVALID
    "Specfies that the target archival location should be in the same region as that of source snappable."
    SOURCE_REGION
    "Specifies that target archival location should be in a specified region irrespective of the region of the source snappables."
    SPECIFIC_REGION
}

"Cloud-native Rubrik Backup Service(RBS) status."
enum CloudNativeRbaStatusType {
    "Cloud native RBS status is Not Registered."
    NOT_REGISTERED
    "Cloud native RBS status is Registered."
    REGISTERED
    "Cloud native RBS status is Unavailable."
    UNAVAILABLE
}

enum CloudNativeTagObjectType {
    AWS_EBS_VOLUME
    AWS_EC2_INSTANCE
    AWS_RDS_INSTANCE
    AZURE_MANAGED_DISK
    AZURE_SQL_DATABASE_DB
    AZURE_SQL_DATABASE_SERVER
    AZURE_SQL_MANAGED_INSTANCE_SERVER
    AZURE_VIRTUAL_MACHINE
}

"Fields to filter tag rules."
enum CloudNativeTagRuleFilterFields {
    "Filter by AWS account."
    AWS_ACCOUNT
    "Filter by cloud native account."
    CLOUD_NATIVE_ACCOUNT
    "Filter by name."
    NAME
    "Filter by SLA domain."
    SLA_DOMAIN
}

"Fields to sort tag rules."
enum CloudNativeTagRuleSortByFields {
    "Sort by name."
    NAME
    "Sort by SLA domain."
    SLA_DOMAIN
    "Sort by tag key and value."
    TAG
}

enum CloudNativeVmAppConsistentObjectType {
    AZURE_VIRTUAL_MACHINE
}

"Cloud provider."
enum CloudProvider {
    "Cloud provider is AWS."
    AWS
    "Cloud provider is Azure."
    AZURE
}

enum CloudProviderType {
    AWS
    AZURE
    GCP
    NOT_SPECIFIED
}

"Cloud provider type."
enum CloudVendor {
    "Cloud provider is AWS."
    AWS
    "Cloud provider is Azure."
    AZURE
    "Cloud provider is GCP."
    GCP
}

"Connection status of the cluster with Rubrik."
enum ClusterConnectionStatus {
    "Cluster is connected to Rubrik."
    CONNECTED
    "Cluster is disconnected from Rubrik."
    DISCONNECTED
    "Cluster was not added or got removed from Rubrik."
    NOT_ATTACHED
}

"Enum representing the cluster's knowledge of a disk state."
enum ClusterDiskStatus {
    "Mounted disk."
    ACTIVE
    "Mounted disk continuously failing health checks."
    FAILED
    "Self encrypting disk in locked state (only for appliances supporting hardware encryption)."
    LOCKED
    "Disk present in node table but not on the node."
    MISSING
    "Disk needs replacement. The disk is still readable but SDFS will drain the data gradually in the background."
    PRE_REMOVAL
    "Disk needs software repair (e.g, fsck) and is not writable."
    PRE_REPAIR
    "Disk finished draininig. User can unplug the disk."
    READY_TO_REMOVE
    "Disk explicitly removed from the cluster."
    REMOVED
    "Disk is under repair (e.g., fsck) and is not available. The expectation is that the disk will become available soon but is not guaranteed. Both read and write operations will not be allowed in this status."
    REPAIR
    "Disk with no ext4 partitions."
    UNFORMATTED
    "Unused."
    UNKNOWN
}

enum ClusterDiskType {
    FLASH
    HDD
    UNKNOWN
}

enum ClusterGroupByEnum {
    Day
    Hour
    Month
    Quarter
    Type
    Week
    Year
}

enum ClusterJobStatusTypeEnum {
    DownloadPackageFailed
    DownloadingPackage
    FailedToInitiateUpgrade
    PreCheckFailureError
    PreCheckFailureWarning
    ReadyForDownload
    ReadyForUpgrade
    ResumingUpgrade
    RollbackFailed
    RollingBackUpgrade
    Unknown
    UpToDate
    UpgradeFailed
    Upgrading
}

"Pause Status of the cluster."
enum ClusterPauseStatus {
    "Cluster not paused."
    NOT_PAUSED
    "Cluster paused."
    PAUSED
    "Unknown Status."
    UNKNOWN
}

enum ClusterProductEnum {
    CDM
    DATOS
    POLARIS
}

enum ClusterRemovalState {
    DATA_DELETING
    DISCONNECTING
    FAILED
    REGISTERED
    UNREGISTERED
    WAITING_FOR_DATA_DELETION
}

"Property to order the cluster list results."
enum ClusterSortByEnum {
    ClusterName
    ClusterType
    "Estimated time before cluster runs out of storage."
    ESTIMATED_RUNWAY
    RegisteredAt
}

enum ClusterStatus {
    Connected
    Disconnected
    Initializing
}

"Cluster system status."
enum ClusterSystemStatus {
    "Several nodes are experiencing failures."
    FATAL
    "All nodes are functioning normally."
    OK
    "Some nodes are experiencing failures."
    WARNING
}

enum ClusterTypeEnum {
    Cloud
    ExoCompute
    OnPrem
    Polaris
    Robo
    Unknown
}

"Available cold storage class options for tiering."
enum ColdStorageClass {
    "Glacier cold storage class for AWS."
    AWS_GLACIER
    "GDA cold storage class for AWS."
    AWS_GLACIER_DEEP_ARCHIVE
    "Archive cold storage tier for Azure."
    AZURE_ARCHIVE
    COLD_STORAGE_CLASS_UNKNOWN
}

enum ComplianceStatusEnum {
    Empty
    InCompliance
    NotApplicable
    NotAvailable
    Null
    OutOfCompliance
    Unprotected
}

enum ComponentEnum {
    APP_FLOWS
    AWS_NATIVE
    AWS_SOURCE
    AZURE_NATIVE
    BLOBSTORE
    CEREBRO
    CLOUD_ACCOUNTS
    CLOUD_NATIVE
    COLOSSUS
    DATA_GOV
    DHRC
    EXO_COMPUTE
    FELDSPAR
    FORGE
    GCP_NATIVE
    GPS
    KUPR
    O365
    PLATFORM
    RADAR
    SNAPPABLES
    SONAR
    THOR
    USER_MANAGEMENT
    WATCHERS
}

enum ConfiguredSlaTypeEnum {
    CONFIGURED_SLA_TYPE_PROTECTION_SLA
    CONFIGURED_SLA_TYPE_RETENTION_SLA
}

enum ConflictResolutionAuthzEnum {
    ALLOW_AUTO_CONFLICT_RESOLUTION
    NONE
    NO_CONFLICT_RESOLUTION
}

enum ConnectionStatusType {
    CONNECTED
    DISCONNECTED
}

"Tells whether snapshot has app or crash consistency"
enum ConsistencyLevelEnum {
    AppConsistent
    CrashConsistent
    FileSystemConsistent
    Inconsistent
    Unknown
    VssConsistent
}

enum ContextFilterTypeEnum {
    APPFLOWS_FAILOVER_TO_AWS
    APPFLOWS_FAILOVER_TO_CDM
    DEFAULT
}

enum CrawlStatusEnum {
    COMPLETE
    COMPLETE_WITH_FAIL
    IN_PROGRESS
    IN_PROGRESS_WITH_FAIL
}

enum CustomReportGroupByEnum {
    ReportFocus
}

enum CustomReportSortByEnum {
    CreationTime
    UpdateTime
    ViewTime
}

enum DataGovFileModeEnum {
    DIRECTORY
    FILE
    SYMLINK
    UNKNOWN
}

enum DataGovOsTypeEnum {
    LINUX
    NONE
    WINDOWS
}

enum DataGovShareTypeEnum {
    NFS
    SMB
    UNKNOWN_SHARE_TYPE
}

enum DataGuardTypeEnum {
    DATA_GUARD_TYPE_DATA_GUARD_GROUP
    DATA_GUARD_TYPE_DATA_GUARD_MEMBER
    DATA_GUARD_TYPE_NON_DATA_GUARD
}

enum DataTransferTypeEnum {
    EMPTY_VALUE
    EXPORT
    HYDRATION
    INPLACE
}

enum DataTypeEnum {
    BOOLEAN
    BYTE
    DATE_TIME
    FILTER_DATE_RANGE
    FLOAT
    INTEGER
    LONG
    STRING
    URL
}

"All reporting table schemas."
enum DataViewTypeEnum {
    BACKUP_COMPLIANCE
    CDM_UPGRADES
    "Global object database table schema."
    GLOBAL_OBJECT
    "Global object summary daily database table schema."
    GLOBAL_OBJECT_SUMMARY_DAILY
    "Global object summary monthly database table schema."
    GLOBAL_OBJECT_SUMMARY_MONTHLY
    INDEXING
    MONITORING_ALL
    MONITORING_CANCELED
    MONITORING_COMPLETED
    MONITORING_FAILED
    MONITORING_IN_PROGRESS
    MONITORING_RETRYABLE_CANCELED
    MONITORING_RETRYABLE_FAILED
    MONITORING_SCHEDULED
    MONITORING_TASK_COUNT_TIME_SERIES
    OBJECT_AUDIT_DETAIL
    OBJECT_AUDIT_LIST
    PROTECTION_TASK_DETAILS
    SLA_AUDIT_DETAIL
    SLA_AUDIT_LIST
    SLA_COMPLIANCE
}

enum DayOfMonth {
    FIFTEENTH
    FIRST_DAY
    LAST_DAY
}

enum DayOfQuarter {
    FIRST_DAY
    LAST_DAY
}

"Specifies the day of the week."
enum DayOfWeek {
    "Indicates Friday."
    FRIDAY
    "Indicates Monday."
    MONDAY
    "Indicates Saturday."
    SATURDAY
    "Indicates Sunday."
    SUNDAY
    "Indicates Thursday."
    THURSDAY
    "Indicates Tuesday."
    TUESDAY
    "Indicates Wednesday."
    WEDNESDAY
}

enum DayOfYear {
    FIRST_DAY
    LAST_DAY
}

enum Db2InstanceSummaryStatusEnum {
    DB2_INSTANCE_SUMMARY_STATUS_ERROR
    DB2_INSTANCE_SUMMARY_STATUS_OK
    DB2_INSTANCE_SUMMARY_STATUS_UNKNOWN
    DB2_INSTANCE_SUMMARY_STATUS_WARNING
}

"Enum for db2 log snapshot sort by field."
enum Db2LogSnapshotSortBy {
    "Sort db2 snapshots by date."
    DATE
}

"Enum for db2 recoverable ranges sort by field."
enum Db2RecoverableRangeSortBy {
    "Sort db2 recoverable range by end time."
    END_TIME
    "Sort db2 recoverable range by start time."
    START_TIME
}

"Enum for db2 snapshot type."
enum Db2SnapshotType {
    "Db2 Snapshot since last successful full snapshot."
    DIFFERENTIAL
    "Db2 Full Snapshot."
    FULL
    "Db2 Snapshot since any (full/differential/incremental) successful snapshot."
    INCREMENTAL
}

"Db2 instance status."
enum Db2Status {
    "Error while connecting to Db2 Instance."
    ERROR
    "Db2 Instance is successfully connected."
    OK
    "Db2 Instance is in the connecting stage."
    UNKNOWN
    "Db2 Instance is connected with warnings."
    WARNING
}

enum DeltaTypeEnum {
    BYTES_CREATED
    BYTES_DELETED
    BYTES_MODIFIED
    NODES_CREATED
    NODES_DELETED
    NODES_MODIFIED
    NODES_SUSPICIOUS
}

enum DiagnosticTaskStatusEnum {
    DIAGNOSTIC_TASK_STATUS_CANCELED
    DIAGNOSTIC_TASK_STATUS_FAILED
    DIAGNOSTIC_TASK_STATUS_QUEUED
    DIAGNOSTIC_TASK_STATUS_RETRIED
    DIAGNOSTIC_TASK_STATUS_STARTED
    DIAGNOSTIC_TASK_STATUS_SUCCEEDED
}

enum DiskEncryptionType {
    CUSTOMER_MANAGED_KEY
    CUSTOMER_MANAGED_KEY_RESOURCE_ID
    GOOGLE_MANAGED_KEY
    SOURCE_DISK_ENCRYPTION
}

enum DownloadIdentifierEnum {
    REPORT
    SEND_NOW_EMAIL
    SNAPSHOT_FILES_DOWNLOAD
    SONAR_DOWNLOAD
}

enum DownloadStatusEnum {
    COMPLETED
    FAILED
    IN_PROGRESS
    PENDING
}

"Email address filter for Mailbox search."
enum EmailAddressFilterType {
    "Search sender or recipients by email."
    ALL
    "Search sender by email."
    FROM
    "Search recipients by email."
    TO
}

"The level of encryption detected in the snapshot."
enum EncryptionLevel {
    "High level of encryption."
    HIGH
    "Low level of encryption."
    LOW
    "Medium level of encryption."
    MEDIUM
    "Encryption level is unavailable."
    UNAVAILABLE
}

"The severity of an event."
enum EventSeverity {
    "Describes a critical event."
    CRITICAL
    "Unused default value."
    EVENT_SEVERITY_UNSPECIFIED
    "Describes an informational event."
    INFO
    "Describes a warning event."
    WARNING
}

"Events that a webhook can subsribe to."
enum EventType {
    "Anomaly event."
    ANOMALY
    "Archive event."
    ARCHIVE
    "Auth domain event."
    AUTH_DOMAIN
    "AWS event."
    AWS_EVENT
    "Backup event."
    BACKUP
    "Classification event."
    CLASSIFICATION
    "Cloud native source event."
    CLOUD_NATIVE_SOURCE
    "Cloud native virtual machine event."
    CLOUD_NATIVE_VIRTUAL_MACHINE
    "Cloud native vm event."
    CLOUD_NATIVE_VM
    "Configuration event."
    CONFIGURATION
    "Connection event."
    CONNECTION
    "Conversion event."
    CONVERSION
    "Diagnostic event."
    DIAGNOSTIC
    "Discovery event."
    DISCOVERY
    "Download event."
    DOWNLOAD
    "Embedded event."
    EMBEDDED_EVENT
    "Unused default."
    EVENT_TYPE_UNSPECIFIED
    "Failover event."
    FAILOVER
    "Fileset event."
    FILESET
    "Hardware event."
    HARDWARE
    "HDFS event."
    HDFS
    "Host event."
    HOST_EVENT
    "Hyperv SCVMM event."
    HYPERV_SCVMM
    "Hyperv Server event."
    HYPERV_SERVER
    "Index event."
    INDEX
    "Instantiate event."
    INSTANTIATE
    "Logal hold event."
    LEGAL_HOLD
    "Local recovery event."
    LOCAL_RECOVERY
    "Maintenance event."
    MAINTENANCE
    "Nutanix cluster event."
    NUTANIX_CLUSTER
    "Radar analysis event."
    RADAR_ANALYSIS
    "Recovery event."
    RECOVERY
    "Replication event."
    REPLICATION
    "Resource operations event."
    RESOURCE_OPERATIONS
    "Storage event."
    STORAGE
    "Storage array event."
    STORAGE_ARRAY
    "Storm resource event."
    STORM_RESOURCE
    "Support event."
    SUPPORT
    "Sync event."
    SYNC
    "System event."
    SYSTEM
    "Test failover event."
    TEST_FAILOVER
    "Threat hunt event."
    THREAT_HUNT
    "TPR event."
    TPR
    "Unknown event type."
    UNKNOWN_EVENT_TYPE
    "Upgrade event."
    UPGRADE
    "VCD event."
    VCD
    "Volume group event."
    VOLUME_GROUP
    "V center event."
    V_CENTER
}

enum ExchangeBackupPreferenceEnum {
    EXCHANGE_BACKUP_PREFERENCE_PASSIVE_ONLY
    EXCHANGE_BACKUP_PREFERENCE_PREFER_PASSIVE
}

"Filter for exchange live mount results."
enum ExchangeLiveMountFilterField {
    "Cluster UUID filter for exchange live mount results."
    CLUSTER_UUID
    "Filter is not specified. Any filter text would not be considered."
    UNSPECIFIED
}

"Sort by parameters for exchange live mount results."
enum ExchangeLiveMountSortByField {
    "Sort by Cluster Name."
    CLUSTER_NAME
    "Sort by Mount Creation Date."
    CREATION_DATE
    "Sort by field is not specified. Any filter text would not be considered."
    UNSPECIFIED
}

enum ExistingSnapshotRetentionEnum {
    EXISTING_SNAPSHOT_RETENTION_EXPIRE_IMMEDIATELY
    EXISTING_SNAPSHOT_RETENTION_KEEP_FOREVER
    EXISTING_SNAPSHOT_RETENTION_RETAIN_SNAPSHOTS
}

enum FailoverClusterAppConnectionStatusEnum {
    FAILOVER_CLUSTER_APP_CONNECTION_STATUS_CONNECTED
    FAILOVER_CLUSTER_APP_CONNECTION_STATUS_DISCONNECTED
    FAILOVER_CLUSTER_APP_CONNECTION_STATUS_REPLICATION_TARGET
}

enum FailoverClusterConnectionStatusEnum {
    FAILOVER_CLUSTER_CONNECTION_STATUS_CONNECTED
    FAILOVER_CLUSTER_CONNECTION_STATUS_DISCONNECTED
    FAILOVER_CLUSTER_CONNECTION_STATUS_PARTIALLY_CONNECTED
    FAILOVER_CLUSTER_CONNECTION_STATUS_REPLICATION_TARGET
}

"Connection status between the Failover cluster objects and the CDM cluster."
enum FailoverClusterConnectivityStatus {
    "Failover cluster object is connected with the CDM cluster."
    CONNECTED
    "Failover cluster object is disconnected with the CDM cluster."
    DISCONNECTED
    "The connection status between CDM cluster and the failover cluster is refreshing."
    PARTIALLY_CONNECTED
    "Failover cluster object is connected with the replicated CDM cluster."
    REPLICATION_TARGET
    "The connection status between the failover cluster object and the CDM cluster is unknown."
    UNKNOWN_CONNECTIVITY_STATUS
}

enum FailoverClusterNodeConnectionStatusEnum {
    FAILOVER_CLUSTER_NODE_CONNECTION_STATUS_CONNECTED
    FAILOVER_CLUSTER_NODE_CONNECTION_STATUS_CONNECTING
    FAILOVER_CLUSTER_NODE_CONNECTION_STATUS_CONNECTOR_NOT_DEPLOYED
    FAILOVER_CLUSTER_NODE_CONNECTION_STATUS_DELETED
    FAILOVER_CLUSTER_NODE_CONNECTION_STATUS_DELETING
    FAILOVER_CLUSTER_NODE_CONNECTION_STATUS_DISCONNECTED
    FAILOVER_CLUSTER_NODE_CONNECTION_STATUS_PARTIALLY_CONNECTED
    FAILOVER_CLUSTER_NODE_CONNECTION_STATUS_REPLICATION_TARGET
    FAILOVER_CLUSTER_NODE_CONNECTION_STATUS_SECONDARY_CLUSTER
}

enum FailoverClusterOsTypeEnum {
    FAILOVER_CLUSTER_OS_TYPE_AIX
    FAILOVER_CLUSTER_OS_TYPE_ANY
    FAILOVER_CLUSTER_OS_TYPE_HPUX
    FAILOVER_CLUSTER_OS_TYPE_LINUX
    FAILOVER_CLUSTER_OS_TYPE_SUN_OS
    FAILOVER_CLUSTER_OS_TYPE_UNIX_LIKE
    FAILOVER_CLUSTER_OS_TYPE_WINDOWS
}

enum FailoverClusterTypeEnum {
    FAILOVER_CLUSTER_TYPE_UNIX_LIKE
    FAILOVER_CLUSTER_TYPE_WINDOWS
}

enum FailoverGroupByEnum {
    Day
    FailoverStatus
    FailoverType
    Hour
    LastTestStatus
    Month
    Quarter
    Source
    TargetSite
    Week
    Year
}

enum FailoverSortByEnum {
    AppBlueprintName
    SourceSiteName
    StartTime
    TargetSiteName
}

enum FailoverStatusEnum {
    FailoverCleanupStarted
    FailoverFailed
    FailoverJobFailed
    FailoverJobSucceeded
    LocalRecoverySucceeded
    Ongoing
    Paused
    TestFailoverSucceeded
}

enum FailoverTableColumnEnum {
    AppBlueprintName
    Duration
    EndTime
    FailoverStatus
    FailoverType
    LastTestStatus
    LastTestTime
    Source
    StartTime
    TargetSite
}

enum FailoverTypeEnum {
    FAILOVER
    LOCALRECOVERY
    TEST_FAILOVER
}

enum FeatureFlagEntityTypeEnum {
    ACCOUNT
    RANDOM
    SESSION
    USER
}

"Feature flag names."
enum FeatureFlagNameEnum {
    "Enables online registration workflow."
    ALLOW_ONLINE_REGISTRATION
    "Determine whether compute cluster support is enabled for Appflows."
    APPFLOWS_COMPUTE_CLUSTER_ENABLED
    "Determines whether Datastore cluster is enabled for Appflows."
    APPFLOWS_DATASTORE_CLUSTER_ENABLED
    "Determines whether Datastore mapping is enabled for Appflows."
    APPFLOWS_DATASTORE_MAPPING_ENABLED
    "Determines whether Appflows Customer Demo features are enabled for Appflows."
    APPFLOWS_DEMO_ENABLED
    APPFLOWS_DEV_ENABLED
    "Determines whether fast fill is enabled for Appflows."
    APPFLOWS_FAST_FILL_ENABLED
    "Determines whether recovery plans is enabled for Appflows."
    APPFLOWS_RECOVERY_PLANS_ENABLED
    AWSAutoProtectByTagsEnabled
    AWSCrossRegionReplicationEnabled
    AWSCustomKeyPairInExportEnabled
    AWSEc2CrashConsistentSnapshotEnabled
    AWSFileIndexingEnabled
    AWSOnDemandIndexingEnabled
    AWSSnapshotIntegrityEnabled
    "Enables iam instance profile recovery feature for ec2 export."
    AWS_EXPORT_IAM_INSTANCE_PROFILE_ENABLED
    AWS_NATIVE_INSTANT_ARCHIVAL_ENABLED
    "Determines whether Cross Account Replication and Export is supported for AWS RDS Instances or not."
    AWS_RDS_CROSS_ACCOUNT_REPLICATION_ENABLED
    "Determines whether we can use RDS API for taking RDS snapshot or we have to use AWS Backup Job."
    AWS_RDS_USE_MANUAL_SNAPSHOT_ENABLED
    "Enables granular disk recoveries feature for vm export and restore."
    AZURE_GRANULAR_DISK_RECOVERIES_ENABLED
    "Determines whether Azure Shared Exocompute Settings is enabled."
    AZURE_SHARED_EXOCOMPUTE_ENABLED
    AZURE_SQL_V1_ENABLED
    "Determines whether Azure Sql V2 is enabled."
    AZURE_SQL_V2_ENABLED
    AddonsUIEnabled
    AppFlowsEnabled
    AppFlowsGAEnabled
    AutoStorageSettingClusterListEnabled
    AutoStorageSettingEnabled
    AwsChinaCloudEnabled
    AwsComputeSettingsEnabled
    AwsCrossAccountReplicationEnabled
    AwsExocomputeConfigEnabled
    AwsExportInstanceInPoweredOffStateEnabled
    AwsNativeArchivalEnabled
    AwsNativeArchivalShortTermRetentionEnabled
    AwsRDSAutoProtectByTagsEnabled
    AwsRDSCrossRegionReplicationEnabled
    AwsRDSProtectionEnabled
    AwsRoleBasedArchivalLocationsEnabled
    AwsSnsSqsBasedAutomatedFlowEnabled
    AzureAppConsistentSnapshotsEnabled
    AzureAutoProtectByTagsEnabled
    AzureCommonResourceGroupEnabled
    AzureCrossRegionReplicationEnabled
    AzureCrossSubscriptionExportEnabled
    AzureFileIndexingEnabled
    AzureLockSnapshotsEnabled
    AzureNationalCloudEnabled
    AzureNativeArchivalEnabled
    AzureRecoverPoweredOffEnabled
    AzureSeparateResourceGroupEnabled
    AzureSnapshotIntegrityEnabled
    BackupFailureRemediationEnabled
    CANCEL_TASKCHAIN_ENABLED
    "Determines whether cascading archival configuration is allowed for SLAs."
    CASCADING_ARCHIVAL_ENABLED
    CDM_CUSTOMER_ADOPTION_ENABLED
    "Determines whether centralized snapshot management is enabled."
    CENTRALIZED_SNAPSHOT_MANAGEMENT_ENABLED
    CLASSIFICATION_BANNER_ENABLED
    CLASSIFICATION_LOGIN_ENABLED
    "Enables the Cloud Cluster ES beta changes."
    CLOUD_CLUSTER_ES_BETA
    CLOUD_CLUSTER_ES_ENABLED
    CLOUD_DIRECT_ENABLED
    "Enables the cluster monitoring dashboards UI."
    CLUSTER_MONITORING_ENABLED
    "Determines whether the cluster network settings are enabled."
    CLUSTER_NETWORK_ENABLED
    "Determines whether cluster operations are enabled."
    CLUSTER_OPERATIONS_ENABLED
    "Specifies whether archival immutability is enabled for Azure native protection."
    CNP_AZURE_ARCHIVAL_IMMUTABILITY_ENABLED
    "Determines if connect as reader functionality is enabled for all storage types excluding RCV."
    CONNECT_AS_READER_ENABLED
    "Determines if connect as reader functionality is enabled for RCV storage locations."
    CONNECT_READER_ENABLED
    "Determines whether scoped upload implementation is enabled for MDS."
    CUSTOMER_SCOPED_MDS_UPLOAD_ENABLED
    CapacityReportNativeSnappableEnabled
    CardPinningEnabled
    CassandraBetaEnabled
    CdmUpgradesEnabled
    CdmUpgradesReportNgEnabled
    CertMgmtEnabled
    CloudAccountForAppFlowsEnabled
    CloudAccountsAwsUpgradePermissionEnabled
    CloudAccountsAzureUpgradePermissionEnabled
    CloudAccountsSeamlessFlowEnabled
    CloudAccountsStackSetFlowEnabled
    CloudNativeAWSEnabled
    CloudNativeAzureEnabled
    CloudNativeGCPEnabled
    CloudNativePermissionsVisibilityEnabled
    CloudNativeUnmanagedObjectsEnabled
    ClusterAddForbidden
    ClusterListFilterEnabled
    ClusterSyncJobsAlertsEnabled
    "Enables the dashboard switcher in the global header navbar."
    DASHBOARD_SWITCHER_ENABLED
    "Determines if immutable archival is enabled for data center storage locations. It does not impact RCV locations."
    DATA_CENTER_IMMUTABLE_ARCHIVAL_ENABLED
    DB2_ENABLED
    "Determine whether Data Health Recovery Center is enabled."
    DHRC_ENABLED
    DarkSiteEnabled
    DataClassificationDevEnabled
    DataClassificationEnabled
    DatagovNasAuditEnabled
    DatagovUAEnabled
    DetailedInventoryCardEnabled
    "Enables option to change upgrade type."
    ENABLE_UPGRADE_TYPE
    EnforceMoatOnAPIsEnabled
    EntitlementsAndSubscriptionsEnabled
    ExpandedGlobalSearchEnabled
    "Determines whether FedRAMP development is enabled."
    FEDRAMP_DEVELOPMENT_ENABLED
    FILTERS_V2_ENABLED
    FederatedLoginEnabled
    FederatedLoginManagementEnabled
    FilesetFeatureEnablementEnabled
    FilesetInventoryEAEnabled
    FilesetInventoryEnabled
    FilesetInventoryGAEnabled
    FilesetRbacEnabled
    GPS_DASH_V2_ENABLED
    "Determines if Polaris GPS features are enabled."
    GPS_ENABLED
    GcpNativeAutoProtectByTagsEnabled
    GcpNativeCrossProjectInstanceExport
    GcpNativeDiskProtection
    GcpNativeExportEncryptedInstances
    GcpNativeExportInstanceInStoppedState
    GcpNativeExportInstancesInSharedVPC
    GcpNativeRestoreEncryptedInstances
    GcpNativeSnapshotStorageReport
    GlobalDashboardEntryPointEnabled
    GlobalDashboardPageEnabled
    GlobalSLAForCDMSnappablesEnabled
    GlobalSLAGPSEnabled
    GoFeatureExtractionEnabled
    "Enables HyperV snappable inventory."
    HYPERV_ENABLED
    "Determines whether Radar is enabled for Hyper-V."
    HYPERV_RADAR_ENABLED
    HyperVHierarchyEnabled
    HyperVInventoryViewEnabled
    IAM_MULTITENANCY_ENABLED
    "Enables the inventory switcher in the global header navbar."
    INVENTORY_SWITCHER_ENABLED
    JobMonitoringUIEnabled
    KUPR_GA_ENABLED
    KUPR_REPLICATION_ENABLED
    KubernetesInventoryEnabled
    "Determines whether License Management UI is enabled for this account or not."
    LICENSE_MANAGEMENT_UI_ENABLED
    LambdaEnabled
    LdapEnabled
    LegalHoldEnabled
    "Determines if Managed Volume is enabled."
    MANAGED_VOLUME_ENABLED
    "Determines whether MFA / TOTOP is going to become mandatory for the account."
    MANDATORY_TOTP_ENABLED
    "Determines whether Minute level SLA frequency configuration is allowed."
    MINUTE_LEVEL_SLA_FREQUENCY_ENABLED
    MONGO_BETA_ENABLED
    "Enables the more items menu in the global header navbar."
    MORE_MENU_ENABLED
    "Determines if MS Exchange GA is enabled."
    MS_EXCHANGE_GA_ENABLED
    "Determines if MS Exchange is enabled."
    MS_EXCHANGE_INVENTORY_ENABLED
    MULTIPLE_ACCOUNT_OWNERS_ENABLED
    "Determines whether multiple archival configuration is allowed for SLAs."
    MULTIPLE_ARCHIVAL_ENABLED
    ManagedVolumeHierarchyEnabled
    MetadataIncrementalSyncEnabled
    MetadataPullerPrioritySchedulingEnabled
    MetadataSyncAdvancedMetricsEnabled
    MetadataSyncDeletionEnabled
    MetadataSyncEnabled
    MssqlBetaEnabled
    MssqlFeatureEnablementEnabled
    MssqlGAEnabled
    MssqlHierarchyEnabled
    "Enables the features for Nas Inventory."
    NAS_INVENTORY_ENABLED
    "Enables the popup based OAuth flows for O365."
    NEW_O365_AUTH_ENABLED
    NEW_THEMES_MIXED_MODE_ENABLED
    NOTES_ENABLED
    "Enables Nutanix snappable inventory."
    NUTANIX_ENABLED
    NameSplitRefreshKorgJobEnabled
    NasFilesetRbacEnabled
    NewThemesEnabled
    O365CalendarEnabled
    O365DashboardEnabled
    O365DashboardV2Enabled
    O365ExchangeAppShardingEnabled
    O365InventoryEnabled
    O365OnedriveEnabled
    O365OnedriveGAEnabled
    O365OnedriveGAOrgSlaAssigmnentEnabled
    O365SharePointEnabled
    O365SharedMailboxEnabled
    O365TeamsEnabled
    O365_ADGROUPS_ENABLED
    "Determines whether O365 Exchange Contacts is enabled."
    O365_CONTACTS_ENABLED
    O365_EXPORT_ENABLED
    O365_LICENSE_ENFORCEMENT_V1_ENABLED
    O365_OBJECT_RBAC_ENABLED
    O365_SHAREPOINT_LIST_ENABLED
    "Determines whether O365 Teams Export is enabled."
    O365_TEAMS_EXPORT_ENABLED
    O365_TEAMS_POSTS_ENABLED
    ON_PREM_PREFERENCES_ENABLED
    ObjectLevelRBACEnabled
    ObjectTypeSLAEnhancementEnabled
    OnDemandCrawlEnabled
    OnDemandSnapshotExpirationEnabled
    OnPremNotificationEnabled
    OracleHierarchyEnabled
    PACTSAFE_EULA_ENABLED
    "Determines if Rubrik cluster pause or resume protection and Global SLA Domain page to show paused clusters information features are enabled."
    PAUSE_SLA_FEEDBACK_ENABLED
    "Enables the CC-CNP unification changes."
    POLARIS2_CC_CNP_ENABLED
    POLARIS2_ONBOARDING_ENABLED
    "Determines whether promote to owner and refresh reader features are enabled for data center archival locations."
    PROMOTE_TO_OWNER_AND_REFRESH_ENABLED
    RADAR_ANOMALY_BETA_ENABLED
    "Determines Determines whether model-b is released for stage 1."
    RADAR_ANOMALY_MODEL_B_RELEASE_ENABLED
    "Determines if model-b is enabled in shadow mode for stage 1."
    RADAR_ANOMALY_MODEL_B_SHADOW_ENABLED
    "Determines whether the Radar BrowseDiffCache is enabled."
    RADAR_BROWSE_DIFF_CACHE_ENABLED
    "Enables the Radar bulk recovery flow."
    RADAR_BULK_RECOVERY_ENABLED
    RADAR_ENCRYPTION_BETA_ENABLED
    "Enables the Radar per snappable investigation flow."
    RADAR_INVESTIGATION_ENABLED
    "Determines whether the RadarQuarantine is enabled."
    RADAR_QUARANTINE_ENABLED
    "Determines whether model-b is released for stage 2."
    RADAR_RANSOMWARE_MODEL_B_RELEASE_ENABLED
    "Determines if model-b is enabled in shadow mode for stage 2."
    RADAR_RANSOMWARE_MODEL_B_SHADOW_ENABLED
    RADAR_RUN_ANOMALY_MODELB_ENABLED
    RADAR_RUN_ENCRYPTION_MODELB_ENABLED
    RADAR_WEEKLY_LIMIT_ENABLED
    RBACForCDMSnappablesEnabled
    RBACForGlobalSLAEnabled
    RCS_ENABLED
    "Determines if customer is entitled to RCV Archive."
    RCV_ARCHIVE_ENTITLEMENT_ENABLED
    "Determines if customer is entitled to RCV Backup."
    RCV_BACKUP_ENTITLEMENT_ENABLED
    RCV_CONSUMPTION
    RCV_EDIT_DELETE_PAUSE_RESUME_ENABLED
    "Determines if RCV locations are allowed as archival target for GSLA."
    RCV_GSLA_ENABLED
    "Determines if Rubrik Data Protection features are enabled."
    RDP_ENABLED
    REPLICATION_TARGETS_ENABLED
    RadarAppFlowsEnabled
    RadarDashboardEnabled
    RadarDemoEnabled
    RadarDevEnabled
    RadarDownloadCsvEnabled
    RadarSIEMEnabled
    RecoverySearchEnabled
    RemoveClusterEnabled
    ReportAsyncDownloadEnabled
    ReportForecasterEnabled
    ReportForwardUIEnabled
    ReportLastSyncedDateEnabled
    ReportPDFEnabled
    RkTableEnabled
    RollbackOnSuccessEnabled
    RollingUpgradeEnabled
    RubrikSEDemoEnabled
    "Determines if Archival in SAP HANA is enabled."
    SAP_HANA_ARCHIVAL_ENABLED
    "Determines if Replication in SAP HANA is enabled."
    SAP_HANA_REPLICATION_ENABLED
    SENTRY_PERFORMANCE_ENABLED
    SLAHierarchyEnabled
    SLASyncHighFreqEnabled
    SLA_DOMAIN_UPGRADE_ENABLED
    SLA_ONBOARDING_ENABLED
    SONAR_DASH_V2_ENABLED
    "Determines if Windows Volume Group is enabled on Sonar."
    SONAR_WINDOWS_VOLUME_GROUP_ENABLED
    SSOEnhancementEnabled
    STORAGE_LOCATIONS_ENABLED
    SapHanaInventoryEnabled
    SapHanaOnGcpEnabled
    SecureUploadEnabled
    ServiceAccountEnabled
    SkipFailedEventQueryEnabled
    SlaComplianceFilterEnabled
    SlaPauseEnabled
    SnapMirrorInventoryEnabled
    SnapshotWindowEnabled
    SonarDashEnabled
    SonarObjectFilesEnabled
    SonarReplicatedObjectsEnabled
    SonarUKAnalyzersEnabled
    SonarVMObjectsEnabled
    SonarVirtualAppliancesEnabled
    SsoEnabled
    StaticRetentionEnabled
    SystemAnnouncementsEnabled
    "A flag that evaluates to the false variant for all entities on all configurations. Used for testing feature flagging."
    TEST_FALSE_FLAG
    THEME_SWITCHER_ENABLED
    "Determines whether threat hunt views are enabled."
    THREAT_HUNT_ENABLED
    ThemedClusterCardEnabled
    UAFileCountsEnabled
    UAPermissionsTabEnabled
    UnmanagedObjectEnabled
    UserAwarenessV1Enabled
    UserAwarenessV2Enabled
    "Determines whether Radar is enabled for Volume groups."
    VOLUME_GROUP_RADAR_ENABLED
    VSphereSearchAndRecoveryRolloutEnabled
    VcdHierarchyEnabled
    "Determines if webhooks are enabled."
    WEBHOOKS_ENABLED
    WINDOWS_VOLUME_GROUP_INVENTORY_ENABLED
    WINDOWS_VOLUME_GROUP_LIVE_MOUNT_ENABLED
    WIPEnabled
    WorkflowBasedRolesEnabled
}

enum FeatureNameEnum {
    FilesetManagement
    MSSQL_MANAGEMENT
    NotSpecified
    VmwareManagement
}

enum FieldEnum {
    ALL
    IS_COMPLETE
    IS_CORRUPTED
    IS_DELETED_FROM_SOURCE
    IS_EXPIRED
    IS_HINT_SET
    IS_INDEXED
    IS_INDEX_MERGED
    IS_ON_DEMAND
    IS_REPLICA
    IS_SKIPPED_FOR_REPLICATION
    TIME_RANGE_WITH_OFFSET
}

enum FileActivitiesSortBy {
    NUM_ACTIVITIES
    USER_NAME
}

enum FileCountTypeEnum {
    ANY
    HITS
    OPEN_ACCESS
    OPEN_ACCESS_HITS
    STALE
    STALE_HITS
}

enum FileModeEnum {
    DIRECTORY
    FILE
    SYMLINK
}

enum FileRecoveryFeasibility {
    EXOCOMPUTE_NOT_CONFIGURED
    FEASIBLE
    SNAPSHOT_EXPIRED
    UNKNOWN
}

enum FileResultSortByEnum {
    CLUSTER
    DAILY_CHANGE
    FILES_WITH_HITS
    FILES_WITH_OPEN_ACCESS_HITS
    HITS
    LAST_ACCESS_TIME
    NAME
    NATIVE_PATH
    NUM_ACTIVITIES
    NUM_ACTIVITIES_DELTA
    OBJECT_LOCATION
    OBJECT_NAME
    OPEN_ACCESS_TYPE
    SNAPSHOT_TIME
    STALE_FILES_WITH_HITS
}

enum FileSystemTypeEnum {
    FILE_SYSTEM_TYPE_NTFS
    FILE_SYSTEM_TYPE_RE_FS
}

enum FileTypeEnum {
    CSV
    PDF
}

enum FileVersionSourceEnum {
    CLOUD
}

enum FilesetOSType {
    LINUX
    NO_OS_TYPE
    UNIX_LIKE
    WINDOWS
}

enum FilesetTemplateCreateOperatingSystemTypeEnum {
    FILESET_TEMPLATE_CREATE_OPERATING_SYSTEM_TYPE_UNIX_LIKE
    FILESET_TEMPLATE_CREATE_OPERATING_SYSTEM_TYPE_WINDOWS
}

enum FilesetTemplateCreateShareTypeEnum {
    FILESET_TEMPLATE_CREATE_SHARE_TYPE_NFS
    FILESET_TEMPLATE_CREATE_SHARE_TYPE_SMB
}

enum FilesetTemplatePatchOperatingSystemTypeEnum {
    FILESET_TEMPLATE_PATCH_OPERATING_SYSTEM_TYPE_UNIX_LIKE
    FILESET_TEMPLATE_PATCH_OPERATING_SYSTEM_TYPE_WINDOWS
}

enum FilesetTemplatePatchShareTypeEnum {
    FILESET_TEMPLATE_PATCH_SHARE_TYPE_NFS
    FILESET_TEMPLATE_PATCH_SHARE_TYPE_SMB
}

"All filter types in the reporting table."
enum FilterTypeEnum {
    "Cluster UUID filter."
    CLUSTER_FILTER
    "Date range picker filter."
    DATE_RANGE
    "Multiple options filter."
    MULTI_SELECT
    "Input search filter."
    SEARCH
    "Single option filter."
    SINGLE_SELECT
    "SLA domain ID filter."
    SLA_DOMAIN
}

"Fields to sort GCP native disks."
enum GcpNativeDiskSortFields {
    "Sort by SLA Domain assignment."
    ASSIGNED_SLA_DOMAIN
    "Sort by SLA Domain."
    EFFECTIVE_SLA_DOMAIN
    "Sort by GCP disk location."
    GCP_DISK_LOCATION
    "Sort by GCP disk native ID."
    GCP_DISK_NATIVE_ID
    "Sort by GCP disk native name."
    GCP_DISK_NATIVE_NAME
    "Sort by GCP project name."
    GCP_DISK_PROJECT_NAME
    "Sort by GCP disk size."
    GCP_DISK_SIZE
}

"Fields to sort GCP native GCE instances."
enum GcpNativeGceInstanceSortFields {
    "Sort by SLA Domain assignment."
    ASSIGNED_SLA_DOMAIN
    "Sort by SLA Domain."
    EFFECTIVE_SLA_DOMAIN
    "Sort by GCP instance native ID."
    GCP_INSTANCE_NATIVE_ID
    "Sort by GCP instance native name."
    GCP_INSTANCE_NATIVE_NAME
    "Sort by network name."
    GCP_INSTANCE_NETWORK_NAME
    "Sort by GCP project name."
    GCP_INSTANCE_PROJECT_NAME
    "Sort by GCP region."
    GCP_INSTANCE_REGION
    "Sort by GCP instance type."
    GCP_INSTANCE_TYPE
}

"GCP native label filter type."
enum GcpNativeLabelFilterType {
    "Filter by label key."
    LABEL_KEY
    "Filter by label key and value."
    LABEL_KEY_VALUE
}

"Fields to sort GCP native projects."
enum GcpNativeProjectSortFields {
    "Sort by SLA Domain."
    EFFECTIVE_SLA_DOMAIN
    "Sort by disk count."
    GCP_PROJECT_DISK_COUNT
    "Sort by GCE instance count."
    GCP_PROJECT_INSTANCE_COUNT
    "Sort by GCP project native ID."
    GCP_PROJECT_NATIVE_ID
    "Sort by GCP project number."
    GCP_PROJECT_NUMBER
    "Sort by GCP project native name."
    GCP_PROJECT_ORG_NAME
    "Sort by GCP project name."
    NAME
}

enum GcpNativeProjectStatusEnum {
    Deleted
    Deleting
    DeletionFailed
    Refreshed
    Refreshing
}

enum GcpRegionEnum {
    ASIA
    ASIA1
    ASIA_EAST1
    ASIA_EAST2
    ASIA_NORTHEAST1
    ASIA_NORTHEAST2
    ASIA_NORTHEAST3
    ASIA_SOUTH1
    ASIA_SOUTHEAST1
    ASIA_SOUTHEAST2
    AUSTRALIA_SOUTHEAST1
    EU
    EUR4
    EUROPE_NORTH1
    EUROPE_WEST1
    EUROPE_WEST2
    EUROPE_WEST3
    EUROPE_WEST4
    EUROPE_WEST6
    NAM4
    NORTHAMERICA_NORTHEAST1
    SOUTHAMERICA_EAST1
    UNKNOWN_GCP_REGION
    US
    USCENTRAL1
    USEAST1
    USEAST4
    USWEST1
    USWEST2
    US_WEST3
    US_WEST4
}

enum GcpStorageClassTypeEnum {
    COLDLINE_GCP
    DURABLE_REDUCED_AVAILABILITY_GCP
    NEARLINE_GCP
    STANDARD_GCP
    UNKNOWN_STORAGE_CLASS_GCP
}

"Available options for retention for existing snapshots"
enum GlobalExistingSnapshotRetentionEnum {
    "Expire immediately"
    EXPIRE_IMMEDIATELY
    "Keep forever"
    KEEP_FOREVER
    NOT_APPLICABLE
    "Preserve retention from previous SLA"
    RETAIN_SNAPSHOTS
}

enum GlobalSlaQueryFilterInputField {
    "Filter SLA Domains for assigned to this Archival group."
    ARCHIVAL_GROUP_ID
    "Filter SLA Domains for assigned to this Archival location."
    ARCHIVAL_LOCATION_ID
    "Filter by Rubrik cluster."
    CLUSTER_UUID
    "Filter SLA Domains eligible for upgrade."
    IS_ELIGIBLE_FOR_UPGRADE
    "Filter by SLA Domain name."
    NAME
    "Filter by object type."
    OBJECT_TYPE
    "Get all Global and cluster SLA Domains."
    SHOW_ALL_RUBRIK_AND_APPLIANCE_SLAS
    "Filter SLA Domains for this Rubrik cluster."
    SHOW_CLUSTER_SLAS_ONLY
    "Filter by SLA Domain upgrade status."
    UPGRADE_STATUS
}

enum GroupByFieldEnum {
    Analyzer
    Cluster
    ClusterType
    ClusterUuid
    ComplianceStatus
    Day
    FailoverStatus
    FailoverType
    File
    Hour
    IsAnomaly
    LastActivityStatus
    LastActivityType
    LastTestStatus
    ManagedId
    Month
    Object
    ObjectName
    ObjectType
    POLICY_VIOLATIONS
    Policy
    ProtectionStatus
    PullTimeWithOffset
    Quarter
    SLADomain
    STATUS_POLICY
    SlaDomain
    Source
    Status
    TIME_ISSUES
    TIME_VIOLATIONS
    TargetSite
    TaskDetailClusterType
    TaskDetailObjectType
    Time
    Type
    UserAuditStatus
    UserAuditType
    Week
    Year
}

enum GuestCredentialAuthorizationStatusEnum {
    FAILED
    PENDING
    SUCCESSFUL
}

enum GuestOSEnum {
    CENTOS
    RHEL
    UBUNTU
    UNKNOWN
    WINDOWS
}

"The guest operating system"
enum GuestOsTypeEnum {
    "Linux Operating System"
    Linux
    "Unknown Guest OS type"
    Unknown
    "Windows Operating System"
    Windows
}

enum HashTypeEnum {
    HASH_TYPE_M_D5
    HASH_TYPE_SH_A1
    HASH_TYPE_SH_A256
}

enum HierarchyFilterField {
    "Filter AWS native accounts based on the features enabled for them."
    AWS_NATIVE_ACCOUNT_ENABLED_FEATURE
    "Filter by AWS account ID."
    AWS_NATIVE_ACCOUNT_ID
    """

    ID of the AWS native EC2 instance (Rubrik ID), applicable for filtering
    EBS volumes with their EC2 instance IDs. Applicable only if the object
    type is AwsNativeEbsVolume
    """
    AWS_NATIVE_EC2_INSTANCE_ID
    "Filter by RDS Instace DB Engine"
    AWS_NATIVE_RDS_DB_ENGINE
    "Filter by RDS Instance DB Instance Class"
    AWS_NATIVE_RDS_DB_INSTANCE_CLASS
    """

    Filter by AWSAccount.aws_region_spec.region, EC2Instance.region, and
    EBSVolume.region
    """
    AWS_REGION
    "Filter by aws_native_tags"
    AWS_TAG
    "Filter by VPC ID"
    AWS_VPC_ID
    "Filter Azure disks by ID of the attached virtual machine"
    AZURE_DISK_ATTACHED_VM
    "Filter Azure disks by common resource group name"
    AZURE_DISK_CRG_NAME
    "Filter Azure disks on subscription ID of common resource group"
    AZURE_DISK_CRG_SUBSCRIPTION_ID
    "Filter Azure disks on Disk size"
    AZURE_DISK_SIZE
    """

    Filter Azure disks by subscription ID
    todo (SPARK-88655): remove usage of VMRG and DiskRG
    """
    AZURE_DISK_SUBSCRIPTION_ID
    "Filter Azure disks on Disk type"
    AZURE_DISK_TYPE
    "Filters Azure disks whose regions have a \"CONNECTED\" exocompute."
    AZURE_NATIVE_DISK_EXOCOMPUTE_CONNECTED
    "Filter by the \"indexing status\" of Azure disks."
    AZURE_NATIVE_DISK_INDEXING_STATUS
    "Filter Azure native subscriptions based on the features enabled for them."
    AZURE_NATIVE_SUBSCRIPTION_ENABLED_FEATURE
    "Filters Azure virtual machines whose regions have a \"CONNECTED\" exocompute."
    AZURE_NATIVE_VM_EXOCOMPUTE_CONNECTED
    "Filter by the \"indexing status\" of Azure VMs."
    AZURE_NATIVE_VM_INDEXING_STATUS
    """

    Filter by AzureSubscription.region_spec.region, AzureResourceGroup.region,
    AzureVm.Region and AzureDisk.region
    """
    AZURE_REGION
    "Filter Azure resource groups by disk SLA or virtual machine SLA"
    AZURE_RG_DISK_OR_VM_SLA
    """

    Filter Azure Resource Groups by SLAs of given workload types.
    SLAs need to be passed as "texts" and workload types need to be
    passed as "object_type_filter_params".
    Note: When using this filter for more than two types of workloads,
    test the performance for large data sizes because internally the operation performs
    some heavy joins to filter the results.
    """
    AZURE_RG_SNAPPABLE_TYPES_SLA
    "Filter Azure resource groups on subscription ID"
    AZURE_RG_SUBSCRIPTION_ID
    "Filter Azure SQL Databases on resource group name"
    AZURE_SQL_DB_RG_NAME
    "Filter Azure SQL Database Servers on resource group name"
    AZURE_SQL_DB_SERVER_RG_NAME
    "Filter Azure SQL Database Servers on subscription ID"
    AZURE_SQL_DB_SERVER_SUBSCRIPTION_ID
    "Filter Azure SQL Databases on subscription ID"
    AZURE_SQL_DB_SUBSCRIPTION_ID
    "Filter Azure SQL Managed Instance Databases on resource group name"
    AZURE_SQL_MI_DB_RG_NAME
    "Filter Azure SQL Managed Instances Databases on subscription ID"
    AZURE_SQL_MI_DB_SUBSCRIPTION_ID
    "Filter Azure SQL Managed Instance Database Servers on resource group name"
    AZURE_SQL_MI_SERVER_RG_NAME
    "Filter Azure SQL Managed Instances Database Servers on subscription ID"
    AZURE_SQL_MI_SERVER_SUBSCRIPTION_ID
    "Filter by azure_native_tags."
    AZURE_TAG
    "Filter Azure virtual machines on common resource group name"
    AZURE_VM_CRG_NAME
    "Filter Azure virtual machines on subscription ID of common resource group"
    AZURE_VM_CRG_SUBSCRIPTION_ID
    "Filter Azure virtual machines on virtual machine size"
    AZURE_VM_SIZE
    """

    Filter Azure virtual machines on subscription ID
    todo (SPARK-88655): remove usage of VMRG and DiskRG
    """
    AZURE_VM_SUBSCRIPTION_ID
    "Filter Azure virtual machines on VNet name"
    AZURE_VNET_NAME
    "Filter by ID of parent Cassandra Keyspace"
    CASSANDRA_KEYSPACE_ID
    "Filter by ID of parent Cassandra Source"
    CASSANDRA_SOURCE_ID
    "Filter by status of CassandraSource."
    CASSANDRA_SOURCE_STATUS
    "Filter cloud instance physical host by descendant object type."
    CLOUD_INSTANCE_HOST_DESCENDANT_OBJECT_TYPE
    "Filter cloud native databases using server name"
    CLOUD_NATIVE_SERVER_NAME_FILTER
    "Filter Rubrik CDM objects by cluster ID."
    CLUSTER_ID
    "Filter clusters by the ClusterTypeEnum"
    CLUSTER_TYPE
    "Filter based on fid of DB2 instance."
    DB2_INSTANCE_ID
    "Filter by status of Db2Instance"
    DB2_INSTANCE_STATUS
    """

    Filter NAS volumes based on whether they are associated
    with a SnapMirror Cloud object.
    """
    DOES_NAS_VOLUME_HAVE_SMC
    "Filter physical hosts that have protected volume group"
    DOES_PHYSICAL_HOST_HAVE_PROTECTED_VOLUME_GROUP
    "Filter by relic filesets of a physical host"
    DOES_PHYSICAL_HOST_HAVE_RELIC_FILESETS
    "Filter by relic volume group of a physical host"
    DOES_PHYSICAL_HOST_HAVE_RELIC_VOLUME_GROUP
    "Filter whether the sharepoint is relic or contains relic object"
    DOES_SHAREPOINT_HAVE_RELIC_OBJECTS
    "Filter by EBSVolume native ID"
    EBS_VOLUME_ID
    "Filter EBS Volumes by status of indexing."
    EBS_VOLUME_INDEXING_STATUS
    "Filter by EBSVOlume.name"
    EBS_VOLUME_NAME
    "Filter by EBS volume name or volume ID"
    EBS_VOLUME_NAME_OR_VOLUME_ID
    "Filter by EbsVolume.type"
    EBS_VOLUME_TYPE
    "Filter by EC2Instance native ID"
    EC2_INSTANCE_ID
    """

    Filter EC2 Instances by status of indexing. Possible values for
    filter are generated strings from AwsIndexingStatusFilter enum.
    """
    EC2_INSTANCE_INDEXING_STATUS
    "Filter by EC2Instance.name"
    EC2_INSTANCE_NAME
    "Filter by EC2 instance name or instance ID"
    EC2_INSTANCE_NAME_OR_INSTANCE_ID
    "Filter by Ec2Instance.type"
    EC2_INSTANCE_TYPE
    EFFECTIVE_SLA
    """

    Filter to include or exclude objects with a specific effective SLA
    source object.
    """
    EFFECTIVE_SLA_SOURCE_OBJECT
    "Filter by the SLA type of the effective SLA"
    EFFECTIVE_SLA_TYPE
    "Filter Exchange Databases by the ID of the Exchange Dag."
    EXCHANGE_DATABASE_BY_DAG_ID
    "Filter Exchange Databases by the ID of the Exchange Host."
    EXCHANGE_DATABASE_BY_HOST_ID
    "Filter Exchange Databases by the ID of the Exchange Server."
    EXCHANGE_DATABASE_BY_SERVER_ID
    "Filter by the ID of Failover cluster app"
    FAILOVER_CLUSTER_APP_ID
    "Filter by ID of parent of Failover Cluster"
    FAILOVER_CLUSTER_ID
    "Filter physical hosts by SLAs attached to their filesets."
    FILESET_SLA
    """

    Filter physical hosts by which fileset templates are attached
    to them.
    """
    FILESET_TEMPLATE_ID
    "Filter fileset templates by OS Type"
    FILESET_TEMPLATE_OS_TYPE
    "Filter by gcp_native_labels"
    GCP_LABEL
    "Filter by GCP Disk location (for regional disk: location=region, for zonal disk: location=zone)"
    GCP_NATIVE_DISK_LOCATION
    "Filter by GCP Disk name or native ID"
    GCP_NATIVE_DISK_NAME_OR_NATIVE_ID
    "Filter by GCP Disk project name"
    GCP_NATIVE_DISK_PROJECT
    """

    Filter by GCP Disk type
    Text of the GCP_DISK_TYPE can have one of the following values:
    regional-pd-ssd regional-pd-standard regional-pd-balanced
    zonal-pd-ssd zonal-pd-standard zonal-pd-balanced
    """
    GCP_NATIVE_DISK_TYPE
    "Filter by GCP instance native ID or name"
    GCP_NATIVE_INSTANCE_NAME_OR_NATIVE_ID
    "Filter by GCP Instance Network Name"
    GCP_NATIVE_INSTANCE_NETWORK_NAME
    "Filter by GCP instance type"
    GCP_NATIVE_INSTANCE_TYPE
    "Filter by GCP project ID for GCE instances"
    GCP_NATIVE_PROJECT_ID
    "Filter by GCP project name or project number"
    GCP_NATIVE_PROJECT_NAME_OR_PROJECT_NUMBER
    "Filter GCP projects by their native ID"
    GCP_NATIVE_PROJECT_NATIVE_ID
    "Filter by GCP region"
    GCP_NATIVE_REGION
    "Filter VSphere virtual machines by guest OS type for file export"
    GUEST_OS_TYPE_FOR_FILE_RESTORE
    "Filter if a workload has parent workload."
    HAS_PARENT_SNAPPABLE
    "Filter hosts based on CBT status."
    HOST_CBT_STATUS
    "Filter the hosts by their Operating System"
    HOST_OPERATING_SYSTEM
    """

    Return only the workloads that are active.
    An active workload is a workload that is without a workload group or
    workload with the highest primary sequence number in the workload group
    """
    IS_ACTIVE
    IS_ARCHIVED
    "Filter archived and non-relic managed-objects."
    IS_GHOST
    "Filter by status of a fileset protection on cdm host."
    IS_HOST_PROTECTED
    "Workload must not be a member of any active bluprint"
    IS_NOT_BLUEPRINT_CHILD
    "Filter by whether object is protected by an SLA Domain."
    IS_PROTECTED
    IS_RELIC
    IS_REPLICATED
    """

    Filter Kubernetes clusters based on associated Rubrik cluster
    Since KuprCluster is natively polaris Managed Object, a separate filter is used
    """
    KUPR_CDM_CLUSTER_ID
    "Filter Kubernetes clusters based on connection status"
    KUPR_CLUSTER_STATUS
    """

    Filter Kubernetes namespaces based on the associated Rubrik cluster of the parent.
    Since KuprNamespace is natively polaris Managed Object, a separate filter is used
    """
    KUPR_NAMESPACE_CDM_CLUSTER_ID
    "Filter Kubernetes namespace based on the connection status of the parent."
    KUPR_NAMESPACE_CLUSTER_STATUS
    "Filter by location or path of an object"
    LOCATION
    "Filter Managed Volume Type."
    MANAGED_VOLUME_TYPE
    "Filter by ID of parent MongoDB Keyspace."
    MONGODB_DATABASE_ID
    "Filter by ID of parent MongoDB Source."
    MONGODB_SOURCE_ID
    "Filter by status of MongoDB Source."
    MONGODB_SOURCE_STATUS
    NAME
    """

    There is already a filter called NAME which filters for all the rows
    where name is "LIKE" the provided string. We have a use-case in
    Azure where we would like to Filter by name but exact-match, not just
    similar match. The use case is that resource groups are identified by
    the tuple of subscription ID and resource group name, similarity
    measure will not distinguish between two similar names.
    """
    NAME_EXACT_MATCH
    "Filter by name or email-address of O365 user."
    NAME_OR_EMAIL_ADDRESS
    "Filter by the ID of the NAS namespace."
    NAS_NAMESPACE_ID
    """

    Filter by the SLA Domain of the SnapMirror Cloud objects under
    the NAS volume.
    """
    NAS_VOLUME_EFFECTIVE_SLA
    """

    O365 specific type: O365_SHARED_USER, O365_SHARED_MAILBOX...This filter is
    introduced to support api-server since it is not convenient to add object-specific
    subtype knowledge there. To query for shared users, we can either:
    1. Specify O365_USER in object type AND this filter with value O365_SHARED_USER
    (api-server way)
    2. Specify O365_SHARED_USER in object type, ignore this filter
    (others should do this)
    """
    O365_SPECIFIC_TYPE
    "Filter by software version of the cluster"
    ON_OR_ABOVE_CLUSTER_VERSION
    "Filter physical hosts by OS name"
    OS_NAME
    "Filter physical hosts by OS type"
    OS_TYPE
    "Filter physical host by cloud instance id."
    PHYSICAL_HOST_BY_CLOUD_INSTANCE_ID
    "Filter by the SLA Domain of the volume group of the physical host."
    PHYSICAL_HOST_BY_VOLUME_GROUP_EFFECTIVE_SLA
    "Filter by the RBS status of the physical host."
    PHYSICAL_HOST_CONNECTION_STATUS
    "Filter by the SLA Domain of the host filesets."
    PHYSICAL_HOST_EFFECTIVE_SLA
    """

    tag_filter_params field.
    Filter by the ID of a Physical Host
    """
    PHYSICAL_HOST_ID
    "Filter by the name by a given regex expression"
    REGEX
    "Filter by the ID of parent SAP HANA system"
    SAP_HANA_SYSTEM_ID
    "Filter by SID of SapHanaSystem"
    SAP_HANA_SYSTEM_SID
    "Filter by status of SapHanaSystem"
    SAP_HANA_SYSTEM_STATUS
    "Filter based on type of database in UDF schema."
    UDF_DATABASE_TYPE
    "Filter isLocal of virtualhost.descendant"
    VSPHERE_DATASTORE_IS_LOCAL
    """

    Filter for the the root level of compute resources for the restore
    hierarchy, which includes compute clusters and standalone hosts.
    """
    VSPHERE_GET_ROOT_RESTORE_HIERARCHY
}

"Type of hierarchy object."
enum HierarchyObjectTypeEnum {
    "AppFlows Recovery Plan."
    APPFLOWS_RECOVERY_PLAN
    AZURE_SQL_DATABASE_DB
    AZURE_SQL_MANAGED_INSTANCE_DB
    AllSubHierarchyType
    AppBlueprint
    AppflowsBlueprint
    AwsNativeAccount
    AwsNativeEbsVolume
    AwsNativeEc2Instance
    AwsNativeRdsInstance
    AzureNativeManagedDisk
    AzureNativeResourceGroup
    AzureNativeSubscription
    AzureNativeVm
    AzureSqlDatabaseServer
    AzureSqlManagedInstanceServer
    Blueprint
    CassandraColumnFamily
    CassandraKeyspace
    CassandraSource
    CloudNativeTagRule
    Db2Database
    Db2Instance
    "Exchange DAG."
    EXCHANGE_DAG
    "Exchange Server."
    EXCHANGE_SERVER
    Ec2Instance
    "Exchange Database."
    ExchangeDatabase
    "Failover Cluster App."
    FAILOVER_CLUSTER_APP
    FeldsparSite
    Fileset
    FilesetTemplate
    GcpNativeDisk
    GcpNativeGCEInstance
    GcpNativeProject
    "Host Failover Cluster."
    HOST_FAILOVER_CLUSTER
    Hdfs
    HostShare
    HypervCluster
    HypervSCVMM
    HypervServer
    HypervVirtualMachine
    KuprCluster
    KuprNamespace
    LinuxFileset
    "Managed Volume Export."
    MANAGED_VOLUME_EXPORT
    "MongoDB Collection."
    MONGODB_COLLECTION
    "MongoDB Database."
    MONGODB_DATABASE
    "MongoDB Source Cluster."
    MONGODB_SOURCE
    "Managed Volume."
    ManagedVolume
    MongoCollection
    MongoDb
    MongoSource
    Mssql
    MssqlAvailabilityGroup
    MssqlDatabaseBatchMaintenance
    MssqlInstance
    NasNamespace
    NasShare
    NasSystem
    NasVolume
    NutanixCluster
    NutanixVirtualMachine
    O365Calendar
    O365File
    O365Group
    O365Mailbox
    O365Onedrive
    O365Org
    O365SharePointDrive
    O365SharePointList
    O365Site
    O365Teams
    O365User
    OracleDatabase
    OracleHost
    OracleRac
    PhysicalHost
    PolarisEbsVolume
    PolarisEc2Instance
    SapHanaDatabase
    SapHanaSystem
    ShareFileset
    SnapMirrorCloud
    StorageArrayVolumeGroup
    "VSphere Datastore cluster."
    VSPHERE_DATASTORE_CLUSTER
    VSphereComputeCluster
    VSphereDatacenter
    VSphereDatastore
    VSphereFolder
    VSphereHost
    VSphereNetwork
    VSphereResourcePool
    VSphereTag
    VSphereTagCategory
    VSphereVCenter
    Vcd
    VcdCatalog
    VcdOrg
    VcdOrgVdc
    VcdVapp
    VcdVimServer
    VmwareVirtualMachine
    VolumeGroup
    WindowsCluster
    WindowsFileset
    WindowsVolumeGroup
}

enum HierarchySortByField {
    ASSIGNED_SLA_DOMAIN
    AWS_NATIVE_ACCOUNT_NAME
    AWS_NATIVE_RDS_DB_ENGINE
    AWS_NATIVE_RDS_DB_INSTANCE_CLASS
    AWS_REGION
    AWS_VPC_ID
    AZURE_DISK_ATTACHED_VM
    AZURE_DISK_CRG_NAME
    AZURE_DISK_CRG_SUBSCRIPTION_NAME
    AZURE_DISK_SIZE
    AZURE_DISK_TYPE
    AZURE_REGION
    AZURE_RG_DISKCOUNT
    AZURE_RG_DISK_EFFECTIVE_SLA
    AZURE_RG_SQL_DATABASE_DB_EFFECTIVE_SLA
    AZURE_RG_SQL_MANAGED_INSTANCE_DB_EFFECTIVE_SLA
    AZURE_RG_SUBSCRIPTION_NAME
    AZURE_RG_VMCOUNT
    AZURE_RG_VM_EFFECTIVE_SLA
    AZURE_SQL_DATABASE_DB_REGION
    AZURE_SQL_DATABASE_SERVER_REGION
    AZURE_SQL_DB_RESOURCE_GROUP
    AZURE_SQL_MANAGED_INSTANCE_DB_REGION
    AZURE_SQL_MANAGED_INSTANCE_SERVER_REGION
    AZURE_SQL_SERVER_RESOURCE_GROUP
    AZURE_SUBNET_NAME
    AZURE_SUBSCRIPTION_DISKCOUNT
    AZURE_SUBSCRIPTION_VMCOUNT
    AZURE_TENANT_ID
    AZURE_VM_CRG_NAME
    AZURE_VM_CRG_SUBSCRIPTION_NAME
    AZURE_VM_SIZE
    AZURE_VNET_NAME
    "Sort DB2 Instance based on instance ID"
    DB2_INSTANCE_ID
    EBS_VOLUME_COUNT
    EBS_VOLUME_ID
    EBS_VOLUME_NAME
    EBS_VOLUME_SIZE
    EBS_VOLUME_TYPE
    EC2_INSTANCE_COUNT
    EC2_INSTANCE_ID
    EC2_INSTANCE_NAME
    EC2_INSTANCE_TYPE
    EFFECTIVE_SLA_DOMAIN
    EMAIL_ADDRESS
    FILESET_TEMPLATE_DOES_NOT_EXCLUDE
    FILESET_TEMPLATE_EXCLUDES
    FILESET_TEMPLATE_INCLUDES
    GCP_DISK_LOCATION
    GCP_DISK_NATIVE_ID
    GCP_DISK_NATIVE_NAME
    GCP_DISK_PROJECT_NAME
    GCP_DISK_SIZE
    GCP_INSTANCE_NATIVE_ID
    GCP_INSTANCE_NATIVE_NAME
    GCP_INSTANCE_NETWORK_NAME
    GCP_INSTANCE_PROJECT_NAME
    GCP_INSTANCE_REGION
    GCP_INSTANCE_TYPE
    GCP_PROJECT_DISK_COUNT
    GCP_PROJECT_INSTANCE_COUNT
    GCP_PROJECT_NATIVE_ID
    GCP_PROJECT_NUMBER
    GCP_PROJECT_ORG_NAME
    ID
    MSSQL_AVAILABILITY_GROUP_COPY_ONLY
    MSSQL_DATABASE_COPY_ONLY
    "Sort MSSQL failover clusters by database count."
    MSSQL_FAILOVER_DATABASE_COUNT
    "Sort MSSQL hosts by number of databases."
    MSSQL_HOST_DB_COUNT
    MSSQL_HOST_INSTANCE_COUNT
    "Sort MSSQL instances by number of databases."
    MSSQL_INSTANCE_DB_COUNT
    NAME
    PHYSICAL_HOST_CONNECTION_STATUS
    PHYSICAL_HOST_OS_NAME
    SAP_HANA_SYSTEM_SID
    SAP_HANA_SYSTEM_STATUS
    VSPHERE_DATASTORE_CAPACITY
    VSPHERE_DATASTORE_FREE_SPACE
    VSPHERE_DATASTORE_TYPE
}

enum HierarchySortOrder {
    ASC
    DESC
}

enum HostConnectivityStatusEnum {
    BADLY_CONFIGURED
    CONNECTED
    CONNECTING
    CONNECTOR_NOT_DEPLOYED
    DELETED
    DELETING
    DELETION_FAILED
    DISCONNECTED
    PARTIALLY_CONNECTED
    REFRESHING
    REFRESH_FAILED
    REMOTE
    REPLICATED_TARGET
    SECONDARY_CLUSTER
    UNKNOWN_CONNECTIVITY_STATUS
}

enum HostFailoverClusterRoot {
    LINUX_HOST_ROOT
    WINDOWS_HOST_ROOT
}

enum HostRoot {
    LINUX_HOST_ROOT
    NAS_HOST_ROOT
    WINDOWS_HOST_ROOT
}

enum HostVfdInstallConfigEnum {
    HOST_VFD_INSTALL_CONFIG_DISABLED
    HOST_VFD_INSTALL_CONFIG_ENABLED
}

enum HostVfdStateEnum {
    HOST_VFD_STATE_INSTALLED
    HOST_VFD_STATE_INSTALLED_BUT_RESTART_REQUIRED
    HOST_VFD_STATE_NOT_INSTALLED
    HOST_VFD_STATE_UNINSTALLED_BUT_RESTART_REQUIRED
}

"The connection status of HyperV Host server."
enum HyperVHostStatusType {
    "HyperV Host is Connected."
    CONNECTED
    "HyperV Host is Connecting."
    CONNECTING
    "HyperV Host is Deleted."
    DELETED
    "HyperV Host is Deleting."
    DELETING
    "HyperV Host is Disconnected."
    DISCONNECTED
    "HyperV Host is Refreshing."
    REFRESHING
    "HyperV Host status could not be parsed."
    UNKNOWN
}

"Filter for hyper-v live mount results."
enum HyperVLiveMountFilterField {
    "Cluster UUID filter for hyper-v live mount results."
    CLUSTER_UUID
    "Mount Name filter for live mount results."
    MOUNT_NAME
    "Filter is not specified. Any filter text would not be considered."
    UNSPECIFIED
}

"Sort by parameters for hyper-v live mount results."
enum HyperVLiveMountSortByField {
    "Sort by Cluster Name."
    CLUSTER_NAME
    "Sort by Mount Creation Date."
    CREATION_DATE
    "Sort by Mount Name."
    MOUNT_NAME
    "Sort by field is not specified. Any filter text would not be considered."
    UNSPECIFIED
}

"The connection status of HyperV Host server."
enum HypervMountedVmStatusType {
    "HyperV Mount is Powered Off."
    POWEREDOFF
    "HyperV Mount is Powered On."
    POWEREDON
    "HyperV Mount is Powering Off."
    POWERINGOFF
    "HyperV Mount is Powering On."
    POWERINGON
    "HyperV Mount Vm status could not be parsed."
    UNKNOWN
}

enum HypervVirtualMachineMountSummaryPowerStatusEnum {
    HYPERV_VIRTUAL_MACHINE_MOUNT_SUMMARY_POWER_STATUS_POWERED_OFF
    HYPERV_VIRTUAL_MACHINE_MOUNT_SUMMARY_POWER_STATUS_POWERED_ON
    HYPERV_VIRTUAL_MACHINE_MOUNT_SUMMARY_POWER_STATUS_POWERING_OFF
    HYPERV_VIRTUAL_MACHINE_MOUNT_SUMMARY_POWER_STATUS_POWERING_ON
}

"Supported Indicators Of Compromise are Yara, File Hash, and File Pattern."
enum IndicatorOfCompromiseKind {
    "Matching file patterns."
    IOC_FILE_PATTERN
    "Match for files with specified hash."
    IOC_HASH
    "Unused default."
    IOC_UNSPECIFIED
    "Matching Yara rules."
    IOC_YARA
}

enum IndicatorOfCompromiseTypeEnum {
    INDICATOR_OF_COMPROMISE_TYPE_HASH
    INDICATOR_OF_COMPROMISE_TYPE_PATH_OR_FILENAME
    INDICATOR_OF_COMPROMISE_TYPE_YARA_RULE
}

enum InfrastructureTableColumnEnum {
    ClusterName
    ClusterType
    EncryptionEnabled
    EstimatedRunway
    Location
    TotalCapacity
    UsedCapacity
}

enum InodeTypeEnum {
    DIRECTORY
    FILE
    UNKNOWN_INODE
}

"Instance type of the location."
enum InstanceTypeEnum {
    "Azure China instance type."
    AZURE_CHINA
    "Azure Default instance type."
    AZURE_DEFAULT
    "Azure Germany instance type."
    AZURE_GERMANY
    "Azure Government instance type."
    AZURE_GOVERNMENT
    "Instance type of location is unknown."
    UNKNOWN_INSTANCE
}

enum InterfaceTypeEnum {
    BOND0
    BOND1
    CUSTOM
    UNKNOWN_TYPE
}

enum InternalDeleteHypervVirtualMachineSnapshotRequestLocationEnum {
    INTERNAL_DELETE_HYPERV_VIRTUAL_MACHINE_SNAPSHOT_REQUEST_LOCATION_ALL
    INTERNAL_DELETE_HYPERV_VIRTUAL_MACHINE_SNAPSHOT_REQUEST_LOCATION_LOCAL
}

enum InternalDeleteNutanixSnapshotRequestLocationEnum {
    INTERNAL_DELETE_NUTANIX_SNAPSHOT_REQUEST_LOCATION_ALL
    INTERNAL_DELETE_NUTANIX_SNAPSHOT_REQUEST_LOCATION_LOCAL
}

enum InternalQueryHypervHostRequestSlaAssignmentEnum {
    INTERNAL_QUERY_HYPERV_HOST_REQUEST_SLA_ASSIGNMENT_DERIVED
    INTERNAL_QUERY_HYPERV_HOST_REQUEST_SLA_ASSIGNMENT_DIRECT
    INTERNAL_QUERY_HYPERV_HOST_REQUEST_SLA_ASSIGNMENT_UNASSIGNED
}

enum InternalQueryHypervHostRequestSortByEnum {
    INTERNAL_QUERY_HYPERV_HOST_REQUEST_SORT_BY_EFFECTIVE_SLA_DOMAIN_NAME
    INTERNAL_QUERY_HYPERV_HOST_REQUEST_SORT_BY_NAME
}

enum InternalQueryHypervHostRequestSortOrderEnum {
    INTERNAL_QUERY_HYPERV_HOST_REQUEST_SORT_ORDER_ASC
    INTERNAL_QUERY_HYPERV_HOST_REQUEST_SORT_ORDER_DESC
}

"Inventory Card options that the user can select as a workload."
enum InventoryCard {
    "Inventory Card is AHV VMS."
    AHV_VMS_CDM
    "Inventory Card is AWS EC2."
    AWS_EC2
    "Inventory Card is AWS RDS."
    AWS_RDS
    "Inventory Card is Azure Virtual Machines."
    AZURE
    "Inventory Card is Azure SQL Databases."
    AZURE_SQL_DB
    "Inventory Card is Azure SQL Managed Instances."
    AZURE_SQL_MI
    "Inventory Card is Cassandra."
    CASSANDRA
    "Inventory Card is DB2."
    DB2
    "Inventory Card is Exchange."
    EXCHANGE
    "Inventory Card is GCP."
    GCP
    "Inventory Card is HyperV."
    HYPERV
    "Inventory Card is HyperV CDM."
    HYPERV_VMS_CDM
    "Inventory Card is Kubernetes."
    KUBERNETES
    "Inventory Card is Linux Filesets."
    LINUX_UNIX_FILESETS
    "Inventory Card is Linux Hosts."
    LINUX_UNIX_HOSTS_CDM
    "Inventory Card is Managed Volumes."
    MANAGED_VOLUMES
    "Inventory Card is Managed Volumes CDM."
    MANAGED_VOLUMES_CDM
    "Inventory Card is Microsoft 365."
    MICROSOFT_365
    "Inventory Card is MongoDB."
    MONGODB
    "Inventory Card is MSSQL."
    MSSQL
    "Inventory Card is NAS Shares."
    NAS_SHARES
    "Inventory Card is NAS Shares CDM."
    NAS_SHARES_CDM
    "Inventory Card is Nutanix AHV."
    NUTANIX_AHV
    "Inventory Card is Oracle."
    ORACLE
    "Inventory Card is Oracle DBs."
    ORACLE_DBS_CDM
    "Inventory Card is Sap Hana."
    SAP_HANA
    "Inventory Card is Snapmirror."
    SNAPMIRROR
    "Inventory Card is SQL Server DBs."
    SQL_SERVER_DBS_CDM
    "Inventory Card is VCD vApps."
    VCD_VAPPS_CDM
    "Inventory Card is vSphere."
    VSPHERE
    "Inventory Card is vSphere VMs."
    VSPHERE_VMS_CDM
    "Inventory Card is Windows Filesets."
    WINDOWS_FILESETS
    "Inventory Card is Windows Hosts."
    WINDOWS_HOSTS_CDM
    "Inventory Card is Windows Volume Group."
    WINDOWS_VOLUME_GROUP
}

enum InventorySubHierarchyRootEnum {
    APPFLOWS_ROOT
    AWSNATIVE_ROOT
    AZURENATIVE_ROOT
    CASSANDRA_ROOT
    CLOUD_NATIVE_TAG_RULE_ROOT
    DB2_ROOT
    "Root of exchange hierarchy."
    EXCHANGE_ROOT
    FELDSPAR_ROOT
    GCPNATIVE_ROOT
    HYPERV_ROOT
    KUPR_ROOT
    LINUX_HOST_ROOT
    MANAGED_VOLUME_ROOT
    MONGODB_ROOT
    MONGO_ROOT
    MSSQL_ROOT
    NAS_HOST_ROOT
    NAS_ROOT
    NUTANIX_ROOT
    O365_ROOT
    ORACLE_ROOT
    PHYSICAL_HOST_ROOT
    SAP_HANA_ROOT
    VCD_ROOT
    VSPHERE_ROOT
    WINDOWS_HOST_ROOT
}

enum IssueEventTypeEnum {
    ADD_WHITELIST_EVENT
    CREATE_EVENT
    DELETE_POLICY_EVENT
    NO_ISSUES_SNAPSHOT_EVENT
    REMOVE_POLICY_OBJ_EVENT
    REMOVE_WHITELIST_EVENT
    SNAPSHOT_EVENT
}

enum IssueStatusEnum {
    OPEN
    RESOLVED
}

enum K8sClusterDBType {
    AWS
    Azure
    GCP
    OnPrem
}

enum K8sClusterProtoType {
    AWS
    AZURE
    GCP
    ON_PREM
    UNKNOWN
}

enum K8sClusterStatus {
    STATUS_CONNECTED
    STATUS_DISCONNECTED
    STATUS_INIT
    STATUS_UNKNOWN
}

enum LastTestStatusEnum {
    Failed
    NotExist
    Succeeded
}

"Field Enum for Authorized LDAP Principal list."
enum LdapAuthorizedPrincipalFieldEnum {
    "Authentication domain of principal."
    DirectoryName
    "Email of principal."
    Email
    "Last login time of principal."
    LAST_LOGIN
    "Name of principal."
    Name
}

enum LdapIntegrationFieldEnum {
    Name
}

enum LdapPrincipalFieldEnum {
    Name
}

"Legal hold query filter field."
enum LegalHoldQueryFilterField {
    "Legal hold time."
    LEGAL_HOLD_TIME
    "Snappable name."
    SNAPPABLE_NAME
    "Snappable type."
    SNAPPABLE_TYPE
    "Snapshot taken time."
    SNAPSHOT_TAKEN_TIME
    "Snapshot type."
    SNAPSHOT_TYPE
    "Unknown filter field."
    UNKNOWN
}

"Legal hold sort type Enum."
enum LegalHoldSortType {
    "Legal hold snapshot count."
    LEGAL_HOLD_SNAPSHOT_COUNT
    "Legal hold time."
    LEGAL_HOLD_TIME
    "Snappable name."
    SNAPPABLE_NAME
    "Snappable type."
    SNAPPABLE_TYPE
    "Snapshot time."
    SNAPSHOT_TIME
    "Snapshot type."
    SNAPSHOT_TYPE
    "Unknown type."
    UNKNOWN
}

enum ListAccessUsersSortEnum {
    EMAIL
    NUM_ACTIVITIES
    NUM_ACTIVITY_DELTA
    USERNAME
}

"Scope of the target location based on how it is managed."
enum LocationScope {
    "Target location is managed by Polaris."
    GLOBAL
    "Target location is managed by CDM."
    LOCAL
    "Scope of target location is unknown."
    UNKNOWN
}

enum LocationType {
    AWS
    AZURE
    CDM
    GCP
    UNKNOWN_TYPE
}

"type of data location"
enum LocationTypeEnum {
    Azure
    CLOUD_NATIVE_AWS
    CLOUD_NATIVE_GCP
    Cleversafe
    Glacier
    Google
    HDS
    LOCAL
    Nfs
    Qstar
    REPLICATION_OFF
    REPLICATION_POLARIS_SOURCE
    REPLICATION_SOURCE
    REPLICATION_SOURCE_AND_TARGET
    REPLICATION_TARGET
    Rehydrated
    S3
    S3Compatible
    Scality
}

enum LogLevelEnum {
    DEBUG
    INFO
}

"Period of time to look back."
enum LookbackPeriod {
    "Last 24 hours."
    LAST_24_HOURS
    "Past 30 days."
    PAST_30_DAYS
    "Past 365 days."
    PAST_365_DAYS
    "Past 7 days."
    PAST_7_DAYS
    "Past 90 days."
    PAST_90_DAYS
    "Since protection of the object started."
    START_OF_PROTECTION
}

"The cloud type for o365 subscription."
enum M365Cloud {
    "Commercial cloud type."
    COMMERCIAL
    "GCC high cloud type."
    GCC_HIGH
    "GCC mil cloud type."
    GCC_MIL
    "Cloud type not defined."
    NULL_CLOUD_TYPE
}

enum MalwareScanInSnapshotStatusEnum {
    MALWARE_SCAN_IN_SNAPSHOT_STATUS_ERROR
    MALWARE_SCAN_IN_SNAPSHOT_STATUS_FINISHED
    MALWARE_SCAN_IN_SNAPSHOT_STATUS_PENDING
}

"Any matches found during malware scan."
enum MalwareScanMatchesFound {
    "One of more matches found."
    MATCHES_FOUND
    "Unused default."
    MATCHES_FOUND_UNSPECIFIED
    "No matches found."
    NO_MATCHES
}

"Status of the running malware scan."
enum MalwareScanStatus {
    "Scan canceled."
    CANCELED
    "Scan is being canceled."
    CANCELING
    "Scan failed."
    FAILED
    "Scan is in progress."
    IN_PROGRESS
    "Unused default."
    STATUS_UNSPECIFIED
    "Scan succeeded."
    SUCCEEDED
}

"""

When a new snappable type is supported, add it to the list in utils.go
and to the method getObjectsProtectedBySlasConnection in api-server
(app/schema/global-sla/resolvers/Queries.scala)
"""
enum ManagedObjectType {
    APP_BLUEPRINT
    AWS_NATIVE_ACCOUNT
    AWS_NATIVE_EBS_VOLUME
    AWS_NATIVE_EC2_INSTANCE
    AWS_NATIVE_RDS_INSTANCE
    AZURE_MANAGED_DISK
    "Azure native common resource group"
    AZURE_RESOURCE_GROUP
    AZURE_RESOURCE_GROUP_FOR_DISK_HIERARCHY
    AZURE_RESOURCE_GROUP_FOR_VM_HIERARCHY
    AZURE_SQL_DATABASE_DB
    "Azure Sql"
    AZURE_SQL_DATABASE_SERVER
    AZURE_SQL_MANAGED_INSTANCE_DB
    AZURE_SQL_MANAGED_INSTANCE_SERVER
    AZURE_SUBSCRIPTION
    AZURE_UNMANAGED_DISK
    AZURE_VIRTUAL_MACHINE
    "Blueprint"
    BLUEPRINT
    CASSANDRA_COLUMN_FAMILY
    CASSANDRA_KEYSPACE
    "Cassandra"
    CASSANDRA_SOURCE
    CLOUD_NATIVE_TAG_RULE
    "UDF"
    DB2_DATABASE
    DB2_INSTANCE
    """

    EXCHANGE
    Managed object enum for Exchange Dag.
    """
    EXCHANGE_DAG
    "Managed object enum for Exchange Database."
    EXCHANGE_DATABASE
    "Managed object enum for Exchange Server."
    EXCHANGE_SERVER
    FAILOVER_CLUSTER_APP
    "Feldspar"
    FELDSPAR_SITE
    FILESET_TEMPLATE
    GCP_NATIVE_DISK
    GCP_NATIVE_GCE_INSTANCE
    "GCP native managed objects"
    GCP_NATIVE_PROJECT
    "Failover Cluster"
    HOST_FAILOVER_CLUSTER
    HOST_SHARE
    "Hyper-V"
    HYPERV_CLUSTER
    HYPERV_SCVMM
    HYPERV_SERVER
    HYPERV_VIRTUAL_MACHINE
    "Kupr"
    KUPR_CLUSTER
    KUPR_NAMESPACE
    LINUX_FILESET
    "Managed Volume"
    MANAGED_VOLUME
    "Managed Volume Export."
    MANAGED_VOLUME_EXPORT
    MONGODB_COLLECTION
    MONGODB_DATABASE
    "MongoDB"
    MONGODB_SOURCE
    MONGO_COLLECTION
    MONGO_DB
    MONGO_SOURCE
    MSSQL_AVAILABILITY_GROUP
    MSSQL_DAG
    MSSQL_DATABASE
    MSSQL_INSTANCE
    "NAS"
    NAS_NAMESPACE
    NAS_SHARE
    NAS_SYSTEM
    NAS_VOLUME
    "Nutanix"
    NUTANIX_CLUSTER
    NUTANIX_VIRTUAL_MACHINE
    O365_CALENDAR
    "O365"
    O365_GROUP
    O365_INDIVIDUAL_MAILBOX
    O365_INDIVIDUAL_USER
    O365_MAILBOX
    O365_ONEDRIVE
    O365_ORGANIZATION
    O365_SHARED_MAILBOX
    O365_SHARED_USER
    O365_SHAREPOINT_DRIVE
    "O365"
    O365_SHAREPOINT_LIST
    "O365 Sharepoint"
    O365_SITE
    "O365 Teams"
    O365_TEAMS
    O365_USER
    ORACLE_DATABASE
    "Oracle"
    ORACLE_HOST
    ORACLE_RAC
    PHYSICAL_HOST
    "RecoveryPlan"
    RECOVERY_PLAN
    SAP_HANA_DATABASE
    "Sap Hana"
    SAP_HANA_SYSTEM
    SHARE_FILESET
    "Snapmirror"
    SNAPMIRROR_CLOUD
    "VCD"
    VCD
    VCD_CATALOG
    VCD_ORG
    VCD_ORG_VDC
    VCD_VAPP
    "VCD Vim Server"
    VCD_VIM_SERVER
    "Volume Group"
    VOLUME_GROUP
    VSPHERE_COMPUTE_CLUSTER
    VSPHERE_DATACENTER
    VSPHERE_DATASTORE
    "VMware"
    VSPHERE_DATASTORE_CLUSTER
    VSPHERE_FOLDER
    VSPHERE_HOST
    VSPHERE_NETWORK
    "VMware"
    VSPHERE_RESOURCE_POOL
    VSPHERE_TAG
    VSPHERE_TAG_CATEGORY
    VSPHERE_VCENTER
    VSPHERE_VIRTUAL_MACHINE
    "MSSQL"
    WINDOWS_CLUSTER
    WINDOWS_FILESET
}

enum ManagedVolumeApplicationTagEnum {
    MANAGED_VOLUME_APPLICATION_TAG_DB_TRANSACTION_LOG
    MANAGED_VOLUME_APPLICATION_TAG_MS_SQL
    MANAGED_VOLUME_APPLICATION_TAG_MY_SQL
    MANAGED_VOLUME_APPLICATION_TAG_ORACLE
    MANAGED_VOLUME_APPLICATION_TAG_ORACLE_INCREMENTAL
    MANAGED_VOLUME_APPLICATION_TAG_POSTGRE_SQL
    MANAGED_VOLUME_APPLICATION_TAG_RECOVER_X
    MANAGED_VOLUME_APPLICATION_TAG_SAP_HANA
    MANAGED_VOLUME_APPLICATION_TAG_SAP_HANA_LOG
}

enum ManagedVolumeShareTypeEnum {
    MANAGED_VOLUME_SHARE_TYPE_NFS
    MANAGED_VOLUME_SHARE_TYPE_SMB
}

enum ManagedVolumeStateEnum {
    MANAGED_VOLUME_STATE_DESTROYED
    MANAGED_VOLUME_STATE_EXPORTED
    MANAGED_VOLUME_STATE_EXPORTING
    MANAGED_VOLUME_STATE_EXPORT_REQUESTED
    MANAGED_VOLUME_STATE_RESETTING
    MANAGED_VOLUME_STATE_RESET_REQUESTED
    MANAGED_VOLUME_STATE_RESIZE_REQUESTED
    MANAGED_VOLUME_STATE_RESIZING
    MANAGED_VOLUME_STATE_SNAPSHOTTING
    MANAGED_VOLUME_STATE_SNAPSHOT_REQUESTED
    MANAGED_VOLUME_STATE_UNEXPORTING
    MANAGED_VOLUME_STATE_UNEXPORT_REQUESTED
}

enum ManagedVolumeTypeEnum {
    MANAGED_VOLUME_TYPE_ALWAYS_MOUNTED
    MANAGED_VOLUME_TYPE_SLA_BASED
}

enum MissedSnapshotDayOfTimeUnitEnum {
    MISSED_SNAPSHOT_DAY_OF_TIME_UNIT_FIFTEENTH
    MISSED_SNAPSHOT_DAY_OF_TIME_UNIT_FIRST_DAY
    MISSED_SNAPSHOT_DAY_OF_TIME_UNIT_FRIDAY
    MISSED_SNAPSHOT_DAY_OF_TIME_UNIT_LAST_DAY
    MISSED_SNAPSHOT_DAY_OF_TIME_UNIT_MONDAY
    MISSED_SNAPSHOT_DAY_OF_TIME_UNIT_SATURDAY
    MISSED_SNAPSHOT_DAY_OF_TIME_UNIT_SUNDAY
    MISSED_SNAPSHOT_DAY_OF_TIME_UNIT_THURSDAY
    MISSED_SNAPSHOT_DAY_OF_TIME_UNIT_TUESDAY
    MISSED_SNAPSHOT_DAY_OF_TIME_UNIT_WEDNESDAY
}

enum MissedSnapshotGroupByEnum {
    Day
    Hour
    Month
    Quarter
    Week
    Year
}

enum MissedSnapshotSortByEnum {
    Date
}

"Represents connection status of Mongodb source to Mosaic cluster"
enum MongodbSourceStatus {
    "Source is being added to nosql cluster. Onboarding tasks are in process and source is not confirmed yet."
    ADDING
    "Source is connected."
    CONNECTED
    "Source is deleted from nosql cluster and it will not be tracked."
    DELETED
    "Source is being removed from nosql cluster and cleanup activities are in process."
    DELETING
    "Source is disconnected. This message is displayed when source is down or unreachable from nosql cluster."
    DISCONNECTED
    "Source is connected and metadata is being refreshed."
    REFRESHING
    "Represents error in displaying status. This status does not necessarily mean that something is wrong with the source."
    UNKNOWN_SYSTEM_STATUS
}

enum Month {
    APRIL
    AUGUST
    DECEMBER
    FEBRUARY
    JANUARY
    JULY
    JUNE
    MARCH
    MAY
    NOVEMBER
    OCTOBER
    SEPTEMBER
}

enum MosaicAddStoreRequestStoreTypeEnum {
    MOSAIC_ADD_STORE_REQUEST_STORE_TYPE_AZURE_STORE
    MOSAIC_ADD_STORE_REQUEST_STORE_TYPE_GS_STORE
    MOSAIC_ADD_STORE_REQUEST_STORE_TYPE_NFS_STORE
    MOSAIC_ADD_STORE_REQUEST_STORE_TYPE_S3_STORE
}

enum MosaicBulkRecoverableRangeRequestSourceTypeEnum {
    MOSAIC_BULK_RECOVERABLE_RANGE_REQUEST_SOURCE_TYPE_CASSANDRA
    MOSAIC_BULK_RECOVERABLE_RANGE_REQUEST_SOURCE_TYPE_MONGO
}

enum MosaicRecoverableRangeRequestSourceTypeEnum {
    MOSAIC_RECOVERABLE_RANGE_REQUEST_SOURCE_TYPE_CASSANDRA
    MOSAIC_RECOVERABLE_RANGE_REQUEST_SOURCE_TYPE_MONGO
}

enum MosaicRetrieveRequestSourceTypeEnum {
    MOSAIC_RETRIEVE_REQUEST_SOURCE_TYPE_CASSANDRA
    MOSAIC_RETRIEVE_REQUEST_SOURCE_TYPE_MONGO
}

"Group mosaic snapshots."
enum MosaicSnapshotGroupBy {
    Day
    Hour
    Month
    Quarter
    Week
    Year
}

"Sort mosaic snapshots."
enum MosaicSnapshotSortBy {
    Date
    SnappableId
    SnapshotId
}

"Type of Mosaic snapshot."
enum MosaicSnapshotType {
    "Full(initial) sync snapshot."
    FULL
    "Incremental(delta) sync snapshot."
    INCREMENTAL
    "Invalid snapshot type."
    INVALID
}

"Mosaic storage location filter."
enum MosaicStorageLocationFilterField {
    "Cluster ID of Mosaic cluster."
    CLUSTER_UUID
    "Name of storage location."
    NAME
    "Type of storage location."
    STORE_TYPE
}

"Field to sort by for mosaic storage locations."
enum MosaicStorageLocationQuerySortByField {
    "Field Name."
    NAME
}

"Status of Mosaic Store Connection."
enum MosaicStoreConnectionStatus {
    "Unable to determine the connection status right now."
    STATUS_UNAVAILABLE
    "Store is connected with Mosaic."
    STORE_CONNECTED
    "Store is disconnected with Mosaic."
    STORE_DISCONNECTED
}

enum MosaicStoreObjectStoreTypeEnum {
    MOSAIC_STORE_OBJECT_STORE_TYPE_AZURE_STORE
    MOSAIC_STORE_OBJECT_STORE_TYPE_GS_STORE
    MOSAIC_STORE_OBJECT_STORE_TYPE_NFS_STORE
    MOSAIC_STORE_OBJECT_STORE_TYPE_S3_STORE
    MOSAIC_STORE_OBJECT_STORE_TYPE_SWIFT_STORE
    MOSAIC_STORE_OBJECT_STORE_TYPE_VFS_STORE
}

"Type of storage location."
enum MosaicStoreType {
    "Microsoft Azure Store."
    AZURE_STORE
    "Google Cloud Store."
    GS_STORE
    "NFS Store."
    NFS_STORE
    "AWS S3 Store."
    S3_STORE
    "Store Type is not available for this store."
    TYPE_UNAVAILABLE
}

enum MosaicVersionObjectVersionStateEnum {
    MOSAIC_VERSION_OBJECT_VERSION_STATE_DATA_COPIED
    MOSAIC_VERSION_OBJECT_VERSION_STATE_REPLAYED
}

enum MssqlBackupTypeEnum {
    MSSQL_BACKUP_TYPE_LOG
    MSSQL_BACKUP_TYPE_SNAPSHOT
}

enum MssqlCbtEffectiveStatusTypeEnum {
    MSSQL_CBT_EFFECTIVE_STATUS_TYPE_OFF
    MSSQL_CBT_EFFECTIVE_STATUS_TYPE_OFF_DEFAULT
    MSSQL_CBT_EFFECTIVE_STATUS_TYPE_ON
    MSSQL_CBT_EFFECTIVE_STATUS_TYPE_ON_DEFAULT
}

enum MssqlCbtStatusTypeEnum {
    MSSQL_CBT_STATUS_TYPE_DEFAULT
    MSSQL_CBT_STATUS_TYPE_DISABLED
    MSSQL_CBT_STATUS_TYPE_ENABLED
}

enum MssqlDatabaseFileTypeEnum {
    MSSQL_DATABASE_FILE_TYPE_DATA
    MSSQL_DATABASE_FILE_TYPE_FILESTREAM
    MSSQL_DATABASE_FILE_TYPE_LOG
}

"Filter for Mssql database live mount results."
enum MssqlDatabaseLiveMountFilterField {
    "Cluster UUID filter field for Mssql database live mount results."
    CLUSTER_UUID
    """

    Mounted database name filter field for Mssql database
    live mount results.
    """
    MOUNTED_DATABASE_NAME
    """

    Source database ID filter field for Mssql database
    live mount results.
    """
    SOURCE_DATABASE_ID
}

"Sort by param for Mssql database live mount results."
enum MssqlDatabaseLiveMountSortByField {
    """

    Creation date sort by field for Mssql database
    live mount results.
    """
    CREATION_DATE
    """

    Mounted database name sort by field for Mssql database
    live mount results.
    """
    MOUNTED_DATABASE_NAME
}

"Sort order param for Mssql database live mount results."
enum MssqlDatabaseLiveMountSortOrderField {
    "Sort in ascending order."
    ASC
    "Sort in descending order."
    DESC
}

enum MssqlDatabaseRecoveryModelEnum {
    MSSQL_DATABASE_RECOVERY_MODEL_BULK_LOGGED
    MSSQL_DATABASE_RECOVERY_MODEL_FULL
    MSSQL_DATABASE_RECOVERY_MODEL_SIMPLE
}

enum MssqlDbReplicaAvailabilityInfoRoleEnum {
    MSSQL_DB_REPLICA_AVAILABILITY_INFO_ROLE_PRIMARY
    MSSQL_DB_REPLICA_AVAILABILITY_INFO_ROLE_RESOLVING
    MSSQL_DB_REPLICA_AVAILABILITY_INFO_ROLE_SECONDARY
}

enum MssqlDbReplicaRecoveryModelEnum {
    MSSQL_DB_REPLICA_RECOVERY_MODEL_BULK_LOGGED
    MSSQL_DB_REPLICA_RECOVERY_MODEL_FULL
    MSSQL_DB_REPLICA_RECOVERY_MODEL_SIMPLE
}

enum MssqlDbSummaryRecoveryModelEnum {
    MSSQL_DB_SUMMARY_RECOVERY_MODEL_BULK_LOGGED
    MSSQL_DB_SUMMARY_RECOVERY_MODEL_FULL
    MSSQL_DB_SUMMARY_RECOVERY_MODEL_SIMPLE
}

enum MssqlLogShippingOkStateEnum {
    MSSQL_LOG_SHIPPING_OK_STATE_RESTORING
    MSSQL_LOG_SHIPPING_OK_STATE_STANDBY
}

enum MssqlLogShippingStatusEnum {
    MSSQL_LOG_SHIPPING_STATUS_BROKEN
    MSSQL_LOG_SHIPPING_STATUS_INITIALIZING
    MSSQL_LOG_SHIPPING_STATUS_OK
    MSSQL_LOG_SHIPPING_STATUS_STALE
}

"Filter for Mssql log shipping target results."
enum MssqlLogShippingTargetFilterField {
    "Cluster UUID filter field for Mssql log shipping target results."
    CLUSTER_UUID
    "Primary Db CDM ID filter field for Mssql log shipping target results."
    PRIMARY_DB_ID
    "Primary name filter field for Mssql log shipping target results."
    PRIMARY_NAME
    "Secondary name filter field for Mssql log shipping target results."
    SECONDARY_NAME
    "Cluster filter field for Mssql log shipping target results."
    STATUS
}

"Sort by param for Mssql log shipping target results."
enum MssqlLogShippingTargetSortByField {
    """

    Last applied point sort by field for Mssql log shipping target
    results.
    """
    LAST_APPLIED_POINT
    "Location sort by field for Mssql log shipping target results."
    LOCATION
    """

    Primary  name sort by field for Mssql log shipping target
    results.
    """
    PRIMARY_NAME
    """

    Secondary name sort by field for Mssql log shipping target
    results.
    """
    SECONDARY_NAME
}

enum MssqlRootPropertiesRootTypeEnum {
    MSSQL_ROOT_PROPERTIES_ROOT_TYPE_HOST
    MSSQL_ROOT_PROPERTIES_ROOT_TYPE_MSSQL_AVAILABILITY_GROUP
    MSSQL_ROOT_PROPERTIES_ROOT_TYPE_WINDOWS_CLUSTER
}

enum MssqlUnprotectableTypeEnum {
    MSSQL_UNPROTECTABLE_TYPE_INSUFFICIENT_PERMISSIONS
}

enum NasVendorTypeEnum {
    NAS_VENDOR_TYPE_FLASHBLADE
    NAS_VENDOR_TYPE_GENERIC
    NAS_VENDOR_TYPE_ISILON
    NAS_VENDOR_TYPE_NETAPP
    NAS_VENDOR_TYPE_NUTANIX
}

enum NetworkAdapterTypeEnum {
    E1000
    E1000E
    PCNET32
    VMXNET
    VMXNET2
    VMXNET3
}

enum NetworkProtocolTypeEnum {
    TCP
    UDP
}

enum NetworkThrottleResourceIdEnum {
    NETWORK_THROTTLE_RESOURCE_ID_ARCHIVAL_EGRESS
    NETWORK_THROTTLE_RESOURCE_ID_REPLICATION_EGRESS
}

enum NetworkTypeEnum {
    DHCP
    STATIC
}

"Filter for Nutanix VM live mount results."
enum NutanixLiveMountFilterField {
    "Cluster UUID filter for Nutanix VM live mount results."
    CLUSTER_UUID
    "Filter is not specified. Any filter text would not be considered."
    FIELD_UNSPECIFIED
    "Mount Name filter for Nutanix VM live mount results."
    MOUNT_NAME
}

"Sort by parameters for Nutanix VM live mount results."
enum NutanixLiveMountSortByField {
    "Sort by Cluster Name."
    CLUSTER_NAME
    "Sort by Mount Creation Date."
    CREATION_DATE
    """

    Sort by field is not specified.
    Any filter text would not be considered.
    """
    FIELD_UNSPECIFIED
    "Sort by Mount Name."
    MOUNT_NAME
}

enum NutanixSnapshotConsistencyMandateEnum {
    NUTANIX_SNAPSHOT_CONSISTENCY_MANDATE_APPLICATION_CONSISTENT
    NUTANIX_SNAPSHOT_CONSISTENCY_MANDATE_AUTOMATIC
    NUTANIX_SNAPSHOT_CONSISTENCY_MANDATE_CRASH_CONSISTENT
}

enum NutanixVirtualMachineScriptDetailFailureHandlingEnum {
    NUTANIX_VIRTUAL_MACHINE_SCRIPT_DETAIL_FAILURE_HANDLING_ABORT
    NUTANIX_VIRTUAL_MACHINE_SCRIPT_DETAIL_FAILURE_HANDLING_CONTINUE
}

"Cloud type for Azure storage account."
enum O365AzureCloudType {
    "Public cloud."
    PUBLIC
    "US Gov cloud."
    USGOV
}

"Object type to constrain search against."
enum O365CalendarSearchObjectType {
    "Search all."
    ALL
    "Search for calendars only."
    CALENDAR
    "Search for calendar events only."
    EVENT
}

"Object type to constrain the search against."
enum O365ContactsSearchObjectType {
    "Search all."
    ALL
    "Search contacts only."
    CONTACT
    "Search contact folders only."
    CONTACT_FOLDER
}

"Recover task type i.e Restore/Export."
enum O365RestoreActionType {
    "Used for export task."
    EXPORT_SNAPPABLE
    "Used for restore task."
    RESTORE_SNAPPABLE
}

"Status of o365 service account."
enum O365ServiceAccountStatus {
    "Service account is invalid."
    INVALID
    "Service account not configured."
    NOT_CONFIGURED
    "Service account is valid."
    VALID
}

"Service status of o365."
enum O365ServiceStatusIndication {
    "Service is down."
    DOWN
    "Service is online."
    ONLINE
}

enum ObjectPolicyStatus {
    STALE
    UNKNOWN
    UP_TO_DATE
}

enum ObjectTypeEnum {
    AZURE_SQL_DATABASE_DB
    AZURE_SQL_MANAGED_INSTANCE_DB
    AppBlueprint
    AwsNativeEbsVolume
    AwsNativeEc2Instance
    AwsNativeRdsInstance
    AzureNativeManagedDisk
    AzureNativeVm
    CassandraColumnFamily
    CassandraKeyspace
    CassandraSource
    Db2Database
    Ec2Instance
    "Exchange Database."
    ExchangeDatabase
    Fileset
    GcpNativeDisk
    GcpNativeGCEInstance
    Hdfs
    HypervVirtualMachine
    KuprNamespace
    LinuxFileset
    "MongoDB Collection."
    MONGODB_COLLECTION
    "MongoDB Database."
    MONGODB_DATABASE
    "MongoDB Source Cluster."
    MONGODB_SOURCE
    "Managed Volume."
    ManagedVolume
    Mssql
    MssqlDatabaseBatchMaintenance
    NutanixVirtualMachine
    O365Calendar
    O365File
    O365Mailbox
    O365Onedrive
    O365SharePointDrive
    O365SharePointList
    O365Site
    O365Teams
    OracleDatabase
    PolarisEbsVolume
    PolarisEc2Instance
    SapHanaDatabase
    ShareFileset
    SnapMirrorCloud
    StorageArrayVolumeGroup
    VcdVapp
    VmwareVirtualMachine
    VolumeGroup
    WindowsFileset
    WindowsVolumeGroup
}

"Search keyword type."
enum OnedriveSearchKeywordType {
    "Search by file type."
    FILE_TYPE
    "Search by file or folder name."
    NAME
}

"Object type to constrain the search against."
enum OnedriveSearchObjectType {
    "Search all."
    ALL
    "Search folders only."
    O365_FOLDER
    "Search files only."
    ONEDRIVE_FILE
}

enum OpenAccessTypeEnum {
    EXPLICIT
    INHERITED
    NOT_OPEN
    UNKNOWN_ACCESS
}

enum OperatingSystemTypeEnum {
    OPERATING_SYSTEM_TYPE_AIX
    OPERATING_SYSTEM_TYPE_HPUX
    OPERATING_SYSTEM_TYPE_LINUX
    OPERATING_SYSTEM_TYPE_SUN_OS
    OPERATING_SYSTEM_TYPE_UNKNOWN
    OPERATING_SYSTEM_TYPE_WINDOWS
}

enum OperationEnum {
    AddAwsCloudAccount
    AddAzureCloudAccount
    AddCluster
    AddGcpCloudAccount
    AddInventory
    AddStorageSettings
    CancelRunningActivity
    CategoryManageDataSource
    CategoryProtection
    CategoryRecovery
    CategoryViewDataSource
    ConfigureDataClassGlobal
    CreateReport
    CreateSLA
    CreateThreatHunt
    DeleteAwsCloudAccount
    DeleteAzureCloudAccount
    DeleteGcpCloudAccount
    DeleteInventory
    DeleteReport
    DeleteSLA
    DeleteSnapshot
    DeleteStorageSettings
    Download
    DownloadFromArchivalLocation
    EditAwsCloudAccount
    EditAzureCloudAccount
    EditCdmNetworkSetting
    EditCdmSupportSetting
    EditCdmSysConfig
    EditGcpCloudAccount
    EditNetworkThrottleSettings
    EditOrganization
    EditQuarantine
    EditReplicationSettings
    EditSecuritySettings
    EditStorageSettings
    EditSystemPreference
    EditUserManagement
    Export
    ExportDataClassGlobal
    ExportFiles
    ExportSnapshots
    InstantRecover
    ManageAccess
    ManageDataSource
    ManageLegalHold
    ManageProtection
    ManageSLA
    ModifyCluster
    ModifyInventory
    ModifyReport
    ModifySLA
    Mount
    ProvisionOnInfrastructure
    RecoverFromQuarantine
    RefreshDataSource
    RemoveCluster
    Restore
    RestoreToOrigin
    TakeOnDemandSnapshot
    ToggleBlackoutWindow
    TransferAccountOwnership
    UPDATE_ACCOUNT_OWNERSHIP
    UpgradeCluster
    ViewAccess
    ViewAuditLog
    ViewAwsCloudAccount
    ViewAzureCloudAccount
    ViewCdmNetworkSetting
    ViewCdmSupportSetting
    ViewCdmSysConfig
    ViewCluster
    ViewDashboard
    ViewDataClassGlobal
    ViewGcpCloudAccount
    ViewInventory
    ViewInventoryWithHierarchy
    ViewNonSystemEvent
    ViewOrganization
    ViewReplicationSettings
    ViewReport
    ViewSLA
    ViewSecuritySettings
    ViewStorageSettings
    ViewSystemEvent
    ViewSystemPreference
    ViewThreatHuntResults
    ViewUserManagement
}

"Fields in an org."
enum OrgField {
    "Name of the org."
    NAME
    "URL of the org."
    URL
}

"Status of the M365 org."
enum OrgStatus {
    "Org is in active state."
    ACTIVE
    "Org is in deleted state."
    DELETED
    "Org is being deleted."
    DELETING
    "Org is in refresh stage."
    REFRESHING
}

enum OsTypeEnum {
    Linux
    Other
    Undefined
    Windows
}

enum PastDurationEnum {
    NONE
    PAST_12_MONTHS
    PAST_24_HOURS
    PAST_30_DAYS
    PAST_3_DAYS
    PAST_7_DAYS
}

"Pause Status of the SLA."
enum PauseStatus {
    "SLA not paused."
    NOT_PAUSED
    "SLA paused."
    PAUSED
    "Unknown Status."
    UNKNOWN
}

enum PendingActionGroupTypeEnum {
    APP_FLOW
    ARCHIVAL_LOCATION
    CLOUD_ACCOUNTS
    GLOBAL_SLA
    REPLICATION
    UNMANAGED_OBJECTS
}

enum PendingActionStatusEnum {
    FAILED
    IN_PROGRESS
    QUEUED
    SUCCEEDED
    SYNCED_TO_CDM
}

enum PendingActionSubGroupTypeEnum {
    ARCHIVAL_LOCATION_DELETE
    ARCHIVAL_LOCATION_DISABLE
    ARCHIVAL_LOCATION_ENABLE
    ARCHIVAL_LOCATION_PAUSE
    ARCHIVAL_LOCATION_RESUME
    AWS_COMPUTE_SETTING_UPSERT
    AWS_IAM_CUSTOMER_ACCOUNT_UPSERT
    AWS_ROLE_BASED_ARCHIVAL_LOCATION
    BLUEPRINT_CREATE
    BLUEPRINT_DELETE
    BLUEPRINT_DEPRECATE
    BLUEPRINT_UPDATE
    CLUSTER_PEER_TOKEN_GET
    CLUSTER_PEER_TOKEN_GET_AND_SET
    CLUSTER_PEER_TOKEN_SET
    DISABLE_REPLICATION_LOCATION_PUT
    ENABLE_LOCATION_AS_REPLICATION_TARGET
    ENABLE_POLARIS_AS_REPLICATION_SOURCE
    GLOBAL_SLA_ASSIGN
    GLOBAL_SLA_ASSIGN_RETENTION_SLA_TO_SNAPPABLE
    GLOBAL_SLA_ASSIGN_RETENTION_SLA_TO_SNAPSHOT
    GLOBAL_SLA_ASSIGN_RETENTION_SLA_TO_SNAPSHOT_V2
    GLOBAL_SLA_DELETE
    GLOBAL_SLA_PUT
    NFS_LOCATION_PUT
    NFS_LOCATION_READER_POST
    OBJECT_STORE_LOCATION_PUT
    OBJECT_STORE_LOCATION_READER_POST
    S3COMPATIBLE_LOCATION_PUT
    S3COMPATIBLE_LOCATION_READER_POST
    UNMANAGED_OBJECT_DELETE_SNAPSHOTS
    UNMANAGED_OBJECT_DELETE_SNAPSHOTS_OF_OBJECT
}

enum PendingActionSyncTypeEnum {
    CDM
    POLARIS
}

enum PlanNameEnum {
    PROD
    PROD_LOCAL
    TEST
}

enum PolarisObjectAuthorizedOperationsEnum {
    ManageDataSource
    ManageProtection
    RefreshDataSource
    ViewInventory
}

"The order of sorts."
enum PolarisReportSortOrderType {
    "The ascending order."
    ASC
    "The descending order."
    DSC
}

"All valid report views."
enum PolarisReportViewType {
    "The object capacity over time report."
    OBJECT_CAPACITY_OVERTIME_REPORT
    "The protection tasks detail report."
    PROTECTION_TASKS_DETAIL_REPORT
}

enum PolarisSnappableAuthorizedOperationsEnum {
    DeleteSnapshot
    Download
    ExportSnapshots
    ManageProtection
    RestoreToOrigin
    TakeOnDemandSnapshot
    ViewInventory
}

enum PolarisSnapshotGroupByEnum {
    Day
    Hour
    Month
    Quarter
    Week
    Year
}

enum PolarisSnapshotSortByEnum {
    Date
    SnappableId
    SnapshotId
}

enum PolicyObjectFilterEnum {
    ALL
    HAS_OBJECTS
    NO_OBJECTS
}

enum PrePostScriptFailureHandlingEnum {
    abort
    continue
}

enum PrechecksStatusTypeEnum {
    PrechecksFailureError
    PrechecksFailureWarning
    PrechecksRunning
    PrechecksSuccess
    Unknown
}

enum PrincipalTypeEnum {
    CLIENT
    GROUP
    UNKNOWN
    USER
}

"Name of product."
enum ProductName {
    "AppFlows."
    APPFLOWS
    "Cloud Cluster ES."
    CC_ES
    "CloudNative."
    CLOUDNATIVE
    "GPS."
    GPS
    "Kubernetes protection."
    KUBERNETES
    "O365."
    O365
    "Radar."
    RADAR
    "Rubrik Cloud Vault (RCV)."
    RCV
    "Rubrik Data Protection (RDP)."
    RDP
    "Saphana."
    SAPHANA
    "Sonar."
    SONAR
    "Unknown name."
    UNSPECIFIED_NAME
}

"State of product."
enum ProductState {
    "Product failed to activate."
    ACTIVATION_FAILED
    "Product is in activation."
    ACTIVATION_PENDING
    "Active product."
    ACTIVE
    "Disabled Product."
    DISABLED
    "Product couldn't be disabled."
    DISABLE_FAILED
    "Product is being disabled."
    DISABLE_PENDING
    "Product has been selected for expiration, but somehow expiration failed."
    EXPIRATION_PENDING
    "Expired product."
    EXPIRED
    "Unknown state."
    UNSPECIFIED_STATE
}

"Type of product."
enum ProductType {
    "POC product."
    POC
    "Revenue product."
    REVENUE
    "Trial product."
    TRIAL
    "Unknown type."
    UNSPECIFIED_TYPE
}

enum ProtectionStatusEnum {
    DoNotProtect
    NoSla
    Protected
}

"The provider of the endpoint to which the webhook will be sent."
enum ProviderType {
    "A generic endpoint receives the webhook."
    CUSTOM
    "A PagerDuty endpoint receives the webhook."
    PAGERDUTY
    "Unused default value."
    PROVIDER_TYPE_UNSPECIFIED
    "A Splunk endpoint receives the webhook."
    SPLUNK
}

"Provision status of o365 subscription."
enum ProvisionStatus {
    "Organization is active to use."
    ACTIVE
    "Organization is deleted."
    DELETED
    "Organization is being deleted."
    DELETING
    "Organization is being refreshed."
    REFRESHING
}

enum RansomwareResultGroupByEnum {
    ClusterUuid
    ManagedId
    SnapshotDay
    SnapshotHour
    SnapshotMonth
    SnapshotWeek
    SnapshotYear
}

enum RansomwareResultSortByEnum {
    ClusterUuid
    EncryptionProbability
    IsEncrypted
    ManagedId
    SnappableId
    SnapshotDate
    SnapshotId
}

"Consumption stats metric name for Rubrik Cloud Storage Archival Location."
enum RcsConsumptionMetricNameType {
    "Blob capacity and Forecasted Blob capacity consumption stats for Rubrik Cloud Storage Archival Location."
    BLOB_CAPACITY
    "Egress and ingress capacity consumption stats for Rubrik Cloud Storage Archival Location."
    EGRESS_INGRESS
}

"Consumption stats metric name for Rubrik Cloud Storage Archival Location."
enum RcsConsumptionMetricOutputNameType {
    "Blob capacity consumption stats for Rubrik Cloud Storage Archival Location."
    BLOB_CAPACITY
    "Egress capacity consumption stats for Rubrik Cloud Storage Archival Location."
    EGRESS
    "Forecasted blob capacity consumption stats for Rubrik Cloud Storage Archival Location."
    FORECASTED_BLOB_CAPACITY
    "Ingress capacity consumption stats for Rubrik Cloud Storage Archival Location."
    INGRESS
}

"Regions for Rubrik Cloud Storage Archival Location"
enum RcsRegionEnumType {
    "Canada East or Quebec City."
    CANADA_EAST
    "Europe north or Netherlands."
    EUROPE_NORTH
    "Europe west or Ireland."
    EUROPE_WEST
    "UK South or London."
    UK_SOUTH
    "US central or Iowa."
    US_CENTRAL
    "US east 2 or Virginia."
    US_EAST_2
    "US west 2 or Washington."
    US_WEST_2
}

"Tiers for Rubrik Cloud Storage Archival Location"
enum RcsTierEnumType {
    "Archive tier for Rubrik Cloud Storage Archival Location"
    ARCHIVE
    "Backup tier for Rubrik Cloud Storage Archival Location"
    BACKUP
}

"Retrieval method for reader archival locations."
enum ReaderRetrievalMethod {
    "Retrieval method that lists workloads as well as snapshots of each workload."
    OBJECT_LIST_AND_DETAILS
    "Retrieval method that lists only workloads."
    OBJECT_LIST_ONLY
    "Unknown retrieval method."
    UNKNOWN_RETRIEVAL_METHOD
}

"Failover type."
enum RecoveryPlanFailoverType {
    "Production failover."
    PROD
    "Test failover."
    TEST
    "Unknown recovery plan type."
    UNKNOWN_RP_TYPE
}

"Location type."
enum RecoveryPlanLocationType {
    "AWS."
    LOCATION_TYPE_AWS
    "Azure."
    LOCATION_TYPE_AZURE
    "CDM."
    LOCATION_TYPE_CDM
    "GCP."
    LOCATION_TYPE_GCP
    "Unknown."
    LOCATION_TYPE_UNKNOWN
}

"Operation type."
enum RecoveryPlanOperationType {
    "Cleanup operation."
    CLEANUP_OPERATION
    "Failover operation."
    FAILOVER_OPERATION
    "Resume operation."
    RESUME_OPERATION
    "Unknown operation."
    UNKNOWN_OPERATION
}

enum RecoverySpecTypeEnum {
    AWS_EC2
    UNKNOWN_VM
    VMWARE_VM
}

enum RefreshableObjectConnectionStatusTypeEnum {
    REFRESHABLE_OBJECT_CONNECTION_STATUS_TYPE_BADLY_CONFIGURED
    REFRESHABLE_OBJECT_CONNECTION_STATUS_TYPE_CONNECTED
    REFRESHABLE_OBJECT_CONNECTION_STATUS_TYPE_DELETING
    REFRESHABLE_OBJECT_CONNECTION_STATUS_TYPE_DISCONNECTED
    REFRESHABLE_OBJECT_CONNECTION_STATUS_TYPE_REFRESHING
    REFRESHABLE_OBJECT_CONNECTION_STATUS_TYPE_REMOTE
}

"Connection status of the replication pair."
enum ReplicationPairConnectionStatus {
    "Rubrik clusters are connected and replication is unpaused"
    REPLICATION_ACTIVE
    "Rubrik clusters are disconnected from each other."
    REPLICATION_DISCONNECTED
    "Replication is paused between the Rubrik clusters."
    REPLICATION_PAUSED
}

"Field to sort by for replication pairs."
enum ReplicationPairsQuerySortByField {
    "Active network throttle limit for source Rubrik Cluster."
    CURRENT_THROTTLE_LIMIT
    "Failed replication task count."
    FAILED_TASKS
    "Running replication task count."
    RUNNING_TASKS
    "Source Rubrik cluster name."
    SOURCE_CLUSTER_NAME
    "Connection status of the replication pair."
    STATUS
    "Storage consumed by replicated snapshots."
    STORAGE
    "Target Rubrik cluster name."
    TARGET_CLUSTER_NAME
}

"Sort order for replication pairs."
enum ReplicationQuerySortByOrder {
    "Ascending order sort."
    ASC
    "Descending order sort."
    DESC
}

enum ReplicationTypeEnum {
    REPLICATION_TO_CLOUD_LOCATION
    REPLICATION_TO_CLOUD_REGION
    UNIDIRECTIONAL_REPLICATION_TO_CLUSTER
    UNKNOWN_REPLICATION_TYPE
}

enum ReportFocusEnum {
    Activity
    Anomaly
    Audit
    Capacity
    Compliance
    Failover
    Infrastructure
    Protection
    ProtectionTaskDetail
    RecoveryTaskDetail
    Sonar
    SonarContent
    TaskSummary
}

enum ReportTableColumnEnum {
    ActivityStatus
    ActivityType
    AnalyzersBreakdown
    AppBlueprintName
    ArchivalTarget
    ArchiveSnapshots
    ArchiveStorage
    BytesCreated
    BytesDeleted
    BytesModified
    BytesNetChanged
    Cluster
    ClusterLocation
    ClusterName
    ClusterType
    ComplianceStatus
    DataReduction
    DataTransferred
    DirectArchive
    Duration
    EncryptionEnabled
    EndDate
    EndTime
    EstimatedRunway
    FailoverStatus
    FailoverType
    FailureReason
    FileName
    FilesCreated
    FilesDeleted
    FilesModified
    IsAnomaly
    LastSnapshot
    LastTestStatus
    LastTestTime
    LastUpdated
    LocalSnapshots
    Location
    LogicalByte
    LogicalBytes
    MissedSnapshots
    NumCoveredObjects
    NumHighRiskLocations
    NumOfCanceled
    NumOfExpected
    NumOfFailed
    NumOfSucceeded
    NumViolatedFiles
    NumViolations
    ObjectName
    ObjectType
    Path
    PhysicalBytes
    PoliciesBreakdown
    PolicyName
    PolicyStatus
    PreviousSnapshotDate
    PreviousSnapshotId
    ProtectedVolume
    RecoveryPoint
    RecoveryPointType
    ReplicaSnapshots
    ReplicaStorage
    ReplicationSource
    ReplicationTarget
    Size
    SlaDomain
    SlaDomainName
    SnappableName
    SnappableType
    SnapshotConsistency
    SnapshotDate
    SnapshotId
    SnapshotTime
    Source
    StartDate
    StartTime
    Status
    SuspiciousFilesAdded
    TargetSite
    TaskType
    TotalCapacity
    TotalFileTransferred
    TotalHits
    TotalSnapshots
    TransferredBytes
    UsedCapacity
    UserAuditStatus
    UserAuditType
    UserName
}

enum ResolutionTypeEnum {
    RESOLVED_AD
    RESOLVED_ON_HOST
    UNRESOLVED
    WELL_KNOWN
}

enum ResourceType {
    BLUEPRINT
    CLUSTER
    SNAPPABLE
}

enum RetentionUnitEnum {
    DAYS
    HOURS
    MINUTES
    MONTHS
    QUARTERS
    WEEKS
    YEARS
}

enum RiskLevelTypeEnum {
    HIGH_RISK
    LOW_RISK
    MEDIUM_RISK
    NO_RISK
    UNKNOWN_RISK
}

enum RoleFieldEnum {
    Name
}

enum SLAAuditDetailFilterFieldEnum {
    USER_NAME
}

enum SLAComplianceTimeRangeEnum {
    Last24Hours
    Last2Snapshots
    Last3Snapshots
    LastSnapshot
    Past30Days
    Past365Days
    Past7Days
    Past90Days
    SinceProtection
}

"Type of objects managed by SLA Domains."
enum SLAObjectTypeEnum {
    AWS_EC2_EBS_OBJECT_TYPE
    AWS_RDS_OBJECT_TYPE
    AZURE_OBJECT_TYPE
    AZURE_SQL_DATABASE_OBJECT_TYPE
    AZURE_SQL_MANAGED_INSTANCE_OBJECT_TYPE
    CASSANDRA_OBJECT_TYPE
    "Db2."
    DB2_OBJECT_TYPE
    "Microsoft Exchange."
    EXCHANGE_OBJECT_TYPE
    FILESET_OBJECT_TYPE
    GCP_OBJECT_TYPE
    KUPR_OBJECT_TYPE
    MANAGED_VOLUME_OBJECT_TYPE
    MONGODB_OBJECT_TYPE
    MSSQL_OBJECT_TYPE
    O365_OBJECT_TYPE
    SAP_HANA_OBJECT_TYPE
    SNAPMIRROR_CLOUD_OBJECT_TYPE
    UNKNOWN_OBJECT_TYPE
    VOLUME_GROUP_OBJECT_TYPE
    VSPHERE_OBJECT_TYPE
}

"Sort Global SLA Domains by field name."
enum SLAQuerySortByFieldEnum {
    "Sort by SLA Domain name."
    NAME
    "Sort by SLA Domain paused cluster count."
    PAUSED_CLUSTER_COUNT
    "Sort by SLA Domain protected object count."
    PROTECTED_OBJECT_COUNT
}

enum SLAQuerySortByOrderEnum {
    ASC
    DESC
}

enum SMTPSecurityTypeEnum {
    NONE
    SSL
    STARTTLS
    TLS
}

enum SapHanaDataPathTypeEnum {
    SAP_HANA_DATA_PATH_TYPE_GCP
    SAP_HANA_DATA_PATH_TYPE_LOCAL
    SAP_HANA_DATA_PATH_TYPE_MANAGED_VOLUME
}

"The encryption provider for the SAPA HANA system."
enum SapHanaEncryptionProvider {
    "Common Crypto."
    COMMON_CRYPTO
    "Encryption provider not set."
    EMPTY_VALUE
    "OpenSSL."
    OPENSSL
    "SAP Crypto."
    SAP_CRYPTO
}

enum SapHanaHostHostTypeEnum {
    SAP_HANA_HOST_HOST_TYPE_MASTER
    SAP_HANA_HOST_HOST_TYPE_SECONDARY_MASTER
    SAP_HANA_HOST_HOST_TYPE_SECONDARY_SLAVE
    SAP_HANA_HOST_HOST_TYPE_SLAVE
}

enum SapHanaLogSnapshotSortByEnum {
    Date
}

enum SapHanaRecoverableRangeSortByEnum {
    EndTime
    StartTime
}

enum SapHanaSslInfoEncryptionProviderEnum {
    SAP_HANA_SSL_INFO_ENCRYPTION_PROVIDER_COMMON_CRYPTO
    SAP_HANA_SSL_INFO_ENCRYPTION_PROVIDER_OPENSSL
    SAP_HANA_SSL_INFO_ENCRYPTION_PROVIDER_SAP_CRYPTO
}

enum SapHanaSystemStatus {
    ERROR
    OK
    UNKNOWN_SYSTEM_STATUS
    WARNING
}

enum SapHanaSystemSummaryContainerTypeEnum {
    SAP_HANA_SYSTEM_SUMMARY_CONTAINER_TYPE_MULTI_CONTAINER
    SAP_HANA_SYSTEM_SUMMARY_CONTAINER_TYPE_SINGLE_CONTAINER
}

enum SapHanaSystemSummaryStatusEnum {
    SAP_HANA_SYSTEM_SUMMARY_STATUS_ERROR
    SAP_HANA_SYSTEM_SUMMARY_STATUS_OK
    SAP_HANA_SYSTEM_SUMMARY_STATUS_UNKNOWN
    SAP_HANA_SYSTEM_SUMMARY_STATUS_WARNING
}

enum ScriptErrorActionEnum {
    SCRIPT_ERROR_ACTION_ABORT
    SCRIPT_ERROR_ACTION_CONTINUE
}

"Search keyword type for Mailbox search."
enum SearchKeywordType {
    "Search subject or folder name by keyword."
    ALL
    "Search folder name by keyword."
    FOLDER_NAME
    "Search subject field by keyword."
    SUBJECT
}

"Object type for Mailbox search."
enum SearchObjectType {
    "Search emails only."
    EMAIL
    "Search folders only."
    FOLDER
}

enum ServiceAccountSortByEnum {
    NAME
}

"Share type for fileset."
enum ShareTypeEnum {
    "NFS share."
    NFS
    "Not shared."
    NoShareType
    "SMB share."
    SMB
}

enum SlaAssignTypeEnum {
    doNotProtect
    noAssignment
    protectWithSlaId
}

enum SlaAssignmentEnum {
    SLA_ASSIGNMENT_DERIVED
    SLA_ASSIGNMENT_DIRECT
    SLA_ASSIGNMENT_UNASSIGNED
}

enum SlaAssignmentTypeEnum {
    Derived
    Direct
    Unassigned
}

"Reasons for the SLA being ineligible for migration."
enum SlaMigrationIneligibilityReason {
    "The remote SLA Domain has an archival policy configured, which is not supported in Polaris currently."
    CASCADED_ARCHIVAL_CONFIGURED
    "Rubrik cluster associated with the SLA Domain is disconnected."
    CLUSTER_DISCONNECTED
    "The version of the Rubrik cluster associated with the SLA Domain is not valid for SLA migration."
    INVALID_CLUSTER_VERSION
    "SLA Domain is not associated with a Rubrik cluster."
    INVALID_LOCAL_SLA
    "The type of replication targets is invalid for migration."
    INVALID_REPLICATION_TARGET
    "Replication targets associated with the SLA Domain have invalid cluster version for migration."
    INVALID_REPLICATION_TARGET_VERSION
    "The SLA Domain has frequency configured in minutes, which is currently not supported in Polaris."
    MINUTE_FREQUENCY_CONFIGURED
    "SLA Domain is eligible for migration."
    NOT_APPLICABLE
    "Replication targets associated with the SLA Domain are disconnected."
    REPLICATION_TARGET_DISCONNECTED
    "The SLA Domain has retention lock configured, which is not supported in Polaris currently."
    RETENTION_LOCK_CONFIGURED
    "The SLA Domain is protecting some objects which are currently not supported for upgrade."
    UNSUPPORTED_PROTECTED_OBJECTS
}

enum SlaMigrationStatus {
    FAILED
    IN_PROGRESS
    STUCK
    SUCCEEDED
}

"Filter for SLAStatus."
enum SlaStatusFilterField {
    "Name of Cluster for Filter."
    CLUSTER_NAME
    "Pause Status for Filter."
    PAUSE_STATUS
}

enum SlaSyncStatus {
    FAILED
    PENDING
    SUCCEEDED
}

enum SlaTimeUnitEnum {
    SLA_TIME_UNIT_DAILY
    SLA_TIME_UNIT_HOURLY
    SLA_TIME_UNIT_MINUTE
    SLA_TIME_UNIT_MONTHLY
    SLA_TIME_UNIT_QUARTERLY
    SLA_TIME_UNIT_WEEKLY
    SLA_TIME_UNIT_YEARLY
}

enum SnappableAggregationsEnum {
    ArchiveStorage
    Count
    LogicalBytes
    MissedSnapshots
    PhysicalBytes
    ReplicaStorage
    TotalSnapshots
}

"Snappable anomalies sort field."
enum SnappableAnomaliesSortBy {
    "Snapshot created file count sort."
    CREATED_FILE_COUNT
    "Snapshot deleted file count sort."
    DELETED_FILE_COUNT
    "Snapshot encryption level sort."
    ENCRYPTION
    "Snapshot modified file count sort."
    MODIFIED_FILE_COUNT
    "Snappable name sort."
    NAME
    "Anomaly severity sort."
    SEVERITY
    "Snapshot date sort."
    SNAPSHOT_DATE
    "Snapshot suspicious file count sort."
    SUSPICIOUS_FILE_COUNT
}

enum SnappableCrawlStatus {
    COMPLETE
    FAIL
    IN_PROGRESS
}

enum SnappableGroupByEnum {
    Cluster
    ClusterType
    ComplianceStatus
    Day
    Hour
    Month
    ObjectType
    ProtectionStatus
    PullTimeWithOffset
    Quarter
    SlaDomain
    Week
    Year
}

enum SnappableLevelHierarchyTypeEnum {
    AllSubHierarchyType
    AwsNativeEbsVolume
    AwsNativeEc2Instance
    AwsNativeRdsInstance
    AzureNativeManagedDisk
    AzureNativeVirtualMachine
    AzureSqlDatabaseDb
    AzureSqlManagedInstanceDb
    GcpNativeGCEInstance
    KuprNamespace
    O365Mailbox
    O365Onedrive
    O365SharePointDrive
    O365SharePointList
    O365Site
    O365Teams
}

enum SnappableSlaAssignmentEnum {
    SNAPPABLE_SLA_ASSIGNMENT_DERIVED
    SNAPPABLE_SLA_ASSIGNMENT_DIRECT
    SNAPPABLE_SLA_ASSIGNMENT_UNASSIGNED
}

enum SnappableSortByEnum {
    ArchivalComplianceStatus
    ArchivalSnapshotLag
    ArchiveSnapshots
    ArchiveStorage
    AwaitingFirstFull
    Cluster
    ClusterName
    ClusterType
    ComplianceStatus
    DataReduction
    LastSnapshot
    LatestArchivalSnapshot
    LatestReplicationSnapshot
    LocalOnDemandSnapshots
    LocalSLASnapshots
    LocalSnapshots
    Location
    LogicalBytes
    LogicalDataReduction
    MissedSnapshots
    Name
    ObjectType
    PULL_TIME
    PhysicalBytes
    ProtectionStatus
    ReplicaSnapshots
    ReplicaStorage
    ReplicationComplianceStatus
    ReplicationSnapshotLag
    SlaDomainName
    TotalSnapshots
    TransferredBytes
}

enum SnappableTableColumnEnum {
    ArchiveSnapshots
    ArchiveStorage
    ClusterName
    ClusterType
    ComplianceStatus
    DataReduction
    LastSnapshot
    LocalSnapshots
    Location
    LogicalByte
    MissedSnapshots
    ObjectType
    PhysicalBytes
    ReplicaSnapshots
    ReplicaStorage
    SlaDomain
    SnappableName
    TotalSnapshots
    TransferredBytes
}

"Snappable type."
enum SnappableType {
    "Used for search of the Calendar subsnappable of Exchange."
    CALENDAR
    "Used for search of the Contacts subsnappable of Exchange."
    CONTACTS
    "Exchange snappable. Used for recovery of any subsnappable (Mailbox, Calendar, Contacts) objects."
    EXCHANGE
    "Used for search of the Mailbox subsnappable of Exchange."
    MAILBOX
    "Onedrive snappable."
    ONEDRIVE
    "Sharepoint drive snappable."
    SHAREPOINT_DRIVE
    "Sharepoint list snappable."
    SHAREPOINT_LIST
    "Sharepoint site snappable."
    SHAREPOINT_SITE
    "Teams snappable."
    TEAMS
}

enum SnapshotCloudStorageTierEnum {
    SNAPSHOT_CLOUD_STORAGE_TIER_AZURE_ARCHIVE
    SNAPSHOT_CLOUD_STORAGE_TIER_COLD
    SNAPSHOT_CLOUD_STORAGE_TIER_COOL
    SNAPSHOT_CLOUD_STORAGE_TIER_GLACIER
    SNAPSHOT_CLOUD_STORAGE_TIER_GLACIER_DEEP_ARCHIVE
    SNAPSHOT_CLOUD_STORAGE_TIER_HOT
}

enum SnapshotConsistencyLevelEnum {
    SNAPSHOT_APP_CONSISTENT
    SNAPSHOT_CRASH_CONSISTENT
    UNKNOWN_CONSISTENCY_LEVEL
}

enum SnapshotFrequencyEnum {
    DAILY
    HOURLY
    MONTHLY
    NA
    QUARTERLY
    WEEKLY
    YEARLY
}

enum SnapshotGroupByTimeEnum {
    Day
    Hour
    Month
    Quarter
    Week
    Year
}

enum SnapshotQueryFilterField {
    ARCHIVAL_LOCATION_IDS
    EBS_AWS_NATIVE_ACCOUNT_ID
    EC2_AWS_NATIVE_ACCOUNT_ID
    HAS_CLOUD_NATIVE_INDEX_FILES
    HAS_UNEXPIRED_ARCHIVED_SNAPSHOTS
    HAS_UNEXPIRED_REPLICAS
    IMMUTABLE_LOCK_END_TIME_BEFORE
    IS_APPFLOWS_QUERY_SNAPSHOT_DETAILS_NOT_NEEDED
    IS_ARCHIVAL_COPY
    IS_ARCHIVED
    IS_DELETED_FROM_SOURCE
    IS_DOWNLOADED
    IS_GCED
    IS_LEGALLY_HELD
    IS_ON_DEMAND
    IS_REPLICA
    IS_REPLICATED
    IS_SAP_HANA_INCREMENTAL_SNAPSHOT
    IS_SKIPPED_FOR_REPLICATION
    ON_DEMAND_SLA_ID
    SLA_ID
    SNAPPABLE_TYPES
    SNAPSHOT_STATUS
    SNAPSHOT_TYPE
}

enum SnapshotQuerySortByField {
    CREATION_TIME
    UNKNOWN
}

"Errors which may occur when searching for a snapshot."
enum SnapshotSearchError {
    "Access to the resource is denied."
    AccessDenied
    "No matching snapshot found."
    NoSnapshotFound
}

"Type of snapshot to be used for file recovery."
enum SnapshotType {
    "Archived snapshot."
    ARCHIVED
    "Replicated snapshot."
    REPLICATED
    "Source snapshot."
    SOURCE
}

enum SnapshotTypeEnum {
    DOWNLOADED
    ON_DEMAND
    SCHEDULED
}

"The type of snapshot to be used for recovery operations if source snapshot is expired."
enum SnapshotTypeForRestoreIfSourceExpired {
    "Use the archived snapshot."
    ARCHIVED
    "Use the replicated snapshot."
    REPLICATED
}

enum SnapshotTypeToUseIfSourceExpired {
    ARCHIVED
    REPLICATED
}

enum SonarContentReportGroupByEnum {
    Analyzer
    Cluster
    File
    ObjectName
    Policy
    SLADomain
    Time
}

enum SonarContentReportSortByEnum {
    AnalyzerName
    Cluster
    FileName
    FilesWithHits
    Location
    ObjectName
    Path
    PolicyName
    SLADomain
    Size
    SnapshotTime
    TotalHits
}

enum SonarContentReportTableColumnEnum {
    AnalyzersBreakdown
    Cluster
    FileName
    ObjectName
    ObjectType
    Path
    PoliciesBreakdown
    Size
    SnapshotTime
    TotalHits
}

enum SonarReportGroupByEnum {
    POLICY_VIOLATIONS
    STATUS_POLICY
    TIME_ISSUES
    TIME_VIOLATIONS
}

enum SonarReportSortByEnum {
    NUM_HIGH_RISK_LOCATIONS
    NUM_OBJECTS
    NUM_VIOLATED_FILES
    NUM_VIOLATION
    POLICY_NAME
    POLICY_STATUS
}

enum SonarReportTableColumnEnum {
    NumCoveredObjects
    NumHighRiskLocations
    NumViolatedFiles
    NumViolations
    PolicyName
    PolicyStatus
}

enum SonarReportTablePolicyStatusEnum {
    DISCOVERY
    IN_COMPLIANCE
    OUT_OF_COMPLIANCE
}

enum SortByFieldEnum {
    ActivityStatus
    ActivityType
    AnalyzerName
    AnomalyProbability
    AppBlueprintName
    ArchivalComplianceStatus
    ArchivalSnapshotLag
    ArchiveSnapshots
    ArchiveStorage
    AwaitingFirstFull
    BytesCreatedCount
    BytesDeletedCount
    BytesModifiedCount
    BytesNetChangedCount
    Cluster
    ClusterName
    ClusterType
    ClusterUuid
    ComplianceStatus
    DataReduction
    Date
    ESTIMATED_RUNWAY
    EndTime
    FileName
    FilesCreatedCount
    FilesDeletedCount
    FilesModifiedCount
    FilesWithHits
    IsAnomaly
    LastSnapshot
    LastUpdated
    LatestArchivalSnapshot
    LatestReplicationSnapshot
    LocalOnDemandSnapshots
    LocalSLASnapshots
    LocalSnapshots
    Location
    LogicalBytes
    LogicalDataReduction
    ManagedId
    MissedSnapshots
    NUM_HIGH_RISK_LOCATIONS
    NUM_OBJECTS
    NUM_VIOLATED_FILES
    NUM_VIOLATION
    Name
    NumCanceled
    NumExpected
    NumFailed
    NumSucceeded
    ObjectName
    ObjectType
    POLICY_NAME
    POLICY_STATUS
    PULL_TIME
    Path
    PhysicalBytes
    PolicyName
    PreviousSnapshotDate
    PreviousSnapshotId
    ProtectionStatus
    RegisteredAt
    ReplicaSnapshots
    ReplicaStorage
    ReplicationComplianceStatus
    ReplicationSnapshotLag
    SLADomain
    Severity
    Size
    SlaDomainName
    SnappableName
    SnappableType
    SnapshotDate
    SnapshotId
    SnapshotTime
    SourceSiteName
    StartTime
    SuspiciousFilesCount
    TargetSiteName
    Time
    TotalHits
    TotalSnapshots
    TransferredBytes
}

"Specifies how the results are sorted."
enum SortOrder {
    "The items are sorted in ascending order."
    ASC
    "The items are sorted in descending order."
    DESC
}

enum SortOrderEnum {
    Asc
    Desc
}

enum SourceSourceTypeEnum {
    SOURCE_SOURCE_TYPE_CASSANDRA
    SOURCE_SOURCE_TYPE_MONGO
}

enum SourceSslCertReqsEnum {
    SOURCE_SSL_CERT_REQS_NONE
    SOURCE_SSL_CERT_REQS_OPTIONAL
    SOURCE_SSL_CERT_REQS_REQUIRED
}

enum StalenessTypeEnum {
    IS_STALE
    NOT_STALE
}

"Azure Storage account SKU type."
enum StorageAccountSku {
    "Standard Geo Redundant Storage."
    STANDARD_GRS
    "Standard Locally Redundant Storage."
    STANDARD_LRS
    "Standard Zone Redundant Storage."
    STANDARD_ZRS
}

"Azure Storage Account Tier."
enum StorageAccountTier {
    "Storage account configured with cool access tier."
    COOL
    "Storage account configured with hot access tier."
    HOT
}

enum StorageArrayTypeEnum {
    STORAGE_ARRAY_TYPE_DELL_EMC_POWER_STORE
    STORAGE_ARRAY_TYPE_NET_APP_ONTAPNFS
    STORAGE_ARRAY_TYPE_PURE_STORAGE
}

enum SyslogFacilityTypeEnum {
    ALL_SYSLOG
    AUTH
    RUBRIK_CLI
    RUBRIK_EVENT
    RUBRIK_SSH
    SECURITY
    SYSLOG
}

enum SyslogSeverityTypeEnum {
    ALL_SEVERITY
    CRITICAL
    INFORMATIONAL
    WARNING
}

"All valid table views."
enum TableViewType {
    "Object capacity over time report's main table."
    OBJECT_CAPACITY_OVERTIME_ALL_TABLE
    "Protection task detail report's main table."
    PROTECTION_TASKS_DETAIL_TABLE
}

enum TagFilterType {
    "Filter by exact value of key, and all the tag values."
    TAG_KEY
    "Filter by exact values of tag key and value."
    TAG_KEY_VALUE
}

enum TagRuleSlaAssignTypeEnum {
    doNotProtect
    protectWithSlaId
}

"Encryption type for data on AWS storage location."
enum TargetEncryptionTypeEnum {
    "Password based encryption."
    ENCRYPTION_PASSWORD_BASED
    "KMS Master Key ID based encryption."
    KMS_MASTER_KEY_BASED
    "RSA Key based encryption."
    RSA_KEY_BASED
    "Unknown encryption type."
    UNKNOWN_ENCRYPTION_TYPE
}

enum TargetMappingQueryFilterFieldEnum {
    ARCHIVAL_GROUP_TYPE
    ARCHIVAL_LOCATION_TYPE
    "Filter by cloud account id."
    CLOUD_ACCOUNT_ID
    EXCLUDE_ARCHIVAL_LOCATION_TYPE
    NAME
}

enum TargetMappingSortByFieldEnum {
    NAME
}

enum TargetQueryFilterFieldEnum {
    "Filter for conveying which additional fields of storage locations are required."
    ADDITIONAL_FIELDS_REQUIRED
    "Filter by Rubrik cluster ID."
    CLUSTER_ID
    "Filter for excluding cloud native locations."
    EXCLUDE_CLOUD_NATIVE
    "Filter by name of the archival location the storage location is part of."
    GROUP_NAME
    "Filter by archived storage locations."
    IS_ARCHIVED
    "Filter by is storage location part of an automatically created archival location."
    IS_MANAGED_BY_AUTO_AG
    "Filter by region filter for RCS archival location."
    LOCATION_REGION
    "Filter by global/locally managed storage location."
    LOCATION_SCOPE
    "Filter by tier for RCS archival location."
    LOCATION_TIER
    "Filter by storage location type."
    LOCATION_TYPE
    "Filter by name of storage location or archival location."
    LOC_NAME_OR_GROUP_NAME
    "Filter by storage location name."
    NAME
    "Filter by availability status of the storage location."
    STATUS
}

enum TargetSortByFieldEnum {
    ARCHIVAL_GROUP_NAME
    CLUSTER_NAME
    FAILED_TASKS
    IMMUTABILITY_DAYS
    LOCATION_TYPE
    NAME
    RUNNING_TASKS
    STATUS
    STORAGE_CONSUMED_BYTES
}

"Sync status of the archival location."
enum TargetSyncStatusEnum {
    "Location sync failed."
    ACTION_FAILED
    "Location sync failure being retried."
    ACTION_FAILED_RETRY
    "Location is not created on cluster."
    NOT_CREATED_ON_CDM
    "Reader location is being promoted to owner."
    PENDING_PROMOTE
    "Reader location is being refreshed."
    PENDING_REFRESH
    "Location is syncing with cluster."
    PENDING_SYNC
    "Location is synced with cluster."
    SYNCED
}

enum TargetTypeEnum {
    AWS
    AZURE
    GOOGLE
    NFS
    RCS_AZURE
    S3_COMPATIBLE
}

enum TaskDetailGroupByEnum {
    Cluster
    Day
    Hour
    Month
    Quarter
    Status
    TaskDetailClusterType
    TaskDetailObjectType
    Week
    Year
}

enum TaskDetailSortByEnum {
    EndTime
}

enum TaskDetailTableColumnEnum {
    ArchivalTarget
    ClusterLocation
    DataTransferred
    DirectArchive
    EndTime
    FailureReason
    Location
    LogicalBytes
    ObjectName
    ObjectType
    PhysicalBytes
    ProtectedVolume
    RecoveryPoint
    RecoveryPointType
    ReplicationSource
    ReplicationTarget
    SlaDomainName
    SnapshotConsistency
    StartTime
    Status
    TaskType
    TotalFileTransferred
    UserName
}

enum TaskReportTableColumnEnum {
    EndDate
    Location
    NumOfCanceled
    NumOfExpected
    NumOfFailed
    NumOfSucceeded
    ObjectName
    ObjectType
    SlaDomainName
    StartDate
}

enum TaskSummaryGroupByEnum {
    Cluster
    ClusterType
    Day
    Month
    Object
    ObjectType
    Quarter
    SlaDomain
    Week
    Year
}

enum TaskSummarySortByEnum {
    Date
    NumCanceled
    NumExpected
    NumFailed
    NumSucceeded
    ObjectName
    ObjectType
    SlaDomainName
}

"Korg taskchain state."
enum TaskchainState {
    "Korg taskchain has been canceled."
    CANCELED
    "Korg taskchain is being canceled."
    CANCELING
    "Korg taskchain in failed state."
    FAILED
    "Korg taskchain ready."
    READY
    "Korg taskchain running."
    RUNNING
    "Korg taskchain succeeded."
    SUCCEEDED
    "Korg taskchain in undoing phase."
    UNDOING
}

enum TaskchainStateEnum {
    CANCELED
    CANCELING
    FAILED
    READY
    RUNNING
    SUCCEEDED
    UNDOING
}

"Tenant auth domain config."
enum TenantAuthDomainConfig {
    "Let the tenant set its own SSO/LDAP config."
    ALLOW_AUTH_DOMAIN_CONTROL
    "Auth domain config unspecified."
    AUTH_DOMAIN_UNSPECIFIED
    "Use the global org's SSO/LDAP config."
    INHERIT_AUTH_DOMAIN
    "Only local users allowed."
    LOCAL_AUTH_DOMAIN_ONLY
}

enum TimeDurationEnum {
    DAY
    HOUR
    MONTH
}

enum TimeGranularityEnum {
    DAY
    MONTH
}

enum TimeUnitEnum {
    Day
    Hour
    Month
    Quarter
    Week
    Year
}

"Unmanaged object status field."
enum UnmanagedObjectStatus {
    "Object is proteted."
    PROTECTED
    "Object is relic."
    RELIC
    "Object is remote unprotected."
    REMOTE_UNPROTECTED
    "Object is replicated relic."
    REPLICATED_RELIC
    "Object is unproteted."
    UNPROTECTED
}

"Unmanaged objects sort type Enum."
enum UnmanagedObjectsSortType {
    "Archival storage."
    ARCHIVAL_STORAGE
    "Local storage."
    LOCAL_STORAGE
    "Location."
    LOCATION
    "Object name."
    NAME
    "Retention SLA domain name."
    RETENTION_SLA_DOMAIN_NAME
    "Snapshot count."
    SNAPSHOTS_COUNT
    "Unmanaged status."
    UNMANAGED_STATUS
}

enum UnmanagedSnapshotTypeEnum {
    UNMANAGED_SNAPSHOT_TYPE_ON_DEMAND
    UNMANAGED_SNAPSHOT_TYPE_POLICY_BASED
    UNMANAGED_SNAPSHOT_TYPE_RETRIEVED
}

enum UpgradeInfoGroupByEnum {
    ClusterJobStatus
    Type
    VersionStatus
}

enum UpgradeInfoSortByEnum {
    ClusterJobStatus
    ClusterLocation
    ClusterName
    ClusterType
    DownloadedVersion
    InstalledVersion
    RegisteredAt
    VersionStatus
}

enum UserAuditGroupByEnum {
    Cluster
    ClusterType
    Day
    Hour
    Month
    ObjectType
    Quarter
    UserAuditStatus
    UserAuditType
    Week
    Year
}

"User audit object type."
enum UserAuditObjectTypeEnum {
    AppBlueprint
    ArchivalLocation
    AuthDomain
    AwsAccount
    AwsEventType
    AwsNativeAccount
    AwsNativeEbsVolume
    AwsNativeEc2Instance
    AwsNativeRdsInstance
    AzureNativeDisk
    AzureNativeSubscription
    AzureNativeVm
    AzureSqlDatabase
    AzureSqlManagedInstance
    Blueprint
    CASSANDRA_COLUMN_FAMILY
    CASSANDRA_KEYSPACE
    CASSANDRA_SOURCE
    CloudNativeTagRule
    Cluster
    DB2_DATABASE
    DB2_INSTANCE
    DataLocation
    "Exchange Dag type."
    EXCHANGE_DAG
    "Exchange Database type."
    EXCHANGE_DATABASE
    "Exchange Server type."
    EXCHANGE_SERVER
    Ec2Instance
    FailoverClusterApp
    FederatedAccess
    GcpNativeDisk
    GcpNativeGceInstance
    GcpNativeProject
    Host
    HostFailoverCluster
    HypervScvmm
    HypervServer
    HypervVm
    IpWhitelist
    JobInstance
    Ldap
    LinuxFileset
    LinuxHost
    MOSAIC_STORAGE_LOCATION
    "Mssql object type."
    MSSQL_OBJECT
    ManagedVolume
    Mssql
    MssqlDatabase
    NasHost
    NutanixCluster
    NutanixVm
    O365Calendar
    O365Group
    O365Mailbox
    O365Onedrive
    O365Organization
    O365SharepointDrive
    O365SharepointList
    O365Team
    OracleDb
    OracleHost
    OracleRac
    PublicCloudMachineInstance
    SapHanaDb
    SapHanaSystem
    ShareFileset
    Sla
    SlaDomain
    SmbDomain
    Snapshot
    StorageArray
    StorageArrayVolumeGroup
    StorageSettings
    Storm
    SupportTunnel
    SystemPreference
    Unknown
    Upgrade
    User
    UserActionAudit
    UserGroup
    UserRole
    Vcd
    VcdVapp
    Vcenter
    VmwareMount
    VmwareVm
    VolumeGroup
    WindowsFileset
    WindowsHost
}

enum UserAuditSeverityEnum {
    Critical
    Info
    NA
    Warning
}

enum UserAuditSortByEnum {
    Time
}

enum UserAuditStatusEnum {
    Failure
    Success
}

enum UserAuditTableColumnEnum {
    ClusterName
    ClusterType
    UserAuditStatus
    UserAuditType
}

enum UserAuditTypeEnum {
    AccessManagement
    Audit
    Backup
    Classification
    Configuration
    Diagnostic
    Download
    Failover
    Index
    LOCAL_RECOVERY
    LegalHold
    Login
    Recovery
    Search
    SlaAssignment
    SlaModification
    Sync
    UnknownUserAuditType
}

enum UserDomainEnum {
    CLIENT
    LDAP
    LOCAL
    SHARED_SSO
    SSO
}

enum UserFieldEnum {
    Domain
    Email
    LastLogin
    Status
}

enum UserStatusEnum {
    ACTIVE
    DEACTIVATED
    UNKNOWN
}

enum V1GetCompatibleMssqlInstancesV1RequestRecoveryTypeEnum {
    V1_GET_COMPATIBLE_MSSQL_INSTANCES_V1_REQUEST_RECOVERY_TYPE_EXPORT
    V1_GET_COMPATIBLE_MSSQL_INSTANCES_V1_REQUEST_RECOVERY_TYPE_MOUNT
    V1_GET_COMPATIBLE_MSSQL_INSTANCES_V1_REQUEST_RECOVERY_TYPE_RESTORE
}

enum V1QueryUnmanagedObjectSnapshotsV1RequestSnapshotTypeEnum {
    V1_QUERY_UNMANAGED_OBJECT_SNAPSHOTS_V1_REQUEST_SNAPSHOT_TYPE_ON_DEMAND
    V1_QUERY_UNMANAGED_OBJECT_SNAPSHOTS_V1_REQUEST_SNAPSHOT_TYPE_POLICY_BASED
    V1_QUERY_UNMANAGED_OBJECT_SNAPSHOTS_V1_REQUEST_SNAPSHOT_TYPE_RETRIEVED
}

enum V1QueryUnmanagedObjectSnapshotsV1RequestSortByEnum {
    V1_QUERY_UNMANAGED_OBJECT_SNAPSHOTS_V1_REQUEST_SORT_BY_ARCHIVAL_LOCATION
    V1_QUERY_UNMANAGED_OBJECT_SNAPSHOTS_V1_REQUEST_SORT_BY_LOCAL_EXPIRATION_DATE
    V1_QUERY_UNMANAGED_OBJECT_SNAPSHOTS_V1_REQUEST_SORT_BY_SNAPSHOT_DATE_AND_TIME
}

enum V1QueryUnmanagedObjectSnapshotsV1RequestSortOrderEnum {
    V1_QUERY_UNMANAGED_OBJECT_SNAPSHOTS_V1_REQUEST_SORT_ORDER_ASC
    V1_QUERY_UNMANAGED_OBJECT_SNAPSHOTS_V1_REQUEST_SORT_ORDER_DESC
}

enum V2BulkDeleteMosaicSourcesRequestSourceTypeEnum {
    V2_BULK_DELETE_MOSAIC_SOURCES_REQUEST_SOURCE_TYPE_CASSANDRA
    V2_BULK_DELETE_MOSAIC_SOURCES_REQUEST_SOURCE_TYPE_MONGO
}

enum VSphereLiveMountStatusEnum {
    DatastoreMounted
    MigratingDatastore
    Mounting
    PoweredOff
    PoweredOn
    Unknown
    Unmounting
}

enum VSphereMountSortByEnum {
    ClusterName
    MountTime
    NewVmName
    SourceVmName
    Status
}

enum VSphereVirtualDiskSortByEnum {
    FileName
    Size
}

enum ValidationStatus {
    FAILURE
    SUCCESS
    WARNING
}

enum VcenterConfigV2ConflictResolutionAuthzEnum {
    VCENTER_CONFIG_V2_CONFLICT_RESOLUTION_AUTHZ_ALLOW_AUTO_CONFLICT_RESOLUTION
    VCENTER_CONFIG_V2_CONFLICT_RESOLUTION_AUTHZ_NO_CONFLICT_RESOLUTION
}

enum VcenterSummaryConflictResolutionAuthz {
    VCENTER_SUMMARY_CONFLICT_RESOLUTION_AUTHZ_ALLOW_AUTO_CONFLICT_RESOLUTION
    VCENTER_SUMMARY_CONFLICT_RESOLUTION_AUTHZ_NO_CONFLICT_RESOLUTION
}

enum VersionSourceTypeEnum {
    VERSION_SOURCE_TYPE_CASSANDRA
    VERSION_SOURCE_TYPE_MONGO
}

enum VersionStatusTypeEnum {
    Stable
    Unknown
    UpgradeRecommended
}

enum VmPowerStatusEnum {
    poweredOff
    poweredOn
    suspended
}

enum VmTypeEnum {
    DENSE
    STANDARD
}

"Filter for volume group live mount results."
enum VolumeGroupLiveMountFilterField {
    "Cluster UUID filter field for volume group live mount results."
    CLUSTER_UUID
    """

    Live mount name filter field for
    live mount results.
    """
    MOUNT_NAME
    "Source host Id filter field for live mount results."
    SOURCE_HOST_ID
}

"Sort by parameters for volume group live mount results."
enum VolumeGroupLiveMountSortByField {
    """

    Cluster Name sort by field for volume group
    live mount results.
    """
    CLUSTER_NAME
    """

    Creation date sort by field for volume group
    live mount results.
    """
    CREATION_DATE
    """

    Mount name sort by field for volume group
    live mount results.
    """
    MOUNT_NAME
}

enum WarningSeverityEnum {
    BLOCKING
    NONE
    NON_BLOCKING
}

"A webhook can be enabled or disabled."
enum WebhookStatus {
    "The webhook is automatically disabled by the system."
    AUTO_DISABLED
    "The webhook is disabled."
    DISABLED
    "The webhook is enabled."
    ENABLED
    "Unused default value."
    WEBHOOK_STATUS_UNSPECIFIED
}

enum WeekDayEnum {
    Friday
    Monday
    Saturday
    Sunday
    Thursday
    Tuesday
    Wednesday
}

enum WhitelistModeEnum {
    ALL_USERS
    LOCAL_USERS
}

scalar AnyScalar

"DateTime"
scalar DateTime

"The `LocalTimeType` scalar type a time of day (i.e., between 00:00 and 23:59) WITHOUT an associated timezone. The timezone is assumed to be the local timezone, so if you want an explicit timezone you'll need to associate it explicitly."
scalar LocalTime

"The `Long` scalar type represents non-fractional signed whole numeric values. Long can represent values between -(2^63) and 2^63 - 1."
scalar Long

scalar URL

scalar UUID

"No value is returned."
scalar Void

"Filter Activity series data"
input ActivitySeriesFilterInput {
    ancestorId: UUID
    cluster: CommonClusterFilterInput
    lastActivityStatus: [ActivityStatusEnum!]
    lastActivityType: [ActivityTypeEnum!]
    lastUpdated_gt: DateTime
    lastUpdated_lt: DateTime
    objectFids: [UUID!]
    objectName: String
    objectType: [ActivityObjectTypeEnum!]
    searchTerm: String
    severity: [ActivitySeverityEnum!]
    startTime_gt: DateTime
    startTime_lt: DateTime
}

"Input to add authentication server-based AWS cloud account for native protection."
input AddAwsAuthenticationServerBasedCloudAccountInput {
    "Name of the agency that provisioned the AWS C2S/SC2S account. Agency name is required only while adding a new AWS cloud account."
    agencyName: String
    "Certificate ID for authentication server CA certificate. If a CA certificate ID is not provided, authentication server will be trusted on first use."
    authServerCaCertId: AwsAuthServerCertificateIdInput
    "Hostname of the authentication server. Hostname is required only while adding a new AWS cloud account."
    authServerHostName: String
    "Certificate ID for authentication server user client certificate. Client certificate is required only while adding a new AWS cloud account."
    authServerUserClientCertId: AwsAuthServerCertificateIdInput
    "C2S mission name or SC2S account name."
    awsAccountName: String!
    "Certificate ID for AWS CA certificate. If no CA certificate ID is provided, AWS server will be trusted on first use."
    awsCaCertId: AwsAuthServerCertificateIdInput
    "List of SC2S/C2S AWS regions for the cloud account. By default, all regions will be added."
    awsRegions: [AwsAuthServerBasedCloudAccountRegion!]
    "AWS C2S/SC2S cloud type to which the AWS account belongs."
    cloudType: AwsCloudType!
    "List of features to be enabled for cloud native protection."
    features: [CloudAccountFeature!]!
    "Native ID of cloud account. Native ID is required only while adding a feature to an existing cloud account."
    nativeId: String
    "Name of the role created on the authentication server to enable cloud-native protection for the AWS cloud account. Role name is required only while adding a new AWS cloud account."
    roleName: String
}

"Input to add IAM user-based AWS cloud account for native protection."
input AddAwsIamUserBasedCloudAccountInput {
    "Access key for IAM user with native protection policy on AWS cloud account. Access key is required only while adding new AWS cloud account."
    accessKey: String
    "List of AWS regions for the cloud account."
    awsRegions: [AwsCloudAccountRegion!]
    "Name of cloud account."
    cloudAccountName: String!
    "Cloud type (Standard/China/Gov) for the cloud account"
    cloudType: AwsCloudType = STANDARD
    "List of features to be enabled for cloud native protection."
    features: [CloudAccountFeature!]!
    "Native ID of cloud account."
    nativeId: String!
    "AWS Role ARN with native protection policy on AWS cloud account. Role name must start with 'rubrik-polaris-'. Role ARN is required only while adding new AWS cloud account."
    roleArn: String
    "Secret key for IAM user with native protection policy on AWS cloud account. Secret key is required only while adding new AWS cloud account."
    secretKey: String
}

"Input for adding Exocompute configurations for an Azure Cloud Account."
input AddAzureCloudAccountExocomputeConfigurationsInput {
    "List of Exocompute configurations to be added."
    azureExocomputeRegionConfigs: [AzureExocomputeAddConfigInputType!]!
    "Rubrik ID of the Azure Cloud Account."
    cloudAccountId: UUID!
}

"Input for enabling a feature for an Azure cloud account."
input AddAzureCloudAccountFeatureInput {
    "Feature to be enabled."
    featureType: CloudAccountFeature!
    "Resource group to be used for creating all the resources for the feature. It is required only for the Cloud Native Archival feature. It will be ignored for other features."
    resourceGroup: AddAzureCloudAccountResourceGroupInput
}

"Input for enabling a feature for an Azure cloud account without oauth."
input AddAzureCloudAccountFeatureInputWithoutOauth {
    "Feature to be enabled."
    featureType: CloudAccountFeature!
    "Version of the Azure role policy."
    policyVersion: Int!
    "Resource group to be used for creating all the resources for the feature. Resource group is required only for the Cloud Native Archival/Archival-Encryption features. It will be ignored for other features."
    resourceGroup: AddAzureCloudAccountResourceGroupInput
    "Specific feature input to be used for enabling the feature. It is required only for the Cloud Native Archival Encryption feature. It will be ignored for other features."
    specificFeatureInput: AddAzureCloudAccountSpecificFeatureInput
}

"Input for adding an Azure Cloud Account."
input AddAzureCloudAccountInput {
    "Regions to be added to the Azure Cloud Account."
    regions: [AzureCloudAccountRegion!]!
    "Session ID of the current OAuth session."
    sessionId: String!
    "Subscriptions to be added to the Azure Cloud Account."
    subscriptions: [AddAzureCloudAccountSubscriptionInput!]!
    "Domain name of the Azure Tenant."
    tenantDomainName: String!
}

"Input for the resource group to be used for the feature being enabled."
input AddAzureCloudAccountResourceGroupInput {
    "The name of the resource group."
    name: String!
    "The region name of the resource group."
    region: AzureCloudAccountRegion!
    "The tags to be added on the resource group. If not passed, no tags will be added on the resource group."
    tags: TagsInput
}

"Input for specific feature details to be used for the feature being enabled."
input AddAzureCloudAccountSpecificFeatureInput {
    "Details of the user-assigned managed identity."
    userAssignedManagedIdentityInput: AddAzureCloudAccountUserAssignedManagedIdentityInput!
}

"Input for adding a subscription."
input AddAzureCloudAccountSubscriptionInput {
    "Features to be enabled for the Azure Cloud Account."
    features: [AddAzureCloudAccountFeatureInput!]!
    "Subscription to be added to the Azure Cloud Account."
    subscription: AzureSubscriptionInput!
}

"Input for adding a subscription without oauth."
input AddAzureCloudAccountSubscriptionInputWithoutOauth {
    "Features to be enabled for the Azure Cloud Account."
    features: [AddAzureCloudAccountFeatureInputWithoutOauth!]!
    "Subscription to be added to the Azure Cloud Account."
    subscription: AzureSubscriptionInput!
}

"Input to specify the details of the user-assigned managed identity to be used for CLOUD_NATIVE_ARCHIVAL_ENCRYPTION feature."
input AddAzureCloudAccountUserAssignedManagedIdentityInput {
    "The name of the managed identity."
    name: String!
    "The ID of the service principal object associated with the managed identity."
    principalId: String!
    "The region of the managed identity."
    region: AzureCloudAccountRegion!
    "The name of the resource group of the managed identity."
    resourceGroupName: String!
}

"Input for adding an Azure Cloud Account without OAuth."
input AddAzureCloudAccountWithoutOauthInput {
    "Type of Azure Tenant. Possible values: Azure Public Cloud, Azure China Cloud."
    azureCloudType: AzureCloudType = AZUREPUBLICCLOUD
    "Regions to be added to the Azure Cloud Account."
    regions: [AzureCloudAccountRegion!]!
    "Subscriptions to be added to the Azure Cloud Account."
    subscriptions: [AddAzureCloudAccountSubscriptionInputWithoutOauth!]!
    "Domain Name of the Azure tenant."
    tenantDomainName: String!
}

"Input required to add credentials for performing backups."
input AddCloudNativeSqlServerBackupCredentialsInput {
    "Credentials for the user in the databases with authorization to perform backups."
    backupCredentials: LoginCredentials!
    "Rubrik IDs of the objects. Some examples of objects are: Azure Subscriptions, Resource Groups."
    objectIds: [UUID!]!
    "The object type to which the credentials apply to."
    snappableType: SnappableLevelHierarchyTypeEnum!
}

"Inventory workloads to add for an account."
input AddInventoryWorkloadsInput {
    "List of Inventory Cards."
    inventoryCards: [InventoryCard!]!
}

input AddMosaicStoreInput {
    "Required. Add store request object with details of store to be added."
    addStoreData: MosaicAddStoreRequestInput!
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
}

"Input required to add Azure native virtual machine application consistency specifications."
input AddVmAppConsistentSpecsInput {
    "Specifies whether to cancel backup if pre snapshot script failed to execute on VM."
    cancelBackupIfPreScriptFails: Boolean!
    "Object type for adding Azure native virtual machine application consistency specifications."
    objectType: CloudNativeVmAppConsistentObjectType!
    "Path of post snapshot script in VM."
    postSnapshotScriptPath: String
    "Timeout (in seconds) for post snapshot script to run in VM."
    postSnapshotScriptTimeoutInSeconds: Int
    "Path of pre snapshot script in VM."
    preSnapshotScriptPath: String
    "Timeout (in seconds) for pre snapshot script to run in VM."
    preSnapshotScriptTimeoutInSeconds: Int
    "List of VM Rubrik IDs."
    snappableIds: [UUID!]!
}

"Input to fetch Amazon Machine Image (AMI) type for AWS Archived snapshot export."
input AmiTypeForAwsNativeArchivedSnapshotExportInput {
    "Rubrik ID of the target AWS account for export."
    destinationAwsAccountRubrikId: UUID!
    "Target region for export."
    destinationRegionId: AwsNativeRegion!
    "ID of snapshot to export. Snapshot should have an archived copy present."
    snapshotId: UUID!
}

input AnalyzerGroupInput {
    analyzers: [AnalyzerInput!] = []
    groupType: AnalyzerGroupTypeEnum = UNDEFINED
    id: String = ""
    name: String = ""
}

input AnalyzerInput {
    analyzerType: AnalyzerTypeEnum = UNDEFINED
    dictionary: [String!] = []
    dictionaryCsv: String = ""
    id: String = ""
    name: String = ""
    regex: String = ""
}

"Filter anomaly result data."
input AnomalyResultFilterInput {
    clusterUuid: [UUID!]
    endTime: DateTime
    isAnomaly: Boolean
    managedId: [String!]
    snappableFid: [UUID!]
    startTime: DateTime
}

input AppBlueprintChildInput {
    bootPriority: Int!
    fid: UUID!
    snappableType: ObjectTypeEnum!
}

input AppBlueprintChildSnappableExportSpec {
    datastoreId: String! = ""
    localRecoverySpec: AppBlueprintChildSnappableLocalRecoverySpec
    vmName: String = ""
}

input AppBlueprintChildSnappableInstantRecoverySpec {
    dataStoreName: String = ""
    localRecoverySpec: AppBlueprintChildSnappableLocalRecoverySpec
    preserveMoid: Boolean = false
    vlan: Int = 0
}

input AppBlueprintChildSnappableLocalRecoverySpec {
    disableNetwork: Boolean = false
    hostId: String = ""
    originalVmId: String! = ""
    recoveredVmName: String = ""
    removeNetworkDevices: Boolean = false
    shouldKeepMacAddresses: Boolean = false
    shouldUnregisterVm: Boolean = false
}

input AppBlueprintChildSnappableMountSpec {
    dataStoreName: String = ""
    localRecoverySpec: AppBlueprintChildSnappableLocalRecoverySpec
    vlan: Int = 0
    vmName: String = ""
}

input AppBlueprintExportSnapshotJobConfig {
    baseConfig: AppBlueprintRestoreSnapshotJobConfigBase
    childrenToRestore: [AppBlueprintChildSnappableExportSpec!]! = []
    newAppName: String = ""
}

input AppBlueprintMountSnapshotJobConfig {
    childrenToRestore: [AppBlueprintChildSnappableMountSpec!]! = []
    jobConfigBase: AppBlueprintRestoreSnapshotJobConfigBase
    newAppName: String = ""
}

input AppBlueprintRecoverySpecCreateReqInputType {
    childRecoverySpecs: [ChildRecoverySpecCreateReqInputType!]!
    locationInfo: LocationInfo
    planType: PlanNameEnum!
    userData: String
}

input AppBlueprintRestoreSnapshotJobConfigBase {
    "Power on the new virtual machine(s) if set to True."
    shouldPowerOn: Boolean = true
}

"O365 list app filter"
input AppFilter {
    field: AppFilterField = APP_TYPE
    texts: [String!] = []
}

"O365 list app sort by param"
input AppSortByParam {
    field: AppSortByParamField = APP_ID
    sortOrder: AppSortOrder = ASC
}

input ArchivalSpecInput {
    archivalGroupId: String = ""
    archivalTieringSpecInput: ArchivalTieringSpecInput
    "Archives all snapshots taken with the specified frequency."
    frequencies: [RetentionUnitEnum!] = []
    threshold: Int = 0
    thresholdUnit: RetentionUnitEnum = MINUTES
}

"Archival tiering spec input."
input ArchivalTieringSpecInput {
    "Cold storage class for tiering."
    coldStorageClass: ColdStorageClass = COLD_STORAGE_CLASS_UNKNOWN
    "Set when instant tiering enabled."
    isInstantTieringEnabled: Boolean = false
    "Min accessible duration specified for smart tiering."
    minAccessibleDurationInSeconds: Long = 0
    "Set to tier existing snapshots for instant tiering."
    shouldTierExistingSnapshots: Boolean = false
}

"A Set of fields needed to archive a kubernetes cluster."
input ArchiveK8sClusterInput {
    "UUID of the Kubernetes Cluster."
    clusterId: UUID!
}

"Archive Recovery Plan configuration."
input ArchiveRecoveryPlanInput {
    "Recovery Plan ID."
    id: String!
}

input AssignMssqlSlaPropertiesAsyncInput {
    "Required. Update information."
    updateInfo: MssqlSlaDomainAssignInfoInput!
    "Required. User note to associate with audits."
    userNote: String
}

input AssignMssqlSlaPropertiesInput {
    "Required. Update information."
    updateInfo: MssqlSlaDomainAssignInfoInput!
}

"Input to assign Rubrik SLA Domains."
input AssignSlaInput {
    "Provide optional snappable type under the object for SLA assignment. This is meant to be used only for objects that support multiple snappable hierarchies. This allows an SLA to be set for one/more specific snappable types under the object, instead of applying the SLA for all the snappable types. For example, an AWS account object can potentially have 2 different snappable types under it - AwsNativeEc2Instance and AwsNativeRdsInstance. This field can be set with the appropriate type so that the SLA only gets applied to snappables of the selected type under that account. If the SLA must be applicable for all the snappable types under the object, then this field can be set to `AllSubHierarchyType` or left blank. This field must either be left blank or set to `AllSubHierarchyType` when assigning SLA to a snappable or to an object that does not support multiple snappable types."
    applicableSnappableType: SnappableLevelHierarchyTypeEnum
    "Choose what to do with existing snapshot in case of do not protect slas."
    existingSnapshotRetention: GlobalExistingSnapshotRetentionEnum
    "Provide list of object IDs you want to assign Global SLA."
    objectIds: [UUID!]!
    "Boolean value to indicate whether to apply changes made to the SLA to existing snapshots."
    shouldApplyToExistingSnapshots: Boolean
    "Boolean value to indicate if the new configuration keeps existing, non-policy snapshots of data sources retained by this SLA Domain."
    shouldApplyToNonPolicySnapshots: Boolean
    "Corresponds to the assignment type for the global SLA."
    slaDomainAssignType: SlaAssignTypeEnum!
    "Corresponds to optional SLA ID."
    slaOptionalId: UUID
    "Optional User note."
    userNote: String
}

"The authentication type and token to authenticate the endpoint."
input AuthInfo {
    "The type of authentication that protects the URL endpoint."
    authType: AuthenticationType!
    "The custom authentication header key and value to authenticate the endpoint."
    customHeader: CustomHeader
    "The token used for authentication."
    token: String
    "The username and password of the user to authenticate the endpoint."
    userCredentials: UserCredentials
}

input AutomaticAwsTargetMappingCreateRequest {
    awsComputeSettingsId: String
    bucketPrefix: String!
    cloudAccountId: UUID!
    clusterUuidList: [String!]
    isConsolidationEnabled: Boolean!
    kmsMasterKeyId: String
    name: String!
    proxySettings: ProxySettingsInput
    region: AwsRegion!
    rsaKey: String
    storageClass: AwsStorageClassTypeEnum!
}

input AutomaticAwsTargetMappingEditRequest {
    awsComputeSettingsId: String
    cloudAccountId: UUID
    clusterUuidList: [String!]
    id: String!
    isConsolidationEnabled: Boolean
    name: String
    proxySettings: ProxySettingsInput
    storageClass: AwsStorageClassTypeEnum
}

input AutomaticAzureTargetMappingCreateRequest {
    accessKey: String!
    cloudAccountId: UUID!
    clusterUuidList: [String!]
    computeSettings: AzureCloudComputeSettingsInput
    containerNamePrefix: String!
    instanceType: InstanceTypeEnum!
    isConsolidationEnabled: Boolean!
    name: String!
    proxySettings: ProxySettingsInput
    rsaKey: String!
    storageAccountName: String!
}

input AutomaticAzureTargetMappingEditRequest {
    accessKey: String
    cloudAccountId: UUID
    clusterUuidList: [String!]
    computeSettings: AzureCloudComputeSettingsInput
    id: String!
    isConsolidationEnabled: Boolean
    name: String
    proxySettings: ProxySettingsInput
    storageAccountName: String
}

input AwsAccountCreateRequest {
    accessKey: String!
    description: String
    name: String!
    secretKey: String!
}

input AwsAccountEditRequest {
    accessKey: String!
    description: String
    id: String!
    name: String!
    secretKey: String!
}

"Input to add certificate details for authentication server-based cloud accounts."
input AwsAuthServerCertificateIdInput {
    "Certificate ID."
    id: Long!
}

"Input to update regions in authentication server-based AWS cloud accounts."
input AwsAuthServerRegionsInput {
    "List of regions for cloud account."
    regions: [AwsAuthServerBasedCloudAccountRegion!]!
}

"Input to update role name in authentication server-based cloud accounts."
input AwsAuthServerRoleNameInput {
    "Name of the role."
    name: String!
}

"CDM versions for Aws account."
input AwsCdmVersionRequest {
    "Cloud account id of the AWS account."
    cloudAccountId: String = ""
    "Aws region."
    region: String = ""
}

"Input to get AWS cloud account configurations."
input AwsCloudAccountConfigsInput {
    "Admin account ID to filter."
    awsAdminAccountFilter: UUID
    "Search text to match in native ID, account name, or role ARN."
    columnSearchFilter: String
    "Type of cloud native protection feature."
    feature: CloudAccountFeature!
    "List of status filters for listing cloud accounts."
    statusFilters: [CloudAccountStatus!]!
}

"Input to protect a feature for the AWS cloud account."
input AwsCloudAccountFeatureVersionInput {
    "Name of feature to be protected for cloud account."
    feature: CloudAccountFeature!
    "Version of feature. This should be same as the response given in the first step (validateAndCreateAwsCloudAccount)."
    version: Int!
}

"Details of an AWS cloud account."
input AwsCloudAccountInput {
    "Name of cloud account."
    accountName: String = ""
    "Cloud type (Standard/China) for the cloud account."
    cloudType: AwsCloudType = STANDARD
    "Rubrik ID of the AWS cloud account."
    id: String = ""
    "Native ID of cloud account."
    nativeId: String = ""
    "Whether seamless setup flow is enabled on cloud account."
    seamlessFlowEnabled: Boolean = false
}

"AWS cloud account with features."
input AwsCloudAccountWithFeaturesInput {
    "Type of cloud native protection features."
    features: [CloudAccountFeature!]!
}

"AWS cloud accounts with features."
input AwsCloudAccountsWithFeaturesInput {
    "Admin account ID to filter."
    awsAdminAccountFilter: UUID
    "Search text to match in native ID, account name, and role ARN."
    columnSearchFilter: String
    "Type of cloud native protection feature."
    feature: CloudAccountFeature!
    "List of status filters for listing cloud accounts."
    statusFilters: [CloudAccountStatus!]!
}

input AwsCloudComputeSettingFilterInput {
    field: AwsCloudComputeSettingFilterFieldEnum = NAME
    text: String = ""
}

input AwsCloudComputeSettingsInput {
    computeProxySettings: ProxySettingsInput
    securityGroupId: String = ""
    subnetId: String = ""
    vpcId: String = ""
}

input AwsComputeSettingsCreateRequest {
    cloudAccountId: String = ""
    clusterInterfaceCidrs: [ClusterInfCidrsInput!] = []
    isSecurityGroupPolarisManaged: Boolean = false
    name: String = ""
    region: AwsRegion = UNKNOWN_AWS_REGION
    securityGroupId: String = ""
    subnetId: String = ""
    vpcId: String = ""
}

input AwsComputeSettingsEditRequest {
    id: String = ""
    name: String = ""
    securityGroupId: String = ""
    subnetId: String = ""
    vpcId: String = ""
}

"ES storage for AWS account."
input AwsEsConfigInput {
    "Bucket name in AWS."
    bucketName: String = ""
    "Create new bucket or use existing."
    shouldCreateBucket: Boolean = false
}

"AWS exocompute configuration to add."
input AwsExocomputeConfigInput {
    "AWS ID of cluster control plane security group. Not required if isPolarisManaged is true."
    clusterSecurityGroupId: String = ""
    "True, if security groups are to be managed to be polaris. False, if security groups are managed by user."
    isPolarisManaged: Boolean!
    "AWS ID of worker node security group. Not required if isPolarisManaged is true."
    nodeSecurityGroupId: String = ""
    "The region for which the configuration is specified."
    region: AwsCloudAccountRegion!
    "List of exactly 2 subnets."
    subnets: [AwsExocomputeSubnetInputType!]!
    "AWS ID of the VPC."
    vpcId: String!
}

"AWS exocompute subnet input."
input AwsExocomputeSubnetInputType {
    "Availability zone of the subnet."
    availabilityZone: String!
    "AWS ID of subnet."
    subnetId: String!
}

"Immutability settings for creating AWS locations."
input AwsImmutabilitySettings {
    "Immutability lock duration of AWS location in days."
    lockDurationDays: Int = 0
}

"Filter to return AWS objects which have account rubrik ID in the given list of account rubrik IDs."
input AwsNativeAccountFilter {
    "List of AWS account Rubrik IDs."
    accountIds: [String!]!
}

"Filters for list of AWS accounts."
input AwsNativeAccountFilters {
    "Filter by effective SLA Domain."
    effectiveSlaFilter: EffectiveSlaFilter
    "Filter by name substring."
    nameSubstringFilter: NameSubstringFilter
}

"Filter to return AWS EBS volumes which are attached to one of the EC2 instances in the given list of EC2 instance IDs."
input AwsNativeAttachedInstanceFilter {
    "List of EC2 instance IDs."
    ec2InstanceIds: [String!]!
}

"Filter to return AWS EBS volumes which have file recovery enabled."
input AwsNativeEbsVolumeFileRecoveryStatusFilter {
    "List of file recovery statuses."
    statuses: [AwsNativeFileRecoveryStatus!]!
}

"Filters for list of AWS EBS volumes."
input AwsNativeEbsVolumeFilters {
    "Filter by AWS account."
    accountFilter: AwsNativeAccountFilter
    "Filter by attached EC2 instance."
    attachedInstanceFilter: AwsNativeAttachedInstanceFilter
    "Filter by effective SLA Domain."
    effectiveSlaFilter: EffectiveSlaFilter
    "Filter by file recovery status."
    fileRecoveryStatusFilter: AwsNativeEbsVolumeFileRecoveryStatusFilter
    "Filter by name or ID substring."
    nameOrIdSubstringFilter: AwsNativeEbsVolumeNameOrIdSubstringFilter
    "Filter by region."
    regionFilter: AwsNativeRegionFilter
    "Filter by relic status."
    relicFilter: RelicFilter
    "Filter by tags."
    tagFilter: AwsNativeTagFilter
    "Filter by EBS volume type."
    typeFilter: AwsNativeEbsVolumeTypeFilter
}

"Filter to return AWS EBS volumes with a given substring in their name or instance ID."
input AwsNativeEbsVolumeNameOrIdSubstringFilter {
    "Name or ID substring."
    nameOrIdSubstring: String!
}

"Filter to return AWS EBS volumes which have volume type in the given list of volume types."
input AwsNativeEbsVolumeTypeFilter {
    "List of EBS volume types."
    ebsVolumeTypes: [AwsNativeEbsVolumeType!]!
}

"Filter to return AWS EC2 instances which have file recovery enabled."
input AwsNativeEc2InstanceFileRecoveryStatusFilter {
    "List of file recovery statuses."
    statuses: [AwsNativeFileRecoveryStatus!]!
}

"Filters for list of AWS EC2 instances."
input AwsNativeEc2InstanceFilters {
    "Filter by AWS account."
    accountFilter: AwsNativeAccountFilter
    "Filter by effective SLA Domain."
    effectiveSlaFilter: EffectiveSlaFilter
    "Filter by file recovery status."
    fileRecoveryStatusFilter: AwsNativeEc2InstanceFileRecoveryStatusFilter
    "Filter by name or ID substring."
    nameOrIdSubstringFilter: AwsNativeEc2InstanceNameOrIdSubstringFilter
    "Filter by region."
    regionFilter: AwsNativeRegionFilter
    "Filter by relic status."
    relicFilter: RelicFilter
    "Filter by tags."
    tagFilter: AwsNativeTagFilter
    "Filter by EC2 instance type."
    typeFilter: AwsNativeEc2InstanceTypeFilter
    "Filter by VPC."
    vpcFilter: AwsNativeVpcFilter
}

"Filter to return AWS EC2 instances with a given substring in their name or instance ID."
input AwsNativeEc2InstanceNameOrIdSubstringFilter {
    "Name or ID substring."
    nameOrIdSubstring: String!
}

"Filter to return AWS EC2 instances which have instance type in the given list of instance types."
input AwsNativeEc2InstanceTypeFilter {
    "List of EC2 instance types."
    ec2InstanceTypes: [AwsNativeEc2InstanceType!]!
}

"Filter to return AWS RDS instances which have database engine in the given list of database engines."
input AwsNativeRdsDbEngineFilter {
    "List of database engines."
    dbEngines: [AwsNativeRdsDbEngine!]!
}

"Filter to return AWS RDS instances which have database instance class in the given list of database instance classes."
input AwsNativeRdsDbInstanceClassFilter {
    "List of database instance classes."
    dbInstanceClasses: [AwsNativeRdsDbInstanceClass!]!
}

"Filters for list of AWS RDS instances."
input AwsNativeRdsInstanceFilters {
    "Filter by AWS account."
    accountFilter: AwsNativeAccountFilter
    "Filter by database engine."
    dbEngineFilter: AwsNativeRdsDbEngineFilter
    "Filter by database instance class."
    dbInstanceClassFilter: AwsNativeRdsDbInstanceClassFilter
    "Filter by effective SLA Domain."
    effectiveSlaFilter: EffectiveSlaFilter
    "Filter by name substring."
    nameSubstringFilter: NameSubstringFilter
    "Filter by region."
    regionFilter: AwsNativeRegionFilter
    "Filter by relic status."
    relicFilter: RelicFilter
    "Filter by tags."
    tagFilter: AwsNativeTagFilter
    "Filter by VPC."
    vpcFilter: AwsNativeVpcFilter
}

"Filter to return AWS objects which have region in the given list of regions."
input AwsNativeRegionFilter {
    "List of regions."
    regions: [AwsNativeRegion!]!
}

"Filter to return AWS objects which have at least one tag in the given list of tags."
input AwsNativeTagFilter {
    "Tag filter parameters."
    tagFilterParams: [TagFilterParams!]!
}

"Filter to return AWS EC2 instances which have VPC ID in the given list of VPC IDs."
input AwsNativeVpcFilter {
    "Virtual Private Cloud (VPC) IDs to filter."
    vpcIds: [String!]!
}

input AwsRdsConfigInput {
    logRetention: SlaDurationInput
}

"Input to update regions for AWS cloud account."
input AwsRegionsInput {
    "AWS regions for native protection."
    regions: [AwsCloudAccountRegion!]!
}

"Input to update role ARN for IAM user-based AWS cloud account."
input AwsRoleArnInput {
    "AWS role ARN for native protection."
    roleArn: String!
}

input AwsTargetCreateRequest {
    awsComputeSettingsId: String
    awsRetrievalTier: AwsRetrievalTier
    bucketName: String!
    cloudAccountId: UUID!
    cloudComputeSettings: AwsCloudComputeSettingsInput
    clusterUuid: String!
    "Field for specifying password to encrypt contents of AWS location."
    encryptionPassword: String
    "AWS immutability settings."
    immutabilitySettings: AwsImmutabilitySettings
    isConsolidationEnabled: Boolean!
    kmsMasterKeyId: String
    name: String!
    proxySettings: ProxySettingsInput
    region: AwsRegion!
    rsaKey: String
    storageClass: AwsStorageClassTypeEnum!
}

input AwsTargetEditRequest {
    awsComputeSettingsId: String
    awsRetrievalTier: AwsRetrievalTier
    cloudAccountId: UUID
    cloudComputeSettings: AwsCloudComputeSettingsInput
    id: String!
    "AWS immutability settings."
    immutabilitySettings: AwsImmutabilitySettings
    isConsolidationEnabled: Boolean
    name: String
    proxySettings: ProxySettingsInput
    storageClass: AwsStorageClassTypeEnum
}

"Input to update AWS IAM user keys for IAM user-based AWS cloud account."
input AwsUserKeysInput {
    "IAM user access key."
    accessKey: String!
    "IAM user secret key."
    secretKey: String!
}

input AwsVMNicSpecInputType {
    awsSecurityGroupId: String = ""
    awsSubnetId: String = ""
    ipv4Address: String = ""
    key: Int = 0
    securityGroupId: String = ""
    subnetId: String = ""
}

input AwsVMRecoverySpecInputType {
    availabilityZone: String = ""
    dedicatedHostId: String = ""
    hostAffinity: String = ""
    instanceTypeId: Int! = 0
    instanceTypeName: String = ""
    keyName: String = ""
    nics: [AwsVMNicSpecInputType!] = []
    placementGroup: String = ""
    tenancy: AwsInstanceTenancyEnum = DEDICATED
    userData: String = ""
    version: Long = 0
    volumes: [AwsVMVolumeSpecInputType!] = []
}

input AwsVMVolumeSpecInputType {
    iops: Int = 0
    "key value defined in VMWare VM"
    key: Int = 0
    sizeGbs: Int = 0
    volumeTypeId: Int = 0
}

"Configuration for creating aws instances."
input AwsVmConfig {
    "CDM version to determine image."
    cdmVersion: String = ""
    "Id of VM image to deploy."
    imageId: String = ""
    "Instance profile to attach to image."
    instanceProfileName: String = ""
    "Node disk size in GB."
    nodeSizeGb: Int = 0
    "List of security groups to assign to instances."
    securityGroups: [String!]
    "Aws subnet in which instance is created."
    subnet: String = ""
    "Tags to attach to created resources."
    tags: String = ""
    "Create dense or sttandard nodes."
    vmType: VmTypeEnum
}

input AzureAccountCreateRequest {
    description: String
    name: String!
    subscriptionId: String!
}

input AzureAccountEditRequest {
    description: String
    id: String!
    name: String
    subscriptionId: String
}

input AzureCloudAccountSubscriptionInput {
    id: String = ""
    name: String = ""
}

input AzureCloudComputeSettingsInput {
    appId: String = ""
    appSecretKey: String = ""
    computeProxySettings: ProxySettingsInput
    generalPurposeStorageContainer: String = ""
    generalPurposeStorageName: String = ""
    region: AzureRegion = UNKNOWN_AZURE_REGION
    resourceGroup: String = ""
    securityGroupId: String = ""
    subnetId: String = ""
    virtualNetworkId: String = ""
}

"Information about the customer-managed key and key vault for a region."
input AzureCmkInput {
    "Name of the customer-managed key."
    keyName: String = ""
    "Name of the key vault."
    keyVaultName: String = ""
    "Region of the key vault."
    region: AzureRegion = UNKNOWN_AZURE_REGION
}

"Input for getting Encryption Keys in an Azure Key Vault."
input AzureEncryptionKeysInput {
    "The Rubrik ID of the cloud account."
    cloudAccountId: UUID!
    "Name of the Key Vault for which Encryption Keys are to be fetched."
    keyVaultName: String!
    "Name of Azure Resource Group of the Key Vault."
    resourceGroupName: String!
}

"ES storage for Azure account."
input AzureEsConfigInput {
    "Storage container name in Azure."
    containerName: String = ""
    "Storage resource group in Azure."
    resourceGroup: String = ""
    "Should create a new container or not?"
    shouldCreateContainer: Boolean = false
    "Storage name in Azure."
    storageAccount: String = ""
    storageSecret: String = ""
}

"ES storage for Azure account."
input AzureEsConfigInputNoSecret {
    "Storage container name in Azure."
    containerName: String = ""
    "Storage resource group in Azure."
    resourceGroup: String = ""
    "Should create a new container or not?"
    shouldCreateContainer: Boolean = false
    "Storage name in Azure."
    storageAccount: String = ""
}

"Azure exocompute config to add."
input AzureExocomputeAddConfigInputType {
    "Specifies if this configuration is managed by Polaris."
    isPolarisManaged: Boolean!
    "The region for which the config is specified."
    region: AzureCloudAccountRegion!
    "Subnet native id where exocompute should be launched."
    subnetNativeId: String!
}

"Input for getting Azure resource groups if they exist."
input AzureGetResourceGroupsInfoIfExistInput {
    "Resource groups to get."
    resourceGroupInputs: [AzureNativeResourceGroupInfoInput!]!
    "Session ID of the current OAuth session."
    sessionId: String!
}

input AzureImmutabilitySettings {
    lockDurationDays: Int = 0
}

"Input for getting Azure Key Vaults in a region."
input AzureKeyVaultsInput {
    "The Rubrik ID of the cloud account."
    cloudAccountId: UUID!
    "Region for which Key Vaults are to be fetched."
    region: AzureRegion!
    "The Principal ID of the user assigned managed identity."
    userAssignedManagedIdentityPrincipalId: UUID
}

"Filter to return Azure disks which are attached to one of the virtual machines in the given list of virtual machine IDs."
input AzureNativeAttachedVmFilter {
    "List of virtual machine IDs."
    virtualMachineIds: [String!]!
}

"Filters for listing Azure resource groups."
input AzureNativeCommonResourceGroupFilters {
    effectiveSlaFilter: AzureNativeRgSlaFilter
    nameSubstringFilter: NameSubstringFilter
    regionFilter: AzureNativeRegionFilter
    subscriptionFilter: AzureNativeCommonRgSubscriptionFilter
}

"Filters Azure resource groups that belong to the subscriptions identified by the list of Rubrik subscription IDs provided."
input AzureNativeCommonRgSubscriptionFilter {
    "List of Rubrik subscription IDs."
    subscriptionIds: [String!]!
}

"Filter to decide whether to get disks with a configured exocompute."
input AzureNativeDiskExocomputeConnectedFilter {
    "Whether to only get snappables whose regions have exocompute configured."
    isConnected: Boolean!
}

"Filter to return Azure disks which have file indexing enabled."
input AzureNativeDiskFileIndexingFilter {
    "The list of status values to filter for."
    statuses: [AzureNativeFileIndexingStatus!]!
}

"Filters for list of Azure disks."
input AzureNativeDiskFilters {
    "Filter by attached Azure Virtual Machine."
    attachedVmFilter: AzureNativeAttachedVmFilter
    diskTypeFilter: AzureNativeDiskTypeFilter
    effectiveSlaFilter: EffectiveSlaFilter
    exocomputeConnectedFilter: AzureNativeDiskExocomputeConnectedFilter
    fileIndexingFilter: AzureNativeDiskFileIndexingFilter
    nameSubstringFilter: NameSubstringFilter
    regionFilter: AzureNativeRegionFilter
    relicFilter: RelicFilter
    resourceGroupFilter: AzureNativeDiskResourceGroupFilter
    subscriptionFilter: AzureNativeDiskSubscriptionFilter
    tagFilter: AzureNativeTagFilter
}

"Filter to return Azure disks which have resource group name in the given list of resource group names."
input AzureNativeDiskResourceGroupFilter {
    resourceGroupNames: [String!]!
}

"Filter to return Azure disks which have rubrik subscription ID in the given list of rubrik subscription IDs."
input AzureNativeDiskSubscriptionFilter {
    subscriptionIds: [String!]!
}

"Filter to return Azure virtual machine which have VM size in the given list of VM sizes."
input AzureNativeDiskTypeFilter {
    diskTypes: [String!]!
}

"Filter to return Azure virtual machine which have region in the given list of regions."
input AzureNativeRegionFilter {
    regions: [AzureNativeRegion!]!
}

"Input for getting Azure resource group if it exists."
input AzureNativeResourceGroupInfoInput {
    "The name of the resource group."
    resourceGroupName: String!
    "The native ID of the Azure subscription."
    subscriptionNativeId: UUID!
}

"Returns Azure resource groups containing objects that are protected by the SLA domains identified by the specified SLA IDs."
input AzureNativeRgSlaFilter {
    "List of SLA Domain IDs."
    effectiveSlaIds: [String!]!
}

"Filters for list of Azure subscriptions."
input AzureNativeSubscriptionFilters {
    effectiveSlaFilter: EffectiveSlaFilter
    nameSubstringFilter: NameSubstringFilter
}

"Filter to return Azure objects which have at least one tag in the given list of tags."
input AzureNativeTagFilter {
    tagFilterParams: [TagFilterParams!]!
}

"Filters for list of Azure virtual machines."
input AzureNativeVirtualMachineFilters {
    effectiveSlaFilter: EffectiveSlaFilter
    exocomputeConnectedFilter: AzureNativeVmExocomputeConnectedFilter
    fileIndexingFilter: AzureNativeVmFileIndexingFilter
    nameSubstringFilter: NameSubstringFilter
    regionFilter: AzureNativeRegionFilter
    relicFilter: RelicFilter
    resourceGroupFilter: AzureNativeVmResourceGroupFilter
    subscriptionFilter: AzureNativeVmSubscriptionFilter
    tagFilter: AzureNativeTagFilter
    vmSizeFilter: AzureNativeVmSizeFilter
    vnetFilter: AzureNativeVnetFilter
}

"Filter to decide whether to get VMs with a configured exocompute."
input AzureNativeVmExocomputeConnectedFilter {
    "Whether to only get snappables whose regions have exocompute configured."
    isConnected: Boolean!
}

"Filter to return Azure VMs which have file indexing enabled."
input AzureNativeVmFileIndexingFilter {
    "The list of status values to filter for."
    statuses: [AzureNativeFileIndexingStatus!]!
}

"Filter by resource group name."
input AzureNativeVmResourceGroupFilter {
    "List of resource group names."
    resourceGroupNames: [String!]!
}

"Filter by virtual machine size."
input AzureNativeVmSizeFilter {
    "List of virtual machine sizes."
    vmSizes: [String!]!
}

"Filter by subscription ID."
input AzureNativeVmSubscriptionFilter {
    "List of subscription IDs."
    subscriptionIds: [String!]!
}

"Filter by VNet name."
input AzureNativeVnetFilter {
    vnetNames: [String!]!
}

"Exocompute config"
input AzureO365ExocomputeConfig {
    existingComputeConfig: ExistingComputeConfig
    existingGroupConfig: GroupConfig
    existingStorageAccountConfig: ExistingStorageAccountConfig
    newComputeConfig: NewComputeConfig
    newGroupConfig: GroupConfig
    newStorageAccountConfig: NewStorageAccountConfig
    regionName: String!
}

"Input to configure the SLA Domain for Azure SQL Database DB."
input AzureSqlDatabaseDbConfigInput {
    "Specifies the number of days for which the Azure SQL Database DB logs will be retained. Number of days can range from 1 to 35."
    logRetentionInDays: Int = 0
}

"Input for exporting Long Term Retention backup of an Azure SQL Database."
input AzureSqlDatabaseDbLtrExport {
    "Region in which database is being exported."
    destinationRegionName: String!
    "Resource Group in which database is being exported."
    destinationResourceGroupName: String!
    "Database Server in which database is being exported."
    destinationServerName: String!
    "Rubrik ID of the snapshot from which database is being exported."
    sourceSnapshotRubrikId: UUID!
}

"Input for exporting Point-in-Time backup of an Azure SQL Database."
input AzureSqlDatabaseDbPitExport {
    "Timestamp of point in time restore."
    restorePointInTime: DateTime!
}

"Filters for list of Azure SQL Databases."
input AzureSqlDatabaseFilters {
    "Filter by Effective SLA."
    effectiveSlaFilter: EffectiveSlaFilter
    "Filter by name substring."
    nameSubstringFilter: NameSubstringFilter
    "Filter by region."
    regionFilter: AzureNativeRegionFilter
    "Filter by relics."
    relicFilter: RelicFilter
    "Filter by resource group name."
    resourceGroupFilter: AzureSqlDatabaseResourceGroupFilter
    "Filter by server."
    serverFilter: CloudNativeDatabaseServerFilter
    "Filter by subscription."
    subscriptionFilter: AzureSqlDatabaseSubscriptionFilter
    "Filter by tag."
    tagFilter: AzureNativeTagFilter
}

"Filter to return Azure SQL Databases which have resource group name in the given list of resource group names."
input AzureSqlDatabaseResourceGroupFilter {
    "List of names of resource groups."
    resourceGroupNames: [String!]!
}

"Filters for list of Azure SQL Database Servers."
input AzureSqlDatabaseServerFilters {
    "Filter by Effective SLA."
    effectiveSlaFilter: EffectiveSlaFilter
    "Filter by name substring."
    nameSubstringFilter: NameSubstringFilter
    "Filter by region."
    regionFilter: AzureNativeRegionFilter
    "Filter by resource group name."
    resourceGroupFilter: AzureSqlDatabaseServerResourceGroupFilter
    "Filter by subscription."
    subscriptionFilter: AzureSqlDatabaseServerSubscriptionFilter
}

"Filter to return Azure SQL Database Servers which have resource group name in the given list of resource group names."
input AzureSqlDatabaseServerResourceGroupFilter {
    "List of names of resource groups."
    resourceGroupNames: [String!]!
}

"Filter to return Azure SQL Database Servers which have resource group name in the given list of resource group names."
input AzureSqlDatabaseServerSubscriptionFilter {
    "List of subscription IDs."
    subscriptionIds: [String!]!
}

"Filter to return Azure SQL Databases with subscription ID in the given list of Rubrik subscription IDs."
input AzureSqlDatabaseSubscriptionFilter {
    "List of subscription IDs."
    subscriptionIds: [String!]!
}

"Filters for list of Azure SQL Managed Instance Databases."
input AzureSqlManagedInstanceDatabaseFilters {
    "Filter by Effective SLA."
    effectiveSlaFilter: EffectiveSlaFilter
    "Filter by name substring."
    nameSubstringFilter: NameSubstringFilter
    "Filter by region."
    regionFilter: AzureNativeRegionFilter
    "Filter by relic."
    relicFilter: RelicFilter
    "Filter by resource group name."
    resourceGroupFilter: AzureSqlManagedInstanceDatabaseResourceGroupFilter
    "Filter by server."
    serverFilter: CloudNativeDatabaseServerFilter
    "Filter by subscription."
    subscriptionFilter: AzureSqlManagedInstanceDatabaseSubscriptionFilter
}

"Filter to return Azure SQL Managed Instance Databases which have resource group name in the given list of resource group names."
input AzureSqlManagedInstanceDatabaseResourceGroupFilter {
    "List of names of resource groups."
    resourceGroupNames: [String!]!
}

"Filter to return Azure SQL Managed Instance Databases which have resource group name in the given list of resource group names."
input AzureSqlManagedInstanceDatabaseSubscriptionFilter {
    "List of subscription IDs."
    subscriptionIds: [String!]!
}

"Input to configure the SLA Domain for Azure SQL Managed Instance DB."
input AzureSqlManagedInstanceDbConfigInput {
    "Specifies the number of days for which the Azure SQL Managed Instance DB logs will be retained. Number of days can range from 1 to 35."
    logRetentionInDays: Int = 0
}

"Input for exporting Long Term Retention backup of Azure SQL Managed Instance database."
input AzureSqlManagedInstanceDbLtrExport {
    "Region to which database is being exported."
    destinationRegionName: String!
    "Rubrik ID of the snapshot from which database is being exported."
    sourceSnapshotRubrikId: UUID!
}

"Input for exporting Point-in-Time backup of an Azure SQL Managed Instance database."
input AzureSqlManagedInstanceDbPitExport {
    "Timestamp of point in time restore."
    restorePointInTime: DateTime!
}

"Filters for list of Azure SQL Managed Instance Servers."
input AzureSqlManagedInstanceServerFilters {
    "Filter by Effective SLA."
    effectiveSlaFilter: EffectiveSlaFilter
    "Filter by name substring."
    nameSubstringFilter: NameSubstringFilter
    "Filter by region."
    regionFilter: AzureNativeRegionFilter
    "Filter by resource group name."
    resourceGroupFilter: AzureSqlManagedInstanceServerResourceGroupFilter
    "Filter by subscription."
    subscriptionFilter: AzureSqlManagedInstanceServerSubscriptionFilter
    "Filter by tag."
    tagFilter: AzureNativeTagFilter
}

"Filter to return Azure SQL Managed Instance Database Servers which have resource group name in the given list of resource group names."
input AzureSqlManagedInstanceServerResourceGroupFilter {
    "List of names of resource groups."
    resourceGroupNames: [String!]!
}

"Filter to return Azure SQL Managed Instance Database Servers which have resource group name in the given list of resource group names."
input AzureSqlManagedInstanceServerSubscriptionFilter {
    "List of subscription IDs."
    subscriptionIds: [String!]!
}

"Input for exporting from Rubrik managed persistent backup."
input AzureSqlPersistentBackupExportInput {
    "Login credentials of the server where the new database needs to be created."
    destinationServerCredentials: LoginCredentials!
    "Rubrik ID of the snapshot from which database is being exported."
    sourceSnapshotRubrikId: UUID!
}

"AzureStorageAccountsReq input for Azure account."
input AzureStorageAccountsReq {
    cloudAccountId: String = ""
    "Resource group in Azure."
    resourceGroup: String = ""
}

input AzureSubscriptionInput {
    name: String!
    nativeId: String!
}

input AzureTargetCreateRequest {
    accessKey: String!
    cloudAccountId: UUID!
    clusterUuid: UUID!
    computeSettings: AzureCloudComputeSettingsInput
    containerName: String!
    immutabilitySettings: AzureImmutabilitySettings
    instanceType: InstanceTypeEnum!
    isConsolidationEnabled: Boolean!
    name: String!
    proxySettings: ProxySettingsInput
    rsaKey: String!
    storageAccountName: String!
}

input AzureTargetEditRequest {
    accessKey: String
    cloudAccountId: UUID
    computeSettings: AzureCloudComputeSettingsInput
    id: UUID!
    immutabilitySettings: AzureImmutabilitySettings
    isConsolidationEnabled: Boolean
    name: String
    proxySettings: ProxySettingsInput
    storageAccountName: String
}

input AzureVmConfig {
    cdmVersion: String = ""
    location: String = ""
    networkResourceGroup: String = ""
    networkSecurityGroup: String = ""
    networkSecurityResourceGroup: String = ""
    nodeSizeGb: Int = 0
    resourceGroup: String = ""
    subnet: String = ""
    tags: String = ""
    "Name of VM image to deploy."
    vmImage: String = ""
    vmType: VmTypeEnum
    vnet: String = ""
    vnetResourceGroup: String = ""
}

"Config for O365 SharePoint List backup."
input BackupO365SharePointListInput {
    "Polaris ID of O365 list object."
    snappableUuid: UUID!
}

input BackupObject {
    eventSeriesId: String = ""
    monitoringId: String = ""
    objectFid: String = ""
}

input BackupRunConfig {
    runNow: Boolean = false
}

"Specifies backup window params"
input BackupWindowInput {
    durationInHours: Int = 0
    startTimeAttributes: StartTimeAttributesInput
}

"Supported in v5.0+"
input BaseGuestCredentialInput {
    """

    Required. Supported in v5.0+
    Password for the account used to login to the VM guest OS.
    """
    password: String!
    """

    Required. Supported in v5.0+
    Username for the account used to login to the VM guest OS. To include a domain, use the format <domain>\<username>.
    """
    username: String!
}

input BaseOnDemandSnapshotConfig {
    slaFid: String = ""
}

"Supported in v5.0+"
input BaseOnDemandSnapshotConfigInput {
    "Supported in v5.0+"
    slaId: String
}

input BasicSnapshotScheduleInput {
    frequency: Int = 0
    retention: Int = 0
    retentionUnit: RetentionUnitEnum = MINUTES
}

input BatchExportInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. An array of configuration objects. Each object includes an identifier for the virtual machine, an identifier for the snapshot of the virtual machine, and the configuration for the exported virtual machine snapshot."
    config: BatchExportSnapshotJobConfigInput!
}

"Supported in v6.0+"
input BatchExportSnapshotJobConfigInput {
    """

    Required. Supported in v6.0+
    Array of objects containing information about snapshots to export.
    """
    snapshots: [ExportSnapshotJobConfigForBatchInput!]!
}

input BatchInPlaceRecoverInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. An array of configuration objects. Each object includes an identifier for the virtual machine, an identifier for the snapshot of the virtual machine, and the configuration for the virtual machine snapshot for in-place recovery."
    config: BatchInPlaceRecoveryJobConfigInput!
}

"Supported in v6.0+"
input BatchInPlaceRecoveryJobConfigInput {
    """

    Required. Supported in v6.0+
    Array of objects containing information about snapshots to use for an in-place recovery.
    """
    snapshots: [InPlaceRecoveryJobConfigForBatchInput!]!
}

input BatchInstantRecoverInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. An array of configuration objects. Each object includes an identifier for the virtual machine, an identifier for the snapshot of the virtual machine, and the configuration for the virtual machine snapshot for Instant Recovery."
    config: BatchInstantRecoveryJobConfigInput!
}

"Supported in v6.0+"
input BatchInstantRecoveryJobConfigInput {
    """

    Required. Supported in v6.0+
    Array of objects containing information about snapshots to mount for Instant Recovery.
    """
    snapshots: [InstantRecoveryJobConfigForBatchInput!]!
}

"Supported in v5.0+"
input BatchMountSnapshotJobConfigInput {
    """

    Required. Supported in v5.0+
    v5.0: Array of virtual machine IDs with snapshots to be live mounted.
    v5.1-v5.3: Array of vm_ids to live mount a snapshot from
    v6.0+: Array of objects containing information about snapshots to mount.
    """
    snapshots: [MountSnapshotJobConfigForBatchV1Input!]!
}

"Supported in v6.0+"
input BatchMountSnapshotJobConfigV2Input {
    """

    Required. Supported in v6.0+
    Array of objects containing information about snapshots to mount.
    """
    snapshots: [MountSnapshotJobConfigForBatchV2Input!]!
}

input BatchMountSnapshotV2Input {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. Configuration object containing an array of virtual machine IDs, providing a way to indicate the selected snapshot and the mount configurations."
    config: BatchMountSnapshotJobConfigV2Input!
}

"Request to batch quarantine list of snapshots."
input BatchQuarantineSnapshotInput {
    "Notes for the operation."
    operationNotes: String!
    "Quarantine spec needed for the operation."
    quarantineSpecs: [QuarantineSpecInput!]!
}

"Request to batch release snapshots from quarantine."
input BatchReleaseFromQuarantineSnapshotInput {
    "Notes for the operation."
    operationNotes: String!
    "Quarantine spec needed for the operation."
    quarantineSpecs: [QuarantineSpecInput!]!
}

"Supported in v5.3+"
input BatchVmwareVmRecoverableRangesRequestInput {
    """

    Supported in v5.3+
    Query filter - only ranges after this time will be included. The date-time string should be in ISO8601 format, such as `2018-01-01T01:23:45.678Z`.
    """
    afterTime: DateTime
    """

    Supported in v5.3+
    Query filter - only ranges before this time will be included. The date-time string should be in ISO8601 format, such as `2018-01-01T01:23:45.678Z`.
    """
    beforeTime: DateTime
    """

    Required. Supported in v5.3+
    The ID of each CDP-enabled virtual machine for which recoverable ranges are being retrieved.
    """
    vmIds: [String!]!
}

input BidirectionalReplicationSpecInput {
    replicationSpec1: UnidirectionalReplicationSpecInput
    replicationSpec2: UnidirectionalReplicationSpecInput
}

input BlueprintFailoverJobConfig {
    "The ID of the Blueprint to be failed over."
    blueprintId: UUID!
    childSnappableFailoverInfos: [SnappableFailoverInfoType!]
    "The type of the data transfer, EXPORT, INPLACE, and HYDRATION."
    dataTransferType: DataTransferTypeEnum
    "Flag to enable recovery using Rubrik backup agent."
    enableRecoveryWithRba: Boolean
    "The failure action of failover, PAUSE or CLEANUP."
    failoverFailureAction: String
    "Errors that should be ignored during failover."
    failoverIgnorableErrors: [BlueprintFailoverIgnorableError!]
    "The operation of the failover, Start or Resume."
    failoverOperation: String
    "The type of the failover job, LOCALRECOVERY, FAILOVER or TEST_FAILOVER."
    failoverType: String!
    "Flag to enable zero RPO."
    isZeroRpo: Boolean
    "The id of recovery plan if it belongs to a recovery plan."
    recoveryPlanId: UUID
    "The type of the target location, CDM, AZURE, AWS or GCP."
    targetLocationType: LocationType
    "The UUID of the target location."
    targetLocationUuid: UUID
    "Timeout in minutes for failover job, if it is not given, then there will be no timeout."
    timeoutInMinutes: Int
}

"Blueprint failover related properties."
input BlueprintFailoverPropertiesInput {
    "Data transfer type: EXPORT, INPLACE, HYDRATION."
    dataTransferType: DataTransferTypeEnum = EMPTY_VALUE
    "Type of plan: Prod, Test."
    planType: PlanNameEnum = PROD
    "Failover target location information."
    targetLocation: LocationInfo
}

input BlueprintFailoverReportGeneratorJobInfo {
    "The IDs for the failover records in the report."
    failoverIds: [String!]!
}

"Blueprint Recovery Plan job configuration."
input BlueprintRecoveryPlanJobConfig {
    "The ID of the Blueprint to be failed over."
    blueprintId: String = ""
    "The type of the data transfer, EXPORT, INPLACE, and HYDRATION."
    dataTransferType: DataTransferTypeEnum = EMPTY_VALUE
    "Flag to enable recovery using Rubrik backup agent."
    enableRecoveryWithRba: Boolean = false
    "The type of the failover job, LOCAL_RECOVERY, FAILOVER or TEST_FAILOVER."
    failoverType: BlueprintFailoverType = UNKNOWN_TYPE
    "Sequence of blueprint failover ignorable errors enum."
    ignorableErrors: [BlueprintFailoverIgnorableErrorType!] = []
    "Flag to pause blueprint on error."
    shouldBlueprintPauseOnError: Boolean = false
    "Flag to enable zero RPO."
    shouldEnableZeroRpoRecovery: Boolean = false
    "Snappable failover information."
    snappableFailoverInfos: [ChildSnappableFailoverInfo!] = []
    "The information of the target location."
    targetLocationInfo: RecoveryPlanLocationInfoInput
}

"Input params for getting bootstrap status of a cluster."
input BootstrapStatusReq {
    bootstrapId: Long = 0
    clusterUuid: String = ""
    masterNodeId: String = ""
}

input BrowseDirectoryFiltersInput {
    analyzerGroupIds: [String!] = []
    whitelistEnabled: Boolean = false
}

input BrowseMssqlBackupFilesInput {
    "Required. Configuration for the browse request."
    config: MssqlBackupSelectionInput!
    "Required. ID of the Microsoft SQL database."
    id: String!
}

input BrowseNutanixSnapshotInput {
    "Required. ID of snapshot."
    id: String!
    "Maximum number of entries in the response."
    limit: Int
    "Starting position in the list of path entries contained in the query results, sorted by lexicographical order. The response includes the specified numbered entry and all higher numbered entries."
    offset: Int
    "Required. The absolute path of the starting point for the directory listing."
    path: String!
}

input BrowseSnapMirrorCloudSnapshotInput {
    "Required. The ID of the snapshot to browse."
    id: String!
    "Maximum number of entries in the response."
    limit: Int
    "Starting position in the list of path entries contained in the query results, sorted by lexicographical order. The response includes the specified numbered entry and all higher numbered entries."
    offset: Int
    "Required. The absolute path of the starting point for the directory listing."
    path: String!
}

"List of blueprint ids."
input BulkCancelFailoversInput {
    "Blueprint ids."
    fids: [String!]!
}

input BulkCreateOnDemandBackupInput {
    "Required. The IDs of the virtual machines for which to take an on-demand snapshot and the ID of the SLA Domain to assign to the resulting snapshot."
    config: BulkOnDemandSnapshotJobConfigInput!
    "Required. User note to associate with audits."
    userNote: String
}

input BulkDeleteMosaicSourcesInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. List of names of sources to be deleted."
    sourceData: BulkDeleteSourceRequestInput!
    sourceType: V2BulkDeleteMosaicSourcesRequestSourceTypeEnum
}

"Supported in m3.2.0-m4.1.0"
input BulkDeleteSourceRequestInput {
    "Supported in m3.2.0-m4.1.0"
    async: Boolean
    "Required. Supported in m3.2.0-m4.1.0"
    sourceNames: [String!]!
}

"Supported in v5.3+"
input BulkOnDemandSnapshotJobConfigInput {
    """

    Supported in v5.3+
    The ID of the SLA Domain to assign to the virtual machines.
    """
    slaId: String
    """

    Required. Supported in v5.3+
    The IDs of the virtual machines for which to take on-demand snapshots.
    """
    vms: [String!]!
}

input BulkUpdateExchangeDagInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. Properties to update for each DAG."
    dagUpdateProperties: [ExchangeDagUpdateConfigInput!]!
}

input BulkUpdateMssqlDbV1Input {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. Properties to update for each database."
    dbsUpdateProperties: [MssqlDbUpdateIdInput!]!
}

input BulkUpdateOracleHostInput {
    "Required. Properties to use for the update of Oracle Host objects."
    bulkUpdateProperties: OracleBulkUpdateInput!
}

input BulkUpdateSnapMirrorCloudInput {
    "Required. For each SnapMirror Cloud protected object to be updated, specify the properties to update."
    updateDefinitions: [SnapMirrorCloudUpdateInput!]!
}

"Email address input for organizer and/or attendee"
input CalendarEmailAddressFilter {
    emailAddress: String = ""
    filterType: CalendarEmailAddressFilterType = ORGANIZER
}

"Struct representing the Calendar group to be restored."
input CalendarGroupInfo {
    "ID of the calendar group to be restored."
    calendarGroupId: String!
    "ID of the snapshot from which to restore."
    snapshotId: UUID!
}

"Struct representing the Calendar to be restored."
input CalendarInfo {
    "ID of the calendar to be restored."
    calendarId: String!
    "ID of the snapshot from which to restore."
    snapshotId: UUID!
}

"Calendar recurrence object type"
input CalendarRecurrenceFilter {
    recurrenceType: CalendarRecurrenceType = SINGLE
}

"Struct representing the calendar contents to be restored."
input CalendarRestoreConfig {
    "Calendar Group(s) to restore in this job."
    calendarGroupsToRestore: [CalendarGroupInfo!]!
    "Calendar(s) to restore in this job."
    calendarsToRestore: [CalendarInfo!]!
    "Event(s) to restore in this job."
    eventsToRestore: [EventInfo!]!
}

"Parameters for calendar event search"
input CalendarSearchFilter {
    emailAddresses: [CalendarEmailAddressFilter!] = []
    recurrenceFilter: CalendarRecurrenceFilter
    searchKeywordFilter: CalendarSearchKeywordFilter
    searchObjectFilter: CalendarSearchObjectFilter
    timerange: TimeRangeFilter
}

"Calendar search keyword and type"
input CalendarSearchKeywordFilter {
    keywordType: CalendarSearchKeywordType = NAME
    searchKeyword: String = ""
}

"Calendar search object type"
input CalendarSearchObjectFilter {
    searchObjectType: O365CalendarSearchObjectType = CALENDAR
}

"The details of the malware scan to cancel."
input CancelPolarisMalwareDetectionInput {
    "The id of the scan."
    scanId: String!
}

"Cascading archival spec."
input CascadingArchivalSpecInput {
    "CDM archival location on the replication target the snapshot will be uploaded to."
    archivalLocationId: String = ""
    "Threshold after which the snapshot will be archived."
    archivalThreshold: SlaDurationInput
    "Archival tiering specification input."
    archivalTieringSpecInput: ArchivalTieringSpecInput
    "Frequencies that are associated with this cascaded archival location."
    frequency: [RetentionUnitEnum!] = []
}

"CDM snapshot filter."
input CdmSnapshotFilter {
    "The field to filter the snapshot list on."
    field: CdmSnapshotFilterField = EMPTY
    "Texts used to support the field being filtered on."
    texts: [String!] = []
}

input CdmSnapshotFilterInput {
    clusterUuid: [UUID!]
    isOnDemandSnapshot: Boolean
    snappableId: [String!]
    snapshotId: [UUID!]
    timeRange: TimeRangeInput
}

"Filters for the cluster list"
input CdmUpgradeInfoFilterInput {
    "Location of cluster"
    clusterLocation: [String!]
    connectionState: [ClusterStatus!]
    "Cluster software version greater than or equal to"
    downloadedVersion: [String!]
    "Cluster UUIDs"
    id: [UUID!]
    installedVersion: [String!]
    "Cluster software version greater than or equal to"
    minSoftwareVersion: String
    "Cluster names"
    name: [String!]
    "Prechecks status of cluster"
    prechecksStatus: [PrechecksStatusTypeEnum!]
    "Product type of Rubrik cluster"
    productType: [ClusterProductEnum!]
    "Cluster registration time greater than"
    registrationTime_gt: DateTime
    "Cluster registration time less than"
    registrationTime_lt: DateTime
    "Cluster types"
    type: [ClusterTypeEnum!]
    "Cluster upgrade job status"
    upgradeJobStatus: [ClusterJobStatusTypeEnum!]
    upgradeScheduled: Boolean
    versionStatus: [VersionStatusTypeEnum!]
}

input ChangePasswordInput {
    "Email of user performing reset."
    email: String = ""
    "New password for user."
    password: String = ""
}

input ChangeVfdOnHostInput {
    "Required. Host volume filter driver install definition."
    config: HostVfdInstallRequestInput!
}

input ChildRecoverySpecCreateReqInputType {
    recoveryPoint: Long
    recoverySpec: ChildRecoverySpecInputType!
    slaId: String
    snappableId: String!
}

input ChildRecoverySpecInputType {
    awsSpec: AwsVMRecoverySpecInputType
    vSphereSpec: VSphereVMRecoverySpecInputType
}

"Child snappable failover information."
input ChildSnappableFailoverInfo {
    "Point in time data, which we will be using to recover the snappable."
    recoveryPoint: Long = 0
    "Snappable ID."
    snappableId: String = ""
}

"List of snappable ids and recovery points."
input ChildSnappableFailoverInfoInput {
    "Point in time to which to recover the VM."
    recoveryPoint: Long = 0
    "Snappable id of the blueprint child."
    snappableId: String = ""
}

input ClassificationBannerSettingsInputType {
    account: String = ""
    bannerColor: BannerColor = NONE
    bannerText: String = ""
}

input ClassificationLoginSettingsInputType {
    account: String = ""
    loginText: String = ""
}

input ClassificationPolicyInput {
    analyzerIds: [String!] = []
    colorEnum: ClassificationPolicyColor = UNKNOWN
    description: String = ""
    id: String = ""
    mode: ClassificationPolicyMode = DISCOVERY
    name: String = ""
    updateAnalyzerIds: Boolean = false
    updateDescription: Boolean = false
    updateMode: Boolean = false
    updateName: Boolean = false
}

input CleanupFailoverJobInfo {
    blueprintId: UUID!
    comments: String
}

"Input required to clear the credentials used for performing backups."
input ClearCloudNativeSqlServerBackupCredentialsInput {
    "Rubrik IDs of the objects. Some examples of objects are: Azure Subscriptions, Resource Groups."
    objectIds: [UUID!]!
    "The object type for which the credentials should be cleared."
    snappableType: SnappableLevelHierarchyTypeEnum!
}

input CloudAccountFilterInput {
    field: CloudAccountFilterFieldEnum = NAME
    text: String = ""
}

"Filter databases for a given list of servers."
input CloudNativeDatabaseServerFilter {
    "Name of database servers."
    serverNames: [String!]!
}

"Feature for which required permissions have to be checked."
input CloudNativeFeatureForPermissionsCheck {
    awsFeature: AwsFeatureForPermissionCheck
    azureFeature: AzureFeatureForPermissionCheck
}

"DataType representing filters on cloud native tag or label rules"
input CloudNativeFilter {
    field: CloudNativeTagRuleFilterFields = SLA_DOMAIN
    texts: [String!] = []
}

"DataType representing cloud native ids"
input CloudNativeIDs {
    awsNativeAccountIds: [String!]
    azureNativeSubscriptionIds: [String!]
    gcpNativeProjectIds: [String!]
}

"Filters for the cluster disk list"
input ClusterDiskFilterInput {
    status: ClusterDiskStatus
    type: ClusterDiskType
}

"Filters for the cluster list."
input ClusterFilterInput {
    "Exclude clusters that do not have any nodes connected."
    excludeEmptyCluster: Boolean
    "Cluster UUIDs."
    id: [UUID!]
    "Cluster software version greater than or equal to."
    minSoftwareVersion: String
    "Cluster names."
    name: [String!]
    "Object types of snappables protected by the cluster."
    objectType: [ObjectTypeEnum!]
    "Type of Rubrik cluster."
    productType: [ClusterProductEnum!]
    "Cluster registration time greater than."
    registrationTime_gt: DateTime
    "Cluster registration time less than."
    registrationTime_lt: DateTime
    "Cluster types."
    type: [ClusterTypeEnum!]
}

input ClusterInfCidrsInput {
    clusterId: String = ""
    clusterName: String = ""
    interfaceCidr: [InterfaceCidrInput!] = []
}

"GeoLocation of the cluster"
input ClusterLocationEdit {
    address: String!
    latitude: Float!
    longitude: Float!
}

"Supported in v6.0+"
input ClusterVisibilityConfigInput {
    """

    Required. Supported in v6.0+
    Names of the host groups being protected.
    """
    hostGroupFilter: [String!]!
    """

    Required. Supported in v6.0+
    VMware managed object ID of the compute cluster. This is not the ID managed by Rubrik.
    """
    id: String!
    """

    Supported in v6.0+
    A Boolean that specifies whether the compute cluster is a VMware Metro Storage Cluster.
    """
    isVmwareMetroStorageCluster: Boolean
}

"Filter cluster data."
input CommonClusterFilterInput {
    id: [UUID!]
    type: [ClusterTypeEnum!]
}

input CommonNotificationSettingInputType {
    hostname: String = ""
    networkType: NetworkProtocolTypeEnum = UDP
    port: Int = 0
    securityType: SMTPSecurityTypeEnum = NONE
    trustedCerts: String = ""
}

"Input for completing authentication of the Azure Cloud Accounts."
input CompleteAzureCloudAccountOauthInput {
    "Client ID of the application. The appID is empty if the tenant uses a Rubrik app or a custom app."
    appId: String
    "Client secret key of the application. The appSecretKey is empty if the tenant uses a Rubrik app or a custom app."
    appSecretKey: String
    "Authorization code received after the OAuth consent flow. For more information, see https://auth0.com/docs/flows/authorization-code-flow."
    authorizationCode: String!
    "Type of Azure Tenant. Possible values: Azure Public Cloud, Azure China Cloud."
    azureCloudType: AzureCloudType = AZUREPUBLICCLOUD
    "Features enabled on the Azure Cloud Account."
    features: [CloudAccountFeature!]!
    "Redirect URL used in the OAuth flow."
    redirectUrl: String!
    "Session ID of the current OAuth session."
    sessionId: String!
    "Specifies whether to skip permission checks of Azure subscriptions required for addition."
    shouldSkipPermissionChecks: Boolean!
    "Domain name of the Azure Tenant."
    tenantDomainName: String!
}

input ConfigGroupByInput {
    "Aggregations for single-level groupBy. This does not affect double-level groupBys."
    aggregations: [String!]!
    "Report-level groupBy selection"
    groupById: String!
}

"The contact folder to be restored."
input ContactFolderInfo {
    "ID of the contact folder to be restored."
    contactFolderId: String!
    "ID of the snapshot from which to restore."
    snapshotId: UUID!
    "Num of the snapshot from which to restore."
    snapshotNum: Int!
}

"The contact to be restored."
input ContactInfo {
    "ID of the contact to be restored."
    contactId: String!
    "ID of the snapshot from which to restore."
    snapshotId: UUID!
    "Num of the snapshot from which to restore."
    snapshotNum: Int!
}

"The contacts to be restored."
input ContactsRestoreConfig {
    "Contact folder(s) to restore in this job."
    contactFoldersToRestore: [ContactFolderInfo!]!
    "Contact(s) to restore in this job."
    contactsToRestore: [ContactInfo!]!
}

"Parameters for contacts search."
input ContactsSearchFilter {
    "Filters on keywords appearing in the contact name, company name, emails or addresses."
    searchKeywordFilter: ContactsSearchKeywordFilter
    "Filters on object type (contact, folder, or all)."
    searchObjectFilter: ContactsSearchObjectFilter
}

"Contacts search keyword."
input ContactsSearchKeywordFilter {
    "Filters on a search keyword."
    searchKeyword: String = ""
}

"Contacts search object type."
input ContactsSearchObjectFilter {
    "Filters on object type (contact, folder, or all)."
    searchObjectType: O365ContactsSearchObjectType = CONTACT
}

input ContextFilterInputField {
    field: String!
    text: String!
}

"Struct representing the conversations contents to be restored"
input ConversationsRestoreConfig {
    ChannelInfoForFullRestore: TeamsConvChannelInfo
    ChannelsToRestore: [TeamsConvChannelInfo!]!
    O365AppID: String!
    RefreshTokenEncrypted: String!
    SearchFilter: TeamsConversationsSearchFilterJson
    ShouldRestoreFileAttachments: Boolean!
}

"CreateAwsClusterInput for Aws account."
input CreateAwsClusterInput {
    "Cloud account id of the AWS account."
    cloudAccountId: String = ""
    "Cluster config to initialize cluster."
    clusterConfig: clusterConfigInput
    "Disable API termination on AWS instances."
    disableApiTermination: Boolean = false
    "Create disk based or CCES."
    isEsType: Boolean = false
    "Flag to keep the cluster on failure."
    keepClusterOnFailure: Boolean = false
    "Aws region."
    region: String = ""
    "VM config to create nodes."
    vmConfig: AwsVmConfig
}

"Input to create AWS exocompute configurations."
input CreateAwsExocomputeConfigsInput {
    "Rubrik ID for cloud account."
    cloudAccountId: UUID!
    "List of exocompute configurations for the cloud account."
    configs: [AwsExocomputeConfigInput!]!
}

"Input for creating an AWS Reader Target."
input CreateAwsReaderTargetInput {
    "Field for creating AWS compute settings ID."
    awsComputeSettingsId: String
    "Field for specifying retrieval tier for this target."
    awsRetrievalTier: AwsRetrievalTier
    "Field for specifying AWS bucket name."
    bucketName: String!
    "Field for specifying cloud account ID."
    cloudAccountId: UUID!
    "Field for specifying cloud compute Settings."
    cloudComputeSettings: AwsCloudComputeSettingsInput
    "Field for specifying cluster UUID of the target."
    clusterUuid: String!
    "Field for specifying whether consolidation is enabled or not."
    isConsolidationEnabled: Boolean!
    "Field for specifying KMS master key for encryption."
    kmsMasterKeyId: String
    "Field for specifying name of the target."
    name: String!
    "Field for creating proxy settings."
    proxySettings: ProxySettingsInput
    "Field for specifying the metadata to be retrieved from a target."
    readerRetrievalMethod: ReaderRetrievalMethod!
    "Field for specifying region of the target."
    region: AwsRegion!
    "Field for specifying RSA key for encryption."
    rsaKey: String
    "Field for specifying storage class of the target."
    storageClass: AwsStorageClassTypeEnum!
}

"CreateAzureClusterInput for Azure account."
input CreateAzureClusterInput {
    cloudAccountId: String = ""
    clusterConfig: clusterConfigInput
    isEsType: Boolean = false
    "Flag to keep the cluster on failure."
    keepClusterOnFailure: Boolean = false
    vmConfig: AzureVmConfig
}

"Input for creating an Azure Reader Target."
input CreateAzureReaderTargetInput {
    "Field for specifying access key of the target."
    accessKey: String!
    "Field for specifying cloud account ID."
    cloudAccountId: UUID!
    "Field for specifying cluster UUID of the target."
    clusterUuid: UUID!
    "Field for Azure compute settings."
    computeSettings: AzureCloudComputeSettingsInput
    "Field for specifying container name of the target."
    containerName: String!
    "Field for specifying immutability settings of Azure target."
    immutabilitySettings: AzureImmutabilitySettings
    "Field for specifying instance type of Azure target."
    instanceType: InstanceTypeEnum!
    "Field for specifying whether consolidation is enabled or not."
    isConsolidationEnabled: Boolean!
    "Field for specifying name of the target."
    name: String!
    "Field for specifying compute settings."
    proxySettings: ProxySettingsInput
    "Field for specifying the metadata to be retrieved from a target."
    readerRetrievalMethod: ReaderRetrievalMethod!
    "Field for specifying RSA key for encryption."
    rsaKey: String!
    "Field for specifying storage account name."
    storageAccountName: String!
}

"Input for CreateCloudNativeAwsStorageSetting mutation"
input CreateCloudNativeAwsStorageSettingInput {
    bucketPrefix: String!
    bucketTags: TagsInput
    cloudAccountId: UUID!
    cloudNativeLocTemplateType: CloudNativeLocTemplateType!
    kmsMasterKeyId: String
    name: String!
    region: AwsRegion
    storageClass: AwsStorageClassTypeEnum!
}

"Input for create storage settings for an account."
input CreateCloudNativeAzureStorageSettingInput {
    "Cloud Account Id of the target subscription."
    cloudAccountId: UUID!
    "Template type of the storage settings. Must be either SOURCE_REGION or SPECIFIC_REGION."
    cloudNativeLocTemplateType: CloudNativeLocTemplateType!
    "Information about the customer-managed key and key vault."
    cmkInfo: [AzureCmkInput!]
    "Name of the container inside storage account. This field must be between 3 to 64 characters in length and must start with a letter or number, and can contain only lowercase letters, numbers, and the dash (-) characters."
    containerName: String!
    "Name of the storage setting."
    name: String!
    "Redundancy type for the Storage Account. Some examples are: LRS, ZRS, GRS etc. More Info: https://docs.microsoft.com/en-us/azure/storage/common/storage-redundancy."
    redundancy: AzureRedundancy!
    "Name or prefix of the storage account. This field can not be empty string and must contain only lowercase letters and numbers. For 'SOURCE_REGION' Template Type, this field must be less than 16 characters. Random UID of eight characters is appended to the prefix to create the actual storage accounts. For 'SPECIFIC_REGION' Template Type, this field must be less than 24 characters."
    storageAccountName: String!
    "Region for the Storage Account. For 'SOURCE_REGION' Template Type, this field will be 'UNKNOWN_AZURE_REGION'. For 'SPECIFIC_REGION' Template Type, this field must be a azure region supporting GPV2, More Info: https://docs.microsoft.com/en-us/azure/storage/common/storage-redundancy#redundancy-in-the-primary-region."
    storageAccountRegion: AzureRegion
    "Tags of the storage account."
    storageAccountTags: TagsInput
    "Storage Tier for the Storage Account. Only Cool, Hot storage tier are supported for now. More Info: https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-storage-tiers."
    storageTier: AzureStorageTier!
    "Azure native subscription id."
    subscriptionNativeId: String!
}

input CreateDownloadMssqlBackupFilesByIdInput {
    "Required. Configuration for a download files by id job."
    config: DownloadMssqlBackupFilesByIdJobConfigInput!
    "Required. ID of the Microsoft SQL database."
    id: String!
    "Required. User note to associate with audits."
    userNote: String
}

input CreateDownloadSnapshotForNutanixInput {
    "Required. ID of snapshot."
    id: String!
}

input CreateDownloadSnapshotForVolumeGroupInput {
    "Required. ID of snapshot."
    id: String!
}

input CreateExchangeSnapshotMountInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. Configuration for the mount request."
    config: ExchangeMountSnapshotConfigInput!
    "Required. ID of the snapshot."
    id: String!
}

input CreateExportMssqlDbInput {
    "Required. Configuration for the export."
    config: ExportMssqlDbJobConfigInput!
    "Required. ID of the Microsoft SQL database."
    id: String!
}

input CreateExportWithDownloadFromCloudV2Input {
    "Required. Configuration for the export request, including timestamp and snapshot ID fields. When the snapshot ID is passed without a timestamp, this endpoint triggers an export using the given snapshot ID. When this endpoint is passed a recovery point or a recovery point and snapshot ID, the endpoint triggers an export using the point in time (PIT) for recovery. Calling this endpoint without a recovery point or a snapshot ID triggers a PIT export that uses the most recent time available."
    config: ExportSnapshotJobConfigV2Input!
    "Required. ID of a VM."
    id: String!
}

"Input for GCP Reader Target."
input CreateGcpReaderTargetInput {
    "Field for creating proxy settings."
    archivalProxySettings: ProxySettingsInput
    "Field for specifying GCP bucket name."
    bucket: String!
    "Field for specifying cluster UUID of the target."
    clusterUuid: UUID!
    "Field for specifying encryption password."
    encryptionPassword: String!
    "Field for specifying name of the target."
    name: String!
    "Field for specifying the metadata to be retrieved from a target."
    readerRetrievalMethod: ReaderRetrievalMethod!
    "Field for specifying region of the target."
    region: GcpRegionEnum!
    "Field for specifying service account JSON key."
    serviceAccountJsonKey: String!
    "Field for specifying storage class of the target."
    storageClass: GcpStorageClassTypeEnum!
}

input CreateGlobalSlaInput {
    archivalSpecs: [ArchivalSpecInput!] = []
    backupWindows: [BackupWindowInput!] = []
    description: String = ""
    firstFullBackupWindows: [BackupWindowInput!] = []
    localRetentionLimit: SlaDurationInput
    logConfig: LogConfig
    name: String = ""
    objectSpecificConfigsInput: ObjectSpecificConfigsInput
    objectTypes: [SLAObjectTypeEnum!] = []
    replicationSpecInput: ReplicationSpecInput
    replicationSpecsV2: [ReplicationSpecV2Input!] = []
    snapshotSchedule: GlobalSnapshotScheduleInput
}

input CreateGuestCredentialInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. Object for guest OS credential definition."
    definition: GuestCredentialDefinitionInput!
}

input CreateHypervVirtualMachineSnapshotInput {
    "Configuration for the on-demand backup."
    config: BaseOnDemandSnapshotConfigInput
    "Required. ID of the VM."
    id: String!
}

input CreateHypervVirtualMachineSnapshotMountInput {
    "Configuration for the mount request."
    config: HypervMountSnapshotJobConfigInput
    "Required. ID of Snapshot."
    id: String!
}

input CreateInPlaceRecoveryV2Input {
    "Required. Configuration for the in-place recovery request, including timestamp and snapshot ID fields. When the snapshot ID is passed without a timestamp, this endpoint triggers an in-place recovery using the given snapshot ID. When this endpoint is passed a recovery point or a recovery point and snapshot ID, the endpoint triggers an in-place recovery using the point in time (PIT) for recovery. Calling this endpoint without a recovery point or a snapshot ID triggers a PIT in-place recovery that uses the most recent time available."
    config: InPlaceRecoveryJobConfigV2Input!
    "Required. ID of a VM."
    id: String!
}

"A Set of fields needed to create Rubrik Kubernetes manifest."
input CreateK8sAgentManifestInput {
    "UUID of the kubernetes Cluster."
    clusterId: UUID!
    "Timeout for the SignedURL of Rubrik Kubernetes manifest in minutes."
    timeoutMinutes: Int!
}

"Configuration of the Kubernetes namespaces to be backed-up."
input CreateK8sNamespaceSnapshotsInput {
    "List of namespace IDs and corresponding SLA Domains."
    snapshotInput: [K8sNamespaceSnapshot!]!
}

"Contains information about the snapshots to be placed on legal hold andconfiguration of the legal hold on which they have to be placed."
input CreateLegalHoldInput {
    "Configuration of the required legal hold."
    holdConfig: HoldConfig
    "List of snapshot IDs."
    snapshotIds: [String!] = []
    "Optional user note."
    userNote: String = ""
}

input CreateLogShippingConfigurationV2Input {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. An object that contains the values of a log shipping configuration."
    config: MssqlLogShippingCreateConfigV2Input!
    "Required. ID of the primary database object."
    id: String!
}

input CreateManagedVolumeV1Input {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. Managed Volume configuration."
    managedVolumeConfig: ManagedVolumeConfigInput!
}

input CreateMssqlMountInput {
    "Required. Configuration for the Live Mount."
    config: MountMssqlDbConfigInput!
    "Required. ID of the SQL Server database."
    id: String!
}

input CreateMssqlUnmountInput {
    "Remove all data within the Rubrik cluster related to the Live Mount, even if the SQL Server database cannot be contacted. Default value is false."
    force: Boolean
    "Required. ID of the Live Mount to delete."
    id: String!
}

"Input for creating a NFS Reader Target."
input CreateNfsReaderTargetInput {
    "Field for specifying cluster UUID of the target."
    clusterUuid: UUID!
    "Field for specifying destination folder of the NFS."
    destinationFolder: String!
    "Field for specifying the encryption password."
    encryptionPassword: String
    "Field for specifying the exported directory at the host of the NFS location."
    exportDir: String!
    "Field for specifying file lock period, in seconds."
    fileLockPeriodInSeconds: Int!
    "Field for specifying the host of the NFS location."
    host: String!
    "Field for whether consolidation should be enabled or not for this target."
    isConsolidationEnabled: Boolean!
    "Field for specifying name of the target."
    name: String!
    "Field for specifying the authentication type of NFS."
    nfsAuthType: AuthTypeEnum!
    "Field for specifying the version of NFS."
    nfsVersion: Int
    "Field for specifying other NFS options."
    otherNfsOptions: String
    "Field for specifying the metadata to be retrieved from a target."
    readerRetrievalMethod: ReaderRetrievalMethod!
}

input CreateNutanixClusterInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. IP address, natural ID of added cluster (since Prism central can manage multiple clusters), and credentials for Prism."
    nutanixClusterConfig: NutanixClusterConfigInput!
}

input CreateNutanixClusterRefreshInput {
    "Required. ID of the Nutanix cluster."
    id: String!
}

input CreateNutanixDownloadFilesJobInput {
    "Required. Configuration information for a job to download files and folders from a Nutanix VM backup."
    config: NutanixDownloadFilesJobConfigInput!
    "Required. ID assigned to a Nutanix VM backup object."
    id: String!
}

input CreateNutanixExportInput {
    "Required. Configuration for the export request."
    config: NutanixVmExportSnapshotJobConfigInput!
    "Required. ID of snapshot."
    id: String!
}

input CreateNutanixMountInput {
    "Required. Configuration for the Live Mount request."
    config: NutanixVmMountSnapshotJobConfigInput!
    "Required. ID of the virtual machine snapshot."
    id: String!
}

input CreateNutanixUnmountInput {
    "Required. ID of the Live Mount."
    id: String!
}

input CreateNutanixVmMountMigrationInput {
    "Required. ID of the Live Mount."
    id: String!
}

input CreateOnDemandExchangeDatabaseBackupInput {
    "Required. Configuration for the on-demand backup."
    config: ExchangeBackupJobConfigInput!
    "Required. ID of the Microsoft Exchange database."
    id: String!
}

input CreateOnDemandMssqlBackupInput {
    "Required. Configuration for the on-demand backup."
    config: MssqlBackupJobConfigInput!
    "Required. ID of the Microsoft SQL database."
    id: String!
    "Required. User note to associate with audits."
    userNote: String
}

input CreateOnDemandMssqlBatchBackupV1Input {
    "Required. Configuration for the on-demand backups."
    config: MssqlBatchBackupJobConfigInput!
    "Required. User note to associate with audits."
    userNote: String
}

input CreateOnDemandMssqlLogBackupInput {
    "Required. ID of the Microsoft SQL database."
    id: String!
}

input CreateOnDemandNutanixBackupInput {
    "Configuration for the on-demand backup."
    config: BaseOnDemandSnapshotConfigInput
    "Required. ID of the VM."
    id: String!
}

input CreateOnDemandOracleBackupInput {
    "Required. Configuration for the on-demand snapshot of an Oracle database."
    config: OracleBackupJobConfigInput!
    "Required. ID assigned to an Oracle database object."
    id: String!
}

input CreateOnDemandOracleLogBackupInput {
    "Required. ID assigned to an Oracle database object."
    id: String!
}

input CreateOnDemandVolumeGroupBackupInput {
    "Configuration for the on-demand backup. Configuration values are `volumeIdsIncludedInSnapshot`, which specifies the unique ID of each volume that is part of this snapshot of the Volume Group, and `slaID`, the ID of the SLA Domain for the snapshot."
    config: VolumeGroupOnDemandSnapshotConfigInput
    "Required. The ID of the Volume Group."
    id: String!
}

"Details of organization to create."
input CreateOrgInput {
    "Allowed clusters for the organization."
    allowedClusters: [String!]!
    "Use global org's SSO/LDAP config or set its own config."
    authDomainConfig: TenantAuthDomainConfig!
    "Description for organization to create."
    description: String!
    "Existing users that were selected to be org admins."
    existingOrgAdmins: [String!]!
    "Force org to use envoy to connect their hosts."
    isEnvoyRequired: Boolean!
    "Name of organization to create."
    name: String!
    "New users that were invited to be org admins."
    orgAdminsToBeInvited: [UserInviteInput!]!
    "New org url prefix of the organization."
    orgUrlPrefix: String!
    "Permissions given to a role."
    permissions: [PermissionInput!]!
    "Enforce MFA for all users in the org."
    shouldEnforceMfaForAll: Boolean!
}

"Input for creating a RCS Reader Target."
input CreateRcsReaderTargetInput {
    "Field for specifying cluster UUID of the target."
    clusterUuid: UUID!
    "Field for specifying the name of original reader location to which to connect as Reader."
    rcsArchivalLocationName: String!
    "Field for specifying the name of reader location for RCS."
    readerLocationName: String!
    "Field for specifying the metadata to be retrieved from a target."
    readerRetrievalMethod: ReaderRetrievalMethod!
}

"Create Recovery Plan configuration."
input CreateRecoveryPlanInput {
    "Recovery Plan configuration."
    config: RecoveryPlanConfigInput
    "Recovery Plan description."
    description: String
    "Recovery Plan name."
    name: String!
}

input CreateRestoreMssqlDbInput {
    """

    Required. v5.0-v5.1: Configuration for the restore.
    v5.2+: Restore configuration.
    """
    config: RestoreMssqlDbJobConfigInput!
    "Required. ID of the Microsoft SQL database."
    id: String!
}

"Input for creating a S3Compatible Reader Target."
input CreateS3CompatibleReaderTargetInput {
    "Field for specifying access key of the target."
    accessKey: String!
    "Field for specifying the bucket prefix of the S3Compatible target."
    bucketPrefix: String!
    "Field for specifying cluster UUID of the target."
    clusterUuid: UUID!
    "Field for specifying encryption key."
    encryptionKeyInDer: String!
    "Field for specifying the endpoint of the target."
    endpoint: String!
    "Field for whether consolidation should be enabled or not for this target."
    isConsolidationEnabled: Boolean!
    "Field for specifying name of the target."
    name: String!
    "Field for specifying number of buckets."
    numberOfBuckets: Int!
    "Field for specifying the metadata to be retrieved from a target."
    readerRetrievalMethod: ReaderRetrievalMethod!
    "Field for specifying the secret key of the target."
    secretKey: String!
    "Field for specifying whether to use system proxy or not."
    useSystemProxy: Boolean!
}

input CreateSnapMirrorCloudBackupJobInput {
    "Configuration for the on-demand backup."
    config: BaseOnDemandSnapshotConfigInput
    "Required. ID of the SnapMirror Cloud protected object."
    id: String!
}

input CreateSnapMirrorCloudInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. Specify a NetApp volume ID."
    definition: SnapMirrorCloudCreateInput!
}

input CreateSnapMirrorCloudRelationshipInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. ID of SnapMirror Cloud protected object."
    definition: RelationshipCreateInput!
}

input CreateSnapMirrorCloudRestoreJobInput {
    "Required. The ID of the snapshot from which to restore."
    id: String!
    "Required. Configuration for the job to restore files or the volume from a SnapMirrorCloud backup."
    jobConfig: SnapMirrorCloudRestoreParametersInput!
}

input CreateUserWithPasswordInput {
    "Email for new user."
    email: String = ""
    "Password for new user."
    password: String = ""
    "Role IDs to add to new user."
    roleIds: [String!] = []
}

input CreateVcenterV2Input {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. The IP address and account credentials of the vCenter Server that is being added."
    vcenterDetail: VcenterConfigV2Input!
}

input CreateVolumeGroupDownloadFilesJobInput {
    "Required. Configuration for a download request."
    config: VolumeGroupDownloadFilesJobConfigInput!
    "Required. ID of Snapshot."
    id: String!
}

input CreateVolumeGroupMountInput {
    "Required. Configuration for the mount request. The mount will expose an SMB address per recovered volume. In addition, if a target host is specified, each volume must specify a mount path. If a target host is specified but no mount paths are, they will be generated for every volume. In all cases, a single SMB share will be created for this mount. If a target host is specified, the share will only be accessible by that host."
    config: VolumeGroupMountSnapshotJobConfigInput!
    "Required. ID of snapshot."
    id: String!
}

"Webhook configuration to add to an account."
input CreateWebhookInput {
    "The authentication type and token to authenticate the endpoint."
    authInfo: AuthInfo
    "A description of the webhook to be created."
    description: String
    "The event severities that the webhook is subscribed to."
    eventSeverities: [EventSeverity!]!
    "List of webhook's subscribed events."
    eventTypes: [EventType!]!
    "The name of the webhook to be created."
    name: String!
    "The application that will receive the webhook."
    providerType: ProviderType!
    "The URL endpoint to the receiving application."
    url: URL!
}

"The custom authentication header key and value to authenticate the endpoint."
input CustomHeader {
    "The custom authentication header's key."
    headerKey: String!
    "The custom authentication header's value."
    headerValue: String!
}

input CustomReportCreate {
    "Chart configs for the report."
    charts: [ReportChartCreate!]
    "Filters for the report data."
    filters: CustomReportFiltersConfig!
    focus: ReportFocusEnum!
    "True if report should be hidden from gallery view."
    isHidden: Boolean = false
    "True if report is auto-generated and not allowed to be edited."
    isReadOnly: Boolean = false
    "Name of the report."
    name: String!
    "Table configs for the report."
    tables: [ReportTableCreate!]
}

"Filter custom reports data."
input CustomReportFilterInput {
    creationTime_gt: DateTime
    creationTime_lt: DateTime
    focus: ReportFocusEnum
    isHidden: Boolean
    isReadOnly: Boolean
    searchTerm: String
}

input CustomReportFiltersConfig {
    activityObjectType: [ActivityObjectTypeEnum!]
    "List of cluster id to filter on."
    clusterId: [UUID!]
    clusterLocation: [String!]
    "List of cluster types to filter on."
    clusterType: [ClusterTypeEnum!]
    complianceStatus: [ComplianceStatusEnum!]
    failoverStatus: [FailoverStatusEnum!]
    failoverType: FailoverTypeEnum
    "Whether the snapshot is anomalous or not."
    isAnomaly: Boolean
    "List of activity types to filter on."
    lastActivityStatus: [ActivityStatusEnum!]
    "List of activity types to filter on."
    lastActivityType: [ActivityTypeEnum!]
    "List of managed ids to filter data on."
    managedId: [String!]
    "List of snappable types to filter on."
    objectType: [ObjectTypeEnum!]
    "List of policy IDs to filter on."
    policyId: [String!]
    protectionStatus: [ProtectionStatusEnum!]
    replicationSource: [String!]
    searchTerm: String
    "List of sla domain ids to filter on."
    slaDomainId: [String!]
    slaTimeRange: SLAComplianceTimeRangeEnum
    sonarObjectTypes: [HierarchyObjectTypeEnum!]
    source: [String!]
    targetSite: [String!]
    taskCategory: [String!]
    taskStatus: [String!]
    taskType: [String!]
    "Start and end time range to filter data on."
    timeRange: GenericTimeRangeInput
    "List of object types to filter on for Audits."
    userAuditObjectType: [UserAuditObjectTypeEnum!]
    "List of user audit status to filter on."
    userAuditStatus: [UserAuditStatusEnum!]
    "List of user audit types to filter on."
    userAuditType: [UserAuditTypeEnum!]
}

input DailySnapshotScheduleInput {
    basicSchedule: BasicSnapshotScheduleInput
}

input DayOfWeekOptInput {
    day: DayOfWeek = MONDAY
}

"Input to configure the SLA Domain for Db2 database."
input Db2ConfigInput {
    "Frequency value for differential backup of Db2 databases."
    differentialFrequency: SlaDurationInput
    "Frequency value for incremental backup of Db2 databases."
    incrementalFrequency: SlaDurationInput
    "Specifies the duration for which the Db2 database logs will be retained."
    logRetention: SlaDurationInput
}

"Supported in v7.0+"
input Db2InstancePatchRequestConfigInput {
    """

    Supported in v7.0+
    List of hosts that are a part of this Db2 instance.
    """
    hostIds: [String!] = []
    """

    Supported in v7.0+
    Instance name of the Db2 instance.
    """
    instanceName: String
    """

    Supported in v7.0+
    Password of the Db2 instance.
    """
    password: String
    """

    Supported in v7.0+
    Username of the Db2 instance.
    """
    username: String
}

"Supported in v7.0+"
input Db2InstanceRequestConfigInput {
    """

    Required. Supported in v7.0+
    List of hosts that are a part of this Db2 instance.
    """
    hostIds: [String!]!
    """

    Required. Supported in v7.0+
    Instance name of the Db2 instance.
    """
    instanceName: String!
    """

    Required. Supported in v7.0+
    Password of the Db2 instance.
    """
    password: String!
    """

    Required. Supported in v7.0+
    Username of the Db2 instance.
    """
    username: String!
}

"Filter Db2 log snapshots."
input Db2LogSnapshotFilterInput {
    "The cluster uuid for which log snapshots are filtered."
    clusterUuid: [UUID!]
    "Start time for the log snapshots connection."
    fromTime: DateTime
    "Filter on archival status of log snapshots. Default behaviour will exlcude archived snapshots."
    isArchived: Boolean
    "The snappable id for which log snapshots are filtered."
    snappableId: [String!]
    "End time for the log snapshots connection."
    toTime: DateTime
}

"Filter Db2 recoverable ranges."
input Db2RecoverableRangeFilterInput {
    "The cluster uuid for which db2 recoverable ranges are filtered."
    clusterUuid: [UUID!]
    "The db2 database id for which db2 recoverable ranges are filtered."
    databaseId: [String!]
    "Start time for db2 recoverable range."
    fromTime: DateTime
    "Filter on archival status of db2 recoverable range. Default behaviour will exlcude archived recovverable ranges."
    isArchived: Boolean
    "End time for the db2 recoverable range."
    toTime: DateTime
}

input DeleteAllOracleDbSnapshotsInput {
    "Required. ID assigned to an Oracle database object."
    id: String!
}

input DeleteAllSnapMirrorCloudSnapshotsInput {
    "Required. The ID of the unprotected SnapMirror Cloud object."
    id: String!
}

"DeleteAwsClusterInput for Aws account."
input DeleteAwsClusterInput {
    "Name of the s3 bucket for CC-ES."
    bucketName: String = ""
    "Cloud account id of the AWS account."
    cloudAccountId: String = ""
    "Name of Aws cluster."
    clusterName: String = ""
    "Uuid of the cluster."
    clusterUuid: String = ""
    "True if the cluster is CC-ES, and false for disk based."
    isEsType: Boolean = false
    "True if the container was created as part of the cluster, and needs to be deleted as well."
    isNewContainer: Boolean = false
    "Number of nodes in the existing cluster."
    numNodes: Int = 0
    "Region name of the aws account."
    region: String = ""
}

"Input to delete AWS exocompute configurations."
input DeleteAwsExocomputeConfigsInput {
    "IDs of exocompute configurations to be deleted."
    configIdsToBeDeleted: [UUID!]!
}

"Input for deleting Exocompute configurations for an Azure Cloud Account."
input DeleteAzureCloudAccountExocomputeConfigurationsInput {
    "Rubrik IDs of the cloud accounts to be deleted."
    cloudAccountIds: [UUID!]!
}

"Input for deleting an Azure Cloud Account."
input DeleteAzureCloudAccountInput {
    "Rubrik IDs of the subscriptions to be deleted."
    azureSubscriptionRubrikIds: [UUID!]!
    "Features enabled on the Azure Cloud Account."
    features: [CloudAccountFeature!]!
    "Session ID of the current OAuth session."
    sessionId: String!
}

"Input for deleting an Azure Cloud Account without OAuth."
input DeleteAzureCloudAccountWithoutOauthInput {
    "Rubrik IDs of the subscriptions to be deleted."
    azureSubscriptionRubrikIds: [UUID!]!
    "Features enabled on the Azure Cloud Account."
    features: [CloudAccountFeature!]!
}

"DeleteAzureClusterInput for Azure account."
input DeleteAzureClusterInput {
    cloudAccountId: String = ""
    "Name of Azure cluster."
    clusterName: String = ""
    clusterUuid: String = ""
    "Storage container in Azure."
    containerName: String = ""
    "If cluster is ES or disk based."
    isEsType: Boolean = false
    "Is it an existing customer container or a new container created by ccprovision?"
    isNewContainer: Boolean = false
    "Azure network resource group name."
    networkResourceGroup: String = ""
    "Number of nodes in the existing cluster."
    numNodes: Int = 0
    "Azure resource group name."
    resourceGroupName: String = ""
    "Storage account in Azure."
    storageAccount: String = ""
    "Storage resource group in Azure."
    storageResourceGroup: String = ""
}

"List of blueprint ids."
input DeleteBlueprintsInput {
    "Blueprint ids."
    fids: [UUID!]!
}

input DeleteExchangeSnapshotMountInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. ID of the mount to remove."
    id: String!
}

input DeleteGuestCredentialByIdInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. ID of the guest OS credential to remove."
    id: String!
}

input DeleteHypervVirtualMachineSnapshotInput {
    "Required. ID of snapshot."
    id: String!
    location: InternalDeleteHypervVirtualMachineSnapshotRequestLocationEnum!
}

input DeleteHypervVirtualMachineSnapshotMountInput {
    "Force unmount to deal with situations where host has been moved."
    force: Boolean
    "Required. ID of the mount to remove."
    id: String!
}

input DeleteHypervVirtualMachineSnapshotsInput {
    "Required. Virtual machine ID."
    id: String!
}

input DeleteLogShippingConfigurationInput {
    """

    v5.0-v5.1:
    v5.2+: Boolean value that determines whether to attempt to delete the secondary database associated with the specified log shipping configuration. The default value is false. When set to false, no attempt is made to delete the secondary database. When set to true, starts an asynchronous job to delete the secondary database.
    """
    deleteSecondaryDatabase: Boolean
    "Required. ID of a log shipping configuration object."
    id: String!
}

input DeleteMosaicStoreInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. Name of the Mosaic store to be deleted."
    storeName: String!
}

input DeleteMssqlDbSnapshotsInput {
    "Required. ID of the Microsoft SQL database."
    id: String!
}

input DeleteNasSystemInput {
    "Required. ID of the NAS system to delete."
    id: String!
}

input DeleteNutanixClusterInput {
    "Required. ID of the Nutanix cluster to remove."
    id: String!
}

input DeleteNutanixSnapshotInput {
    "Required. ID of snapshot."
    id: String!
    location: InternalDeleteNutanixSnapshotRequestLocationEnum!
}

input DeleteNutanixSnapshotsInput {
    "Required. Virtual machine ID."
    id: String!
}

"Delete organization."
input DeleteOrgInput {
    "Id of the organization to delete."
    organizationId: String!
}

input DeleteSnapMirrorCloudInput {
    "Required. Provide the ID of a SnapMirror Cloud protected object to delete."
    id: String!
    "Flag to indicate whether to preserve snapshots of the SnapMirror Cloud protected object or delete them. The default is to preserve the snapshots."
    preserveSnapshots: Boolean
}

input DeleteSnapMirrorCloudRelationshipInput {
    "Required. Managed ID of the SnapMirrorCloud."
    id: String!
}

input DeleteSnapMirrorCloudSnapshotInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. The ID of the snapshot."
    id: String!
}

"Input required for resetting TOTP for multiple users."
input DeleteTotpConfigsInput {
    "Users for whom TOTP is reset."
    userIds: [String!] = []
}

input DeleteVolumeGroupSnapshotMountInput {
    "Required. ID of the mount to remove."
    id: String!
}

"The webhook to delete from the account."
input DeleteWebhookInput {
    "The id of the webhook to be deleted."
    id: Int!
}

"An object providing the parameters for the recovery of a snapshot and a next snapshot delta."
input DeltaRecoveryInput {
    "The delta type options which the files will be filtered on."
    deltaTypeFilter: [DeltaTypeEnum!]!
    "The fid of the next snapshot to perform the delta on."
    nextSnapshotFid: UUID!
}

"Supported in v5.3+"
input DisablePerLocationPauseInput {
    """

    Required. Supported in v5.3+
    Specifies whether to replicate snapshots taken during and before replication pause. When this value is 'true,' snapshots taken during and before the replication pause are not replicated. In all other cases, snapshots taken before and during the replication pause are replicated.
    """
    shouldSkipOldSnapshots: Boolean!
    """

    Required. Supported in v5.3+
    Replication from specified Rubrik clusters are resumed. Specified Rubrik clusters must be paused replication sources of local Rubrik cluster.
    """
    sourceClusterUuids: [String!]!
}

input DisablePerLocationPauseInputVariable {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. A configuration value that specifies which source clusters resume replication. Snapshots taken before or during the replication pause can be skipped."
    disablePerLocationPause: DisablePerLocationPauseInput!
}

"Input for disabling archival location."
input DisableTargetInput {
    "Id of the archival location to be disabled."
    id: String = ""
}

input DiscoverDb2InstanceInput {
    "Required. ID of the Db2 instance."
    id: String!
}

"Supported in v7.0+"
input DiscoverNasSystemRequestInput {
    """

    Required. Supported in v7.0+
    IDs of NAS systems.
    """
    ids: [String!]!
}

input DiscoverNasSystemsInput {
    "Required. IDs of the NAS systems to re-discover."
    discoverNasSystemRequest: DiscoverNasSystemRequestInput!
}

input DiskIdToIsExcluded {
    diskId: UUID!
    isExcluded: Boolean!
}

"Contains information about the snapshots to be removed from legal hold."
input DissolveLegalHoldInput {
    "List of snapshot IDs."
    snapshotIds: [String!] = []
    "Optional user note."
    userNote: String = ""
}

"Org details to check for existence."
input DoesOrgExistInput {
    "Name of the organization to check for existence."
    name: String!
    "URL of the organization to check for existence."
    url: String!
}

"Filters for cdm upgrades page for pdf generation."
input DownloadCdmUpgradesPdfFiltersInput {
    clusterLocations: [String!] = []
    clusterNames: [String!] = []
    clusterTypes: [String!] = []
    clusterUuids: [String!] = []
    downloadedVersions: [String!] = []
    installedVersions: [String!] = []
    prechecksStatus: [String!] = []
    upgradeJobStatus: [String!] = []
    versionStatus: [String!] = []
}

input DownloadFromArchiveInput {
    "Required. Configuration for the archive download request."
    config: MssqlDownloadFromArchiveConfigInput!
    "Required. ID of the Microsoft SQL database."
    id: String!
}

input DownloadHypervVirtualMachineSnapshotFilesInput {
    "Required. Configuration information for a job to download files and folders from a Hyper-V VM backup."
    config: HypervDownloadFilesJobConfigInput!
    "Required. ID assigned to a Hyper-V VM backup object."
    id: String!
}

input DownloadHypervVirtualMachineSnapshotInput {
    "Required. ID of snapshot."
    id: String!
}

"Supported in v5.2+"
input DownloadMssqlBackupFilesByIdJobConfigInput {
    """

    Required. Supported in v5.2+
    A list of snapshots and logs to download.
    """
    items: [String!]!
    """

    Supported in v5.2+
    v5.2: Optional. A Boolean that specifies whether the download is in response to a Legal Hold.
    v5.3+: Optional. A Boolean that specifies if the download is in response to a Legal Hold.
    """
    legalHoldDownloadConfig: LegalHoldDownloadConfigInput
}

input DownloadObjectFilesCsvInput {
    "The day, (YYYY-MM-DD), from which to collect user activity."
    day: String!
    "The filters to apply on the list of activities."
    filters: ListObjectFilesFiltersInput!
    "The user's IANA timezone."
    timezone: String!
}

input DownloadObjectsListCsvInput {
    "The day (YYYY-MM-DD) to get the latest snapshots of."
    day: String!
    "The user's IANA timezone."
    timezone: String!
}

input DownloadResultsCsvFiltersInput {
    analyzerGroupIds: [String!] = []
    browseDirectorySnappablePath: SnappablePathInput
    fileType: FileCountTypeEnum!
    listFileResultsSearchText: String = ""
    listFileResultsSnappablePaths: [SnappablePathInput!] = []
    listFileResultsSnappableTypes: [String!] = []
    whitelistEnabled: Boolean = false
}

input DownloadUserActivityCsvInput {
    "The day, (YYYY-MM-DD), from which to collect user activity."
    day: String!
    "The filters to apply on the list of activities."
    filters: ListObjectFilesFiltersInput!
    "The user's IANA timezone."
    timezone: String!
}

input DownloadUserFileActivityCsvInput {
    "The path to get all activity from."
    nativePath: String!
    "The path's corresponding snapshot."
    snapshot: ResourceInput!
    "The day (YYYY-MM-DD) from which to collect all activity after."
    startDay: String!
    "The user's IANA timezone."
    timezone: String!
    "The user to fetch activity for."
    userId: String!
}

"Struct representing the onedrive contents to be restored"
input DriveRestoreConfig {
    FilesToRestore: [FileInfo!]!
    FoldersToRestore: [FolderInfo!]!
    RestoreFolderPath: String!
}

"Filter to return objects whose effective SLA ID is one of the given SLA IDs"
input EffectiveSlaFilter {
    effectiveSlaIds: [String!]!
}

"Email address and to/from/both"
input EmailAddressFilter {
    emailAddress: String = ""
    emailAddressType: EmailAddressFilterType = TO
}

"Input required to enable application consistent snapshots."
input EnableDisableAppConsistencyInput {
    "Specifies whether to enable app consistency on VMs."
    enable: Boolean!
    "Object type for enabling app consistent protection."
    objectType: CloudNativeVmAppConsistentObjectType!
    "List of VM Rubrik IDs."
    snappableIds: [UUID!]!
}

"Supported in v5.3+"
input EnablePerLocationPauseInput {
    """

    Required. Supported in v5.3+
    Specifies whether replication jobs are canceled immediately. When this value is 'true,' replication jobs will be canceled immediately. In all other cases, current running replication jobs will be allowed to finish before pausing.
    """
    shouldCancelImmediately: Boolean!
    """

    Required. Supported in v5.3+
    Replication from specified Rubrik clusters are paused. Specified Rubrik clusters must be active replication sources of local Rubrik cluster.
    """
    sourceClusterUuids: [String!]!
}

input EnablePerLocationPauseInputVariable {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. A configuration value that specifies which source clusters pause replication. Replication jobs can be canceled immediately or be allowed to finish."
    enablePerLocationPause: EnablePerLocationPauseInput!
}

"Input for enabling archival location."
input EnableTargetInput {
    "Id of the archival location to be enabled."
    id: String = ""
}

"Event digest config to specify events criteria."
input EventDigestConfig {
    activitySeverity: [ActivitySeverityEnum!]
    activityStatus: [ActivityStatusEnum!]
    "Activity type to filter for emails. Valid types are Storage, Tpr, Classification, LegalHold, HypervScvmm, Hdfs, RadarAnalysis, VolumeGroup, LockSnapshot, Instantiate, HypervServer, Configuration, Upgrade, CloudNativeVm, StorageArray, Connection, Conversion, AuthDomain, UnknownEventType, CloudNativeVirtualMachine, Discovery, Replication, Maintenance, Support, Fileset, LocalRecovery, System, Failover, StormResource, Diagnostic, Vcd, Anomaly, Archive, CloudNativeSource, HostEvent, AwsEvent, ResourceOperations, Backup, Sync, Hardware, TestFailover, Recovery, Download, EmbeddedEvent, NutanixCluster, VCenter, Index, ThreatHunt, and OTHER_FILTER_ITEM"
    activityType: [String!]
    clusters: [String!]
    objectType: [ActivityObjectTypeEnum!]
}

"Struct representing the Calendar event to be restored."
input EventInfo {
    "ID of the event to be restored."
    eventId: String!
    "ID of the snapshot from which to restore."
    snapshotId: UUID!
}

input ExchangeBackupJobConfigInput {
    baseOnDemandSnapshotConfig: BaseOnDemandSnapshotConfigInput
    "Specifies whether to take a full snapshot. When true, a full snapshot is taken. When false, an incremental snapshot is taken."
    forceFullSnapshot: Boolean
}

input ExchangeDagUpdateConfigInput {
    "Required. ID of the Exchange DAG."
    id: String!
    "Required. "
    updateProperties: ExchangeDagUpdateInput!
}

input ExchangeDagUpdateInput {
    backupPreference: ExchangeBackupPreferenceEnum!
}

"Filter exchange live mount results."
input ExchangeLiveMountFilterInput {
    "Type of filter."
    field: ExchangeLiveMountFilterField = UNSPECIFIED
    "Values for the filter type."
    texts: [String!] = []
}

"Sort exchange live mounts results."
input ExchangeLiveMountSortByInput {
    "Field for exchange live mounts sort by."
    field: ExchangeLiveMountSortByField = UNSPECIFIED
    "Sort order for exchange live mounts sort by."
    sortOrder: SortOrder = ASC
}

input ExchangeMountSnapshotConfigInput {
    "Domain name of the users that are authenticated to access the SMB share."
    smbDomainName: String
    "IP address of the hosts that are authenticated to access the SMB share."
    smbValidIps: [String!] = []
    "Usernames of the users authenticated to access the SMB share."
    smbValidUsers: [String!] = []
}

"Input to mark volumes to be excluded for EC2 snapshot."
input ExcludeAwsNativeEbsVolumesFromSnapshotInput {
    "Rubrik ID of EC2 instance."
    awsNativeEc2InstanceId: UUID!
    "List of maps of Rubrik IDs to excluded status of volumes."
    volumeIdExclusions: [VolumeIdExclusion!]!
}

"Inputs to trigger Exclusion of Azure Native Managed Disk From Snapshot."
input ExcludeAzureNativeManagedDisksFromSnapshotInput {
    "A list that specifies which disks are excluded from snapshots of the virtual machine."
    managedDiskExclusions: [ManagedDiskExclusion!]!
    "Rubrik ID of the virtual machine (VM)."
    virtualMachineRubrikId: UUID!
}

"existing compute config"
input ExistingComputeConfig {
    subnetId: String = ""
    vnetId: String = ""
}

"existing storage account config"
input ExistingStorageAccountConfig {
    id: String = ""
}

input ExportHypervVirtualMachineSnapshotInput {
    "Required. Configuration for the export request."
    config: HypervExportSnapshotJobConfigInput!
    "Required. ID of snapshot."
    id: String!
}

"Config of the Kupr namespace snapshot to be exported and the target details."
input ExportK8sNamespaceInput {
    "Filter resources based on labels."
    labelSelector: LabelSelector
    "The UUID of the kupr namepspace snapshot to be exported."
    snapshotUuid: UUID!
    "The UUID of the target cluster to export the namespace snapshot to."
    targetClusterUuid: UUID!
    "The name of the target namespace to export the namespace snapshot to."
    targetNamespaceName: String!
}

"Supported in v5.0+"
input ExportMssqlDbJobConfigInput {
    """

    Supported in v5.0+
    A Boolean value that determines whether an existing database can be overwritten by a database this is exported from a backup. Set to false to prevent overwrites. This is the default. Set to true to allow overwrites.
    """
    allowOverwrite: Boolean
    """

    Supported in v5.0+
    A Boolean value that determines the recovery option to use during database restore. When this value is 'true', the database is restored using the RECOVERY option and is fully functional at the end of the restore operation. When this value is 'false', the database is restored using the NORECOVERY option and remains in recovering mode at the end of the restore operation.
    """
    finishRecovery: Boolean
    """

    Supported in v5.0+
    Maximum number of parallel data streams that can be used to copy data to the target system.
    """
    maxDataStreams: Int
    "Required. Supported in v5.0+"
    recoveryPoint: MssqlRecoveryPointInput!
    """

    Supported in v5.0+
    The target path to store all data files.
    """
    targetDataFilePath: String
    """

    Required. Supported in v5.0+
    Name of the new database.
    """
    targetDatabaseName: String!
    """

    Supported in v5.0+
    One target path for each individual database file. Overrides targetDataFilePath and targetLogFilePath.
    """
    targetFilePaths: [MssqlDbFileExportPathInput!] = []
    """

    Required. Supported in v5.0+
    ID of the Microsoft SQL instance for the new database.
    """
    targetInstanceId: String!
    """

    Supported in v5.0+
    The target path to store all log files.
    """
    targetLogFilePath: String
}

"Config for O365 mailbox export"
input ExportO365MailboxInput {
    "Configuration for restore job."
    exportConfigs: [RestoreObjectConfig!]!
    "Polaris id of the source mailbox."
    fromMailboxUUID: UUID!
    "Polaris ID of O365 subscription."
    orgUuid: UUID
    "Polaris id of restoring snapshot."
    snapshotUUID: UUID
    "Polaris id of the destination mailbox."
    toMailboxUUID: UUID!
}

"Supported in v5.0+"
input ExportPathPairInput {
    """

    Required. Supported in v5.0+
    Destination path of export files.
    """
    dstPath: String!
    """

    Required. Supported in v5.0+
    Original file path.
    """
    srcPath: String!
}

"Supported in v6.0+"
input ExportSnapshotJobConfigForBatchInput {
    """

    Required. Supported in v6.0+
    Configuration for snapshot export.
    """
    config: ExportSnapshotJobConfigV2Input!
    """

    Supported in v6.0+
    Exports the oldest snapshot taken after the specified date. This parameter is only evaluated when no values are set for snapshotId and snapshotBeforeDate.
    """
    snapshotAfterDate: DateTime
    """

    Supported in v6.0+
    Exports the most recent snapshot taken prior to the specified date. This parameter is only evaluated when no value is set for snapshotId.
    """
    snapshotBeforeDate: DateTime
    """

    Supported in v6.0+
    The ID of the snapshot to export. This parameter is optional if either of the snapshotBeforeDate or snapshotAfterDate parameters is configured.
    """
    snapshotId: String
    """

    Required. Supported in v6.0+
    ID of the virtual machine whose snapshot needs to be exported.
    """
    vmId: String!
    """

    Supported in v6.0+
    Prefix to be added to the name of the exported virtual machine.
    """
    vmNamePrefix: String
}

"Supported in v5.1+"
input ExportSnapshotJobConfigV2Input {
    """

    Supported in v5.2+
    ID of the cluster to export the new virtual machine to. virtual machine.
    """
    clusterId: String
    """

    Required. Supported in v5.1+
    ID of the datastore to assign to the exported virtual machine.
    """
    datastoreId: String!
    """

    Supported in v5.1+
    ID of the ESXi host to export the new virtual machine to.
    """
    hostId: String
    mountExportSnapshotJobCommonOptionsV2: MountExportSnapshotJobCommonOptionsV2Input
    requiredRecoveryParameters: RequiredRecoveryParametersInput
    """

    Supported in v5.2+
    ID of the resource pool to export the new virtual machine to.
    """
    resourcePoolId: String
    """

    Supported in v5.1+
    The job recovers any tags that were assigned to the virtual machine.
    """
    shouldRecoverTags: Boolean
    """

    Supported in v7.0+
    Boolean value that determines whether Export uses a HotAdd mode to transport virtual disk data. When this value is `true`, Export uses HotAdd mode to transport virtual disk data. When this value is `false`, Export uses NBDSSL to transport virtual disk data. The default value is `false`.
    """
    shouldUseHotAddProxy: Boolean
    """

    Supported in v5.1+
    A Boolean value that determines whether the new virtual machine created from a snapshot is registered with the vCenter Server. When this value is 'true', the registration is removed from the vCenter Server. When this value is 'false', the registration is kept on the vCenter Server. The default is 'false'.
    """
    unregisterVm: Boolean
    """

    Supported in v6.0+
    The network binding for vNIC of the virtual machine.
    """
    vNicBindings: [VmwareVNicBindingInfoV2Input!] = []
}

"Supported in v5.2+"
input FailoverClusterAppConfigInput {
    """

    Supported in v5.2+
    ID of the SLA Domain that is assigned to the specified failover cluster app. Existing snapshots of the object will be retained with the configuration of specified SLA Domain.
    """
    configuredSlaDomainId: String
    """

    Required. Supported in v5.2+
    The source used by the failover cluster app to perform fileset backups. Either a virtual IP address or a node order must be specified in order for the failover cluster app to perform app backup.
    """
    failoverClusterAppSource: FailoverClusterAppSourceInput!
    """

    Required. Supported in v5.2+
    Cluster ID of the failover cluster app.
    """
    failoverClusterId: String!
    failoverClusterType: FailoverClusterTypeEnum!
    """

    Required. Supported in v5.2+
    Name of the failover cluster app.
    """
    name: String!
}

"Supported in v5.2+"
input FailoverClusterAppSourceInput {
    """

    Supported in v5.2+
    Specifies an order for the failover cluster nodes. Failover cluster app backups use the failover cluster nodes in the specified order.
    """
    nodeOrders: [FailoverClusterNodeOrderInput!] = []
    "Virtual IP addresses of the failover cluster."
    vips: [String!] = []
    """

    Supported in v5.3+
    Virtual IP addresses of the failover cluster.
    """
    virtualIps: [String!] = []
}

"Supported in v5.2+"
input FailoverClusterConfigInput {
    """

    Supported in v5.2+
    ID of the SLA Domain that is assigned to the specified failover cluster. Existing snapshots of the object will be retained with the configuration of specified SLA Domain.
    """
    configuredSlaDomainId: String
    """

    Required. Supported in v5.2+
    Managed ID's of Hosts of the failover cluster.
    """
    hostIds: [String!]!
    """

    Required. Supported in v5.2+
    Name of the failover cluster.
    """
    name: String!
}

"Supported in v5.2+"
input FailoverClusterNodeOrderInput {
    """

    Required. Supported in v5.2+
    ID of the failover cluster node.
    """
    nodeId: String!
    """

    Supported in v5.3+
    The name of the failover cluster node.
    """
    nodeName: String
    """

    Required. Supported in v5.2+
    An integer that specifies the place occupied by this node in the failover cluster app backup order.
    """
    order: Int!
}

"Filter appflows failover jobs"
input FailoverFilterInput {
    failoverStatus: [FailoverStatusEnum!]
    failoverType: FailoverTypeEnum
    source: [String!]
    targetSite: [String!]
    time_gt: DateTime
    time_lt: DateTime
}

"A contextual value affecting the evaluation of a feature flag"
input FeatureFlagContextField {
    "Key corresponding to this field"
    key: String!
    "The value of this field. Can be any GraphQL scalar."
    value: AnyScalar!
}

input FederatedLoginStatusInput {
    "Enable or Disable federated login."
    enabled: Boolean!
    "Enable or Disable federated login inventory card."
    inventoryCardEnabled: Boolean!
}

"Sorts to apply when listing a file's user activities."
input FileActivitiesSort {
    "The field to sort on."
    sortBy: FileActivitiesSortBy = USER_NAME
    "The direction to sort on."
    sortOrder: SortOrder = ASC
}

"Config which describes file details."
input FileDetailsInput {
    "Name of the file."
    fileName: String!
}

"Struct representing the Onedrive file to be restored"
input FileInfo {
    ChannelInfo: TeamsChannelInfo
    FileID: String!
    FileName: String!
    FileSnapshotsToRestore: [FileSnapshotInfo!]!
}

input FileResultSortInput {
    analyzerGroupId: String = ""
    sortBy: FileResultSortByEnum = HITS
    sortOrder: SortOrder = ASC
}

"Struct representing the Onedrive file snapshot to be restored"
input FileSnapshotInfo {
    FileSize: Long!
    SnapshotID: UUID!
    SnapshotNum: Int!
}

"Supported in v5.0+"
input FilesetArraySpecInput {
    """

    Supported in v5.0+
    ID assigned to a proxy host for array-enabled backups. This property is only required for array-enabled backups.
    """
    proxyHostId: String
}

"Supported in v5.0+"
input FilesetCreateInput {
    "Supported in v5.0+"
    arraySpec: FilesetArraySpecInput
    """

    Supported in v5.1+
    A Boolean value that determines whether to recognize and dedupe hardlinks in a fileset. When 'true,' performs a hardlink deduplication. When 'false,' performs a normal backup that treats hardlinks as normal files. If not specified, this defaults to false.
    """
    enableHardlinkSupport: Boolean
    """

    Supported in v5.1+
    A Boolean value that determines whether to resolve symlink in a fileset. When 'true,' performs a symlink resolution. When 'false,' performs no symlink resolution. If not specified, this defaults to false.
    """
    enableSymlinkResolution: Boolean
    """

    Supported in v5.2+
    ID of the failover cluster app.
    """
    failoverClusterAppId: String
    "Supported in v5.0+"
    hostId: String
    """

    Supported in v7.0+
    Specifies whether the fileset is managed by Polaris.
    """
    isManagedByPolaris: Boolean
    """

    Supported in v5.0+
    v5.0: A Boolean value that determines whether to take a direct archive backup. When 'true,' performs a direct archive backup. When 'false,' performs a normal backup.
    v5.1+: A Boolean value that determines whether to take a direct archive backup. When 'true,' performs a direct archive backup. When 'false,' performs a normal backup. If not specified, this defaults to false.
    """
    isPassthrough: Boolean
    """

    Supported in v7.0+
    Specifies whether the fileset is created in Polaris and is based on the new NAS model.
    """
    isPolarisNasModel: Boolean
    "Supported in v5.0+"
    shareId: String
    """

    Supported in v5.3+
    Rubrik CDM uses a prefix match to select the latest SnapMirror snapshot that matches this value during a full backup of a SnapMirror destination share.
    """
    snapMirrorLabelForFullBackup: String
    """

    Supported in v5.3+
    Rubrik CDM selects the latest SnapMirror snapshot that matches this value using a prefix match during an incremental backup of a SnapMirror destination share.
    """
    snapMirrorLabelForIncrementalBackup: String
    "Required. Supported in v5.0+"
    templateId: String!
}

"Supported in v5.0+"
input FilesetDownloadFilesJobConfigInput {
    """

    Supported in v5.2+
    An optional argument containing a Boolean parameter to depict if the download is being triggered for Legal Hold use case.
    """
    legalHoldDownloadConfig: LegalHoldDownloadConfigInput
    """

    Required. Supported in v5.0+
    An array containing the full source path of each file and folder that is part of the download job. The array must contain at least one path.
    """
    sourceDirs: [String!]!
}

"Supported in v5.0+"
input FilesetExportFilesJobConfigInput {
    """

    Required. Supported in v5.0+
    Pairs of source path and destination path.
    """
    exportPathPairs: [FilesetExportPathPairInput!]!
    """

    Required. Supported in v5.0+
    Host ID.
    """
    hostId: String!
    """

    Supported in v5.0+
    Optional Boolean value that determines whether or not to ignore errors during an export. By default, this value is set to False. Set this value to True to ignore errors.
    """
    ignoreErrors: Boolean
    """

    Supported in v5.0+
    Network share ID.
    """
    shareId: String
}

"Supported in v5.0+"
input FilesetExportPathPairInput {
    exportPathPair: ExportPathPairInput
}

"Supported in v5.0+"
input FilesetOptionsInput {
    """

    Supported in v5.0+
    Include or exclude hidden folders inside locally-mounted remote file systems from backups.
    """
    allowBackupHiddenFoldersInNetworkMounts: Boolean
    """

    Supported in v5.0+
    Include or exclude locally-mounted remote file systems from backups.
    """
    allowBackupNetworkMounts: Boolean
    """

    Supported in v5.0+
    Use VSS during Windows backups.
    """
    useWindowsVss: Boolean
}

"Supported in v5.0+"
input FilesetRestoreFilesJobConfigInput {
    """

    Supported in v5.0+
    Optional field to determine if we should ignore single error during restore. Default value is false.
    """
    ignoreErrors: Boolean
    """

    Required. Supported in v5.0+
    v5.0-v5.3: Absolute file path and restore path if not restored back to itself
    v6.0+: Absolute file path.. and restore path if not restored back to itself.
    """
    restoreConfig: [FilesetRestorePathPairInput!]!
}

"Supported in v5.0+"
input FilesetRestorePathPairInput {
    restorePathPair: RestorePathPairInput
}

"Supported in v5.0+"
input FilesetTemplateCreateInput {
    """

    Supported in v5.0+
    Action taken if script fails. Options are "abort", "continue".
    """
    backupScriptErrorHandling: String
    """

    Supported in v5.0+
    Number of seconds after which the script is killed if it has not completed execution.
    """
    backupScriptTimeout: Long
    "Supported in v5.0+"
    exceptions: [String!] = []
    "Supported in v5.0+"
    excludes: [String!] = []
    filesetOptions: FilesetOptionsInput
    "Required. Supported in v5.0+"
    includes: [String!]!
    """

    Supported in v5.0+
    Boolean value that determines whether the fileset is array-enabled. Set to true to indicate that the fileset is array-enabled. Set to false to indicate that the fileset is not array-enabled. When a fileset is array-enabled, the includes must be top-level LVM logical volume mount points.
    """
    isArrayEnabled: Boolean
    """

    Supported in v7.0+
    Specifies whether this is created by a Kupr Host.
    """
    isCreatedByKupr: Boolean
    """

    Supported in v7.0+
    Specifies whether the template was created for Polaris NAS.
    """
    isCreatedByPolarisNas: Boolean
    "Required. Supported in v5.0+"
    name: String!
    operatingSystemType: FilesetTemplateCreateOperatingSystemTypeEnum
    """

    Supported in v5.0+
    Script to run after backup of this fileset ends.
    """
    postBackupScript: String
    """

    Supported in v5.0+
    Script to run before backup of this fileset starts.
    """
    preBackupScript: String
    shareType: FilesetTemplateCreateShareTypeEnum
}

"Supported in v5.0+"
input FilesetTemplatePatchInput {
    """

    Supported in v5.0+
    Action taken if script fails. Options are "abort", "continue".
    """
    backupScriptErrorHandling: String
    """

    Supported in v5.0+
    Number of seconds after which the script is killed if it has not completed execution.
    """
    backupScriptTimeout: Long
    "Supported in v5.0+"
    exceptions: [String!] = []
    "Supported in v5.0+"
    excludes: [String!] = []
    filesetOptions: FilesetOptionsInput
    "Required. Supported in v5.0+"
    id: String!
    "Supported in v5.0+"
    includes: [String!] = []
    """

    Supported in v7.0+
    Specifies whether this is created by a Kupr Host.
    """
    isCreatedByKupr: Boolean
    """

    Supported in v7.0+
    Specifies whether the template was created for Polaris NAS.
    """
    isCreatedByPolarisNas: Boolean
    "Supported in v5.0+"
    name: String
    operatingSystemType: FilesetTemplatePatchOperatingSystemTypeEnum
    """

    Supported in v5.0+
    Script to run after backup of this Fileset ends.
    """
    postBackupScript: String
    """

    Supported in v5.0+
    Script to run before backup of this Fileset starts.
    """
    preBackupScript: String
    shareType: FilesetTemplatePatchShareTypeEnum
}

"Filter"
input Filter {
    awsNativeProtectionFeatureNames: [AwsNativeProtectionFeature!] = []
    azureNativeProtectionFeatureNames: [AzureNativeProtectionFeature!] = []
    field: HierarchyFilterField = IS_ARCHIVED
    isNegative: Boolean = false
    isSlowSearchEnabled: Boolean = false
    objectTypeFilterParams: [ManagedObjectType!] = []
    tagFilterParams: [TagFilterParams!] = []
    texts: [String!] = []
}

"Input to process and finalize deletion of AWS cloud account."
input FinalizeAwsCloudAccountDeletionInput {
    "Rubrik ID of account to be deleted."
    cloudAccountId: UUID!
    "Protection feature to be deleted for the cloud account."
    feature: CloudAccountFeature!
}

"Input to finalize set up of an AWS cloud account."
input FinalizeAwsCloudAccountProtectionInput {
    "Action to be performed with cloud account."
    action: CloudAccountAction!
    "Admin account, required for bulk upload."
    awsAdminAccount: AwsCloudAccountInput
    "List of AWS accounts."
    awsChildAccounts: [AwsCloudAccountInput!]!
    "List of AWS regions for the cloud account."
    awsRegions: [AwsCloudAccountRegion!]
    "External ID of the IAM role trust policy for the cloud account."
    externalId: String!
    "List of feature types to be protected for the cloud account."
    featureVersion: [AwsCloudAccountFeatureVersionInput!]!
    "List of features for native protection of cloud account."
    features: [CloudAccountFeature!]!
    "Name of the CloudFormation stack to be created."
    stackName: String
    "Stackset name of the CloudFormation stack to be created."
    stackSetName: String
}

"Struct representing the Onedrive folder to be restored"
input FolderInfo {
    ChannelInfo: TeamsChannelInfo
    FolderID: String!
    FolderName: String!
    FolderSize: Long!
    SnapshotID: UUID!
    SnapshotNum: Int!
}

"Filters for list of GCP disks."
input GcpNativeDiskFilters {
    diskTypeFilter: GcpNativeDiskTypeFilter
    effectiveSlaFilter: EffectiveSlaFilter
    labelFilter: GcpNativeLabelFilter
    locationFilter: GcpNativeDiskLocationFilter
    nameOrIDSubstringFilter: GcpNativeDiskNameOrIDSubstringFilter
    projectFilter: GcpNativeDiskProjectFilter
    relicFilter: RelicFilter
}

"Filter to return GCP disks which have location in the given list of locations. Location can be a zone or a region."
input GcpNativeDiskLocationFilter {
    locations: [String!]!
}

"Filter to return GCP disks with a given substring in their name or ID."
input GcpNativeDiskNameOrIDSubstringFilter {
    nameOrIDSubstring: String!
}

"Filter to return GCP disks which have project rubrik ID in the given list of project rubrik IDs."
input GcpNativeDiskProjectFilter {
    projectIds: [String!]!
}

"Filter to return GCP disks which have disk type in the given list of disk types."
input GcpNativeDiskTypeFilter {
    diskTypes: [String!]!
}

"Filters for list of GCP GCE instances."
input GcpNativeGceInstanceFilters {
    effectiveSlaFilter: EffectiveSlaFilter
    labelFilter: GcpNativeLabelFilter
    machineTypeFilter: GcpNativeMachineTypeFilter
    nameOrIDSubstringFilter: GcpNativeInstanceNameOrIDSubstringFilter
    networkFilter: GcpNativeNetworkFilter
    projectFilter: GcpNativeProjectFilter
    regionFilter: GcpNativeRegionFilter
    relicFilter: RelicFilter
}

"Filter to return GCP GCE instances with a given substring in their name or ID."
input GcpNativeInstanceNameOrIDSubstringFilter {
    nameOrIDSubstring: String!
}

"Filter to return GCP objects which have at least one label in the given list of labels."
input GcpNativeLabelFilter {
    labelFilterParams: [LabelFilterParams!]!
}

"Filter to return GCP GCE instances which have instance type in the given list of machine types."
input GcpNativeMachineTypeFilter {
    machineTypes: [String!]!
}

"Filter to return GCP GCE instances which have network name in the given list of network names."
input GcpNativeNetworkFilter {
    networkNames: [String!]!
}

"Filter to return GCP objects which have project rubrik ID in the given list of project rubrik IDs."
input GcpNativeProjectFilter {
    projectIds: [String!]!
}

"Filters for list of GCP projects."
input GcpNativeProjectFilters {
    effectiveSlaFilter: EffectiveSlaFilter
    idSubstringFilter: GcpNativeProjectIdSubstringFilter
    nameOrNumberSubstringFilter: GcpNativeProjectNameOrNumberSubstringFilter
}

"Filter to return GCP projects with the given string in their project ID."
input GcpNativeProjectIdSubstringFilter {
    idSubstring: String!
}

"Filter to return GCP projects with a given substring in their name or number."
input GcpNativeProjectNameOrNumberSubstringFilter {
    nameOrNumberSubstring: String!
}

"Filter to return GCP objects which have region in the given list of regions."
input GcpNativeRegionFilter {
    regions: [String!]!
}

input GcpTargetCreateInput {
    archivalProxySettings: ProxySettingsInput
    bucket: String!
    clusterUuid: UUID!
    encryptionPassword: String!
    name: String!
    region: GcpRegionEnum!
    serviceAccountJsonKey: String!
    storageClass: GcpStorageClassTypeEnum!
}

input GcpTargetEditInput {
    archivalProxySettings: ProxySettingsInput
    bucket: String
    encryptionPassword: String
    id: UUID!
    name: String
    region: GcpRegionEnum
    serviceAccountJsonKey: String
    storageClass: GcpStorageClassTypeEnum
}

"Input required for providing cluster config details for registration."
input GenerateClusterRegistrationTokenInput {
    "Indicates whethere the registration is being performed in offline mode or online. Input is optional as all CDM releases don't support offline registration."
    isOfflineRegistration: Boolean
    "If true, generate a token for registering a Hybrid cluster. If false, generate a token for registering LifeOfDevice cluster. If it's not passed, the product type is inferred automatically. Value would be absent in case of single SKU."
    managedByPolaris: Boolean
    "Configuration details for nodes in the cluster. Input is optional as all CDM releases don't support this config generation."
    nodeConfigs: [NodeRegistrationConfigsInput!]
}

input GenericTimeRangeInput {
    absoluteTimeRange: TimeRangeInput
    relativeTimeRange: RelativeTimeRangeInput
}

input GetAcoParameterListInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
}

input GetCompatibleMssqlInstancesV1Input {
    "Required. ID of the Microsoft SQL database."
    id: String!
    "Time, in ISO8601 format, to recover to. For example \"2016-01-01T01:23:45.678Z\". If this is not specified, the latest recoverable time is used."
    recoveryTime: DateTime
    recoveryType: V1GetCompatibleMssqlInstancesV1RequestRecoveryTypeEnum!
}

input GetContainersInput {
    "Required. ID of the Nutanix cluster."
    id: String!
}

input GetDefaultDbPropertiesV1Input {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
}

input GetExampleAcoDownloadLinkInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
}

input GetLambdaDetectMalwareRequestStatusInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. ID of an asynchronous malware detection."
    id: String!
}

input GetLambdaDetectMalwareResultInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. ID of an asynchronous malware detection."
    id: String!
}

input GetLambdaMalwareScanDetailInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. ID of an asynchronous malware detection."
    id: String!
}

input GetMissedMssqlDbSnapshotsInput {
    "Filter snapshots to those missed on or after this time. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678\"."
    afterTime: DateTime
    "Filter snapshots to those missed on or before this time. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678\"."
    beforeTime: DateTime
    "Required. ID of the Microsoft SQL database."
    id: String!
}

input GetMosaicRecoverableRangeInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. Request Object with details of Tables whose recovery range is required."
    recoveryRangeRequestData: MosaicRecoverableRangeRequestInput!
}

input GetMosaicStoreInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
}

input GetMosaicTableSchemaInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. Schema request Object with details of schema which needs to be retrieved."
    schemaRequestData: MosaicGetSchemaRequestInput!
}

input GetMosaicVersionInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. Version filters"
    versionData: VersionInput!
}

input GetMssqlDbMissedRecoverableRangesInput {
    "Filter the missed ranges to end after this time. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678\"."
    afterTime: DateTime
    "Filter the missed ranges to start before this time. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678\"."
    beforeTime: DateTime
    "Required. ID of the Microsoft SQL database."
    id: String!
}

input GetMssqlDbRecoverableRangesInput {
    "Filter ranges to end after this time. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678Z\"."
    afterTime: DateTime
    "Filter ranges to start before this time. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678\"."
    beforeTime: DateTime
    "Required. ID of the Microsoft SQL database."
    id: String!
}

input GetNutanixClusterAsyncRequestStatusInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. ID of the request."
    id: String!
}

input GetNutanixVmAsyncRequestStatusInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. ID of the request."
    id: String!
}

input GetOracleDbMissedRecoverableRangesInput {
    "Filter the missed ranges to end after this time. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678\"."
    afterTime: DateTime
    "Filter the missed ranges to start before this time. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678\"."
    beforeTime: DateTime
    "Required. ID of the Oracle database."
    id: String!
}

input GetOracleDbRecoverableRangesInput {
    "Filter ranges to end after this time. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678Z\"."
    afterTime: DateTime
    "Filter ranges to start before this time. The date-time string should be in ISO8601 format, such as \"2016-01-01T01:23:45.678\"."
    beforeTime: DateTime
    "Required. ID of the Oracle database."
    id: String!
    "Include database snapshot summaries in the response."
    shouldIncludeDbSnapshotSummaries: Boolean
}

input GetPendingSlaAssignmentsInput {
    "Required. Object with a list of object IDs to use when retrieving pending SLA Domain assignments."
    pendingAssignmentsRequest: PendingSlaOperationsRequestInput!
}

input GlobalSearchApiQueryInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. Global search query."
    query: GlobalSearchApiRequestInput!
}

"Supported in v5.1+"
input GlobalSearchApiRequestInput {
    """

    Required. Supported in v5.1+
    Regex to match.
    """
    regex: String!
    """

    Required. Supported in v5.1+
    Managed IDs of snappables to search across.
    """
    snappableIds: [String!]!
}

input GlobalSlaEditRequest {
    archivalSpecInput: ArchivalSpecInput
    archivalSpecInputs: [ArchivalSpecInput!] = []
    archivalSpecs: [ArchivalSpecInput!] = []
    backupWindows: [BackupWindowInput!] = []
    description: String = ""
    firstFullBackupWindows: [BackupWindowInput!] = []
    id: String = ""
    localRetentionLimit: SlaDurationInput
    logConfig: LogConfig
    name: String = ""
    objectSpecificConfigsInput: ObjectSpecificConfigsInput
    objectTypeList: [SLAObjectTypeEnum!] = []
    objectTypes: [SLAObjectTypeEnum!] = []
    replicationSpecInput: ReplicationSpecInput
    replicationSpecV2List: [ReplicationSpecV2Input!] = []
    replicationSpecsV2: [ReplicationSpecV2Input!] = []
    shouldApplyToExistingSnapshots: ShouldApplyToExistingSnapshots
    shouldApplyToNonPolicySnapshots: ShouldApplyToNonPolicySnapshots
    snapshotSchedule: GlobalSnapshotScheduleInput
    stateVersion: Long = 0
    "Optional user note."
    userNote: String = ""
}

input GlobalSlaFilterInput {
    field: GlobalSlaQueryFilterInputField = NAME
    objectTypeList: [SLAObjectTypeEnum!] = []
    text: String = ""
}

input GlobalSnapshotScheduleInput {
    daily: DailySnapshotScheduleInput
    hourly: HourlySnapshotScheduleInput
    minute: MinuteSnapshotScheduleInput
    monthly: MonthlySnapshotScheduleInput
    quarterly: QuarterlySnapshotScheduleInput
    weekly: WeeklySnapshotScheduleInput
    yearly: YearlySnapshotScheduleInput
}

"group config"
input GroupConfig {
    name: String = ""
}

"Supported in v5.0+"
input GuestCredentialDefinitionInput {
    baseGuestCredential: BaseGuestCredentialInput
    "Supported in v5.0+"
    domain: String
}

"Supported in v5.2+"
input HdfsBaseConfigInput {
    """

    Supported in v5.2+
    API token to access Hdfs.
    """
    apiToken: String
    """

    Required. Supported in v5.2+
    List of Hdfs Namenode Hosts.
    """
    hosts: [HdfsHostInput!]!
    """

    Supported in v5.2+
    Ticket Cache Path of Kerberos Ticket.
    """
    kerberosTicket: String
    """

    Supported in v5.2+
    Logical name for nameservice for Hdfs HA.
    """
    nameservices: String
    """

    Supported in v5.2+
    Username to access Hdfs API.
    """
    username: String
}

"Supported in v5.2+"
input HdfsConfigInput {
    hdfsBaseConfig: HdfsBaseConfigInput
}

"Supported in v5.2+"
input HdfsHostInput {
    """

    Required. Supported in v5.2+
    Hostname or Ip of Namenode.
    """
    hostname: String!
    """

    Required. Supported in v5.2+
    Port number of Namenode.
    """
    port: Int!
}

"Contains configuration of the legal hold to be placed."
input HoldConfig {
    "Boolean which denotes whether a snapshot is to be held in place."
    shouldHoldInPlace: Boolean = false
}

"Supported in v5.0+"
input HostRegisterInput {
    """

    Supported in v5.1+
    A user-specified string that returns this host in searches.
    """
    alias: String
    "Supported in v5.0+"
    hasAgent: Boolean
    "Supported in v5.2+"
    hdfsConfig: HdfsConfigInput
    "Required. Supported in v5.0+"
    hostname: String!
    """

    Supported in v5.2+
    A Boolean that specifies whether to discover Oracle information at registration. A value of 'true' discovers Oracle information at registration.
    """
    isOracleHost: Boolean
    "Supported in v5.0+"
    nasConfig: NasConfigInput
    """

    Supported in v5.0+
    Specifies the Oracle username for an account with query privileges. The account must have query privileges for a specified Oracle installation to enable Oracle discovery queries for that installation.
    """
    oracleQueryUser: String
    """

    Supported in v5.0+
    v5.0: Specifies the Oracle username for an account with sysdba privileges. The account must have sysdba privileges for a specified Oracle installation to enable backup and recovery of Oracle databases for that installation. This field overrides the configured global sysdba user for the specified Oracle installation.
    v5.1+: Specifies the Oracle username for an account with sysdba privileges. The account must have sysdba privileges for a specified Oracle installation to enable Oracle discovery queries for that installation. This field overrides the configured global sysdba user for the specified Oracle installation.
    """
    oracleSysDbaUser: String
    """

    Supported in v5.0+
    The ID of the organization to which the host is assigned.
    """
    organizationId: String
}

"Supported in v5.0+"
input HostUpdateIdInput {
    """

    Required. Supported in v5.0+
    ID of the host.
    """
    hostId: String!
    "Required. Supported in v5.0+"
    updateProperties: HostUpdateInput!
}

"Supported in v5.0+"
input HostUpdateInput {
    """

    Supported in v5.1+
    A user-specified string that returns this host in searches.
    """
    alias: String
    "Supported in v5.0+"
    compressionEnabled: Boolean
    "Supported in v5.2+"
    hdfsConfig: HdfsConfigInput
    """

    Supported in v5.0+
    When VFD is disabled on the specified Windows host, set this property to false to instruct the Rubrik cluster to remove the VFD driver from a specified Windows host. Before using this property, disable VFD on the specified Windows host by setting the value of HostVfdEnabled to Disabled.
    """
    hostVfdDriverInstalled: Boolean
    hostVfdEnabled: HostVfdInstallConfigEnum
    "Supported in v5.0+"
    hostname: String
    """

    Supported in v5.2+
    v5.2-v5.3: A Boolean that specifies whether to discover Oracle information during host refresh. A value of 'true' discovers Oracle information during host refresh.
    v6.0: A Boolean that specifies whether to discover Oracle information during host refresh. A value of 'true' discovers Oracle information during host refresh.

    v7.0+: A Boolean that specifies whether to discover Oracle information during host refresh. A value of 'true' discovers Oracle information during host refresh.
    """
    isOracleHost: Boolean
    """

    Supported in v7.0+
    A Boolean that specifies whether to update the Rubrik Backup Agent and agent ID during host edit.
    """
    isUpdateCertAndAgentIdEnabled: Boolean
    """

    Supported in v5.0+
    When CBT is disabled on the specified Windows host, set this property to false to instruct the Rubrik cluster to remove the CBT driver from a specified Windows host. Before using this property, disable CBT on the specified Windows host by setting the value of mssqlCbtEnabled to Disabled.
    """
    mssqlCbtDriverInstalled: Boolean
    mssqlCbtEnabled: MssqlCbtStatusTypeEnum
    "Supported in v5.0+"
    nasConfig: NasConfigInput
    """

    Supported in v5.0+
    Specifies the Oracle username for an account with query privileges. The account must have query privileges for a specified Oracle installation to enable Oracle discovery queries for that installation.
    """
    oracleQueryUser: String
    """

    Supported in v5.0+
    v5.0: Specifies the Oracle username for an account with sysdba privileges. The account must have sysdba privileges for a specified Oracle installation to enable backup and recovery of Oracle databases for that installation. This field overrides the configured global sysdba user for the specified Oracle installation.
    v5.1-v5.3: Specifies the Oracle username for an account with sysdba privileges. The account must have sysdba privileges for a specified Oracle installation to enable Oracle discovery queries for that installation. This field overrides the configured global sysdba user for the specified Oracle installation.
    v6.0+: Specifies the Oracle username for an account with sysdba privileges. The account must have sysdba privileges for a specified Oracle installation to enable Oracle discovery queries for that installation. This field overrides the configured global sysdba user for the specified Oracle installation.
    """
    oracleSysDbaUser: String
}

"Supported in v5.0+"
input HostVfdInstallRequestInput {
    """

    Required. Supported in v5.0+
    Ids of host on which to install/uninstall VFD.
    """
    hostIds: [String!]!
    "Required. Supported in v5.0+"
    install: Boolean!
}

input HourlySnapshotScheduleInput {
    basicSchedule: BasicSnapshotScheduleInput
}

"Filter hyper-v live mount results."
input HyperVLiveMountFilterInput {
    "Type of filter."
    field: HyperVLiveMountFilterField = UNSPECIFIED
    "Values for the filter type."
    texts: [String!] = []
}

"Sort hyper-v live mounts results."
input HyperVLiveMountSortByInput {
    "Field for hyper-v live mounts sort by."
    field: HyperVLiveMountSortByField = UNSPECIFIED
    "Sort order for hyper-v live mounts sort by."
    sortOrder: SortOrder = ASC
}

"Supported in v5.0+"
input HypervDownloadFilesJobConfigInput {
    """

    Supported in v5.2+
    An optional argument containing a Boolean parameter to depict if the download is being triggered for Legal Hold use case.
    """
    legalHoldDownloadConfig: LegalHoldDownloadConfigInput
    """

    Required. Supported in v5.0+
    An array containing the full source path of each file and folder that is part of the download job. The array must contain at least one path. When the source is a Windows virtual machine, the paths must all be on the same disk.
    """
    paths: [String!]!
}

"Supported in v5.0+"
input HypervExportSnapshotJobConfigInput {
    """

    Supported in v5.0+
    v5.0-v7.0: Sets the state of the network interfaces when the virtual machine is mounted. Use 'false' to enable the network interfaces. Use 'true' to disable the network interfaces. Disabling the interfaces can prevent IP conflicts. Default value is 'true'.
    v8.0: Sets the state of the network interfaces when the virtual machine is mounted. 'false' enables the network interfaces. 'true' disables the network interfaces. The default value is 'true'. Disabling the interfaces can prevent IP address conflicts.
    """
    disableNetwork: Boolean
    """

    Supported in v5.0+
    v5.0-v5.3: ID of the host to export to
    v6.0-v7.0: ID of the host to export to.
    v8.0: ID of the host for export.
    """
    hostId: String
    """

    Required. Supported in v5.0+
    v5.0-v5.3: Destination path for the new VM virtual disks
    v6.0-v7.0: Destination path for the new VM virtual disks.
    v8.0: Destination path for the virtual disks of the new virtual machine.
    """
    path: String!
    """

    Supported in v5.0+
    v5.0-v5.3: Whether the VM should be powered on after export. Default value is true
    v6.0-v7.0: Whether the VM should be powered on after export. Default value is true.
    v8.0: Determines whether the virtual machine should be powered on after export. The default value is true.
    """
    powerOn: Boolean
    """

    Supported in v5.0+
    v5.0-v7.0: Determines whether to remove the network interfaces from the mounted virtual machine. Set to 'true' to remove all network interfaces. The default value is 'false'.
    v8.0: Determines whether to remove the network interfaces from the mounted virtual machine. 'true' removes all network interfaces. The default value is 'false'.
    """
    removeNetworkDevices: Boolean
    """

    Supported in v5.0+
    v5.0-v5.3: name of the new VM for export
    v6.0-v7.0: name of the new VM for export.
    v8.0: Name of the new virtual machine being exported.
    """
    vmName: String
}

"Supported in v5.0+"
input HypervInstantRecoveryJobConfigInput {
    """

    Supported in v5.0+
    ID of the host to instantly recover to.
    """
    hostId: String
    """

    Supported in v5.0+
    name of the new VM to instantly recover.
    """
    vmName: String
}

"Supported in v5.0+"
input HypervMountSnapshotJobConfigInput {
    """

    Supported in v5.0+
    Sets the state of the network interfaces when the virtual machine is mounted. Use 'false' to enable the network interfaces. Use 'true' to disable the network interfaces. Disabling the interfaces can prevent IP conflicts. Default value is 'true'.
    """
    disableNetwork: Boolean
    """

    Supported in v5.0+
    ID of host for the mount to use.
    """
    hostId: String
    """

    Supported in v5.0+
    Whether the VM should be powered on after mount. Default value is true.
    """
    powerOn: Boolean
    """

    Supported in v5.0+
    Determines whether to remove the network interfaces from the mounted virtual machine. Set to 'true' to remove all network interfaces. The default value is 'false'.
    """
    removeNetworkDevices: Boolean
    """

    Supported in v5.0+
    Name of the mounted VM.
    """
    vmName: String
}

"Supported in v5.0+"
input HypervRestoreFileConfigInput {
    """

    Required. Supported in v5.0+
    Absolute file path.
    """
    path: String!
    """

    Required. Supported in v5.0+
    Directory of folder to copy files into.
    """
    restorePath: String!
}

"Supported in v5.0+"
input HypervRestoreFilesConfigInput {
    """

    Required. Supported in v5.0+
    Absolute path of the target location for the copied files.
    """
    restoreConfig: [HypervRestoreFileConfigInput!]!
}

"Supported in v5.0+"
input HypervScvmmRegisterInput {
    """

    Required. Supported in v5.0+
    Name of the SCVMM host.
    """
    hostname: String!
    """

    Required. Supported in v5.0+
    The RunAs account which will be used to install connector on hosts.
    """
    runAsAccount: String!
    """

    Required. Supported in v5.0+
    Flag to specify if Rubrik can deploy connector to hosts. If true, Rubrik tries to deploy connector to the hyperv hosts. If false, Rubrik deployment of connector will be handled by the client.
    """
    shouldDeployAgent: Boolean!
}

"Supported in v5.0+"
input HypervScvmmUpdateInput {
    """

    Supported in v5.0+
    v5.0-v5.1: Assign this SCVMM to the given SLA domain.
    v5.2+: Assign this SCVMM to the given SLA domain. Existing snapshots of the object will be retained with the configuration of specified SLA Domain.
    """
    configuredSlaDomainId: String
    """

    Supported in v5.0+
    Name of the SCVMM host.
    """
    hostname: String
    """

    Supported in v5.0+
    The RunAs account which will be used to install connector on hosts.
    """
    runAsAccount: String
    """

    Supported in v5.0+
    Flag to specify if Rubrik can deploy connector to hosts. If true, Rubrik tries to deploy connector to the hyperv hosts. If false, Rubrik deployment of connector will be handled by the client.
    """
    shouldDeployAgent: Boolean
}

"Supported in v5.0+"
input HypervUpdateMountConfigInput {
    """

    Required. Supported in v5.0+
    True to power on, false to power off.
    """
    powerStatus: Boolean!
}

input HypervVmRegisterAgentInput {
    "Required. ID of the Virtual Machine."
    id: String!
}

"Supported in v6.0+"
input InPlaceRecoveryJobConfigForBatchInput {
    """

    Required. Supported in v6.0+
    Configuration for in-place recovery.
    """
    config: InPlaceRecoveryJobConfigV2Input!
    """

    Supported in v6.0+
    Runs in-place recovery with the oldest snapshot taken after the specified date. This parameter is only evaluated when no values are set for snapshotId and snapshotBeforeDate.
    """
    snapshotAfterDate: DateTime
    """

    Supported in v6.0+
    Runs in-plance recovery with the most recent snapshot taken prior to the specified date. This parameter is only evaluated when no value is set for snapshotId.
    """
    snapshotBeforeDate: DateTime
    """

    Supported in v6.0+
    The ID of the snapshot to use for in-place recovery. This parameter is optional if either of the snapshotBeforeDate or snapshotAfterDate parameters is configured.
    """
    snapshotId: String
    """

    Required. Supported in v6.0+
    ID of the virtual machine to be recovered.
    """
    vmId: String!
}

"Supported in v5.3+"
input InPlaceRecoveryJobConfigV2Input {
    requiredRecoveryParameters: RequiredRecoveryParametersInput
    """

    Supported in v5.3+
    Indicates whether to keeep the vSphere snapshot on the vCenter Server after the in-place recovery or not. Use `true` to keep the snapshot after in-place recovery. Use `false` to delete the snapshot after in-place recovery. The default is `false`.
    """
    shouldKeepVsphereSnapshotAfterRecovery: Boolean
}

"Supported in v6.0+"
input IndicatorOfCompromiseInput {
    iocType: IndicatorOfCompromiseTypeEnum!
    """

    Required. Supported in v6.0+
    Type specific payload.
    """
    iocValue: String!
}

input InstantRecoveryJobConfig {
    baseConfig: AppBlueprintRestoreSnapshotJobConfigBase
    childrenToRestore: [AppBlueprintChildSnappableInstantRecoverySpec!] = []
    shouldRemoveChildrenFromAppBlueprint: Boolean = false
    shouldRemoveChildrenFromOtherAppBlueprints: Boolean = false
}

"Supported in v6.0+"
input InstantRecoveryJobConfigForBatchInput {
    """

    Required. Supported in v6.0+
    Configuration for snapshot export.
    """
    config: InstantRecoveryJobConfigV2Input!
    """

    Supported in v6.0+
    Mounts the oldest snapshot taken after the specified date. This parameter is only evaluated when no values are set for snapshotId and snapshotBeforeDate.
    """
    snapshotAfterDate: DateTime
    """

    Supported in v6.0+
    Mounts the most recent snapshot taken prior to the specified date. This parameter is only evaluated when no value is set for snapshotId.
    """
    snapshotBeforeDate: DateTime
    """

    Supported in v6.0+
    The ID of the snapshot to mount. This parameter is optional if either of the snapshotBeforeDate or snapshotAfterDate parameters is configured.
    """
    snapshotId: String
    """

    Required. Supported in v6.0+
    ID of the virtual machine whose snapshot needs to be mounted.
    """
    vmId: String!
}

"Supported in v5.1+"
input InstantRecoveryJobConfigV2Input {
    """

    Supported in v6.0+
    ID of the compute cluster where the new virtual machine will be mounted.
    """
    clusterId: String
    """

    Supported in v5.1+
    ID of the ESXi host to use for Instant Recovery.
    """
    hostId: String
    mountExportSnapshotJobCommonOptionsV2: MountExportSnapshotJobCommonOptionsV2Input
    """

    Supported in v5.1+
    A Boolean value that determines whether the MOID of the source virtual machine is preserved in a restore operation. When this value is 'true', the MOID of the source is preserved. When this value is 'false', the restored virtual machine is assigned a new MOID.
    """
    preserveMoid: Boolean
    requiredRecoveryParameters: RequiredRecoveryParametersInput
    """

    Supported in v6.0+
    ID of the resource pool where the new virtual machine will be mounted.
    """
    resourcePoolId: String
    """

    Supported in v5.1+
    A Boolean value that determines whether the job recovers the tags assigned to the virtual machine. When this value is 'true', the job recovers the tags. When this value is 'false', the job does not recover the tags.
    """
    shouldRecoverTags: Boolean
    """

    Supported in v6.0+
    The network binding for vNIC of the virtual machine.
    """
    vNicBindings: [VmwareVNicBindingInfoV2Input!] = []
    """

    Supported in v5.1+
    The preferred VLAN ID used by the VLAN ESXi host to mount the datastore.
    """
    vlan: Int
}

input InterfaceCidrInput {
    cidr: String = ""
    interfaceType: InterfaceTypeEnum = UNKNOWN_TYPE
    selected: Boolean = false
}

"Config of the k8s cluster to onboard."
input K8sClusterCreateInput {
    "The ID of the CDM cluster for ON_PREM k8s clusters."
    cdmClusterId: UUID
    "List of host IPs/hostnames of the k8s nodes."
    hostList: [String!]!
    "Name of the k8s cluster."
    name: String!
    "Port on the k8s node for the kupr Ingress Controller."
    port: Int!
    "Ports in the range of node port service range of the Kubernetes cluster."
    rbsPortRanges: [PortRange!]!
    "KuprClusterType of the k8s cluster."
    type: K8sClusterProtoType!
    "Node port ranges dedicated for export operations."
    userDrivenPortRanges: [PortRange!]
}

"Config of the kupr cluster to refresh."
input K8sClusterRefreshInput {
    "The ID of the kupr cluster to be refreshed."
    kuprClusterID: UUID!
}

"Config of the Kupr namespace snapshot to be restored and the target details."
input K8sNamespaceRestore {
    "Filter resources based on labels."
    labelSelector: LabelSelector
    "The UUID of the kupr namepspace snapshot to be restored."
    snapshotUUID: UUID!
    "The UUID of the target cluster to restore the namespace snapshot to."
    targetClusterUUID: UUID!
    "The name of the target namespace to restore the namespace snapshot to."
    targetNamespaceName: String!
}

"Configuration of the Kubernetes namespaces to be backed-up."
input K8sNamespaceSnapshot {
    "The ID of the kupr namespace managed object to snapshot."
    namespaceId: UUID!
    "The SLA ID of the on demand snapshot request."
    onDemandSnapshotSlaId: String
}

"Label filter parameters for GCP objects."
input LabelFilterParams {
    filterType: GcpNativeLabelFilterType!
    labelKey: String!
    labelValue: String!
}

"Label query over a set of K8's resources."
input LabelSelector {
    "List of label selector requirements. The requirements are ANDed."
    matchExpressions: [LabelSelectorRequirement!] = []
}

"Selector that contains values, a key, and an operator that relates the key and values."
input LabelSelectorRequirement {
    "Label key that the selector applies to."
    key: String = ""
    "Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist."
    operator: String = ""
    "Array of string values."
    values: [String!] = []
}

"DataType representing label key-value pair"
input LabelType {
    labelKey: String!
    labelValue: String!
    matchAllValues: Boolean!
}

"LDAP Server"
input LdapServerInput {
    "Hostname for the LDAP server."
    hostname: String = ""
    "Port used by the LDAP server."
    port: Int = 0
    "Whether the LDAP server uses TLS."
    useTls: Boolean = false
}

"Supported in v5.2+"
input LegalHoldDownloadConfigInput {
    """

    Required. Supported in v5.2+
    v5.2: Specifies whether the download action is in response to a Legal Hold. This download generates a SHA1 checksum of downloaded data that is used for integrity verification by external bodies.
    v5.3+: Specifies if the download action is in response to a Legal Hold. This download generates a SHA1 checksum of downloaded data that external bodies can use for integrity verification.
    """
    isLegalHoldDownload: Boolean!
}

"Legal Hold query filter."
input LegalHoldQueryFilter {
    "Filter after the specific time."
    afterTime: DateTime
    "Filter before the specific time."
    beforeTime: DateTime
    "Legal hold query filter field."
    filterFiled: LegalHoldQueryFilterField = UNKNOWN
    "Snappable name."
    snappableName: String = ""
    "Snappable type."
    snappableType: ManagedObjectType = O365_ORGANIZATION
    "Snapshot type."
    snapshotType: SnapshotTypeEnum = SCHEDULED
}

"Input to query snappables with legal hold snapshots."
input LegalHoldSnapshotsForSnappableInput {
    "Snappable cluster Uuid."
    clusterUuid: String!
    "Filter Parameters list."
    filterParams: [LegalHoldQueryFilter!]!
    "Snappable Id."
    snappableId: String!
    "Sorting Parameters."
    sortParam: LegalHoldSortParam
}

"Legal hold sorting parameters."
input LegalHoldSortParam {
    "Sort order."
    sortOrder: SortOrder = ASC
    "Sort type."
    type: LegalHoldSortType = UNKNOWN
}

input ListAccessGroupsFilterInput {
    groupName: String = ""
    userId: String = ""
}

input ListAccessUsersFilterInput {
    groupsIds: [String!] = []
    search: String = ""
    timeRange: UserTimeRangeInput!
}

input ListAccessUsersSortInput {
    sortBy: ListAccessUsersSortEnum = USERNAME
    sortOrder: SortOrder = ASC
}

input ListFileActivitiesInput {
    "The corresponding snappable's FID."
    snappableFid: String!
    "The datetime to collect user activity from."
    startDateTime: String!
    "The standardized path to fetch user activities for."
    stdPath: String!
    "The user's IANA timezone."
    timezone: String!
}

input ListFileResultFiltersInput {
    analyzerGroupIds: [String!] = []
    fileType: FileCountTypeEnum!
    searchText: String = ""
    snappablePaths: [SnappablePathInput!] = []
    snappableTypes: [String!] = []
    whitelistEnabled: Boolean = false
}

input ListMalwareScansInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
}

input ListObjectFilesFiltersInput {
    accessTypes: [AccessTypeEnum!] = []
    activityTypes: [ActivityAccessTypeEnum!] = []
    analyzerGroupIds: [String!] = []
    clusterIds: [String!] = []
    fileCountTypes: [FileCountTypeEnum!] = []
    inodeTypes: [InodeTypeEnum!] = []
    objectIds: [String!] = []
    objectTypes: [HierarchyObjectTypeEnum!]!
    openAccessTypes: [OpenAccessTypeEnum!] = []
    pathPrefix: String = ""
    searchText: String = ""
    snappableTypes: [String!] = []
    stalenessTypes: [StalenessTypeEnum!] = []
    whitelistEnabled: Boolean = false
}

"Location information."
input LocationInfo {
    "Id of the location."
    locationId: String = ""
    "Location type: CDM, AZURE, AWS, GCP."
    locationType: LocationType = UNKNOWN_TYPE
}

input LogConfig {
    slaLogFrequencyConfig: SlaLogFrequencyConfig
}

"Input for logging in."
input LoginCredentials {
    "Login."
    login: String!
    "Password for the login."
    password: String!
}

"Supported in v5.0+"
input LsnRecoveryPointInput {
    """

    Required. Supported in v5.0+
    LSN of the recovery point.
    """
    lsn: String!
    """

    Supported in v5.0+
    Recovery fork GUID of the recovery point. If not provided, the recovery fork GUID of the latest snapshot is used.
    """
    recoveryForkGuid: String
}

"Type representing the mailbox contents to be restored."
input MailboxRestoreConfig {
    RestoreConfigs: [RestoreObjectConfig!]!
    SnapshotUUID: UUID
}

"Supported in v6.0+"
input MalwareScanConfigInput {
    """

    Supported in v6.0+
    Criteria to restrict files to scan.
    """
    fileScanCriteria: MalwareScanFileCriteriaInput
    """

    Required. Supported in v6.0+
    List of IOCs to scan for.
    """
    indicatorsOfCompromise: [IndicatorOfCompromiseInput!]!
    """

    Supported in v6.0+
    Maximum number of matches per shapshot, per IOC.  Scanning for an Indicator Of Compromise within a snapshot will terminate once this many matches have been detected. Defaults to one.
    """
    maxMatchesPerSnapshot: Int
    """

    Supported in v6.0+
    Name of this scan.
    """
    name: String
    """

    Supported in v6.0+
    Notes to describe this scan.
    """
    notes: String
    """

    Required. Supported in v6.0+
    Snappable IDs to scan for malware.
    """
    objectIds: [String!]!
    """

    Supported in v6.0+
    Additional information required for files with malware matches.
    """
    requestedMatchDetails: RequestedMatchDetailsInput
    """

    Supported in v6.0+
    Specifies whether features that rely on the accuracy of filesystem metadata, like creation time and modification time of files, are enabled or not. These features include backend optimizations to skip re-scanning files that have not changed across snapshots, as indicated by the unchanged timestamps of files. This flag also gates access to some filters that can be specified in this API. Note that this flag should be used with caution, as relying on file timestamps may make the system vulnerable to adversarial techniques such as timestamp manipulation.
    """
    shouldTrustFilesystemTimeInfo: Boolean
    """

    Supported in v6.0+
    Limit which snapshots to include in the malware scan.
    """
    snapshotScanLimit: MalwareScanSnapshotLimitInput
}

"Supported in v6.0+"
input MalwareScanFileCriteriaInput {
    """

    Supported in v6.0+
    Specify the smallest and largest files to scan.
    """
    fileSizeLimits: MalwareScanFileSizeLimitsInput
    """

    Supported in v6.0+
    Specify limits around file creation and modification time. The top-level API field `shouldTrustFilesystemTimeInfo` must be set to true when this field is specified.
    """
    fileTimeLimits: MalwareScanFileTimeLimitsInput
    """

    Supported in v6.0+
    Please see /fileset_template for a detailed description of how includes, excludes, and exceptions are interpreted.
    """
    pathFilter: MalwareScanPathFilterInput
}

"Supported in v6.0+"
input MalwareScanFileSizeLimitsInput {
    """

    Supported in v6.0+
    Maximum size of files to scan. Files that are bigger than this size are ignored.
    """
    maximumSizeInBytes: Long
    """

    Supported in v6.0+
    Minimum size of files to scan. Files smaller than this size are ignored.
    """
    minimumSizeInBytes: Long
}

"Supported in v6.0+"
input MalwareScanFileTimeLimitsInput {
    """

    Supported in v6.0+
    Earliest file creation time.  Any files created before this time will be elided.
    """
    earliestCreationTime: DateTime
    """

    Supported in v6.0+
    Earliest file modification time.  Any files last modified before this time will be elided.
    """
    earliestModificationTime: DateTime
    """

    Supported in v6.0+
    Latest file creation time.  Any files created after this time will be elided.
    """
    latestCreationTime: DateTime
    """

    Supported in v6.0+
    Latest file modification time.  Any files modified after this time will be elided.
    """
    latestModificationTime: DateTime
}

"""

Supported in v6.0+
Please see v1/fileset_template API doc for a detailed description of how includes, excludes, & exceptions are interpreted.
"""
input MalwareScanPathFilterInput {
    """

    Supported in v6.0+
    Paths to exempt from exclusion.
    """
    exceptions: [String!] = []
    """

    Supported in v6.0+
    Paths to exclude.
    """
    excludes: [String!] = []
    """

    Supported in v6.0+
    Paths to include.
    """
    includes: [String!] = []
}

"Supported in v6.0+"
input MalwareScanSnapshotLimitInput {
    """

    Supported in v6.0+
    Maximum snapshot time.  Any snapshots taken after this time will be elided.
    """
    endTime: DateTime
    """

    Supported in v6.0+
    Maximum number of snapshots to scan per object.  The snapshots of each object are scanned in reverse chronological order, so this is equivalent to scan-last-n-snapshots.
    """
    maxSnapshotsPerObject: Int
    """

    Supported in v6.0+
    A array of object ID and list of snapshots of that object to scan. If this field is specified, none of the other `MalwareScanSnapshotLimit` fields may be specified.
    """
    snapshotsToScanPerObject: [ObjectIdToSnapshotIdsInput!] = []
    """

    Supported in v6.0+
    Minimum snapshot time.  Any snapshots taken before this time will be elided.
    """
    startTime: DateTime
}

"Specifies which Managed Disks are excluded from snapshots."
input ManagedDiskExclusion {
    "Specifies whether the Managed Disk is excluded from snapshots or not. When true, the Managed Disk will be excluded from the snapshot."
    isExcludedFromSnapshot: Boolean!
    "Rubrik ID of the Managed Disk."
    managedDiskRubrikId: UUID!
}

"Supported in v5.0+"
input ManagedVolumeConfigInput {
    applicationTag: ManagedVolumeApplicationTagEnum
    "Required. Supported in v5.0+"
    exportConfig: ManagedVolumeExportConfigInput!
    mvType: ManagedVolumeTypeEnum
    """

    Required. Supported in v5.0+
    Name of the managed volume.
    """
    name: String!
    """

    Supported in v5.0+
    v5.0-v7.0: Number of channels to divide the volume into. Each channel provides a unique share to write to.
    v8.0: Number of channels to divide the Managed Volume into. Each channel provides a unique share for writing.
    """
    numChannels: Int
    "Supported in v5.3+"
    slaClientConfig: SlaManagedVolumeClientConfigInput
    """

    Supported in v5.0+
    v5.0-v5.3: IP subnet that specifies an outgoing VLAN interface for a Rubrik node. This is a required value when creating a managed volume on a Rubrik node that has multiple VLAN interfaces
    v6.0-v7.0: IP subnet that specifies an outgoing VLAN interface for a Rubrik node. This is a required value when creating a managed volume on a Rubrik node that has multiple VLAN interfaces.
    v8.0: IP subnet specifing an outgoing VLAN interface for a Rubrik node. This is a required value when creating a Managed Volume on a Rubrik node that has multiple VLAN interfaces.
    """
    subnet: String
    """

    Required. Supported in v5.0+
    v5.0-v7.0: Maximum capacity for the volume across all the channels.
    v8.0: Maximum capacity for the Managed Volume across all channels.
    """
    volumeSize: Long!
}

"Supported in v5.0+"
input ManagedVolumeExportConfigInput {
    managedVolumePatchConfig: ManagedVolumePatchConfigInput
    shareType: ManagedVolumeShareTypeEnum
    """

    Supported in v5.0+
    v5.0-v7.0: IP subnet that specifies an outgoing VLAN interface for a Rubrik node. This is a required value when creating a managed volume on a Rubrik node that has multiple VLAN interfaces.
    v8.0: IP subnet specifing an outgoing VLAN interface for a Rubrik node. This is a required value when creating a Managed Volume on a Rubrik node that has multiple VLAN interfaces.
    """
    subnet: String
}

"Supported in v5.0+"
input ManagedVolumePatchConfigInput {
    """

    Supported in v5.0+
    v5.0-v5.3: List of host patterns. A host pattern describes a set of hosts who can mount the host. It can either be a host name, a network in CIDR notation or hostnames matching wildcards * or ?
    v6.0-v7.0: List of host patterns. A host pattern describes a set of hosts who can mount the host. It can either be a host name, a network in CIDR notation or hostnames matching wildcards * or ?.
    v8.0: List of host patterns. A host pattern describes a set of hosts that can mount the host. It can either be a host name, a network in CIDR notation or hostnames matching wildcards * or ?.
    """
    hostPatterns: [String!] = []
    """

    Supported in v5.0+
    v5.0-v7.0: List of node-ids to use for mounting this managed volume channels. Caller should specify at least one node per channel in the managed volume. If the nodeHint is not provided, system will randomly select a subset of nodes in cluster to mount the channels.
    v8.0: List of node-IDs to use for mounting the channels of this Managed Volume. Caller should specify at least one node per channel in the Managed Volume. If nodeHint is not provided, the system randomly selects a subset of Rubrik cluster nodes to mount the channels.
    """
    nodeHint: [String!] = []
    """

    Supported in v5.0+
    v5.0-v5.3: Valid Active Directory domain name for users accessing this managed volume over SMB
    v6.0-v7.0: Valid Active Directory domain name for users accessing this managed volume over SMB.
    v8.0: Valid Active Directory domain name for users accessing this Managed Volume over SMB.
    """
    smbDomainName: String
    """

    Supported in v5.0+
    v5.0-v5.3: List of valid SMB host IP addresses that can access the SMB share for this managed volume. This parameter is required when the value of shareType is SMB
    v6.0-v7.0: List of valid SMB host IP addresses that can access the SMB share for this managed volume. This parameter is required when the value of shareType is SMB.
    v8.0: List of valid SMB host IP addresses that can access the SMB share for this Managed Volume. This parameter is required when the value of shareType is SMB.
    """
    smbValidIps: [String!] = []
    """

    Supported in v5.0+
    v5.0-v5.3: List of valid usersnames in the domain that can access the SMB share for this managed volume. This parameter is required when the value of shareType is SMB
    v6.0-v7.0: List of valid usersnames in the domain that can access the SMB share for this managed volume. This parameter is required when the value of shareType is SMB.
    v8.0: List of valid usersnames in the domain that can access the SMB share for this Managed Volume. This parameter is required when the value of shareType is SMB.
    """
    smbValidUsers: [String!] = []
}

"Supported in v5.3+"
input ManagedVolumePatchSlaClientConfigInput {
    """

    Supported in v5.3+
    The full command with arguments to execute the main backup script that backs up data from the host.
    """
    backupScriptCommand: String
    """

    Supported in v5.3+
    An optional timeout for the main backup script in seconds. When this value is 0 or unspecified no timeout is used.
    """
    backupScriptTimeout: Long
    """

    Supported in v5.3+
    A list of mount paths where the host mounts individual channels for managed volumes.
    """
    channelHostMountPaths: [String!] = []
    """

    Supported in v5.3+
    The ID of the host that mounts the managed volume channels and where the backup scripts run.
    """
    clientHostId: String
    """

    Supported in v5.3+
    The full command with arguments to execute the optional post-backup script that runs after unsuccessful data backup.
    """
    postBackupScriptOnBackupFailureCommand: String
    """

    Supported in v5.3+
    An optional timeout for the post-backup script that runs after unsuccessful data backup in seconds. When this value is 0 or unspecified no timeout is used.
    """
    postBackupScriptOnBackupFailureTimeout: Long
    """

    Supported in v5.3+
    The full command with arguments to execute the optional post-backup script that runs after data backup is complete.
    """
    postBackupScriptOnBackupSuccessCommand: String
    """

    Supported in v5.3+
    An optional timeout for the post-backup script that runs after data backup is complete in seconds. When this value is 0 or unspecified no timeout is used.
    """
    postBackupScriptOnBackupSuccessTimeout: Long
    """

    Supported in v5.3+
    The full command with arguments to execute the optional pre-backup script that runs after data backup is complete.
    """
    preBackupScriptCommand: String
    """

    Supported in v5.3+
    An optional timeout for the pre-backup script in seconds. When this value is 0 or unspecified no timeout is used.
    """
    preBackupScriptTimeout: Long
    """

    Supported in v5.3+
    Specifies whether a failure of the pre-backup script halts the backup process.
    """
    shouldCancelBackupOnPreBackupScriptFailure: Boolean
    """

    Required. Supported in v5.3+
    Specifies whether to disable the execution of the optional post-backup script that runs after unsuccessful data backup.
    """
    shouldDisablePostBackupScriptOnBackupFailure: Boolean!
    """

    Required. Supported in v5.3+
    Specifies whether to disable the execution of the optional post-backup script that runs after data backup is complete.
    """
    shouldDisablePostBackupScriptOnBackupSuccess: Boolean!
    """

    Required. Supported in v5.3+
    Specifies whether to disable the execution of the optional pre-backup script.
    """
    shouldDisablePreBackupScript: Boolean!
    """

    Supported in v5.3+
    The name of the user that runs the scripts on the host.
    """
    username: String
}

"Supported in v5.0+"
input ManagedVolumeUpdateInput {
    "Supported in v5.0+"
    config: ManagedVolumePatchConfigInput
    """

    Supported in v5.0+
    v5.0-v5.1: Assign this managed volume to the given SLA domain.
    v5.2+: Assign this managed volume to the given SLA domain. Existing snapshots of the object will be retained with the configuration of specified SLA Domain.
    """
    configuredSlaDomainId: String
    """

    Supported in v5.0+
    Change the name of this managed volume.
    """
    name: String
    "Supported in v5.3+"
    slaClientConfig: ManagedVolumePatchSlaClientConfigInput
    """

    Supported in v5.3+
    Change the IP subnet that specifies an outgoing VLAN interface for a Rubrik node. This option is only available for SLA Managed Volumes.
    """
    subnet: String
    """

    Supported in v5.0+
    Increase capacity for the volume across all the channels.
    """
    volumeSize: Long
}

input ManualTargetMappingCreateRequest {
    archivalLocationClusterMappings: [TargetToClusterMapping!] = []
    name: String = ""
    type: TargetTypeEnum = AWS
}

input ManualTargetMappingEditRequest {
    archivalLocationClusterMappings: [TargetToClusterMapping!] = []
    id: String = ""
    name: String = ""
}

"Input for mapping Azure cloud accounts to an Exocompute subscription."
input MapAzureCloudAccountExocomputeSubscriptionInput {
    "Rubrik IDs of the cloud accounts to be mapped."
    cloudAccountIds: [UUID!]!
    "Rubrik ID of the Exocompute cloud account to map to for launching exocompute."
    exocomputeCloudAccountId: UUID!
}

"Input for mapping Azure cloud accounts to a persistent storage location."
input MapAzureCloudAccountToPersistentStorageLocationInput {
    "Type of native protection feature to be mapped to."
    azureNativeProtectionFeature: AzureNativeProtectionFeature!
    "Rubrik IDs of the cloud accounts to be mapped."
    cloudAccountIds: [UUID!]!
    "Rubrik ID of the storage account to be used for persistent storage location."
    persistentStorageId: UUID!
}

input MinuteSnapshotScheduleInput {
    basicSchedule: BasicSnapshotScheduleInput
}

input MissedSnapshotFilterInput {
    timeRange: TimeRangeInput
}

input ModifyMosaicStoreInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. Modify store request object with modified details of a store."
    modifyStoreData: MosaicModifyStoreRequestInput!
}

input MonthlySnapshotScheduleInput {
    basicSchedule: BasicSnapshotScheduleInput
    dayOfMonth: DayOfMonth = FIRST_DAY
}

"""

Supported in m3.2.0-m4.1.0
Object for stores added on mosaic.
"""
input MosaicAddStoreRequestInput {
    "Supported in m3.2.0-m4.1.0"
    accessKeyId: String
    "Supported in m3.2.0-m4.1.0"
    nfsServer: String
    "Supported in m3.2.0-m4.1.0"
    nfsServerMountPath: String
    "Supported in m3.2.0-m4.1.0"
    secretKey: String
    "Supported in m3.2.0-m4.1.0"
    skipKeyFileConfig: Boolean
    """

    Required. Supported in m3.2.0-m4.1.0
    Name of the store
    """
    storeName: String!
    storeType: MosaicAddStoreRequestStoreTypeEnum!
    """

    Required. Supported in m3.2.0-m4.1.0
    Store path/url.
    """
    storeUrl: String!
}

"Struct representing the store input for protection."
input MosaicBackupStoreInfoInput {
    "Name of the store."
    storeName: String = ""
}

"Supported in m3.2.0-m4.1.0"
input MosaicBulkRecoverableRangeRequestInput {
    """

    Required. Supported in m3.2.0-m4.1.0
    List of management objects
    """
    managementObjects: MosaicDatabaseManagementObjectInput!
    """

    Required. Supported in m3.2.0-m4.1.0
    Name of the source
    """
    sourceName: String!
    sourceType: MosaicBulkRecoverableRangeRequestSourceTypeEnum
}

input MosaicBulkRecoveryRangeInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. Retrieve Recoverable Range required for Restore operation"
    recoveryRangeData: MosaicBulkRecoverableRangeRequestInput!
}

"Supported in m3.2.0-m4.1.0"
input MosaicDatabaseManagementObjectInput {
    "Supported in m3.2.0-m4.1.0"
    databases: [MosaicDatabaseObjectInput!] = []
}

"Supported in m3.2.0-m4.1.0"
input MosaicDatabaseObjectInput {
    "Supported in m3.2.0-m4.1.0"
    dbName: String
    "Supported in m3.2.0-m4.1.0"
    tables: [String!] = []
}

"Supported in m3.2.0-m4.1.0"
input MosaicGetSchemaRequestInput {
    "Required. Supported in m3.2.0-m4.1.0"
    databaseName: String!
    "Required. Supported in m3.2.0-m4.1.0"
    sourceName: String!
    "Required. Supported in m3.2.0-m4.1.0"
    tableName: String!
    "Required. Supported in m3.2.0-m4.1.0"
    versionTimestamp: String!
}

"""

Supported in m3.2.0-m4.1.0
Object for stores added on mosaic.
"""
input MosaicModifyStoreRequestInput {
    "Supported in m3.2.0-m4.1.0"
    accessKeyId: String
    "Supported in m3.2.0-m4.1.0"
    secretKey: String
    "Supported in m3.2.0-m4.1.0"
    skipKeyFileConfig: Boolean
    """

    Required. Supported in m3.2.0-m4.1.0
    Name of the store
    """
    storeName: String!
}

"Struct representing the monitor input for protection."
input MosaicMonitorInfoInput {
    "Frequency of monitor."
    frequency: Int = 0
    "Frequency unit of monitor."
    frequencyUnit: RetentionUnitEnum = MINUTES
    "Whether to enable monitor."
    isEnabled: Boolean = false
}

"Supported in m3.2.0-m4.1.0"
input MosaicRecoverableRangeRequestInput {
    "Required. Supported in m3.2.0-m4.1.0"
    databaseName: String!
    "Required. Supported in m3.2.0-m4.1.0"
    sourceName: String!
    sourceType: MosaicRecoverableRangeRequestSourceTypeEnum
    "Required. Supported in m3.2.0-m4.1.0"
    tableName: String!
}

input MosaicRestoreDataInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. Retrieve Request Object with details required for Restore operation"
    recoveryData: MosaicRetrieveRequestInput!
}

"Supported in m3.2.0-m4.1.0"
input MosaicRetrieveRequestInput {
    "Supported in m3.2.0-m4.1.0"
    destinationManagementObjects: MosaicDatabaseManagementObjectInput
    "Required. Supported in m3.2.0-m4.1.0"
    destinationPath: String!
    "Supported in m3.2.0-m4.1.0"
    destinationSourceName: String
    "Supported in m3.2.0-m4.1.0"
    keyspaceConfig: String
    "Required. Supported in m3.2.0-m4.1.0"
    managementObjects: MosaicDatabaseManagementObjectInput!
    "Supported in m3.2.0-m4.1.0"
    maxDiskUsage: String
    "Required. Supported in m3.2.0-m4.1.0"
    parameterEncoded: Boolean!
    "Supported in m3.2.0-m4.1.0"
    restoreDbUserPwd: String
    "Supported in m3.2.0-m4.1.0"
    restoreDbUsername: String
    "Required. Supported in m3.2.0-m4.1.0"
    sourceName: String!
    sourceType: MosaicRetrieveRequestSourceTypeEnum
    "Supported in m3.2.0-m4.1.0"
    startTimestamp: Int
    "Supported in m3.2.0-m4.1.0"
    targetEncryptionKey: String
    "Supported in m3.2.0-m4.1.0"
    targetQuery: String
    "Required. Supported in m3.2.0-m4.1.0"
    versionTime: Int!
}

"Struct representing the protection backup input."
input MosaicSlaInfoInput {
    "Store information."
    mosaicBackupStoreInfo: MosaicBackupStoreInfoInput
    "Monitor information."
    mosaicMonitorInfo: MosaicMonitorInfoInput
    "Whether to backup table index."
    shouldBackupIndex: Boolean
    "Whether to delete all previous versions."
    shouldDelete: Boolean
    "Whether to delete data copy versions."
    shouldDeleteData: Boolean
}

"Represents the mosaic snapshot filter input."
input MosaicSnapshotFilterInput {
    "ID of the snappable."
    snappableId: [String!]
    "Range of time."
    timeRange: TimeRangeInput
}

"Input for MosaicStorageLocation Query Filter."
input MosaicStorageLocationFilterInput {
    "Field from which query should be filtered."
    field: MosaicStorageLocationFilterField = NAME
    "Value of field."
    text: String = ""
}

"Supported in v5.0+"
input MountExportSnapshotJobCommonOptionsInput {
    """

    Supported in v5.0+
    Sets the state of the network interfaces when the virtual machine is mounted or exported. Use 'false' to enable the network interfaces. Use 'true' to disable the network interfaces. Disabling the interfaces can prevent IP conflicts.
    """
    disableNetwork: Boolean
    """

    Supported in v5.0+
    Determines whether the MAC addresses of the network interfaces on the source virtual machine are assigned to the new virtual machine. Set to 'true' to assign the original MAC addresses to the new virtual machine. Set to 'false' to assign new MAC addresses. The default is 'false'. When removeNetworkDevices is set to true, this property is ignored.
    """
    keepMacAddresses: Boolean
    """

    Supported in v5.0+
    Determines whether the virtual machine should be powered on after mount or export. Set to 'true' to power on the virtual machine. Set to 'false' to mount or export the virtual machine but not power it on. The default is 'true'.
    """
    powerOn: Boolean
    """

    Supported in v5.0+
    Determines whether to remove the network interfaces from the mounted or exported virtual machine. Set to 'true' to remove all network interfaces. The default value is 'false'.
    """
    removeNetworkDevices: Boolean
    """

    Supported in v5.0+
    Name of the new VM created by mount or export.
    """
    vmName: String
}

"Supported in v5.1+"
input MountExportSnapshotJobCommonOptionsV2Input {
    """

    Supported in v5.1+
    Sets the state of the network interfaces when the virtual machine is mounted or exported. Use 'false' to enable the network interfaces. Use 'true' to disable the network interfaces. Disabling the interfaces can prevent IP conflicts.
    """
    disableNetwork: Boolean
    """

    Supported in v5.1+
    Determines whether the MAC addresses of the network interfaces on the source virtual machine are assigned to the new virtual machine. Set to 'true' to assign the original MAC addresses to the new virtual machine. Set to 'false' to assign new MAC addresses. The default is 'false'. When removeNetworkDevices is set to true, this property is ignored.
    """
    keepMacAddresses: Boolean
    """

    Supported in v5.1+
    Determines whether the virtual machine should be powered on after mount or export. Set to 'true' to power on the virtual machine. Set to 'false' to mount or export the virtual machine but not power it on. The default is 'true'.
    """
    powerOn: Boolean
    """

    Supported in v5.1+
    Determines whether to remove the network interfaces from the mounted or exported virtual machine. Set to 'true' to remove all network interfaces. The default value is 'false'.
    """
    removeNetworkDevices: Boolean
    """

    Supported in v5.1+
    Name of the new VM created by mount or export.
    """
    vmName: String
}

"Supported in v5.0+"
input MountMssqlDbConfigInput {
    """

    Required. Supported in v5.0+
    Name to assign to the mounted database.
    """
    mountedDatabaseName: String!
    recoveryModel: MssqlDatabaseRecoveryModelEnum
    "Required. Supported in v5.0+"
    recoveryPoint: MssqlRecoveryPointInput!
    """

    Supported in v5.0+
    ID of the SQL Server instance to mount the database on. For availability source databases, this must be specified. When unspecified for non-availability source databases, the source SQL Server instance is used.
    """
    targetInstanceId: String
}

"Supported in v5.0+"
input MountSnapshotJobConfigForBatchV1Input {
    """

    Required. Supported in v5.0+
    v5.0-v5.3: Snapshot mount config
    v6.0+: Configuration for Snapshot mount.
    """
    config: MountSnapshotJobConfigV1Input!
    """

    Supported in v5.0+
    Mounts the oldest snapshot taken after the specified date. This parameter is only evaluated when no values are set for snapshotId and snapshotBeforeDate.
    """
    snapshotAfterDate: DateTime
    """

    Supported in v5.0+
    v5.0-v5.3: Mounts the most recent snapshot prior to the specified date. This parameter is only evaluated when no value is set for snapshotId.
    v6.0+: Mounts the most recent snapshot taken prior to the specified date. This parameter is only evaluated when no value is set for snapshotId.
    """
    snapshotBeforeDate: DateTime
    """

    Supported in v5.0+
    v5.0-v5.3: ID of snapshot to mount. Optional. The snapshot to mount is determined from the other parameters in this call when the ID is not provided.
    v6.0+: The ID of the snapshot to export. This parameter is optional if either of the `snapshotBeforeDate` or `snapshotAfterDate` parameters is configured.
    """
    snapshotId: String
    """

    Required. Supported in v5.0+
    v5.0: Mount a snapshot from this virtual machine.
    v5.1-v5.3: Mount a snapshot from this virtual machine
    v6.0+: ID of the virtual machine whose snapshot needs to be mounted.
    """
    vmId: String!
}

"Supported in v6.0+"
input MountSnapshotJobConfigForBatchV2Input {
    """

    Required. Supported in v6.0+
    Snapshot mount configuration.
    """
    config: MountSnapshotJobConfigV2Input!
    """

    Supported in v6.0+
    Mounts the oldest snapshot taken after the specified date. This parameter is evaluated only snapshotId and snapshotBeforeDate. do not have values set.
    """
    snapshotAfterDate: DateTime
    """

    Supported in v6.0+
    Mounts the most recent snapshot taken prior to the specified date. This parameter is evaluated only when snapshotId does not have a value set.
    """
    snapshotBeforeDate: DateTime
    """

    Supported in v6.0+
    ID of the snapshot to mount. This parameter is optional if either the `snapshotBeforeDate` or `snapshotAfterDate` parameters are configured.
    """
    snapshotId: String
    """

    Required. Supported in v6.0+
    ID of the virtual machine whose snapshot must be mounted.
    """
    vmId: String!
    """

    Supported in v7.0+
    Prefix added to the name of new virtual machines created by the mount or export operation.
    """
    vmNamePrefix: String
}

"Supported in v5.0+"
input MountSnapshotJobConfigV1Input {
    """

    Supported in v5.0+
    The job creates a datastore that contains the VMDK, but does not create the corresponding virtual machine.
    """
    createDatastoreOnly: Boolean
    """

    Supported in v5.0+
    v5.0: Name of the host NAS datastore to use with the new virtual machine. The Rubrik cluster creates a new datastore on the host using the provided name.
    v5.1+: Obsolete parameter.
    """
    dataStoreName: String
    """

    Supported in v5.0+
    ID of the ESXi host to mount the new virtual machine on.
    """
    hostId: String
    mountExportSnapshotJobCommonOptions: MountExportSnapshotJobCommonOptionsInput
    """

    Supported in v5.0+
    The job recovers the tags that were assigned to the virtual machine.
    """
    shouldRecoverTags: Boolean
    """

    Supported in v5.0+
    VLAN ID for the VLAN ESXi host prefer to use for mounting the datastore.
    """
    vlan: Int
}

"Supported in v5.1+"
input MountSnapshotJobConfigV2Input {
    """

    Supported in v6.0+
    ID of the compute cluster where the new virtual machine will be mounted.
    """
    clusterId: String
    """

    Supported in v5.1+
    The job creates a datastore that contains the VMDK, but does not create the corresponding virtual machine.
    """
    createDatastoreOnly: Boolean
    """

    Supported in v5.1+
    Obsolete parameter.
    """
    dataStoreName: String
    """

    Supported in v5.1+
    ID of the ESXi host to mount the new virtual machine on.
    """
    hostId: String
    mountExportSnapshotJobCommonOptionsV2: MountExportSnapshotJobCommonOptionsV2Input
    requiredRecoveryParameters: RequiredRecoveryParametersInput
    """

    Supported in v6.0+
    ID of the resource pool where the new virtual machine will be mounted.
    """
    resourcePoolId: String
    """

    Supported in v5.1+
    The job recovers the tags that were assigned to the virtual machine.
    """
    shouldRecoverTags: Boolean
    """

    Supported in v6.0+
    The network binding for vNIC of the virtual machine.
    """
    vNicBindings: [VmwareVNicBindingInfoV2Input!] = []
    """

    Supported in v5.1+
    VLAN ID for the VLAN ESXi host preferred to use for mounting the datastore.
    """
    vlan: Int
}

"Supported in v5.0+"
input MssqlBackupJobConfigInput {
    baseOnDemandSnapshotConfig: BaseOnDemandSnapshotConfigInput
    """

    Supported in v5.0+
    Whether to force a full snapshot or an incremental.
    """
    forceFullSnapshot: Boolean
}

"Supported in v5.2+"
input MssqlBackupSelectionInput {
    backupType: MssqlBackupTypeEnum
    "Supported in v5.2+"
    endPoint: MssqlRecoveryPointInput
    """

    Supported in v5.2+
    v5.2: Optional. A Boolean that specifies whether the download is in response to a Legal Hold.
    v5.3+: Optional. A Boolean that specifies if the download is in response to a Legal Hold.
    """
    legalHoldDownloadConfig: LegalHoldDownloadConfigInput
    "Supported in v5.2+"
    recoveryPoint: MssqlRecoveryPointInput
    "Supported in v5.2+"
    startPoint: MssqlRecoveryPointInput
}

"Supported in v5.0+"
input MssqlBatchBackupJobConfigInput {
    """

    Supported in v5.0+
    v5.0-v5.2: IDs of the Microsoft SQL availability groups. All databases with a `rootId` belonging to this list will be considered.
    v5.3+: IDs of the Microsoft SQL availability groups. All databases with a `rootId` belonging to this list are considered for taking an on demand snapshot.
    """
    availabilityGroupIds: [String!] = []
    baseOnDemandSnapshotConfig: BaseOnDemandSnapshotConfigInput
    """

    Supported in v5.0+
    v5.0-v5.2: IDs of the Microsoft SQL databases. All databases in this list will be considered.
    v5.3+: IDs of the Microsoft SQL databases. All databases in this list are considered for taking an on demand snapshot.
    """
    databaseIds: [String!] = []
    """

    Supported in v5.0+
    v5.0-v5.2: Whether to force a full snapshot or an incremental.
    v5.3+: Determines whether to force a full or incremental snapshot.
    """
    forceFullSnapshot: Boolean
    """

    Supported in v5.0+
    v5.0-v5.2: IDs of the hosts. All databases with a `rootId` belonging to this list will be considered.
    v5.3+: IDs of the hosts. All databases with a `rootId` belonging to this list are considered for taking an on demand snapshot.
    """
    hostIds: [String!] = []
    """

    Supported in v5.0+
    v5.0-v5.2: IDs of the Microsoft SQL instances. All non-availability databases on these instances will be considered.
    v5.3+: IDs of the Microsoft SQL instances. All non-availability databases on these instances are considered for taking an on demand snapshot.
    """
    instanceIds: [String!] = []
    """

    Supported in v5.0+
    v5.0-v5.2: IDs of the Windows clusters. All databases with a `rootId` belonging to this list will be considered.
    v5.3+: IDs of the Windows clusters. All databases with a `rootId` belonging to this list are considered for taking an on demand snapshot.
    """
    windowsClusterIds: [String!] = []
}

"Input to configure the log settings for SQL Server database in an SLA Domain."
input MssqlConfigInput {
    "Frequency for log backups of SQL Server databases."
    frequency: SlaDurationInput
    "The duration for which the logs will be retained."
    logRetention: SlaDurationInput
}

"Filter Mssql database live mount results."
input MssqlDatabaseLiveMountFilterInput {
    "Type of filter."
    field: MssqlDatabaseLiveMountFilterField = MOUNTED_DATABASE_NAME
    "Values for the filter type."
    texts: [String!] = []
}

"Sort Mssql database live mount results."
input MssqlDatabaseLiveMountSortByInput {
    "Field for Mssql database sort by."
    field: MssqlDatabaseLiveMountSortByField = MOUNTED_DATABASE_NAME
    "Sort order for Mssql database sort by."
    sortOrder: MssqlDatabaseLiveMountSortOrderField = ASC
}

"Supported in v5.0+"
input MssqlDbDefaultsUpdateInput {
    """

    Supported in v5.0+
    v5.0-v5.2: True to enable CBT based backup, false to disable.
    v5.3+: True to enable a CBT-based backup, false to disable a CBT-based backup.
    """
    cbtStatus: Boolean
    "Supported in v5.0+"
    logBackupFrequencyInSeconds: Long
    "Supported in v5.3+"
    logRetentionTimeInHours: Int
    """

    Supported in v7.0+
    Use the default backup location configured in SQL Server for file-based log backups.
    """
    shouldUseDefaultBackupLocation: Boolean
}

"Supported in v5.0+"
input MssqlDbFileExportPathInput {
    """

    Required. Supported in v5.0+
    The target path for the database file.
    """
    exportPath: String!
    """

    Required. Supported in v5.0+
    Logical name of the database file.
    """
    logicalName: String!
    """

    Supported in v5.0+
    New filename for the database file.
    """
    newFilename: String
    """

    Supported in v5.0+
    New logical name for the database file.
    """
    newLogicalName: String
}

"Supported in v5.0+"
input MssqlDbUpdateIdInput {
    """

    Required. Supported in v5.0+
    ID of the Microsoft SQL database.
    """
    databaseId: String!
    "Required. Supported in v5.0+"
    updateProperties: MssqlDbUpdateInput!
}

"Supported in v5.0+"
input MssqlDbUpdateInput {
    """

    Supported in v5.0
    Assign DB to SLA Domain
    """
    configuredSlaDomainId: String
    """

    Supported in v5.2+
    Whether to pause or resume backups/archival for this database.
    """
    isPaused: Boolean
    """

    Supported in v5.0+
    Maximum number of parallel data streams that can be used to back up the database.
    """
    maxDataStreams: Int
    mssqlNonSlaProperties: MssqlNonSlaPropertiesInput
    mssqlSlaPatchProperties: MssqlSlaPatchPropertiesInput
    "Supported in v5.0+"
    postBackupScript: MssqlScriptDetailInput
    "Supported in v5.0+"
    preBackupScript: MssqlScriptDetailInput
    """

    Supported in v5.2+
    Determines whether to force a full for the next snapshot of a SQL Server database. When this value is true, the Rubrik cluster takes a full snapshot. This value is false by default and is reset to false after a successful full snapshot.
    """
    shouldForceFull: Boolean
}

"Supported in v5.2+"
input MssqlDownloadFromArchiveConfigInput {
    "Required. Supported in v5.2+"
    recoveryPoint: MssqlRecoveryPointInput!
}

input MssqlGetRestoreFilesV1Input {
    "Required. ID of the Microsoft SQL database."
    id: String!
    "LSN to recover to. This value or the time are required."
    lsn: String
    "Recovery fork GUID of LSN to recover to. Meaningful only when lsn is specified."
    recoveryForkGuid: String
    "Time, in ISO8601 date-time format, to recover to. For example, \"2016-01-01T01:23:45.678\". This value or the LSN are required."
    time: DateTime
}

"Supported in v5.0+"
input MssqlLogShippingCreateConfigInput {
    """

    Supported in v5.0+
    Maximum number of parallel data streams that can be used to copy data to the target system.
    """
    maxDataStreams: Int
    mssqlLogShippingTargetStateOptions: MssqlLogShippingTargetStateOptionsInput
    """

    Supported in v5.0+
    The path to the default target location for data file storage.
    """
    targetDataFilePath: String
    """

    Required. Supported in v5.0+
    The name of the secondary database.
    """
    targetDatabaseName: String!
    """

    Supported in v5.0+
    Array of database file storage paths. Each path is the target storage location for a database file. Values in this array override the values in targetDataFilePath and targetLogFilePath for the specified database files.
    """
    targetFilePaths: [MssqlDbFileExportPathInput!] = []
    """

    Required. Supported in v5.0+
    The ID of the SQL Server instance that hosts the secondary database.
    """
    targetInstanceId: String!
    """

    Supported in v5.0+
    The path to the location of the log files.
    """
    targetLogFilePath: String
}

"Supported in v5.3+"
input MssqlLogShippingCreateConfigV2Input {
    """

    Supported in v5.3+
    Maximum number of makeup reseed attempts during a 24 hour period.
    """
    makeupReseedLimit: Int
    mssqlLogShippingCreateConfig: MssqlLogShippingCreateConfigInput
}

"Supported in v5.0+"
input MssqlLogShippingReseedConfigInput {
    mssqlLogShippingTargetStateOptions: MssqlLogShippingTargetStateOptionsInput
}

"Filter Mssql log shipping target results."
input MssqlLogShippingTargetFilterInput {
    "Type of filter."
    field: MssqlLogShippingTargetFilterField = CLUSTER_UUID
    "Values for the filter type."
    texts: [String!] = []
}

"Sort Mssql log shipping target results."
input MssqlLogShippingTargetSortByInput {
    "Field for Mssql log shipping target sort by."
    field: MssqlLogShippingTargetSortByField = SECONDARY_NAME
    "Sort order for Mssql log shipping target sort by."
    sortOrder: SortOrder = ASC
}

"Supported in v5.0+"
input MssqlLogShippingTargetStateOptionsInput {
    """

    Supported in v5.0+
    v5.0-v5.2: Whether to automatically disconnect users from a secondary database in Standby mode when a restore operation is performed. If this value is false and users remain connected, then any scheduled restore operations will fail. If the "state" field is `RESTORING`, this value can be omitted and will otherwise be ignored.
    v5.3+: Specifies whether to automatically disconnect users from a secondary database in standby mode when a restore operation is performed. If this value is set to false and users remain connected, any scheduled restore operations fail. If the "state" field is `RESTORING`, this value can be omitted and is ignored.
    """
    shouldDisconnectStandbyUsers: Boolean
    state: MssqlLogShippingOkStateEnum!
}

"Supported in v5.3+"
input MssqlLogShippingUpdateV2Input {
    """

    Supported in v5.3+
    Maximum number of makeup reseed attempts during a 24 hour period.
    """
    makeupReseedLimit: Int
}

"Supported in v5.0"
input MssqlNonSlaPropertiesInput {
    """

    Supported in v5.0
    Boolean value that specifies whether or not to perform copy-only backups of the database. When true, database backups are copy-only backups. When false, database backups are full backups.
    """
    copyOnly: Boolean
    """

    Supported in v5.0
    Seconds between two log backups. A value of 0 disables log backup.
    """
    logBackupFrequencyInSeconds: Int
    """

    Supported in v5.0
    Number of hours to retain a log backup. When the value is set to -1 the Rubrik cluster retains the log backup until the database snapshots that precede the log backup have expired.
    """
    logRetentionHours: Int
}

"Supported in v5.0+"
input MssqlRecoveryPointInput {
    """

    Supported in v5.2+
    Recovery point specified in ISO8601 format, such as "2016-01-01T01:23:45.678".
    """
    date: DateTime
    "Supported in v5.0+"
    lsnPoint: LsnRecoveryPointInput
    """

    Supported in v5.0+
    v5.0-v5.1: Recovery point specified in the form of a timestamp (in milliseconds).
    v5.2+: Recovery point specified in the form of a timestamp (in milliseconds). Deprecated. Please use 'date' instead.
    """
    timestampMs: Long
}

input MssqlRestoreEstimateV1Input {
    "Required. ID of the Microsoft SQL database."
    id: String!
    "LSN to recover to. This value or the LSN are required."
    lsn: String
    "Recovery fork GUID of LSN to recover to. Meaningful only when lsn is specified."
    recoveryForkGuid: String
    "Time, in ISO8601 date-time format, to recover to. For example, \"2016-01-01T01:23:45.678\". This value or the LSN are required."
    time: DateTime
}

"Supported in v5.0+"
input MssqlScriptDetailInput {
    scriptErrorAction: ScriptErrorActionEnum!
    """

    Required. Supported in v5.0+
    The script to be run.
    """
    scriptPath: String!
    """

    Required. Supported in v5.0+
    Time (in ms) after which the script will be terminated if it has not completed.
    """
    timeoutMs: Long!
}

"Supported in v5.1+"
input MssqlSlaDomainAssignInfoInput {
    existingSnapshotRetention: ExistingSnapshotRetentionEnum
    """

    Required. Supported in v5.1+
    List of SQL Server object IDs which should be assigned these properties.
    """
    ids: [String!]!
    mssqlSlaPatchProperties: MssqlSlaPatchPropertiesInput
    """

    Supported in v7.0+
    A Boolean value indicating whether to retain existing snapshots of assigned objects with the specified SLA Domain configuration. The default value is 'true'. If objects are unprotected, existing snapshots are retained according to the value of the 'existingSnapshotRetention' parameter. For unprotected objects, this value is empty. When an SLA Domain assignment is cleared from an object, the retention strategy described by the 'existingSnapshotRetention' parameter is used only when the object can inherit a protection SLA Domain from an ancestor object.
    """
    shouldApplyToExistingSnapshots: Boolean
    """

    Supported in v7.0+
    A Boolean value. When true, specifies that the retention changes corresponding to the new SLA Domain are applied to non-policy snapshots in addition to existing policy-based snapshots.
    """
    shouldApplyToNonPolicySnapshots: Boolean
}

"Supported in v5.1+"
input MssqlSlaPatchPropertiesInput {
    """

    Supported in v5.1+
    v5.1: SLA Domain ID assigned to instance.
    v5.2+: SLA Domain ID assigned to instance. Existing snapshots of the instance will be retained with the configuration of specified SLA Domain.
    """
    configuredSlaDomainId: String
    mssqlSlaRelatedProperties: MssqlSlaRelatedPropertiesInput
    """

    Supported in v5.3+
    Determines whether to use the configured default value of log backup retention.
    """
    useConfiguredDefaultLogRetention: Boolean
}

"Supported in v5.1+"
input MssqlSlaRelatedPropertiesInput {
    """

    Supported in v5.1+
    Boolean value that specifies whether or not to perform copy-only backups of the database. When true, database backups are copy-only backups. When false, database backups are full backups.
    """
    copyOnly: Boolean
    """

    Supported in v7.0+
    A boolean value specifying whether the database obtains the log backup configurations from the SLA Domain.
    """
    hasLogConfigFromSla: Boolean
    """

    Supported in v5.1+
    Seconds between two log backups. A value of 0 disables log backup.
    """
    logBackupFrequencyInSeconds: Int
    """

    Supported in v5.1+
    Number of hours to retain a log backup. When the value is set to -1 the Rubrik cluster retains the log backup until the database snapshots that precede the log backup have expired.
    """
    logRetentionHours: Int
}

"Filter to return objects with a given substring in their name."
input NameSubstringFilter {
    nameSubstring: String!
}

"Supported in v7.0+"
input NasApiCredentialsInput {
    """

    Supported in v7.0+
    TLS certification to validate NAS server.
    """
    apiCertificate: String
    """

    Supported in v7.0+
    Password associated with the NAS API user account.
    """
    apiPassword: String
    """

    Supported in v7.0+
    Username to access the vendor-specific NAS API.
    """
    apiUsername: String
    """

    Supported in v7.0+
    The ID corresponding to the imported certificate.
    """
    certificateId: String
}

"Supported in v5.0+"
input NasConfigInput {
    """

    Supported in v5.0+
    TLS certification to validate NAS server.
    """
    apiCertificate: String
    """

    Supported in v5.0+
    API endpoint to access NAS API 'FLASHBLADE'.
    """
    apiEndpoint: String
    """

    Supported in v5.0+
    Hostname or IP used in the NAS API calls.
    """
    apiHostname: String
    """

    Supported in v5.0+
    v5.0-v5.3: Password to access NAS API 'ISILON/NETAPP'
    v6.0+: Password to access NAS vendor API.
    """
    apiPassword: String
    """

    Supported in v5.0+
    API token to access NAS API 'FLASHBLADE'.
    """
    apiToken: String
    """

    Supported in v5.0+
    v5.0-v5.3: Username to access NAS API 'ISILON/NETAPP'
    v6.0+: Username to access NAS vendor API.
    """
    apiUsername: String
    """

    Supported in v5.2+
    v5.2: A Boolean value that specifies whether Changelist is enabled on Isilon NAS share. When this value is 'true', metadata fetches during backup operations use the Isilon Changelist feature. The Changelist feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.
    v5.3+: Indicates if Changelist is enabled on Isilon NAS share. When this value is 'true', metadata fetches during backup operations use the Isilon Changelist feature. The Changelist feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.
    """
    isIsilonChangelistEnabled: Boolean
    """

    Supported in v5.2+
    v5.2: A Boolean value that specifies whether SnapDiff is enabled on NetApp NAS share. When this value is 'true', metadata fetches during backup operations use the NetApp SnapDiff feature. The SnapDiff feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.
    v5.3+: Indicates if SnapDiff is enabled on NetApp NAS share. When this value is 'true', metadata fetches during backup operations use the NetApp SnapDiff feature. The SnapDiff feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.
    """
    isNetAppSnapDiffEnabled: Boolean
    """

    Supported in v6.0+
    Indicates whether CFT (Change File Tracking) is enabled on the Nutanix NAS share. When this value is 'true', metadata fetches during backup operations use the Nutanix CFT feature. The CFT feature improves incremental backup performance by tracking the difference between two snapshots, reducing the metadata scanning time during a backup job.
    """
    isNutanixCftEnabled: Boolean
    """

    Supported in v5.3+
    Specifies whether shares on the NAS host are automatically discovered. When this value is 'true', Rubrik periodically (every 30 minutes by default) connects to the NAS host to discover NFS and SMB shares.
    """
    isShareAutoDiscoveryEnabled: Boolean
    """

    Supported in v5.1
    Control if snapdiff is enabled on Netapp NAS
    """
    isSnapdiffEnabled: Boolean
    """

    Required. Supported in v5.0+
    v5.0-v5.3: Type of NAS vendor 'ISILON/NETAPP/FLASHBLADE'
    v6.0+: Specifies the NAS vendor, which can be ISILON, NETAPP, FLASHBLADE, or NUTANIX.
    """
    vendorType: String!
    """

    Supported in v5.0+
    Name of the Isilon zone that data IP belongs to.
    """
    zoneName: String
}

"Supported in v7.0+"
input NasSystemRegisterInput {
    "Required. Supported in v7.0+"
    hostname: String!
    "Required. Supported in v7.0+"
    nasTmpApiCredentials: NasApiCredentialsInput!
    nasVendorType: NasVendorTypeEnum!
}

"Supported in v7.0+"
input NasSystemUpdateInput {
    """

    Supported in v7.0+
    The updated hostname of the NAS system.
    """
    hostname: String
    """

    Supported in v7.0+
    The updated API credentials of the NAS system.
    """
    nasApiCredentials: NasApiCredentialsInput
}

"Supported in v5.0+"
input NetworkThrottleScheduleSummaryInput {
    """

    Required. Supported in v5.0+
    Array of int32 values that represent the days of the week on which to apply a scheduled network throttle. The days of the week are represented from 1-7 with Sunday as 1.
    """
    daysOfWeek: [Int!]!
    """

    Required. Supported in v5.0+
    An int64 value that represents the end time for a scheduled network throttle. The end time should be an hour of the day in minutes. For example, 0, 12*60 and 24*60 are valid values.
    """
    endTime: Long!
    """

    Required. Supported in v5.0+
    An int64 value that represents the start time for a scheduled network throttle. The start time should be an hour of the day in minutes. For example, 0, 12*60 and 24*60 are valid values.
    """
    startTime: Long!
    """

    Required. Supported in v5.0+
    Network bandwidth throttle limit for a resource, in Mbps. The throttle limit is precise to two decimal places.
    """
    throttleLimit: Float!
}

"Supported in v5.0+"
input NetworkThrottleUpdateInput {
    """

    Supported in v5.0+
    Default throttle limit for a resource, in Mbps. The throttle limit is precise to two decimal places.
    """
    defaultThrottleLimit: Float
    """

    Supported in v5.0+
    Boolean value that determines whether a throttle limit is enabled. Set to true to enable the throttle limit, or set to false to disable the throttle limit.
    """
    isEnabled: Boolean
    """

    Supported in v5.2+
    The network interface where outgoing traffic is throttled.
    """
    networkInterface: String
    """

    Supported in v5.0+
    An array containing all of the scheduled throttle limits for a specified resource.
    """
    scheduledThrottles: [NetworkThrottleScheduleSummaryInput!] = []
}

"new compute config"
input NewComputeConfig {
    securityGroupName: String = ""
    subnetName: String = ""
    vnetName: String = ""
}

"new storage account config"
input NewStorageAccountConfig {
    name: String = ""
    sku: StorageAccountSku = STANDARD_LRS
    tier: StorageAccountTier = COOL
}

input NfsTargetCreateRequest {
    clusterUuid: UUID!
    destinationFolder: String!
    encryptionPassword: String
    exportDir: String!
    fileLockPeriodInSeconds: Int!
    host: String!
    isConsolidationEnabled: Boolean!
    name: String!
    nfsAuthType: AuthTypeEnum!
    nfsVersion: Int
    otherNfsOptions: String
}

input NfsTargetEditRequest {
    exportDir: String
    fileLockPeriodInSeconds: Int
    host: String
    id: UUID!
    isConsolidationEnabled: Boolean
    name: String
    nfsAuthType: AuthTypeEnum
}

"Input required for providing node config details for registration."
input NodeRegistrationConfigsInput {
    "Capacity of the cluster."
    capacity: String = ""
    "Cluster UUID."
    clusterUuid: String = ""
    "Node id."
    id: String = ""
    "Entitlement status of the node."
    isEntitled: Boolean = false
    "Manufacture time of node."
    manufactureTime: DateTime
    "Platform type."
    platform: String = ""
    "Node serial number."
    serial: String = ""
    "System uuid of node."
    systemUuid: String = ""
    "Teleport token of node."
    teleportToken: String = ""
}

"Supported in v5.0+"
input NtpServerConfigurationInput {
    """

    Required. Supported in v5.0+
    Name or IP address of the NTP server.
    """
    server: String!
    "Supported in v5.0+"
    symmetricKey: NtpSymmKeyConfigurationInput
}

"Supported in v5.0+"
input NtpSymmKeyConfigurationInput {
    """

    Required. Supported in v5.0+
    Symmetric key (asci or hex format).
    """
    key: String!
    """

    Required. Supported in v5.0+
    Symmetric key id.
    """
    keyId: Int!
    """

    Required. Supported in v5.0+
    Symmetric key type (e.g., MD5, SHA1).
    """
    keyType: String!
}

"Supported in v5.0+"
input NutanixClusterConfigInput {
    """

    Required. Supported in v5.0+
    Concatenated X.509 certificates in Base64 encoded DER format. Each certificate must start with -----BEGIN CERTIFICATE----- and end with -----END CERTIFICATE-----.
    """
    caCerts: String!
    """

    Required. Supported in v5.0+
    Address for the Prism host. Any Prism Element or Prism central host will do. We will use the highly available IP, if set, and this address, if not, to communicate with the cluster.
    """
    hostname: String!
    """

    Required. Supported in v5.0+
    The UUID of the Nutanix cluster being added. This is required because Prism Central may manage multiple clusters, and we need to differentiate between them.
    """
    nutanixClusterUuid: String!
    "Required. Supported in v5.0+"
    password: String!
    "Required. Supported in v5.0+"
    username: String!
}

"Supported in v5.0+"
input NutanixClusterPatchInput {
    """

    Supported in v5.0+
    Concatenated X.509 certificates in Base64 encoded DER format. Each certificate must start with -----BEGIN CERTIFICATE----- and end with -----END CERTIFICATE-----.
    """
    caCerts: String
    """

    Supported in v5.0+
    v5.0-v5.1: ID of the SLA Domain that is configured for this Nutanix Cluster.
    v5.2+: ID of the SLA Domain that is configured for this Nutanix Cluster. Existing snapshots of the object will be retained with the configuration of specified SLA Domain.
    """
    configuredSlaDomainId: String
    """

    Supported in v5.0+
    Address for the Prism host. Any Prism Element or Prism central host will do. We will use the highly available IP, if set, and this address, if not, to communicate with the cluster.
    """
    hostname: String
    "Supported in v5.0+"
    password: String
    "Supported in v5.0+"
    username: String
}

"Supported in v5.0+"
input NutanixDownloadFilesJobConfigInput {
    """

    Supported in v5.2+
    An optional argument containing a Boolean parameter to depict if the download is being triggered for Legal Hold use case.
    """
    legalHoldDownloadConfig: LegalHoldDownloadConfigInput
    """

    Required. Supported in v5.0+
    An array containing the full source path of each file and folder that is part of the download job. The array must contain at least one path. When the source is a Windows virtual machine, the paths must all be on the same disk.
    """
    paths: [String!]!
}

"Filter Nutanix VM live mount results."
input NutanixLiveMountFilterInput {
    "Type of filter."
    field: NutanixLiveMountFilterField = FIELD_UNSPECIFIED
    "Values for the filter type."
    texts: [String!] = []
}

"Sort Nutanix VM live mounts results."
input NutanixLiveMountSortByInput {
    "Field for Nutanix VM live mounts sort by."
    field: NutanixLiveMountSortByField = FIELD_UNSPECIFIED
    "Sort order for Nutanix VM live mounts sort by."
    sortOrder: SortOrder = ASC
}

input NutanixMissedSnapshotsInput {
    "Required. ID of the vm."
    id: String!
}

"Supported in v6.0+"
input NutanixPatchVmMountConfigInput {
    """

    Required. Supported in v6.0+
    Specifies whether to power on the mounted virtual machine. When set to true, the virtual machine will be powered on. When set to false, the virtual machine will be powered off.
    """
    shouldPowerOn: Boolean!
}

"Supported in v5.0+"
input NutanixRestoreFileConfigInput {
    """

    Required. Supported in v5.0+
    Absolute file path.
    """
    path: String!
    """

    Required. Supported in v5.0+
    Target folder for the copied files.
    """
    restorePath: String!
}

"Supported in v5.0+"
input NutanixRestoreFilesConfigInput {
    """

    Required. Supported in v5.0+
    Directory of folder to copy files into.
    """
    restoreConfig: [NutanixRestoreFileConfigInput!]!
}

"Supported in v6.0+"
input NutanixVirtualMachineScriptDetailInput {
    failureHandling: NutanixVirtualMachineScriptDetailFailureHandlingEnum!
    """

    Required. Supported in v6.0+
    The command to be run in VM guest OS.
    """
    scriptPath: String!
    """

    Required. Supported in v6.0+
    Time (in ms) after which the script will be terminated if it has not completed.
    """
    timeoutMs: Long!
}

"Supported in v5.0+"
input NutanixVmExportSnapshotJobConfigInput {
    """

    Required. Supported in v5.0+
    The natural ID of the container that will store the export VM's disks.
    """
    containerNaturalId: String!
    """

    Supported in v5.0+
    The ID of the Nutanix cluster to export to. If not specified, we will default to the VM's cluster.
    """
    nutanixClusterId: String
    """

    Supported in v5.0+
    Whether the VM should be powered on after export. Default value is true.
    """
    powerOn: Boolean
    """

    Supported in v5.0+
    Determines whether to remove the network interfaces from the exported virtual machine. Set to 'true' to remove all network interfaces. The default value is 'false'. If 'false' the export job will attempt to add nics that were both present at snapshot time and connected to networks that are still present on the target cluster.
    """
    removeNetworkDevices: Boolean
    """

    Supported in v5.0+
    name of the new VM for export.
    """
    vmName: String
}

"Supported in v6.0+"
input NutanixVmMountSnapshotJobConfigInput {
    """

    Supported in v6.0+
    The natural ID of the container that will store the disks of the mounted virtual machine when migration is selected.
    """
    containerNaturalId: String
    """

    Supported in v6.0+
    ID of the Nutanix cluster to mount the new virtual machine to. Default value is the ID of the Nutanix cluster that hosts the source virtual machine of the snapshot.
    """
    nutanixClusterId: String
    """

    Required. Supported in v6.0+
    Specifies whether the migration option should be disabled for the live mount. When set to true, the Rubrik cluster will serve as the external repository for the mounted virtual machine, and storage migration to the Nutanix cluster will be disabled. When set to false, a storage container on the Nutanix cluster must be specified, and a storage migration otion will be available for the live mount when it succeeds.
    """
    shouldDisableMigration: Boolean!
    """

    Supported in v6.0+
    Specifies whether to trigger migration immediately when the Live Mount succeeds.
    """
    shouldMigrateImmediately: Boolean
    """

    Supported in v6.0+
    Specifies whether the virtual machine should be powered on after the Live Mount. Default value is true.
    """
    shouldPowerOn: Boolean
    """

    Supported in v6.0+
    Specifies whether to remove network configuration on the new virtual machine. Default value is false.
    """
    shouldRemoveNetwork: Boolean
    """

    Supported in v6.0+
    The target network on the newly mounted virtual machine if network configuration is not removed.
    """
    targetNetwork: String
    """

    Supported in v6.0+
    Name of the newly mounted virtual machine.
    """
    vmName: String
}

"Supported in v5.0+"
input NutanixVmPatchInput {
    """

    Supported in v5.0+
    v5.0-v5.1: Assign this VM to the given SLA domain.
    v5.2+: Assign this VM to the given SLA domain. Existing snapshots of the object will be retained with the configuration of specified SLA Domain.
    """
    configuredSlaDomainId: String
    """

    Supported in v5.0+
    A list of virtual disks IDs to exclude from the backup for this virtual machine.
    """
    excludedDiskIds: [String!] = []
    """

    Supported in v5.0+
    Whether backup/archival/replication is paused for this VM.
    """
    isPaused: Boolean
    "Supported in v6.0+"
    postBackupScript: NutanixVirtualMachineScriptDetailInput
    "Supported in v6.0+"
    postSnapScript: NutanixVirtualMachineScriptDetailInput
    "Supported in v6.0+"
    preBackupScript: NutanixVirtualMachineScriptDetailInput
    snapshotConsistencyMandate: NutanixSnapshotConsistencyMandateEnum
}

input NutanixVmRegisterAgentInput {
    "Required. ID of the Virtual Machine."
    id: String!
}

"Channel object consisting naturalId and name"
input O365TeamConvChannelInput {
    folderId: String!
    name: String!
    naturalId: String!
}

"Supported in v6.0+"
input ObjectIdToSnapshotIdsInput {
    """

    Required. Supported in v6.0+
    Object ID.
    """
    id: String!
    """

    Required. Supported in v6.0+
    Snapshot IDs.
    """
    snapshots: [String!]!
}

input ObjectIdsForHierarchyTypeInput {
    objectIds: [String!]!
    snappableType: SnappableLevelHierarchyTypeEnum!
}

input ObjectSpecificConfigsInput {
    awsRdsConfigInput: AwsRdsConfigInput
    "Input to configure the SLA Domain for Azure SQL Database DB."
    azureSqlDatabaseDbConfigInput: AzureSqlDatabaseDbConfigInput
    "Input to configure the SLA Domain for Azure SQL Managed Instance DB."
    azureSqlManagedInstanceDbConfigInput: AzureSqlManagedInstanceDbConfigInput
    "Input to configure the SLA Domain for Db2 database."
    db2ConfigInput: Db2ConfigInput
    "Input to configure the SLA Domain for SQL Server database."
    mssqlConfigInput: MssqlConfigInput
    "Input to configure the SLA Domain for Oracle database."
    oracleConfigInput: OracleConfigInput
    sapHanaConfigInput: SapHanaConfigInput
    vmwareVmConfigInput: VmwareVmConfigInput
}

"Supported in v7.0+"
input ObjectStoreAccessInput {
    """

    Supported in v7.0+
    Specifies whether SSL is enabled for the SnapMirrorCloud cloud target.
    """
    isSslEnabled: Boolean
    """

    Supported in v7.0+
    The URL of the object server for the cloud target.
    """
    objectServerUrl: String
    """

    Supported in v7.0+
    The type of provider for the cloud target.
    """
    providerType: String
    """

    Supported in v7.0+
    Specifies whether to use an HTTP proxy to connect to the SnapMirrorCloud cloud target.
    """
    shouldUseHttpProxy: Boolean
}

input OldRestorePathPairInput {
    path: String = ""
    restorePath: String = ""
}

"Parameters for onedrive file or folder search"
input OnedriveSearchFilter {
    channelFolderName: String
    channelId: String
    channelNameKeyword: String
    createTime: TimeRangeFilter
    excludeItemsUnderRoot: Boolean
    modifiedTime: TimeRangeFilter
    searchKeywordFilter: OnedriveSearchKeywordFilter
    searchObjectFilter: OnedriveSearchObjectFilter
}

"Onedrive search keyword and keyword type"
input OnedriveSearchKeywordFilter {
    keywordType: OnedriveSearchKeywordType = NAME
    searchKeyword: String = ""
}

"Onedrive search object type"
input OnedriveSearchObjectFilter {
    searchObjectType: OnedriveSearchObjectType = O365_FOLDER
}

"Supported in v5.0+"
input OracleBackupJobConfigInput {
    baseOnDemandSnapshotConfig: BaseOnDemandSnapshotConfigInput
    """

    Supported in v5.0+
    Boolean value that indicates whether to force a full snapshot for the specified Oracle database object. Set to true to force a full snapshot. Set to false to allow the Rubrik cluster to determine the type of snapshot required.
    """
    forceFullSnapshot: Boolean
}

"Supported in v5.2+"
input OracleBulkUpdateInput {
    """

    Required. Supported in v5.2+
    An array containing the IDs assigned to Oracle host, Oracle RAC, and Oracle Database objects.
    """
    ids: [String!]!
    oracleUpdate: OracleUpdateInput
}

"Input to configure the log settings for Oracle database in an SLA Domain."
input OracleConfigInput {
    "Frequency for log backups of Oracle databases."
    frequency: SlaDurationInput
    "The duration for which the archived redo logs will be retained."
    hostLogRetention: SlaDurationInput
    "The duration for which the logs will be retained."
    logRetention: SlaDurationInput
}

"Supported in v6.0+"
input OracleDataGuardGroupUpdateInput {
    oracleUpdateCommon: OracleUpdateCommonInput
    """

    Supported in v6.0+
    Ordered list of database unique names to use for backup.
    """
    preferredDgMemberUniqueNames: [String!] = []
    """

    Supported in v6.0+
    Value that indicates whether to backup from the PRIMARY member only, or from any available member.
    """
    shouldBackupFromPrimaryOnly: Boolean
}

"Supported in v5.0+"
input OracleNodeOrderInput {
    """

    Required. Supported in v5.0+
    Nodename of the Oracle RAC node.
    """
    nodeName: String!
    """

    Required. Supported in v5.0+
    Order in which Rubrik uses this node for automated Oracle backup.
    """
    order: Int!
}

"Supported in v6.0+"
input OracleUpdateCommonInput {
    """

    Supported in v7.0+
    Boolean value specifying whether the database obtains the log backup configurations from the SLA Domain.
    """
    hasLogConfigFromSla: Boolean
    """

    Supported in v6.0+
    Specifies an interval in hours. For Oracle archived redo log files whose nextTime is before (now - interval), the next log snapshot job will delete them from the host. Set to 0 for inheriting the value from its parent; -1 for immediate deletion; and -2 to skip log deletion.
    """
    hostLogRetentionHours: Int
    """

    Supported in v6.0+
    Path where the NFS share is mounted on the host.
    """
    hostMount: String
    """

    Supported in v6.0+
    Specifies an interval in minutes. This interval is the period between successive log backups.
    """
    logBackupFrequencyInMinutes: Int
    """

    Supported in v6.0+
    Specifies an interval in hours. Log backups are retained for the duration of the interval.
    """
    logRetentionHours: Int
    """

    Supported in v6.0+
    Number of channels used to backup the Oracle database.
    """
    numChannels: Int
}

"Supported in v5.0+"
input OracleUpdateInput {
    """

    Supported in v5.0-v5.1
    ID of the SLA Domain protecting the specified Oracle object.
    """
    configuredSlaDomainId: String
    """

    Supported in v6.0+
    ID of the SLA domain protecting the specified Oracle object. Log backup jobs are no longer scheduled if the SLA domain indicates the Oracle object is unprotected. The specified SLA domain is not used to configure the protection or retention for this Oracle object. This is a DEPRECATED field, and will be removed in later releases.
    """
    configuredSlaDomainIdDeprecated: String
    """

    Supported in v5.2-v5.3
    Specifies an interval in hours. For Oracle archived redo log files whose nextTime is before (now - interval), the next log snapshot job will delete them from the host. Set to 0 for inheriting the value from its parent; -1 for immediate deletion; and -2 to skip log deletion.
    """
    hostLogRetentionHours: Int
    """

    Supported in v5.0-v5.3
    Path where the NFS share is mounted on the host.
    """
    hostMount: String
    """

    Supported in v5.0-v5.3
    Specifies an interval in minutes. This interval is the period between successive log backups.
    """
    logBackupFrequencyInMinutes: Int
    """

    Supported in v5.0-v5.3
    Specifies an interval in hours. Log backups are retained for the duration of the interval.
    """
    logRetentionHours: Int
    """

    Supported in v6.0+
    Specifies an order for the RAC nodes. Automated Oracle backups use the RAC nodes in the specified order.
    """
    nodeOrder: [OracleNodeOrderInput!] = []
    """

    Supported in v5.0-v5.3
    Number of channels used to backup the Oracle database.
    """
    numChannels: Int
    oracleUpdateCommon: OracleUpdateCommonInput
    """

    Supported in v6.0+
    Boolean value that specifies whether the Rubrik cluster should automatically distribute backups across Oracle database instances running on the RAC nodes. By default, backups are run from the first connected node in the RAC priority order.
    """
    shouldDistributeBackupsAutomatically: Boolean
}

"Input to update authentication server-based AWS cloud account."
input PatchAwsAuthenticationServerBasedCloudAccountInput {
    "Authentication server's CA certificate to be updated for authentication server-based AWS cloud account."
    authServerCaCertId: AwsAuthServerCertificateIdInput
    "Authentication server's user client certificate to be updated for the authentication server-based AWS cloud account."
    authServerUserClientCertId: AwsAuthServerCertificateIdInput
    "Rubrik ID for the AWS cloud account."
    awsCloudAccountId: String!
    "Regions to be updated for the authentication server-based AWS cloud account."
    awsRegions: AwsAuthServerRegionsInput
    "Native protection feature to be updated."
    feature: CloudAccountFeature!
    "Name of the role created on the authentication server for the user account to be used by Rubrik."
    roleName: AwsAuthServerRoleNameInput
}

"Input to update IAM user-based AWS cloud account."
input PatchAwsIamUserBasedCloudAccountInput {
    "Rubrik ID for the AWS cloud account."
    awsCloudAccountId: String!
    "List of AWS Regions."
    awsRegions: AwsRegionsInput
    "AWS role ARN for native protection."
    awsRoleArn: AwsRoleArnInput
    "AWS IAM user access/secret keys."
    awsUserKeys: AwsUserKeysInput
    "Native protection feature to be updated."
    feature: CloudAccountFeature!
}

input PatchNutanixClusterInput {
    "Required. ID of the Nutanix cluster."
    id: String!
    "Required. Object containing updated Nutanix cluster information."
    patchProperties: NutanixClusterPatchInput!
}

input PatchNutanixVmInput {
    "Required. ID of Nutanix Virtual Machine."
    id: String!
    "Required. Properties to patch."
    vmPatchProperties: NutanixVmPatchInput!
}

input PatchNutanixVmMountInput {
    "Required. Configuration for updating the power status of the Live Mount."
    config: NutanixPatchVmMountConfigInput!
    "Required. ID of the Live Mount."
    id: String!
}

input PatchVolumeGroupInput {
    "Required. The ID of Volume Group."
    id: String!
    "Required. Properties to update for this Volume Group."
    patchProperties: VolumeGroupPatchInput!
}

input PauseSlaRequest {
    "List of Cluster Uuids."
    clusterUuids: [String!] = []
    "Whether or not to pause SLA."
    pauseSla: Boolean = false
    "Global SLA ID."
    slaId: String = ""
}

"Supported in v5.2+"
input PendingSlaOperationsRequestInput {
    """

    Required. Supported in v5.2+
    List of object IDs to use when retrieving pending SLA Domain assignments.
    """
    objectIds: [String!]!
}

input PermissionInput {
    objectsForHierarchyTypes: [ObjectIdsForHierarchyTypeInput!]!
    operation: OperationEnum!
}

"The data which represents indicator of compromise: a file path/pattern, hash, or YARA rule."
input PolarisIndicatorOfCompromiseInput {
    """

    The hash type to compute, required if the ioc type is hash. Unused.
    TODO(SPARK-106446) - remove before going GA.
    """
    hashType: HashTypeEnum
    "IOC kind that represents this input."
    iocKind: IndicatorOfCompromiseKind
    """

    IOC type that represents this input. Unused, unreleased field. Do not use.
    TODO(SPARK-106446) - remove before going GA.
    """
    iocType: IndicatorOfCompromiseTypeEnum
    "IOC value as a string."
    iocValue: String = ""
}

input PolarisSnapshotFilterInput {
    isOnDemandSnapshot: Boolean
    snappableId: [String!]
    timeRange: TimeRangeInput
}

input PolarisSnapshotFilterNewInput {
    field: FieldEnum = ALL
    texts: [String!] = []
}

"Range of ports that are allowed to be accessed."
input PortRange {
    "The maximum port in the port range."
    portMax: Int = 0
    "The minimum port in the port range."
    portMin: Int = 0
}

input PostBackupScriptInputType {
    failureHandling: String
    scriptPath: String
    timeoutInMs: Long
}

input PostSnapScriptInputType {
    failureHandling: String
    scriptPath: String
    timeoutInMs: Long
}

input PreBackupScriptInputType {
    failureHandling: String
    scriptPath: String
    timeoutInMs: Long
}

"Input to initiate deletion of AWS cloud account."
input PrepareAwsCloudAccountDeletionInput {
    "Rubrik ID of account to be deleted."
    cloudAccountId: UUID!
    "Protection feature to be deleted for the cloud account."
    feature: CloudAccountFeature!
}

"Input to prepare feature update for AWS cloud account."
input PrepareFeatureUpdateForAwsCloudAccountInput {
    "AWS account ID."
    cloudAccountId: UUID!
    "List of features to be updated for the AWS account."
    features: [CloudAccountFeature!]!
}

input PreviewerClusterConfigInput {
    clusterId: String = ""
    enabled: Boolean = false
}

"Input for promoting reader archival location."
input PromoteReaderTargetInput {
    "Id of the reader archival location to be promoted."
    locationId: String = ""
    "Refresh reader location before promoting to owner."
    refreshBeforePromote: Boolean = false
}

input ProxySettingsInput {
    password: String = ""
    portNumber: Int = 0
    protocol: String = ""
    proxyServer: String = ""
    username: String = ""
}

"Config which indicates which files and snapshots to quarantine."
input QuarantineSpecInput {
    "Files which need to be quarantined."
    filesDetails: [FileDetailsInput!]!
    "Id of the snapshot."
    snapshotId: String!
}

input QuarterlySnapshotScheduleInput {
    basicSchedule: BasicSnapshotScheduleInput
    dayOfQuarter: DayOfQuarter = FIRST_DAY
    quarterStartMonth: Month = JANUARY
}

input QueryGuestCredentialInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
}

input QueryHypervHostInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Filter by ID of effective SLA domain."
    effectiveSlaDomainId: String
    "Limit the number of matches returned."
    limit: Int
    "Search vm by vm name."
    name: String
    "Ignore these many matches in the beginning."
    offset: Int
    "Filter by primary cluster ID, or **local**."
    primaryClusterId: String
    slaAssignment: InternalQueryHypervHostRequestSlaAssignmentEnum
    sortBy: InternalQueryHypervHostRequestSortByEnum
    sortOrder: InternalQueryHypervHostRequestSortOrderEnum
}

input QueryStorageArraysInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
}

input QueryUnmanagedObjectSnapshotsV1Input {
    "Filter all the snapshots after a date."
    afterDate: DateTime
    "Filter all the snapshots before a date."
    beforeDate: DateTime
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. ID of a object."
    id: String!
    "Limit the number of matches returned."
    limit: Int
    "Ignore these many matches in the beginning."
    offset: Int
    "Search snapshot by date and time."
    searchValue: String
    snapshotType: V1QueryUnmanagedObjectSnapshotsV1RequestSnapshotTypeEnum
    sortBy: V1QueryUnmanagedObjectSnapshotsV1RequestSortByEnum
    sortOrder: V1QueryUnmanagedObjectSnapshotsV1RequestSortOrderEnum
}

"Filter ransomware result data."
input RansomwareResultFilterInput {
    clusterUuid: [UUID!]
    endTime: DateTime
    isEncrypted: Boolean
    managedId: [String!]
    startTime: DateTime
}

"Input for creating RCS locations"
input RcsAzureTargetMappingCreateRequest {
    "List of Rubrik cluster UUIDs."
    clusterUuidList: [String!]
    "Immutability lock period in days."
    lockDurationDays: Long!
    "Name of RCS location"
    name: String!
    "Region for RCS location"
    region: RcsRegionEnumType!
    "RSA key for RCS location"
    rsaKey: String!
    "Tier for RCS location"
    tier: RcsTierEnumType!
}

"Input for getting RCS azure archival locations consumption stats."
input RcsConsumptionStatsInput {
    "Input for enable forecasting of consumption stats."
    doForecasting: Boolean
    "Input of Polaris archival location identifiers for getting consumption stats."
    locationIds: [UUID!]!
    "Input of metric of which consumption stats are required."
    metricName: RcsConsumptionMetricNameType!
}

input RcsTargetCreateRequest {
    clusterUuid: UUID!
    instanceType: InstanceTypeEnum!
    "Immutability lock period in days."
    lockDurationDays: Long!
    name: String!
    region: RcsRegionEnumType!
    rsaKey: String!
    spaceUsageAlertThreshold: Int!
    tier: RcsTierEnumType!
}

input RcsTargetEditRequest {
    id: UUID!
    name: String
    spaceUsageAlertThreshold: Int
}

input RecoverHypervVirtualMachineSnapshotInput {
    "Required. Configuration for the instant recover request."
    config: HypervInstantRecoveryJobConfigInput!
    "Required. ID of Snapshot."
    id: String!
}

"Recovery Plan Blueprint information."
input RecoveryPlanBlueprintInfoInput {
    "Blueprint IDs."
    blueprintId: String = ""
    "Boot priority."
    bootPriority: Int = 0
    "Target location information."
    targetLocationInfo: RecoveryPlanLocationInfoInput
}

"Recovery Plan configuration."
input RecoveryPlanConfigInput {
    "Blueprints information."
    blueprintsInfo: [RecoveryPlanBlueprintInfoInput!] = []
    "Boot priority delay in seconds."
    bootPriorityDelaySeconds: [Int!] = []
}

"Recovery Plan failover job configuration."
input RecoveryPlanFailoverJobConfig {
    "Blueprint failover job configurations."
    blueprintFailoverJobConfigs: [BlueprintRecoveryPlanJobConfig!] = []
    "Continue Recovery Plan failover on blueprint error."
    continueRpFailoverOnBlueprintError: Boolean = false
    "Recovery Plan failover type."
    recoveryPlanFailoverType: RecoveryPlanFailoverType = UNKNOWN_RP_TYPE
    "Recovery Plan ID."
    recoveryPlanId: String = ""
    "Recovery Plan operation."
    recoveryPlanOperation: RecoveryPlanOperationType = UNKNOWN_OPERATION
}

"Recovery Plan location information."
input RecoveryPlanLocationInfoInput {
    "Location ID."
    locationId: String = ""
    "Location type."
    locationType: RecoveryPlanLocationType = LOCATION_TYPE_UNKNOWN
}

input RefreshHypervHostInput {
    "Required. ID of the Hyper-V host."
    id: String!
}

input RefreshOracleDbInput {
    "Required. ID of the Oracle database."
    id: String!
}

"Input for refreshing reader archival location."
input RefreshReaderTargetInput {
    "Id of the reader archival location to be refreshed."
    locationId: String = ""
}

input RegisterNasSystemInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. Registration definition for a NAS system. This contains parameters needed to protect the NAS system such as a hostname or the cluster management IP address, and login credentials to access the system."
    nasSystem: NasSystemRegisterInput!
}

"Supported in v7.0+"
input RelationshipCreateInput {
    """

    Supported in v7.0+
    Properties required to access the object store (cloud target) for the SnapMirrorCloud object.
    """
    objectStoreAccess: ObjectStoreAccessInput
    """

    Required. Supported in v7.0+
    ID of SnapMirror Cloud protected object.
    """
    snapMirrorCloudId: String!
}

input RelativeTimeRangeInput {
    magnitude: Int!
    unit: TimeUnitEnum!
}

"Filter to return objects which are relic or not."
input RelicFilter {
    relic: Boolean!
}

"Inventory workloads to remove from an account."
input RemoveInventoryWorkloadsInput {
    "List of Inventory Cards."
    inventoryCards: [InventoryCard!]!
}

"Filter for replication pairs request."
input ReplicationPairsQueryFilter {
    "Rubrik cluster name."
    clusterName: String = ""
    "Source Rubrik cluster uuids."
    sourceClusterUuids: [String!] = []
    "Connection status of the replication pair."
    status: [ReplicationPairConnectionStatus!] = []
    "Target Rubrik cluster uuids."
    targetClusterUuids: [String!] = []
}

input ReplicationSpecInput {
    replicationType: ReplicationTypeEnum = UNKNOWN_REPLICATION_TYPE
    specificReplicationSpecInput: SpecificReplicationSpecInput
}

input ReplicationSpecV2Input {
    awsAccount: String = ""
    awsRegion: AwsNativeRegionForReplication
    azureRegion: AzureNativeRegionForReplication
    azureSubscription: String = ""
    "Cascading Archival Specifications."
    cascadingArchivalSpecs: [CascadingArchivalSpecInput!] = []
    clusterUuid: String = ""
    "Time snapshot is kept on local target cluster."
    replicationLocalRetentionDuration: SlaDurationInput
    retentionDuration: SlaDurationInput
    storageSettingId: String = ""
}

input ReplicationToCloudLocationSpecInput {
    cloudProvider: CloudProvider = AWS
    replicationTargetId: String = ""
    retentionDuration: SlaDurationInput
}

input ReplicationToCloudRegionSpecInput {
    cloudProvider: CloudProvider = AWS
    replicationTargetRegion: String = ""
    retention: Int = 0
    retentionUnit: RetentionUnitEnum = MINUTES
}

"Create configs for a snappable data chart."
input ReportChartCreate {
    "The metrics focus of the chart."
    focus: ReportFocusEnum!
    groupBy: [GroupByFieldEnum!]
    "The name of the chart."
    name: String!
}

input ReportConfigInput {
    aggregations: [String!]!
    "Column selection for the report"
    columns: [String!]!
    "Type of report"
    dataViewType: DataViewTypeEnum!
    "Filter selection for the report"
    filters: [ReportFilterInput!]!
    "GroupBy selection for the report"
    groupBy: ConfigGroupByInput!
    "Report name"
    name: String!
    sortBy: String!
    sortOrder: SortOrderEnum
}

input ReportFilterInput {
    name: String!
    "values are JSON serialized string of the original value"
    values: [String]!
}

"Create configs for an activity data table."
input ReportTableCreate {
    focus: ReportFocusEnum!
    groupBy: [GroupByFieldEnum!]
    "The name of the table."
    name: String!
    selectedColumns: [ReportTableColumnEnum!]!
    sortBy: SortByFieldEnum
    "The data sorting order for the table, Asc or Des."
    sortOrder: SortOrderEnum
}

"Supported in v6.0+"
input RequestedMatchDetailsInput {
    requestedHashTypes: [HashTypeEnum!]
}

"Supported in v5.1+"
input RequiredRecoveryParametersInput {
    """

    Supported in v5.1+
    Point in time to recover to.
    """
    recoveryPoint: DateTime
    """

    Supported in v5.1+
    ID of the snapshot to recover.
    """
    snapshotId: String
}

input ReseedSecondaryInput {
    "Required. Configuration parameters for the reseed operation."
    config: MssqlLogShippingReseedConfigInput!
    "Required. ID of the log shipping configuration object for the specified secondary database."
    id: String!
}

input ResourceInput {
    snappableFid: String = ""
    snapshotFid: String = ""
}

input RestoreConfig {
    deltaTypeFilter: [DeltaTypeEnum!] = []
    domainName: String = ""
    nextSnapshotFid: String = ""
    password: String = ""
    restoreFilesConfig: [RestoreFileConfig!] = []
    shouldIgnoreErrors: Boolean = false
    shouldRestoreXAttrs: Boolean
    shouldSaveCredentials: Boolean = false
    shouldUseAgent: Boolean
    username: String = ""
}

input RestoreFileConfig {
    path: String = ""
    restorePath: String = ""
}

"Supported in v5.0+"
input RestoreFilesJobConfigInput {
    """

    Supported in v5.1+
    Managed ID of the destination object that the files should be recovered to.
    """
    destObjectId: String
    """

    Supported in v5.0+
    Domain name (Use . for local admin).
    """
    domainName: String
    """

    Supported in v5.0+
    v5.0: Optional field to determine whether to ignore errors during restore jobs that use the Rubrik Backup Service. Default value is false, errors are not ignored.
    v5.1+: Optional Boolean field to determine whether to ignore errors during restore jobs that use the Rubrik Backup Service. When 'true', errors are ignored. Default value is 'false', errors are not ignored.
    """
    ignoreErrors: Boolean
    """

    Supported in v5.0+
    Password.
    """
    password: String
    """

    Required. Supported in v5.0+
    Absolute file path and restore path if not restored back to itself.
    """
    restoreConfig: [VmRestorePathPairInput!]!
    """

    Supported in v5.1+
    Boolean value that determines restore file settings for Linux systems and for Windows systems. For Linux, use 'true' to include the extended attributes of restored files. For Windows, use 'true' to include alternate data streams for restored files. For both, use 'false' to exclude this additional metadata.
    """
    shouldRestoreXAttrs: Boolean
    """

    Supported in v5.0+
    v5.0: Whether we should save the user-entered credentials
    v5.1+: A Boolean value that specifies whether to save the user-entered credentials. When 'true', the user-entered credentials are saved.
    """
    shouldSaveCredentials: Boolean
    """

    Supported in v5.1+
    A Boolean that specifies whether to use the Rubrik Backup Service or VMware tools to restore files. When 'true', the RBS restores files. When 'false',the VMware tools restores files.
    """
    shouldUseAgent: Boolean
    """

    Supported in v5.0+
    Username.
    """
    username: String
}

input RestoreHypervVirtualMachineSnapshotFilesInput {
    "Required. Configuration for a job to restore files from a snapshot."
    config: HypervRestoreFilesConfigInput!
    "Required. ID assigned to a snapshot."
    id: String!
}

"Supported in v5.0+"
input RestoreMssqlDbJobConfigInput {
    """

    Supported in v5.0+
    A Boolean value that determines the recovery option to use during database restore. When this value is 'true', the database is restored using the RECOVERY option and is fully functional at the end of the restore operation. When this value is 'false', the database is restored using the NORECOVERY option and remains in recovering mode at the end of the restore operation.
    """
    finishRecovery: Boolean
    """

    Supported in v5.0+
    Maximum number of parallel data streams that can be used to copy data to the target system.
    """
    maxDataStreams: Int
    "Required. Supported in v5.0+"
    recoveryPoint: MssqlRecoveryPointInput!
}

input RestoreNutanixVmSnapshotFilesInput {
    "Required. Configuration for a job to restore files to a source Nutanix virtual machine."
    config: NutanixRestoreFilesConfigInput!
    "Required. ID of snapshot."
    id: String!
}

"Config for O365 mailbox restore"
input RestoreO365MailboxInput {
    "Polaris id of the mailbox."
    mailboxUUID: UUID!
    "Polaris ID of O365 subscription."
    orgUuid: UUID
    "Configuration for restore job."
    restoreConfigs: [RestoreObjectConfig!]!
    "Polaris id of restoring snapshot."
    snapshotUUID: UUID
}

"Config for the mailbox object (email/folder) to be restored"
input RestoreObjectConfig {
    EmailID: String
    FolderID: String
    SnapshotUUID: UUID!
}

"Supported in v5.0+"
input RestorePathPairInput {
    """

    Required. Supported in v5.0+
    Original file path to be restored.
    """
    path: String!
    """

    Supported in v5.0+
    Directory of the folder to copy files into. If this is empty, file will be restored back into original directory.
    """
    restorePath: String
}

input RestoreVolumeGroupSnapshotFilesInput {
    "Required. Configuration containing snapshot file paths and restore path."
    config: VolumeGroupRestoreFilesConfigInput!
    "Required. ID of snapshot."
    id: String!
}

input RunCustomAnalyzerInput {
    content: String = ""
    dictionaryCsv: String = ""
    regex: String = ""
}

input RunDetectMalwareInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. Configuration for malware detection."
    malwareScanConfig: MalwareScanConfigInput!
}

input S3CompatibleTargetCreateInput {
    accessKey: String!
    bucketPrefix: String!
    clusterUuid: UUID!
    encryptionKeyInDer: String!
    endpoint: String!
    isConsolidationEnabled: Boolean!
    name: String!
    numberOfBuckets: Int!
    secretKey: String!
    useSystemProxy: Boolean!
}

input S3CompatibleTargetEditInput {
    accessKey: String
    endpoint: String
    id: UUID!
    isConsolidationEnabled: Boolean
    name: String
    numberOfBuckets: Int
    secretKey: String
    useSystemProxy: Boolean
}

input SLAAuditDetailFilterInput {
    field: SLAAuditDetailFilterFieldEnum = USER_NAME
    text: String = ""
}

input SapHanaConfigInput {
    differentialFrequency: SlaDurationInput
    incrementalFrequency: SlaDurationInput
    logRetention: SlaDurationInput
}

"Filter Sap Hana log snapshots."
input SapHanaLogSnapshotFilterInput {
    clusterUuid: [UUID!]
    fromTime: DateTime
    isArchived: Boolean
    snappableId: [String!]
    toTime: DateTime
}

"Filter Sap Hana recoverable ranges."
input SapHanaRecoverableRangeFilterInput {
    clusterUuid: [UUID!]
    databaseId: [String!]
    fromTime: DateTime
    isArchived: Boolean
    toTime: DateTime
}

"Supported in v5.3+"
input SapHanaSslInfoInput {
    """

    Supported in v7.0+
    Library path for SAP HANA crypto library (libsapcrypto.so).
    """
    cryptoLibPath: String
    encryptionProvider: SapHanaSslInfoEncryptionProviderEnum!
    """

    Supported in v7.0+
    Override the hostname used to verify the server's identity.
    """
    hostNameInCertificate: String
    """

    Required. Supported in v5.3+
    The path where the encryption key for the SAP HANA system is stored.
    """
    keyStorePath: String!
    """

    Supported in v7.0+
    Specifies whether to encrypt the database connection using SSL/TLS.
    """
    shouldEncrypt: Boolean
    """

    Supported in v7.0+
    Specifies whether to validate the SSL certificate of the SAP HANA DB server.
    """
    shouldValidateCertificate: Boolean
    """

    Supported in v7.0+
    Path to a trust store file that contains the public certificates of the SAP HANA DB server.
    """
    trustStorePath: String
}

"Supported in v5.3+"
input SapHanaSystemConfigInput {
    """

    Supported in v6.0+
    Data path details of the SAP HANA system.
    """
    dataPathSpec: SapHanaSystemDataPathSpecInput
    """

    Required. Supported in v5.3+
    The SAP HANA system hosts.
    """
    hostIds: [String!]!
    """

    Required. Supported in v5.3+
    The instance number of the SAP HANA system.
    """
    instanceNumber: String!
    """

    Required. Supported in v5.3+
    The password of the SAP HANA system.
    """
    password: String!
    """

    Required. Supported in v5.3+
    The SAP System Identification (SID) code for the SAP HANA system.
    """
    sid: String!
    """

    Supported in v7.0+
    Information required to connect to SAP HANA database over SSL.
    """
    sslInfo: SapHanaSslInfoInput
    """

    Required. Supported in v5.3+
    The username of the SAP HANA system.
    """
    username: String!
}

"Supported in v6.0+"
input SapHanaSystemDataPathSpecInput {
    dataPathType: SapHanaDataPathTypeEnum
}

"Supported in v5.3+"
input SapHanaSystemPatchInput {
    """

    Supported in v5.3+
    The ID of the SLA Domain that is configured for the SAP HANA system.
    """
    configuredSlaDomainId: String
    """

    Supported in v5.3+
    The SAP HANA system hosts.
    """
    hostIds: [String!] = []
    """

    Supported in v5.3+
    The instance number of the SAP HANA system.
    """
    instanceNumber: String
    """

    Supported in v5.3+
    The password of the SAP HANA system.
    """
    password: String
    """

    Supported in v5.3+
    The SAP System Identification (SID) code for the SAP HANA system.
    """
    sid: String
    """

    Supported in v7.0+
    Information required to connect to SAP HANA database over SSL.
    """
    sslInfo: SapHanaSslInfoInput
    """

    Supported in v5.3+
    The username of the SAP HANA system.
    """
    username: String
}

input ScheduledReportCreate {
    creatorId: String
    dailyTime: LocalTime
    hasCSVAttachment: Boolean!
    hasPDFAttachment: Boolean!
    monthlyDate: Int
    monthlyTime: LocalTime
    recipients: [String!]!
    "Chart configs for the report."
    reportId: Int!
    title: String!
    weeklyDays: [WeekDayEnum!]
    weeklyTime: LocalTime
}

"Filters for the scheduled report list"
input ScheduledReportFilterInput {
    reportId: Int
}

"Parameters for mail or folder search"
input SearchFilter {
    emailAddresses: [EmailAddressFilter!] = []
    fromTime: DateTime
    searchKeywordFilter: SearchKeywordFilter
    searchObjectFilter: SearchObjectFilter
    untilTime: DateTime
}

"Search keyword and keyword type"
input SearchKeywordFilter {
    keywordType: SearchKeywordType = SUBJECT
    searchKeyword: String = ""
}

input SearchNutanixVmInput {
    "Pagination cursor returned by the previous request."
    cursor: String
    "Required. ID of the vm."
    id: String!
    "Maximum number of entries in the response."
    limit: Int
    "Required. The path query. Either path prefix or filename prefix."
    path: String!
}

"Search object type"
input SearchObjectFilter {
    searchObjectType: SearchObjectType = FOLDER
}

input SearchSnapMirrorCloudInput {
    "Pagination cursor returned by the previous request."
    cursor: String
    "Required. The Rubrik ID of the SnapMirrorCloud to search."
    id: String!
    "Maximum number of entries in the response."
    limit: Int
    "Required. The path query. Either path prefix or filename prefix."
    path: String!
}

"Input for setting the app credentials in the Azure Cloud Accounts."
input SetAzureCloudAccountCustomerAppCredentialsInput {
    "Client ID of the Application."
    appId: String!
    "Name of the application."
    appName: String
    "Client secret key of the Application."
    appSecretKey: String!
    "ID of the home tenant of the application."
    appTenantId: String
    "Type of Azure Tenant. Possible values: Azure Public Cloud, Azure China Cloud."
    azureCloudType: AzureCloudType! = AZUREPUBLICCLOUD
    "Domain Name of the Azure tenant."
    tenantDomainName: String
}

"MFA settings to update for a LDAP integration."
input SetLdapMfaSettingInput {
    "Optional boolean value indicating whether TOTP is enforced for the given LDAP integration. If omitted, existing value of the setting is kept."
    isTotpEnforced: Boolean
    "ID of the LDAP integration."
    ldapId: String = ""
}

"MFA settings to update for an account."
input SetMfaSettingInput {
    "Optional boolean value indicating whether TOTP is globally enforced. If omitted, existing value of the setting is kept."
    isTotpEnforcedGlobal: Boolean
    "Optional integer value indicating the time of remembering the MFA login in hours. If omitted, existing value of the setting is kept."
    mfaRememberHours: Int
    "Optional integer value indicating the period of showing TOTP configuration reminder in hours. If omitted, existing value of the setting is kept."
    totpReminderHours: Int
}

input SetTotpConfigInput {
    "TOTP one-time password."
    otp: String = ""
    "TOTP secret for setting up TOTP as 2FA."
    secret: String = ""
    userId: String = ""
}

input SetUserLevelTotpEnforcementInput {
    "Indicate if TOTP is enforced at user level."
    isEnforced: Boolean = false
    "Users for whom TOTP is enforced."
    userIds: [String!] = []
}

"Input for SetWwwTlsCert."
input SetWwwTlsCertInputType {
    "ID of certificate."
    certificateId: Long = 0
}

"Input required to setup backups."
input SetupCloudNativeSqlServerBackupInput {
    "Credentials for the admin in the databases."
    adminCredentials: LoginCredentials!
    "Rubrik IDs of the SQL Server databases."
    databaseIds: [UUID!]!
}

"Struct representing the sharepoint doc lib contents to be restored"
input SharePointDriveRestoreConfig {
    DocLibName: String
    DriveRestoreConfig: DriveRestoreConfig!
    ParentSiteUUID: UUID
}

"Struct representing the SharePoint list item to be restored."
input SharePointListItem {
    "Id of item to restore."
    itemId: String!
    "Name of item to restore."
    itemName: String!
    "List of snapshots of this item to restore."
    itemSnapshotsToRestore: [SharePointListItemSnapshot!]!
}

"Struct representing the SharePoint list item snapshot to be restored."
input SharePointListItemSnapshot {
    "Id to snapshot to restore."
    snapshotId: UUID!
    "Number of snapshot to restore."
    snapshotNum: Int!
}

"Struct representing the sharepoint list contents to be restored."
input SharePointListRestoreConfig {
    "List of list folders to restore."
    foldersToRestore: [FolderInfo!]!
    "List of list items to restore."
    itemsToRestore: [SharePointListItem!]!
    "Destination list name."
    listName: String
    "Destination site id."
    parentSiteUuid: UUID
    "Path within destination list to restore to."
    restoreFolderPath: String!
}

input ShouldApplyToExistingSnapshots {
    value: Boolean = false
}

input ShouldApplyToNonPolicySnapshots {
    value: Boolean = false
}

input SlaDurationInput {
    duration: Int = 0
    unit: RetentionUnitEnum = MINUTES
}

input SlaLogFrequencyConfig {
    retention: SlaDurationInput
}

"Supported in v5.3+"
input SlaManagedVolumeClientConfigInput {
    """

    Required. Supported in v5.3+
    Specifies configuration information for the main backup script that backs up data from the host.
    """
    backupScript: SlaManagedVolumeScriptConfigInput!
    """

    Required. Supported in v5.3+
    v5.3-v7.0: A list of mount paths where the host mounts individual channels for managed volumes.
    v8.0: A list of mount paths where the host mounts individual channels for Managed Volumes.
    """
    channelHostMountPaths: [String!]!
    """

    Required. Supported in v5.3+
    v5.3-v7.0: The ID of the host that mounts the managed volume channels and where the backup scripts run.
    v8.0: The ID of the host that mounts the Managed Volume channels and location where the backup scripts are run.
    """
    clientHostId: String!
    """

    Supported in v5.3+
    v5.3-v7.0: Specifies configuration information for the optional post-backup script that runs after data backup failed.
    v8.0: Specifies configuration information for the optional post-backup script that runs if data backup fails.
    """
    postBackupScriptOnBackupFailure: SlaManagedVolumeScriptConfigInput
    """

    Supported in v5.3+
    v5.3-v7.0: Specifies configuration information for the optional post-backup script that runs after data backup is complete.
    v8.0: Specifies configuration information for the optional post-backup script that runs after data backup completes.
    """
    postBackupScriptOnBackupSuccess: SlaManagedVolumeScriptConfigInput
    """

    Supported in v5.3+
    Specifies configuration information for the optional pre-backup script that runs before data backup begins.
    """
    preBackupScript: SlaManagedVolumeScriptConfigInput
    """

    Supported in v5.3+
    Specifies whether a failure of the pre-backup script halts the backup process.
    """
    shouldCancelBackupOnPreBackupScriptFailure: Boolean
    """

    Required. Supported in v5.3+
    v5.3-v7.0: The name of the user that runs the scripts on the host.
    v8.0: Name of the user running the scripts on the host.
    """
    username: String!
}

"Supported in v5.3+"
input SlaManagedVolumeScriptConfigInput {
    """

    Required. Supported in v5.3+
    v5.3-v7.0: The full command with arguments to execute the script.
    v8.0: The full command, with arguments, to execute the script.
    """
    scriptCommand: String!
    """

    Supported in v5.3+
    v5.3-v7.0: An optional timeout for the script in seconds. When this value is 0 or unspecified no timeout is used.
    v8.0: Optional timeout, in seconds, for the script. When this value is 0 or unspecified, the script does not use a timeout.
    """
    timeout: Long
}

"Filter for SlaStatus."
input SlaStatusFilterInput {
    "Field for SLA Status Filter."
    field: SlaStatusFilterField = CLUSTER_NAME
    "Text for SLA Status Filter."
    text: String = ""
}

"Supported in v7.0+"
input SnapMirrorCloudCreateInput {
    "Supported in v7.0+"
    nasVolumeId: String
    "Supported in v7.0+"
    snapMirrorLabel: String
}

"Supported in v7.0+"
input SnapMirrorCloudRestoreParametersInput {
    """

    Supported in v7.0+
    Optional. A Boolean that specifies whether to ignore errors during the restore operation. By default, this value is false.
    """
    ignoreErrors: Boolean
    """

    Required. Supported in v7.0+
    A Boolean that specifies whether the restore operation is for the entire volume.
    """
    isVolumeRestore: Boolean!
    """

    Supported in v7.0+
    The name of the aggregate on the NetApp system under which to create the new volume.
    """
    netAppAggregateName: String
    """

    Supported in v7.0+
    The path relative to the root of the NAS share of the source file. If the restore operation is not using the original source path, also includes the new destination path.
    """
    restorePathPairs: [SnapMirrorCloudRestorePathPairInput!] = []
    """

    Supported in v7.0+
    The Rubrik ID of the NAS namespace on which to create the new volume to which the data should be exported.
    """
    targetNasNamespaceId: String
    """

    Supported in v7.0+
    The Rubrik ID of the NAS system on which to create the new volume to which the data should be exported.
    """
    targetNasSystemId: String
    """

    Supported in v7.0+
    The Rubrik ID of the NAS volume to which the data should be exported.
    """
    targetNasVolumeId: String
    """

    Supported in v7.0+
    The name of the new volume to create to which the data should be exported.
    """
    targetNasVolumeName: String
}

"Supported in v7.0+"
input SnapMirrorCloudRestorePathPairInput {
    """

    Supported in v7.0+
    Absolute path to the restore or export destination for files and folders.
    """
    dstPath: String
    """

    Required. Supported in v7.0+
    Path relative to the root of the NAS share of the files/folders to restore or export.
    """
    srcPath: String!
}

"Supported in v7.0+"
input SnapMirrorCloudUpdateConfigInput {
    "Required. Supported in v7.0+"
    snapMirrorLabel: String!
}

"Supported in v7.0+"
input SnapMirrorCloudUpdateInput {
    "Required. Supported in v7.0+"
    snapMirrorCloudId: String!
    "Required. Supported in v7.0+"
    snapMirrorLabel: String!
}

input SnappableFailoverInfoType {
    recoveryPoint: Long!
    snappableId: String!
}

"Filter snappable data."
input SnappableFilterInput {
    cluster: CommonClusterFilterInput
    complianceStatus: [ComplianceStatusEnum!]
    objectType: [ObjectTypeEnum!]
    protectionStatus: [ProtectionStatusEnum!]
    searchTerm: String
    slaDomain: SnappableSlaDomainFilterInput
    slaTimeRange: SLAComplianceTimeRangeEnum
}

"Filter snappable data (including search capability)."
input SnappableFilterInputWithSearch {
    cluster: CommonClusterFilterInput
    complianceStatus: [ComplianceStatusEnum!]
    objectType: [ObjectTypeEnum!]
    protectionStatus: [ProtectionStatusEnum!]
    searchTerm: String
    slaDomain: SnappableSlaDomainFilterInput
    slaTimeRange: SLAComplianceTimeRangeEnum
    timeRange: TimeRangeInput
}

"Filter snappable data in group by."
input SnappableGroupByFilterInput {
    cluster: CommonClusterFilterInput
    complianceStatus: [ComplianceStatusEnum!]
    objectType: [ObjectTypeEnum!]
    protectionStatus: [ProtectionStatusEnum!]
    slaDomain: SnappableSlaDomainFilterInput
    slaTimeRange: SLAComplianceTimeRangeEnum
    timeRange: TimeRangeInput
}

"List of snappable ids and recovery points."
input SnappableIdentifierInput {
    "Point in time to which to recover the VM."
    recoveryPoint: Long
    "Snappable id of the blueprint child."
    snappableId: UUID!
    "Snappable type."
    snappableType: ObjectTypeEnum!
}

"Input for snappable info."
input SnappableInfoType {
    "Id of the snappable."
    id: String = ""
    "Recovery point of a snappable."
    recoveryPoint: Long = 0
}

input SnappablePathInput {
    snappableFid: String = ""
    stdPath: String = ""
}

"Struct representing the snappable contents to be restored"
input SnappableRestoreConfig {
    MailboxRestoreConfig: MailboxRestoreConfig
    OneDriveRestoreConfig: DriveRestoreConfig
    SharePointDriveRestoreConfig: SharePointDriveRestoreConfig
    TeamsRestoreConfig: TeamsRestoreConfig
    "Restore config for Calendar jobs."
    calendarRestoreConfig: CalendarRestoreConfig
    "Restore config for Contacts jobs."
    contactsRestoreConfig: ContactsRestoreConfig
    "Restore config for SharePoint list jobs."
    sharePointListRestoreConfig: SharePointListRestoreConfig
}

"Filter snappable data based on properties of its Sla domain."
input SnappableSlaDomainFilterInput {
    id: [String!]
}

"Input to query snappables with legal hold snapshots."
input SnappablesWithLegalHoldSnapshotsInput {
    "Snappable cluster Uuid."
    clusterUuid: String!
    "Filter Parameters list."
    filterParams: [LegalHoldQueryFilter!]!
    "Sorting Parameters."
    sortParam: LegalHoldSortParam
}

input SnapshotDeltaFilterInput {
    deltaType: [DeltaTypeEnum!]
}

"Filter snapshots."
input SnapshotQueryFilterInput {
    "Type of filter."
    field: SnapshotQueryFilterField = SLA_ID
    "Snapshots from linked snappables."
    shouldFetchLinked: Boolean = false
    "Additional Information for the filter type."
    text: String = ""
    "List of search texts for the filter type."
    textList: [String!] = []
    time: DateTime
    "Snapshot types to be filtered."
    typeFilters: [SnapshotTypeEnum!] = []
}

input SonarContentReportFilter {
    applyWhitelists: Boolean = false
    clusterIds: [String!] = []
    objectTypes: [HierarchyObjectTypeEnum!]!
    policyIds: [String!] = []
    search: String = ""
}

"Supported in m3.2.0-m4.1.0"
input SourceInput {
    "Supported in m3.2.0-m4.1.0"
    async: Boolean
    "Supported in m3.2.0-m4.1.0"
    cassandraYaml: [String!] = []
    "Supported in m3.2.0-m4.1.0"
    dseYaml: [String!] = []
    "Supported in m3.2.0-m4.1.0"
    enableSsl: Boolean
    "Supported in m3.2.0-m4.1.0"
    httpsCertificate: String
    "Supported in m3.2.0-m4.1.0"
    ignoreSecondaries: [String!] = []
    "Supported in m3.2.0-m4.1.0"
    jmxPassword: String
    "Supported in m3.2.0-m4.1.0"
    jmxUser: String
    "Supported in m3.2.0-m4.1.0"
    parameterEncoded: Boolean
    "Supported in m3.2.0-m4.1.0"
    sourceAuthKey: String
    "Supported in m3.2.0-m4.1.0"
    sourceAuthKeyfile: String
    "Supported in m3.2.0-m4.1.0"
    sourceAuthPassphrase: String
    "Supported in m3.2.0-m4.1.0"
    sourceDriverPassword: String
    "Supported in m3.2.0-m4.1.0"
    sourceDriverUser: String
    "Supported in m3.2.0-m4.1.0"
    sourceHttpsPort: String
    "Required. Supported in m3.2.0-m4.1.0"
    sourceIp: [String!]!
    "Required. Supported in m3.2.0-m4.1.0"
    sourceName: String!
    "Supported in m3.2.0-m4.1.0"
    sourcePassword: String
    "Supported in m3.2.0-m4.1.0"
    sourcePort: String
    "Supported in m3.2.0-m4.1.0"
    sourceRpcPort: String
    "Supported in m3.2.0-m4.1.0"
    sourceSshPort: String
    sourceType: SourceSourceTypeEnum!
    "Supported in m3.2.0-m4.1.0"
    sourceUser: String
    "Supported in m3.2.0-m4.1.0"
    sslCaCerts: String
    sslCertReqs: SourceSslCertReqsEnum
    "Supported in m3.2.0-m4.1.0"
    sslCertfile: String
    "Supported in m3.2.0-m4.1.0"
    sslKeyfile: String
}

input SpecificReplicationSpecInput {
    bidirectionalSpecInput: BidirectionalReplicationSpecInput
    cloudLocationSpecInput: ReplicationToCloudLocationSpecInput
    cloudRegionSpecInput: ReplicationToCloudRegionSpecInput
    unidirectionalSpecInput: UnidirectionalReplicationSpecInput
}

"Input required to start the job to disable AWS Exocompute."
input StartAwsExocomputeDisableJobInput {
    "Rubrik ID of the account for which Exocompute needs to be disabled."
    cloudAccountId: UUID!
}

"Input to trigger AWS native account disable job."
input StartAwsNativeAccountDisableJobInput {
    "Rubrik ID of AWS account."
    awsAccountRubrikId: UUID!
    "Type of native protection to be disabled."
    awsNativeProtectionFeature: AwsNativeProtectionFeature!
    "Whether to delete snapshots in the account."
    shouldDeleteNativeSnapshots: Boolean!
}

"Input to initiate a job to create AWS EC2 instance snapshots."
input StartAwsNativeEc2InstanceSnapshotsJobInput {
    "List of Rubrik EC2 instance IDs."
    ec2InstanceIds: [UUID!]!
    "Retention SLA Rubrik ID."
    retentionSlaId: String = ""
}

"Input to initiate job to create AWS RDS Instance snapshots."
input StartAwsNativeRdsInstanceSnapshotsJobInput {
    "List of Rubrik UUIDs of the RDS Instances."
    rdsInstanceIds: [UUID!]!
    "ID of the SLA Domain to be used for retention of the snapshots that are created by the RDS instance snapshot job."
    retentionSlaId: String = ""
}

"Input for initiating authentication of the Azure Cloud Accounts."
input StartAzureCloudAccountOauthInput {
    "Type of Azure Tenant. Possible values: Azure Public Cloud, Azure China Cloud."
    azureCloudType: AzureCloudType = AZUREPUBLICCLOUD
    "Domain name of the Azure Tenant."
    tenantDomainName: String
}

"Input required to trigger a job to create an index of snapshots."
input StartCloudNativeSnapshotsIndexJobInput {
    snapshotIds: [UUID!]!
}

"Input to initiate the snapshot creation job for AWS native EBS volume."
input StartCreateAwsNativeEbsVolumeSnapshotsJobInput {
    "Rubrik UUIDs of EBS volumes for snapshot creation."
    ebsVolumeIds: [UUID!]!
    "Retention SLA ID to be used for the snapshots to be created."
    retentionSlaId: String = ""
}

"Input to initiate a job to create Azure Native Managed Disk snapshots."
input StartCreateAzureNativeManagedDiskSnapshotsJobInput {
    "Rubrik UUIDs of the managed disks whose snapshots are to be taken.."
    managedDiskRubrikIds: [UUID!]!
    "The ID of the SLA Domain assigned to protect the on-demand snapshot."
    retentionSlaId: String
}

"Input to initiate a job to create Azure Native Virtual Machine snapshots."
input StartCreateAzureNativeVirtualMachineSnapshotsJobInput {
    "Retention SLA ID of the on-demand snapshot."
    retentionSlaId: String
    "Rubrik UUIDs of the Virtual Machines (VMs) whose snapshots are to be taken."
    virtualMachineRubrikIds: [UUID!]!
}

"Input for starting jobs to disable a cloud account feature for a list of Azure Cloud Accounts."
input StartDisableAzureCloudAccountJobInput {
    "Rubrik IDs of the Cloud Accounts to be disabled."
    cloudAccountIds: [UUID!]!
    "Feature to be disabled."
    feature: CloudAccountFeature!
}

"Input for the job to start disabling protection from the Azure Native Subscription."
input StartDisableAzureNativeSubscriptionProtectionJobInput {
    "Type of native protection to be disabled."
    azureNativeProtectionFeature: AzureNativeProtectionFeature!
    "The Rubrik ID of the Azure subscription for which to disable protection."
    azureSubscriptionRubrikId: UUID!
    "Specifies whether to delete the snapshots associated with the subscription being deleted. When true, deletes the snapshots associated with the subscription being deleted."
    shouldDeleteNativeSnapshots: Boolean!
}

"Input to initiate an export job for an AWS native EC2 instance."
input StartEc2InstanceSnapshotExportJobInput {
    "ID of the Amazon Machine Image (AMI) to be used for launching the EC2 instance. This field should be specified only when snapshotType is specified as Archived and amiTypeForAwsNativeArchivedSnapshot returns AMI type as USER_SPECIFIED. In other cases, either a pre-existing AMI is picked, or a new AMI is created at runtime, and an AMI ID is not required. The AMI specified here should be present in the target account and region of export. The specified AMI will be used for launching the instance for export, and all its volumes will be replaced."
    amiId: String
    "Rubrik UUID of the AWS account where the instance will be exported."
    destinationAwsAccountRubrikId: UUID!
    "Region of the exported instance."
    destinationRegionId: AwsNativeRegion!
    "Power state of the exported instance."
    exportInstanceInPoweredOffState: Boolean = false
    "ARN of the IAM instance profile to be attached to the exported EC2 instance."
    iamInstanceProfileArn: String
    "Name of the exported instance."
    instanceName: String!
    "AWS Native EC2 instance type to be used after export. Some examples are: t2.nano, m5.xlarge. For more information, see https://aws.amazon.com/ec2/instance-types."
    instanceType: AwsNativeEc2InstanceType!
    "ID of the KMS key to be used for export."
    kmsKeyId: String = ""
    "List of security group IDs to be used for the exported instance."
    securityGroupIds: [String!]!
    "Specifies whether to copy tags to the exported instance."
    shouldCopyTags: Boolean!
    "ID of the snapshot to be exported."
    snapshotId: UUID!
    "Type of snapshot used for export."
    snapshotType: SnapshotType = SOURCE
    "Name of the SSH key pair to be used for export."
    sshKeyPairName: String = ""
    "ID of the subnet to use for the exported instance."
    subnetId: String!
}

"Input to initiate an export job for the AWS native EBS volume."
input StartExportAwsNativeEbsVolumeSnapshotJobInput {
    "Availability Zone (AZ) of the exported volume."
    availabilityZone: String!
    "Rubrik UUID of the AWS account where exported volume will reside."
    destinationAwsAccountRubrikId: UUID!
    "Region of the exported volume."
    destinationRegionNativeId: AwsNativeRegion!
    "Input/Output (IO) operation limit per second for the exported volume."
    iops: Int!
    "ID of the KMS key to be used for export."
    kmsKeyId: String = ""
    "Specifies whether to copy tags to the exported volume."
    shouldCopyTags: Boolean!
    "Specifies whether to replace attached volumes."
    shouldReplaceAttached: Boolean!
    "ID of the snapshot to be exported."
    snapshotId: UUID!
    "Type of snapshot used for export."
    snapshotType: SnapshotType = SOURCE
    "Name of the exported volume."
    volumeName: String!
    "Size of the exported volume in Giga Bytes."
    volumeSize: Int!
    "AWS Native EBS volume type. Some examples are: g3, io2. For more information, see https://aws.amazon.com/ebs/volume-types."
    volumeType: AwsNativeEbsVolumeType!
}

"Input for the job to export the specified Azure Native Managed Disks to the specified destination."
input StartExportAzureNativeManagedDiskJobInput {
    "Availability Zone in which to export the disk. It is empty for regions types which do not support availability zones."
    destinationAvailabilityZone: String
    "Region in which the disk created after export will exist."
    destinationRegion: AzureNativeRegion!
    "Rubrik ID of the subscription in which to export the disk. When empty, the disk is exported to same subscription."
    destinationSubscriptionRubrikId: UUID
    "Name of the disk created after export."
    diskName: String!
    "Size of the disk created after export, in GiB."
    diskSize: Int!
    "Type of the disk created after export."
    diskStorageTier: AzureNativeManagedDiskType!
    "Resource group to be associated with the disk created after export."
    resourceGroup: String!
    "Specifies whether to export tags from the snapshot or not. When true, the tags from the snapshot are exported as well."
    shouldExportTags: Boolean!
    "Specifies whether to run only the export job or to run both the export and replace jobs. When true, the attached managed disk is exported and replaced."
    shouldReplaceAttachedManagedDisk: Boolean!
    "Specifies whether to recover from the replica of the source snapshot or not. Default value is false."
    shouldUseReplica: Boolean
    "Snapshot ID of the snapshot with which the disk is to be exported."
    snapshotId: UUID!
    "The type of the snapshot to recover from."
    snapshotType: AzureSnapshotType
}

"Input for the job to export the specified Azure Native Virtual Machine to the specified destination."
input StartExportAzureNativeVirtualMachineJobInput {
    "The native ID of the availability set used by the virtual machine created by the export job."
    availabilitySetNativeId: String
    "The Availability Zone where the virtual machine created by the export job exists. When the region type does not support Availability Zones, this value is null."
    destinationAvailabilityZone: String
    "The region where the virtual machine created by the export job exists."
    destinationRegion: AzureNativeRegion!
    "The Rubrik ID of the Azure subscription to which the virtual machine is exported. When this value is not specified, the virtual machine is exported to the same Azure subscription."
    destinationSubscriptionRubrikId: UUID
    "The native ID of the network security group used by the virtual machine created by the export job."
    networkSecurityGroupNativeId: String
    "Specifies a list of Rubrik IDs for the disks that will be exported. When empty, all disks from the snapshot will be exported."
    recoveryDiskIds: [UUID!]
    "The resource group associated with the virtual machine created by the export job."
    resourceGroupName: String!
    "Specifies whether to enable accelerated networking for the virtual machine created by the export job. This value is false by default."
    shouldEnableAcceleratedNetworking: Boolean
    "Specifies whether to export the tags from the snapshot."
    shouldExportTags: Boolean!
    "Specifies whether to export the virtual machine in a powered-down state."
    shouldPowerOff: Boolean!
    "Specifies whether to recover from a replica of the source snapshot."
    shouldUseReplica: Boolean
    "The snapshot ID of the snapshot used to export a virtual machine."
    snapshotId: UUID!
    "The type of the snapshot to recover from."
    snapshotType: AzureSnapshotType
    "The native ID of the subnet used by the virtual machine created by the export job."
    subnetNativeId: String!
    "The name of the virtual machine created as a result of the export job."
    virtualMachineName: String!
    "The size, in GiB, of the virtual machine created by the export job."
    virtualMachineSize: String!
}

"Input for the job to export the specified Azure SQL Database."
input StartExportAzureSqlDatabaseDbJobInput {
    "Input for exporting from Long Term Retention (LTR) backup."
    azureSqlDatabaseDbLtrExportInput: AzureSqlDatabaseDbLtrExport
    "Input for exporting from Point-in-Time (PiT) backup."
    azureSqlDatabaseDbPitExportInput: AzureSqlDatabaseDbPitExport
    "Name of the exported Azure SQL Database."
    destinationDatabaseName: String!
    "Rubrik ID of the server to which export will be done."
    destinationServerRubrikId: UUID
    "Name of the elastic pool for the exported database."
    elasticPoolName: String
    "Input for exporting from Rubrik managed persistent backup."
    persistentBackupExportInput: AzureSqlPersistentBackupExportInput
    "Specifies whether the tags will be exported to the new Azure SQL Database."
    shouldExportTags: Boolean!
    "Rubrik ID of the Azure SQL Database instance to be exported."
    sourceDatabaseRubrikId: UUID!
}

"Input for the job to export the specified Azure SQL Managed Instance database."
input StartExportAzureSqlManagedInstanceDbJobInput {
    "Input for exporting from Long Term Retention (LTR) backup."
    azureSqlManagedInstanceDbLtrExportInput: AzureSqlManagedInstanceDbLtrExport
    "Input for exporting from Point-in-Time (PiT) backup."
    azureSqlManagedInstanceDbPitExportInput: AzureSqlManagedInstanceDbPitExport
    "Name of the exported Azure SQL Managed Instance database."
    destinationDatabaseName: String!
    "Name of the Azure SQL Managed Instance in which database is being exported."
    destinationManagedInstanceName: String!
    "Destination Rubrik ID of the Asure SQL Managed Instance to which export will be done."
    destinationManagedInstanceRubrikId: UUID
    "Resource Group in which database is being exported."
    destinationResourceGroupName: String!
    "Input for exporting from Rubrik managed persistent backup."
    persistentBackupExportInput: AzureSqlPersistentBackupExportInput
    "Rubrik ID of the Azure SQL Managed Instance Database to be exported."
    sourceManagedInstanceDatabaseRubrikId: UUID!
}

"Input to trigger AWS native RDS Instance export job."
input StartExportRdsInstanceJobInput {
    "Instance class of RDS instance."
    dbInstanceClass: AwsNativeRdsDbInstanceClass!
    "Name of the exported RDS DB instance."
    dbInstanceName: String!
    "AWS account in which the exported RDS instance will be launched."
    destinationAwsNativeAccountId: String!
    "Region in which the exported RDS DB instance will be launched."
    destinationRegionNativeId: AwsNativeRegion!
    "Export timestamp for Point in Time recovery of the instance."
    exportTime: DateTime
    "Input Output (I/O) per second of the exported RDS DB instance."
    iops: Int = 0
    "Whether the exported RDS DB instance is multi-AZ or not."
    isMultiAz: Boolean!
    "Whether the export of the instance is from snapshot or point-in-time."
    isPointInTime: Boolean!
    "Whether the new RDS instance is publicly accessible or not."
    isPubliclyAccessible: Boolean!
    "KMS Key ID of the exported RDS DB instance."
    kmsKeyId: String = ""
    "Name of the option group selected by the user for the new RDS instance."
    optionGroupName: String = ""
    "Name of the DB parameter group selected by the user for the new RDS instance."
    parameterGroupName: String = ""
    "Port on which the exported RDS DB instance accepts connections."
    port: Long!
    "Availability Zone (AZ) in which the exported RDS DB instance must be launched."
    primaryAz: String = ""
    "Rubrik ID of the RDS Instance to be exported."
    rdsInstanceId: UUID!
    "List of security group IDs for the new RDS instance. Default security group is used if empty list is provided here."
    securityGroupIds: [String!] = []
    "Whether tags will be exported to the new RDS instance."
    shouldExportTags: Boolean!
    "ID of the snapshot if the export is from snapshot."
    snapshotId: String
    "Type of snapshot used for export. Required only if export is from a snapshot."
    snapshotType: SnapshotType = SOURCE
    "Storage type of the exported RDS DB instance."
    storageType: AwsNativeRdsStorageType = NOT_SPECIFIED
    "Name of the subnet group for the new RDS instance."
    subnetGroupName: String = ""
    "List of subnet IDs for the newly created subnet group, which will be associated with the exported RDS DB instance. Default subnet ids are used if empty list is provided here."
    subnetIds: [String!] = []
}

"Start Recovery Plan configuration."
input StartRecoveryPlanInput {
    "Account."
    account: String!
    "Recovery Plan configurations."
    configs: [RecoveryPlanFailoverJobConfig!]!
}

"Input to initiate a job to refresh an AWS native account."
input StartRefreshAwsNativeAccountsJobInput {
    "Rubrik UUIDs of the AWS account to be refreshed."
    awsAccountRubrikIds: [UUID!]!
    "Native protection feature to be refreshed."
    awsNativeProtectionFeatures: [AwsNativeProtectionFeature!]!
}

"Input to trigger the Refresh Azure Native Subscriptions job."
input StartRefreshAzureNativeSubscriptionsJobInput {
    "Rubrik IDs of the Azure Native Subscriptions to be refreshed."
    azureSubscriptionRubrikIds: [UUID!]!
}

"Trigger AWS EC2 instance snapshot restore job."
input StartRestoreAwsNativeEc2InstanceSnapshotJobInput {
    "Specifies the power status of the restored EC2 Instance. When true, the EC2 Instance is powered-on after completion of the restore."
    shouldPowerOn: Boolean!
    "Specifies whether to restore associated tags. If true, the restored EC2 Instance will have same tags associated."
    shouldRestoreTags: Boolean!
    "ID of snapshot to restore."
    snapshotId: String!
    "Snapshot type to use if source snapshot is expired."
    snapshotTypeToUseIfSourceExpired: SnapshotTypeToUseIfSourceExpired
}

"Inputs to trigger the job to restore Azure Native Virtual Machine."
input StartRestoreAzureNativeVirtualMachineJobInput {
    "Specifies a list of Rubrik IDs for the disks that will be restored. When empty, all disks from the snapshot will be restored."
    recoveryDiskIds: [UUID!]
    "Specifies whether the restored VM is to be launched in powered on state. When false, the restored VM will not be connected to the internet."
    shouldPowerOn: Boolean!
    "Specifies whether the tags at the time of snapshot should also be restored. When true, the tags on the VM will be reverted to the time of the backup."
    shouldRestoreTags: Boolean!
    "Snapshot ID of the snapshot which is to be restored."
    snapshotId: UUID!
    "Snapshot type to use if source snapshot is expired."
    snapshotTypeToUseIfSourceExpired: SnapshotTypeForRestoreIfSourceExpired
}

"The configuration to start a hunt, including which objects, indicators of compromise, and advanced parameters."
input StartThreatHuntInput {
    "UUID used to identify the cluster the request goes to."
    clusterUuid: UUID!
    "Criteria to restrict files to scan."
    fileScanCriteria: MalwareScanFileCriteriaInput
    "List of IOCs to scan for."
    indicatorsOfCompromise: [PolarisIndicatorOfCompromiseInput!]!
    "Maximum number of matches per shapshot, per IOC.  Scanning for an Indicator Of Compromise within a snapshot will terminate once this many matches have been detected. Defaults to one."
    maxMatchesPerSnapshot: Int
    "Name of this scan."
    name: String!
    "Notes to describe this scan."
    notes: String = ""
    "Object FIDs to scan for malware."
    objectFids: [UUID!]!
    "Additional information required for files with malware matches."
    requestedMatchDetails: RequestedMatchDetailsInput
    "Specifies whether features that rely on the accuracy of filesystem metadata, like creation time and modification time of files, are enabled or not. These features include backend optimizations to skip re-scanning files that have not changed across snapshots, as indicated by the unchanged timestamps of files. This flag also gates access to some filters that can be specified in this API. Note that this flag should be used with caution, as relying on file timestamps may make the system vulnerable to adversarial techniques such as timestamp manipulation."
    shouldTrustFilesystemTimeInfo: Boolean
    "Limit which snapshots to include in the malware scan."
    snapshotScanLimit: MalwareScanSnapshotLimitInput
}

input StartTimeAttributesInput {
    dayOfWeek: DayOfWeekOptInput
    hour: Int = 0
    minute: Int = 0
}

"Input to stop a job instance."
input StopJobInstanceInput {
    "UUID of the job instance."
    jobInstanceId: String!
}

input SyslogConfigInputType {
    id: Int = 0
    notificationConf: CommonNotificationSettingInputType
    syslogConf: SyslogSettingInputType
}

input SyslogSettingInputType {
    facility: SyslogFacilityTypeEnum = ALL_SYSLOG
    severity: SyslogSeverityTypeEnum = ALL_SEVERITY
}

"Tag filter parameters."
input TagFilterParams {
    filterType: TagFilterType = TAG_KEY
    tagKey: String = ""
    tagValue: String = ""
}

input TagInput {
    key: String!
    value: String!
}

"DataType representing tag key-value pair"
input TagType {
    matchAllValues: Boolean!
    tagKey: String!
    tagValue: String!
}

input TagsInput {
    tagList: [TagInput!]!
}

input TargetFilterInput {
    field: TargetQueryFilterFieldEnum = NAME
    text: String = ""
    textList: [String!] = []
}

input TargetMappingDeleteRequest {
    id: String = ""
}

input TargetMappingFilterInput {
    field: TargetMappingQueryFilterFieldEnum = NAME
    text: String = ""
}

input TargetToClusterMapping {
    clusterUuid: String = ""
    locationId: String = ""
}

"Filter task detail"
input TaskDetailFilterInput {
    clusterLocation: [String!]
    clusterType: [String!]
    clusterUuid: [UUID!]
    objectType: [String!]
    replicationSource: [String!]
    searchTerm: String
    slaDomain: SnappableSlaDomainFilterInput
    taskCategory: [String!]
    taskStatus: [String!]
    taskType: [String!]
    time_gt: DateTime
    time_lt: DateTime
}

"Filter task summary"
input TaskSummaryFilterInput {
    cluster: CommonClusterFilterInput
    objectType: [ObjectTypeEnum!]
    slaDomain: SnappableSlaDomainFilterInput
    time_gt: DateTime
    time_lt: DateTime
}

"Struct representing the Teams Channels to/from be restored"
input TeamsChannelInfo {
    ChannelFolderName: String
    ChannelID: UUID
    ChannelName: String
    ChannelNaturalId: String
    TeamID: UUID!
}

"Struct representing the Teams Channels to/from be restored"
input TeamsConvChannelInfo {
    ChannelFolderId: String
    ChannelFolderName: String
    ChannelID: UUID
    ChannelName: String
    ChannelNaturalId: String
    TeamID: UUID!
}

"Parameters for teams conversations search"
input TeamsConversationsSearchFilter {
    channelNaturalId: String
    convId: String
    "describes whether to send post senders(shouldn't be called by UI)"
    fetchAllPostSenders: String
    includeArchived: Boolean = false
    parentId: String
    postedBy: String
    postedTime: TimeRangeFilter
    snapshotId: String
    snapshotNum: Int
}

"Struct representing the teams conversations search filter"
input TeamsConversationsSearchFilterJson {
    PostedBy: String
    PostedTime: TimeRangeFilterJson
    SnapshotId: String
}

"Struct representing the teams contents to be restored"
input TeamsRestoreConfig {
    ConversationsRestoreConfig: ConversationsRestoreConfig
    DestChannelInfo: TeamsChannelInfo
    FilesRestoreConfig: DriveRestoreConfig
    ShouldCreateDestChannel: Boolean!
}

"The existing webhook to test."
input TestExistingWebhookInput {
    "The id of the webhook to be tested."
    id: Int!
}

"Webhook configuration to test."
input TestWebhookInput {
    "The authentication type and token to authenticate the endpoint."
    authInfo: AuthInfo
    "The application that will receive the webhook."
    providerType: ProviderType!
    "The URL endpoint to the receiving application."
    url: URL!
}

input TimeFilterInput {
    endTime: String = ""
    startTime: String = ""
    timeDuration: TimeDurationEnum = HOUR
    timezone: String = ""
}

"Timerange filter"
input TimeRangeFilter {
    fromTime: DateTime
    untilTime: DateTime
}

"Struct representing the time range filter"
input TimeRangeFilterJson {
    FromTime: Long
    UntilTime: Long
}

input TimeRangeInput {
    end: DateTime!
    start: DateTime!
}

input UnidirectionalReplicationSpecInput {
    replicationTargetId: String = ""
    retention: Int = 0
    retentionUnit: RetentionUnitEnum = MINUTES
}

"Unmanaged object status."
input UnmanagedObjectStatusParam {
    "Unmanaged Object Status."
    status: UnmanagedObjectStatus = PROTECTED
}

"Unmanaged object type."
input UnmanagedObjectTypeParam {
    "Unmanaged Object type."
    objectType: ManagedObjectType = O365_ORGANIZATION
}

"Input to query unmanaged objects."
input UnmanagedObjectsInput {
    "Snappable cluster Uuid."
    clusterUuid: String!
    "Object name."
    name: String
    "Object type to filter."
    objectType: UnmanagedObjectTypeParam
    "Retention SLA to filter."
    retentionSlaDomainName: String
    "Sorting Parameters."
    sortParam: UnmanagedObjectsSortParam
    "Unmanaged status to filter."
    unmanagedStatus: UnmanagedObjectStatusParam
}

"Unmanaged objects sorting parameters."
input UnmanagedObjectsSortParam {
    "Sort order."
    sortOrder: SortOrder = ASC
    "Sort type."
    type: UnmanagedObjectsSortType = NAME
}

"Input for unmapping Azure cloud accounts from the mapped Exocompute subscription."
input UnmapAzureCloudAccountExocomputeSubscriptionInput {
    "Rubrik IDs of the cloud accounts to be unmapped."
    cloudAccountIds: [UUID!]!
}

"Input to update an AWS account."
input UpdateAwsCloudAccountInput {
    "Action to be taken for cloud account update."
    action: CloudAccountAction!
    "AWS account name."
    awsAccountName: String = ""
    "List of regions to be added."
    awsRegions: [AwsCloudAccountRegion!]
    "Rubrik ID of the AWS account."
    cloudAccountId: UUID!
    "Native protection feature to be updated."
    feature: CloudAccountFeature!
    "Role ARN for the cloud account."
    roleArn: String = ""
    "Stack ARN for the cloud account."
    stackArn: String = ""
}

"Input for updating an Azure Cloud Account."
input UpdateAzureCloudAccountInput {
    "Features enabled on the Azure Cloud Account."
    features: [CloudAccountFeature!]!
    "Regions to be added."
    regionsToAdd: [AzureCloudAccountRegion!]
    "Regions to be removed."
    regionsToRemove: [AzureCloudAccountRegion!]
    "Subscriptions to be updated."
    subscriptions: [AzureCloudAccountSubscriptionInput!]!
}

"Input for updateCloudNativeAwsStorageSetting mutation"
input UpdateCloudNativeAwsStorageSettingInput {
    id: UUID!
    kmsMasterKeyId: String
    name: String
    storageClass: AwsStorageClassTypeEnum
}

"Input for updating azure storage settings. Specify old value of the property if no change is intended on the property."
input UpdateCloudNativeAzureStorageSettingInput {
    "Information about the customer-managed key and key vault."
    cmkInfo: [AzureCmkInput!]
    "ID for the storage setting."
    id: UUID!
    "Name of the storage setting."
    name: String!
    "Tags for the storage account. Old tags are removed and new tags are applied."
    storageAccountTags: TagsInput!
    "Storage tier for the storage account."
    storageTier: AzureStorageTier!
}

"Input to pause or resume a list of Rubrik clusters."
input UpdateClusterPauseStatusInput {
    "List of cluster UUIDs."
    clusterUuids: [String!] = []
    "Specifies whether to pause or resume the clusters."
    togglePauseStatus: Boolean = false
}

input UpdateDefaultDbPropertiesV1Input {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. Updated default properties."
    defaultProperties: MssqlDbDefaultsUpdateInput!
}

input UpdateGlobalSlaInput {
    archivalSpecs: [ArchivalSpecInput!] = []
    backupWindows: [BackupWindowInput!] = []
    description: String = ""
    firstFullBackupWindows: [BackupWindowInput!] = []
    id: String = ""
    localRetentionLimit: SlaDurationInput
    logConfig: LogConfig
    name: String = ""
    objectSpecificConfigsInput: ObjectSpecificConfigsInput
    objectTypes: [SLAObjectTypeEnum!] = []
    replicationSpecInput: ReplicationSpecInput
    replicationSpecsV2: [ReplicationSpecV2Input!] = []
    shouldApplyToExistingSnapshots: ShouldApplyToExistingSnapshots
    shouldApplyToNonPolicySnapshots: ShouldApplyToNonPolicySnapshots
    snapshotSchedule: GlobalSnapshotScheduleInput
    stateVersion: Long = 0
    "Optional user note."
    userNote: String = ""
}

input UpdateGuestCredentialInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. Object for guest OS credential definition."
    definition: GuestCredentialDefinitionInput!
    "Required. ID of the guest OS credential to update."
    id: String!
}

input UpdateHypervVirtualMachineSnapshotMountInput {
    "Required. Power state configuration."
    config: HypervUpdateMountConfigInput!
    "Required. ID of a Live Mount."
    id: String!
}

input UpdateLogShippingConfigurationV2Input {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. Configuration parameters for the update operation."
    config: MssqlLogShippingUpdateV2Input!
    "Required. ID of a log shipping configuration object."
    id: String!
}

input UpdateManagedVolumeInput {
    "Required. ID of managed volume."
    id: String!
    "Required. Properties to update."
    update: ManagedVolumeUpdateInput!
}

input UpdateNasSystemInput {
    "Required. ID of the registered NAS system."
    id: String!
    "Required. Properties of the NAS system to update."
    nasSystemUpdateProperties: NasSystemUpdateInput!
}

input UpdateNetworkThrottleInput {
    "Required. UUID used to identify the cluster the request goes to"
    clusterUuid: String!
    "Required. ID assigned to a network throttle object."
    id: String!
    "Required. Configuration changes to apply to a specified network throttle object. Unspecified values are left unchanged."
    throttleUpdate: NetworkThrottleUpdateInput!
}

"Config for updating an O365 organization custom name."
input UpdateO365OrgCustomNameInput {
    "Custom name to use for the O365 organization."
    customName: String!
    "Polaris ID for an O365 organization."
    orgUuid: UUID!
}

input UpdateOracleDataGuardGroupInput {
    "Required. ID assigned to an Oracle Data Guard group object."
    id: String!
    "Required. Properties to use for the update of an Oracle Data Guard group object."
    updateProperties: OracleDataGuardGroupUpdateInput!
}

"Update organization details."
input UpdateOrgInput {
    "Allowed clusters for the organization."
    allowedClusters: [String!]!
    "Use global org's SSO/LDAP config or set its own config."
    authDomainConfig: TenantAuthDomainConfig!
    "New description of the organization."
    description: String!
    "Force org to use envoy to connect their hosts."
    isEnvoyRequired: Boolean!
    "New name of the organization."
    name: String!
    "New org url prefix of the organization."
    orgUrlPrefix: String!
    "Id of the organization to update."
    organizationId: String!
    "Enforce MFA for all users in the org."
    shouldEnforceMfaForAll: Boolean!
}

"Input to update RCS automatic target mapping."
input UpdateRcsAutomaticTargetMappingInput {
    "List of cluster UUIDs."
    clusterUuidList: [String!]
    "ID of the target mapping."
    id: String!
    "Immutability lock duration in days."
    lockDurationDays: Long!
    "Name of the target mapping."
    name: String
}

"Update Recovery Plan configuration."
input UpdateRecoveryPlanInput {
    "Recovery Plan configuration."
    config: RecoveryPlanConfigInput
    "Recovery Plan description."
    description: String
    "Recovery Plan ID."
    id: String!
    "Recovery Plan name."
    name: String!
}

input UpdateSnapMirrorCloudInput {
    "Required. ID of the SnapMirror Cloud object to update."
    id: String!
    "Required. Properties of the SnapMirror Cloud to update."
    snapmirrorCloudUpdateConfig: SnapMirrorCloudUpdateConfigInput!
}

"Webhook configuration to update."
input UpdateWebhookInput {
    "The authentication type and token to authenticate the endpoint."
    authInfo: AuthInfo
    "A description of the webhook to be created."
    description: String
    "Minimum severity of webhook's subscribed events."
    eventSeverities: [EventSeverity!]
    "List of webhook's subscribed events."
    eventTypes: [EventType!]
    "The id of the webhook to be updated."
    id: Int!
    "The new name of the webhook to be updated."
    name: String
    "The application that will receive the webhook."
    providerType: ProviderType
    "Describes whether the webhook is enabled or disabled."
    status: WebhookStatus
    "The URL endpoint to the receiving application."
    url: URL
}

"Input to update status of features of AWS cloud account to connected from missing permissions state."
input UpgradeAwsCloudAccountFeaturesWithoutCftInput {
    "Rubrik ID of cloud account to be upgraded."
    awsCloudAccountId: String!
    "Cloud account features to be upgraded."
    features: [CloudAccountFeature!]!
}

"Input to set status of IAM user-based AWS cloud account to connected from missing permissions state."
input UpgradeAwsIamUserBasedCloudAccountPermissionsInput {
    "Rubrik ID of cloud account to be upgraded."
    awsCloudAccountId: String!
    "Cloud native features to be upgraded."
    features: [CloudAccountFeature!]!
}

"Input for upgrading an Azure Cloud Account."
input UpgradeAzureCloudAccountInput {
    "Rubrik IDs of the subscriptions to be upgraded."
    azureSubscriptionRubrikIds: [UUID!]!
    "Features enabled on the Azure Cloud Account."
    features: [CloudAccountFeature!]!
    "Session ID of the current OAuth session."
    sessionId: String!
}

"Input for upgrading Azure Cloud Account feature to connected state from missing permissions without OAuth."
input UpgradeAzureCloudAccountPermissionsWithoutOauthInput {
    "Rubrik ID of the cloud accounts to upgrade permissions."
    cloudAccountId: UUID!
    "Feature enabled on the Azure Cloud Account, which is currently in Missing Permissions state."
    feature: CloudAccountFeature!
}

"Input for upgrading GCP Cloud Account feature to connected state from missing permissions without OAuth."
input UpgradeGcpCloudAccountPermissionsWithoutOauthInput {
    "Rubrik ID of the cloud account to upgrade permissions."
    cloudAccountId: UUID!
    "Feature enabled on the GCP Cloud Account, which is currently in Missing Permissions state."
    feature: CloudAccountFeature!
}

"Input to upgrade Rubrik SLA Domains."
input UpgradeSlasInput {
    "List of Rubrik SLA Domain IDs to upgrade."
    slaIds: [UUID!]!
}

"Filter User Audit data"
input UserAuditFilterInput {
    cluster: CommonClusterFilterInput
    clusterIds: [UUID!]
    "Filter if user note is attached."
    hasUserNote: Boolean
    "Filter by object IDs."
    objectIds: [String!]
    searchTerm: String
    status: [UserAuditStatusEnum!]
    time_gt: DateTime
    time_lt: DateTime
    userAuditObjectType: [UserAuditObjectTypeEnum!]
    userAuditSeverity: [UserAuditSeverityEnum!]
    userAuditType: [UserAuditTypeEnum!]
}

"The username and password of the user to authenticate the endpoint."
input UserCredentials {
    "The password of the user to authenticate the endpoint."
    password: String!
    "The username of the user to authenticate the endpoint."
    username: String!
}

input UserGroupToRolesInput {
    roleIds: [String!] = []
    userGroupId: String = ""
}

"Details of the user invitation."
input UserInviteInput {
    "Email of the invited user."
    email: String!
    "Note to the invited user."
    note: String!
}

input UserSettingInputType {
    setting: String = ""
    value: String = ""
}

input UserTimeRangeInput {
    endTime: String = ""
    startTime: String = ""
    timezone: String = ""
}

input VSphereComputeTargetInputType {
    computeClusterCdmId: String = ""
    computeClusterId: String = ""
    computeClusterName: String = ""
    hostCdmId: String = ""
    hostId: String = ""
    hostName: String = ""
    resourcePoolCdmId: String = ""
    resourcePoolId: String = ""
    resourcePoolName: String = ""
    vcenterCdmId: String = ""
    vcenterId: String = ""
    vcenterName: String = ""
}

input VSphereMountFilter {
    clusterUuid: [UUID!]
    name: String
    powerStatus: [Boolean!]
    sourceVmId: UUID
}

input VSphereVMNicSpecInputType {
    adapterType: NetworkAdapterTypeEnum = E1000
    dnsInfos: [String!] = []
    gateway: String = ""
    ipv4Address: String = ""
    ipv6Address: String = ""
    isPrimaryNic: Boolean = false
    key: String = ""
    netmask: String = ""
    networkId: String = ""
    networkMoid: String = ""
    networkType: NetworkTypeEnum = STATIC
}

input VSphereVMRecoverySpecInputType {
    enableMacPreserveOnly: Boolean = false
    enableNetworkPreserve: Boolean = false
    memoryMbs: Int = 0
    nics: [VSphereVMNicSpecInputType!] = []
    target: VSphereComputeTargetInputType
    userData: String = ""
    vcpus: Int = 0
    version: Long = 0
    volumes: [VSphereVMVolumeSpecInputType!] = []
}

input VSphereVMVolumeSpecInputType {
    "Cdm Id of vSphere Datastore."
    dataStoreCdmId: String = ""
    "Id of vSphere Datastore."
    dataStoreId: String = ""
    "Id of vSphere Datastore Cluster."
    datastoreClusterId: String = ""
    "Key value defined in Ebs Volume."
    key: String = ""
    "Size of datastore or datastore cluster in Gbs."
    sizeGbs: Float = 0.0
}

input VSphereVirtualDiskFilter {
    clusterUuid: [UUID!]
    fileName: String
    sourceVmId: UUID
}

"Input to validate and set up an AWS account."
input ValidateAndCreateAwsCloudAccountInput {
    "Action to be performed with the cloud account."
    action: CloudAccountAction!
    "Admin account, required for bulk upload."
    awsAdminAccount: AwsCloudAccountInput
    "Details for cloud accounts to be initiated."
    awsChildAccounts: [AwsCloudAccountInput!]!
    "List of features to be enabled for cloud native protection."
    features: [CloudAccountFeature!]!
}

"Input for validating Exocompute configurations for an Azure Cloud Account."
input ValidateAzureCloudAccountExocomputeConfigurationsInput {
    "List of Exocompute configurations to be validated."
    azureExocomputeRegionConfigs: [AzureExocomputeAddConfigInputType!]!
    "Rubrik ID of the Azure Cloud Account."
    cloudAccountId: UUID!
}

"Input for ValidateBlueprint."
input ValidateBlueprintInput {
    "Blueprint failover related properties."
    blueprintFailoverProperties: BlueprintFailoverPropertiesInput!
    "Blueprint uuid."
    blueprintId: UUID!
    "List of snappable ids and recovery points."
    childSnappableFailoverInfos: [ChildSnappableFailoverInfoInput!]!
    "Flag to enable recoveries using Rubrik backup agent."
    enableRecoveryWithRba: Boolean
}

"Input for ValidateBlueprints."
input ValidateBlueprintsInput {
    "List of blueprint details."
    blueprintDetails: [ValidateBlueprintInput!]!
}

"Supported in v5.3+"
input VcenterConfigV2Input {
    """

    Supported in v5.3+
    Concatenated X.509 certificates in Base64 encoded DER format. Each certificate must start with -----BEGIN CERTIFICATE----- and end with -----END CERTIFICATE-----.
    """
    caCerts: String
    """

    Supported in v6.0+
    Select compute clusters that must be visible to this Rubrik Cluster. All other compute resources are hidden. If 'computeVisibilityFilter' is not specified, all resources are visible. If 'hostGroupFilter' is not specified for a compute cluster, all compute resources in the compute cluster are visible. If 'hostGroupFilter' is specified for a compute cluster, only virtual machines that currently reside on these hosts are visible. For the stretched cluster configuration (vMSC), specify the appropriate host groups.
    """
    computeVisibilityFilter: [ClusterVisibilityConfigInput!] = []
    conflictResolutionAuthz: VcenterConfigV2ConflictResolutionAuthzEnum
    """

    Required. Supported in v5.3+
    The hostname of the new vCenter.
    """
    hostname: String!
    """

    Required. Supported in v5.3+
    The password of the new vCenter.
    """
    password: String!
    """

    Supported in v7.0+
    A Boolean value that determines whether to enable HotAdd transport mode for On-Premise vCenter. When this value is `true`, VMware virtual machines can use HotAdd proxy to transport virtual disk data in addition to NBD(SSL). When this value is `false`, VMware virtual machines can ONLY usee NBD(SSL) to transport virtual disk data. Default value is `false`.
    """
    shouldEnableHotAddProxyForOnPrem: Boolean
    """

    Required. Supported in v5.3+
    The username of the new vCenter.
    """
    username: String!
}

"Supported in m3.2.0-m4.1.0"
input VersionInput {
    """

    Required. Supported in m3.2.0-m4.1.0
    Name of the database.
    """
    databaseName: String!
    """

    Supported in m3.2.0-m4.1.0
    Limit number of entries.
    """
    maxEntries: Int
    """

    Supported in m3.2.0-m4.1.0
    Since the given timestamp.
    """
    since: Int
    """

    Required. Supported in m3.2.0-m4.1.0
    Name of the source.
    """
    sourceName: String!
    sourceType: VersionSourceTypeEnum
    """

    Required. Supported in m3.2.0-m4.1.0
    Name of the table.
    """
    tableName: String!
    """

    Supported in m3.2.0-m4.1.0
    Upto the given timestamp.
    """
    upto: Int
}

input VmDiskUpdateInput {
    excludeFromSnapshots: Boolean
    virtualDiskFid: UUID!
}

input VmRegisterAgentInput {
    "Required. ID assigned to a virtual machine object."
    id: String!
}

"Supported in v5.0+"
input VmRestorePathPairInput {
    restorePathPair: RestorePathPairInput
}

input VmwareDownloadSnapshotFromLocationInput {
    "Additional configuration for the snapshot download operation."
    downloadConfig: VmwareSnapshotDownloadRequestInput
    "Required. ID of the replication or archival location."
    locationId: String!
    "Required. ID of a snapshot."
    snapshotId: String!
}

"Supported in v6.0+"
input VmwareNetworkDeviceInfoV2Input {
    """

    Required. Supported in v6.0+
    Device key of the network adapter.
    """
    key: Int!
    """

    Required. Supported in v6.0+
    Name of the network adapter.
    """
    name: String!
}

"Supported in v6.0+"
input VmwareNetworkInfoV2Input {
    """

    Required. Supported in v6.0+
    MOID of the VMware network.
    """
    moid: String!
    """

    Required. Supported in v6.0+
    Name of the VMware network.
    """
    name: String!
}

"Supported in v7.0+"
input VmwareSnapshotDownloadRequestInput {
    """

    Supported in v7.0+
    ID of the SLA Domain to manage retention of the downloaded snapshot.
    """
    slaId: String
}

"Supported in v6.0+"
input VmwareVNicBindingInfoV2Input {
    """

    Required. Supported in v6.0+
    Information about the backing network.
    """
    backingNetworkInfo: VmwareNetworkInfoV2Input!
    """

    Required. Supported in v6.0+
    Information about the network device.
    """
    networkDeviceInfo: VmwareNetworkDeviceInfoV2Input!
}

input VmwareVmConfigInput {
    logRetentionSeconds: Long = 0
}

"Supported in v5.0+"
input VolumeGroupDownloadFilesJobConfigInput {
    """

    Supported in v5.2+
    An optional argument containing a Boolean parameter to depict if the download is being triggered for Legal Hold use case.
    """
    legalHoldDownloadConfig: LegalHoldDownloadConfigInput
    """

    Required. Supported in v5.0+
    An array containing the full source path of each file and folder that is part of the download job. The array must contain at least one path.
    """
    paths: [String!]!
}

"Filter volume group live mount results."
input VolumeGroupLiveMountFilterInput {
    "Type of filter."
    field: VolumeGroupLiveMountFilterField = MOUNT_NAME
    "Values for the filter type."
    texts: [String!] = []
}

"Sort volume group live mounts results."
input VolumeGroupLiveMountSortByInput {
    "Field for volume group live mounts sort by."
    field: VolumeGroupLiveMountSortByField = MOUNT_NAME
    "Sort order for volume group live mounts sort by."
    sortOrder: SortOrder = ASC
}

"Supported in v5.0+"
input VolumeGroupMountSnapshotJobConfigInput {
    """

    Supported in v5.0+
    Domain name of the users that are authenticated to access the SMB share.
    """
    smbDomainName: String
    """

    Supported in v5.0+
    IP address of the hosts that are authenticated to access the SMB share.
    """
    smbValidIps: [String!] = []
    """

    Supported in v5.0+
    Usernames of the users that are authenticated to access the SMB share.
    """
    smbValidUsers: [String!] = []
    """

    Supported in v5.0+
    Only specified if mounting on a specific Host is desired. If not specified, Rubrik will simply expose addresses of SMB mounts per recovered Volume. If a mount point is specified in any of the volumeConfigs, this must be defined. If this is specified, but no mount points are, Rubrik will generate mount paths to mount on the target Host for each volume.
    """
    targetHostId: String
    """

    Required. Supported in v5.0+
    The configuration of the Volumes to be mounted on the Host.
    """
    volumeConfigs: [VolumeGroupVolumeMountConfigInput!]!
}

"Supported in v5.0+"
input VolumeGroupOnDemandSnapshotConfigInput {
    baseOnDemandSnapshotConfig: BaseOnDemandSnapshotConfigInput
    """

    Supported in v5.0+
    v5.0-v5.2: IDs of the Volumes which we will include in the snapshot. If not passed, the Volumes currently assigned to the Volume Group will be used.
    v5.3+: The unique ID of each volume included in the Volume Group snapshot.
    """
    volumeIdsIncludedInSnapshot: [String!] = []
}

"Supported in v5.0+"
input VolumeGroupPatchInput {
    """

    Supported in v5.0+
    v5.0-v5.2: Assign this Volume Group to the given SLA domain.
    v5.3+: The ID of the SLA Domain policy to assign to the Volume Group.
    """
    configuredSlaDomainId: String
    """

    Supported in v5.1+
    v5.1-v5.2: Boolean value that determines whether to force a full for the next snapshot of a volume group. Use true to force a full and false to use the default. The backup job resets the parameter to false after a successful full snapshot.
    v5.3+: Determines whether the next snapshot of the Volume Group is a full. After the snapshot has completed, this parameter will be reset to the default false value.
    """
    forceFull: Boolean
    """

    Supported in v5.0+
    v5.0-v5.2: Whether backup/archival/replication is paused for this Volume Group
    v5.3+: Indicates whether backup, archival, and replicated is paused for this Volume Group.
    """
    isPaused: Boolean
    """

    Supported in v5.0+
    v5.0-v5.2: IDs of the Volumes which we will include in snapshots. The volume must either currently exist on the host, or already be included in snapshots.
    v5.3: The unique ID of each volume included in the Volume. Group.
    v6.0+: The unique ID of each volume included in the Volume Group.
    """
    volumeIdsIncludedInSnapshots: [String!] = []
}

"Supported in v5.0+"
input VolumeGroupRestoreFileConfigInput {
    """

    Required. Supported in v5.0+
    Absolute file path.
    """
    path: String!
    """

    Required. Supported in v5.0+
    Target folder for the copied files.
    """
    restorePath: String!
}

"Supported in v5.0+"
input VolumeGroupRestoreFilesConfigInput {
    """

    Required. Supported in v5.0+
    Directory of folder to copy files into.
    """
    restoreConfigs: [VolumeGroupRestoreFileConfigInput!]!
    """

    Supported in v5.0+
    Windows Host ID to restore files to. If left empty, the host ID of the Volume Group will be used.
    """
    targetHostId: String
}

"Supported in v5.0+"
input VolumeGroupVolumeMountConfigInput {
    """

    Supported in v5.0+
    The path on the Host on which the Volume will be mounted. It must be either an untaken drive letter name, a directory that does not exist but on a valid drive letter, or an empty directory that already exists.
    """
    mountPointOnHost: String
    """

    Required. Supported in v5.0+
    ID of the Volume to mount.
    """
    volumeId: String!
}

"Exclusion status of AWS EBS volumes."
input VolumeIdExclusion {
    "Specfies whether the EBS volume is excluded from snapshot."
    isExcluded: Boolean!
    "ID of the AWS EBS volume."
    volumeId: String!
}

input WeeklySnapshotScheduleInput {
    basicSchedule: BasicSnapshotScheduleInput
    dayOfWeek: DayOfWeek = MONDAY
}

input YearlySnapshotScheduleInput {
    basicSchedule: BasicSnapshotScheduleInput
    dayOfYear: DayOfYear = FIRST_DAY
    yearStartMonth: Month = JANUARY
}

"ClusterConfig for Azure account."
input bootstrapClusterInput {
    adminPassword: String = ""
    awsEsConfig: AwsEsConfigInput
    azureEsConfig: AzureEsConfigInput
    clusterName: String = ""
    clusterUuid: String = ""
    dnsNameServers: [String!]
    dnsSearchDomains: [String!]
    ntpServers: [String!]
    numNodes: Int = 0
    userEmail: String = ""
}

"CDM versions for Azure account."
input cdmVersionRequest {
    cloudAccountId: String = ""
    location: String = ""
}

"ClusterConfig for Azure account."
input clusterConfigInput {
    adminPassword: String = ""
    awsEsConfig: AwsEsConfigInput
    azureEsConfig: AzureEsConfigInputNoSecret
    clusterName: String = ""
    dnsNameServers: [String!]
    dnsSearchDomains: [String!]
    ntpServers: [String!]
    numNodes: Int = 0
    userEmail: String = ""
}

"GCP KMS Crypto Key"
input kmsCryptoKey {
    key: String = ""
    keyRing: String = ""
    location: String = ""
    projectNativeId: String = ""
}

"NsgRequest for Azure account."
input nsgRequest {
    cloudAccountId: String = ""
    resourceGroup: String = ""
}

"SubnetRequest for Azure account."
input subnetRequest {
    cloudAccountId: String = ""
    resourceGroup: String = ""
    vnetName: String = ""
}

"VNetRequest for Azure account."
input vnetRequest {
    cloudAccountId: String = ""
    resourceGroup: String = ""
}
